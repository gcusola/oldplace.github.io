<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>AGC062 B Split and Insert</title>
    <url>/2023/09/01/AGC062-B-Split-and-Insert/</url>
    <content><![CDATA[<p>题目链接：<a href="https://atcoder.jp/contests/agc062/tasks/agc062_b">https://atcoder.jp/contests/agc062/tasks/agc062_b</a></p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>非常有意思的一道题目。</p>
<p>我们考虑一个序列被切割以后进入一种如放的状态，简单来说就是我手里现在有两个序列可以拼起来。</p>
<p>当操作一次后会发现手里的两个序列变成了四个序列，而代价实际上就是原来两个序列裂成两个序列的代价之和（因为代价的计算公式是一次式）。</p>
<p>因此，显然，我们要把原串切成一堆上升序列，而代价都是可以自己独立统计后再加起来的，直接上区间 DP ，时间复杂度：$O(Kn^3)$ 。</p>
<p>无解的充分必要条件：最少的上升序列个数 $&gt;2^K$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 110</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line">LL dp[N][N][N],C[N];</span><br><span class="line"><span class="type">int</span> n,K,a[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;K);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=K;i++)<span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;C[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="type">int</span> x;<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">        a[x]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// for(int i=1;i&lt;=n;i++)printf(&quot;%d &quot;,a[i]);</span></span><br><span class="line">    <span class="comment">// printf(&quot;\n&quot;);</span></span><br><span class="line">    <span class="built_in">memset</span>(dp,<span class="number">20</span>,<span class="built_in">sizeof</span>(dp));</span><br><span class="line">    <span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i]&gt;a[i+<span class="number">1</span>])cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=K;i++)cnt&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(cnt)&#123;<span class="built_in">printf</span>(<span class="string">&quot;-1\n&quot;</span>);<span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        dp[K+<span class="number">1</span>][i][i]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[j]&lt;a[j<span class="number">-1</span>])<span class="keyword">break</span>;</span><br><span class="line">            dp[K+<span class="number">1</span>][i][j]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> t=K;t&gt;=<span class="number">1</span>;t--)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i;j&lt;=n;j++)&#123;</span><br><span class="line">                dp[t][i][j]=dp[t+<span class="number">1</span>][i][j];</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k=i;k&lt;j;k++)dp[t][i][j]=<span class="built_in">min</span>(dp[t+<span class="number">1</span>][i][k]+dp[t+<span class="number">1</span>][k+<span class="number">1</span>][j]+(j-k)*C[t],dp[t][i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// for(int i=1;i&lt;=K+1;i++)&#123;</span></span><br><span class="line">    <span class="comment">//     for(int j=1;j&lt;=n;j++)&#123;</span></span><br><span class="line">    <span class="comment">//         for(int k=j;k&lt;=n;k++)printf(&quot;%d %d %d:%lld\n&quot;,i,j,k,dp[i][j][k]);</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,dp[<span class="number">1</span>][<span class="number">1</span>][n]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></details>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
  </entry>
  <entry>
    <title>AGC061 C First Come First Serve</title>
    <url>/2023/08/25/AGC061-C-First-Come-First-Serve/</url>
    <content><![CDATA[<p>题目链接：<a href="https://atcoder.jp/contests/agc061/tasks/agc061_c">https://atcoder.jp/contests/agc061/tasks/agc061_c</a></p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>显然的方向：我们可以让一些选择非法，使得每个答案对应一个合法的选择。</p>
<p>准确来说，我们定义 $ff[i]$ 表示最大的 $j$ 使得 $i&lt;k\le j$ 满足 $l_k&lt;r_i$ 。</p>
<p>我们考虑每个顾客，填 $1$ 表示选择离开时候记录，$0$ 表示选择进入时记录。</p>
<p>那么一个位置填 $0$ 的条件为 $(i,ff[i]]$ 中有一个位置填 $0$ 或者存在一个位置 $k$ 填 $1$ 且 $i\in (k,ff[k]]$ 。</p>
<p>然后用 DP 维护合法方案即可。</p>
<p>一个显然的傻瓜式 DP 是：</p>
<p>$f_1[i]$ 表示 $i$ 填 $1$ 的目前合法序列个数。</p>
<p>$f_2[i]$ 表示 $i$ 填 $0$ 的可能合法序列个数。</p>
<p>$f_3[i]$ 表示 $i$ 填 $0$ ，$i-1$ 填 $1$ 的合法序列个数。</p>
<p>转移即可。</p>
<p>但是这里要讲一个优化，把 $f_3$ 优化掉，就是有一个转移是：</p>
<p>$f_2-&gt;f_3$ ，内容为往后放若干 $1$ 后放一个 $0$ ,那我们不妨先转移到 $f_1$ ，再减去没有放 $0$ 的序列（即减去不合法的序列）</p>
<p>于是：</p>
<p>$f_1[j]+=f2<a href="j\in (i,ff[i]">i</a>),f_1[j]-=(j\in (i+1,ff[i]])$</p>
<p>但是这时又产生了一个疑惑，在化简了式子后可以缩减为：</p>
<p>$f_1[i+1]+=f_2[i],f_1[ff[i]]-=f_2[i]$ 。</p>
<p>其实不难发现，所有的不合法方案在 DP 过程中都一定会经过 $f_1[ff[i]]$ 且贡献为 $1$ ，减掉即可。</p>
<p>时间复杂度：$O(n)$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 510000</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> LL mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> l,r;</span><br><span class="line">&#125;a[N];<span class="type">int</span> ff[N],n;</span><br><span class="line">LL f1[N],f2[N],f3[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a[i].l,&amp;a[i].r);</span><br><span class="line">    <span class="type">int</span> now=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(now&lt;n &amp;&amp; a[now+<span class="number">1</span>].l&lt;=a[i].r)now++;</span><br><span class="line">        ff[i]=now;</span><br><span class="line">    &#125;</span><br><span class="line">    LL fnow=<span class="number">0</span>;f1[<span class="number">1</span>]=f2[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        (f1[i]+=fnow)%=mod;(f2[ff[i]+<span class="number">1</span>]+=f1[i])%=mod;</span><br><span class="line">        <span class="keyword">if</span>(ff[i]&gt;i)(f2[i+<span class="number">1</span>]+=f2[i])%=mod,(f1[i+<span class="number">1</span>]+=f2[i])%=mod,(f1[ff[i]]+=mod-f2[i])%=mod;</span><br><span class="line">        (fnow+=f1[i])%=mod;(f3[ff[i]+<span class="number">1</span>]+=f1[i])%=mod;</span><br><span class="line">        (fnow+=mod-f3[i])%=mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// for(int i=1;i&lt;=n;i++)printf(&quot;%d:%d %lld %lld\n&quot;,i,ff[i],f1[i],f2[i]);</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,fnow);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></details>]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>AGC061 B Summation By Construction</title>
    <url>/2023/09/06/AGC061-B-Summation-By-Construction/</url>
    <content><![CDATA[<p>题目链接：<a href="https://atcoder.jp/contests/agc061/tasks/agc061_b">https://atcoder.jp/contests/agc061/tasks/agc061_b</a></p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>Mad，纯纯折磨题。</p>
<p>首先，$n=2$ 的时候是无解的，因为连出 $i=2$ 的路径后剩下的两条边无法连到一起。</p>
<p>做法的核心思想是，将两条路径拼到一起，考虑找出一个更长的路径，然后再拆开。</p>
<p>例如奇数的情况，是把路径拼成 $\frac{n+1}{2}$ 条长度为 $2n$ 的路径，然后拆出结果。</p>
<p>做法就是，下面分别从 $1,3,5..$ 开时重复连 M 型。（下面默认二分图上面部分有 $n$ 个点，下面部分有 $n+1$ 个点）</p>
<p>$n=5$ 的情况如下：</p>
<p><img src="1.png" alt=""></p>
<p>然后当时因为 $2$ 无解，而且偶数的情况我想不出来，感觉应该是无解，然后还证明了，然后就写了交上去，WA飞了，百思不得其解，下了数据才发现除了 $2$ 都有解，但是由于已经忘了怎么证了，也就不知道证明哪里假了。</p>
<p>所以，在做这种题目的时候，不能因为没想出来就主观认为无解（不然你猜猜这道题目的评级为什么 3000+ ），还是应该写个暴力或者手动再验证几组数据再下结论。</p>
<p>那么偶数怎么做呢？</p>
<p>同样的思路，我们发现 $i=n$ 一定会在下面产生两个奇数点，需要一条路径消掉，所以不妨考虑处理 $\frac{n}{2}+2$ 条路经，其中 $\frac{n}{2}-1$ 条处理上面为起终点的长度为 $2(n-1)$ 的路径，然后剩下三条路径一条以上面剩下两个奇数点为起终点，两条在下面。</p>
<p>首先是 $\frac{n}{2}-1$ 的路径，在上面分别以 $3,5,7…$ 为起点，以下面的 $n-1$ 个点为中转点抛出类似 M 的路径，被去掉的 $2$ 个点也是有规律的，按照 $(n-2,n-1),(n-4,n-3)…$ 这样下去。</p>
<p>剩下的边可以凑数长度为 $4,2n,2(n-3)$ 的路径，至于怎么凑，看代码吧。</p>
<p>时间复杂度：$O(Tn^2)$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 110</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NN 210</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> v[N][N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> T;<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">2</span>)&#123;<span class="built_in">printf</span>(<span class="string">&quot;No\n&quot;</span>);<span class="keyword">continue</span>;&#125;</span><br><span class="line">        <span class="keyword">if</span>(n&amp;<span class="number">1</span>)&#123;</span><br><span class="line">           <span class="type">int</span> x=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i+i&lt;=n;i++)&#123;</span><br><span class="line">                <span class="type">int</span> cnt=<span class="number">0</span>;<span class="type">int</span> y=x;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">                    cnt++;</span><br><span class="line">                    <span class="keyword">if</span>(cnt&lt;=i+i)v[j][y]=i;</span><br><span class="line">                    <span class="keyword">else</span> v[j][y]=n-i;</span><br><span class="line">                    cnt++;y++;<span class="keyword">if</span>(y==n+<span class="number">2</span>)y=<span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">if</span>(cnt&lt;=i+i)v[j][y]=i;</span><br><span class="line">                    <span class="keyword">else</span> v[j][y]=n-i;</span><br><span class="line">                &#125;</span><br><span class="line">                x+=<span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="type">int</span> pre=<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n/<span class="number">2</span>;i++)&#123;</span><br><span class="line">                <span class="type">int</span> x=i*<span class="number">2</span>+<span class="number">1</span>,t=n-i*<span class="number">2</span>,y=<span class="number">1</span>,cnt=pre+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span>(cnt==<span class="number">2</span> || cnt==n<span class="number">-3</span>)cnt++;</span><br><span class="line">                pre=cnt;</span><br><span class="line">                <span class="type">int</span> type=cnt;</span><br><span class="line">                <span class="comment">// printf(&quot;%d %d %d\n&quot;,x,y,t);</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;n;j++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(j&gt;cnt)type=n<span class="number">-1</span>-cnt;</span><br><span class="line">                    v[x][y]=type;</span><br><span class="line">                    x++;<span class="keyword">if</span>(x==n+<span class="number">1</span>)x=<span class="number">1</span>;</span><br><span class="line">                    <span class="comment">// printf(&quot;%d %d %d\n&quot;,x,y,t);</span></span><br><span class="line">                    v[x][y]=type;</span><br><span class="line">                    y++;<span class="keyword">if</span>(y==n+<span class="number">2</span>)y=<span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">while</span>(y==t || y==t+<span class="number">1</span>)&#123;y++;<span class="keyword">if</span>(y==n+<span class="number">2</span>)y=<span class="number">1</span>;&#125;</span><br><span class="line">                    <span class="comment">// printf(&quot;%d %d %d\n&quot;,x,y,t);</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            v[<span class="number">1</span>][<span class="number">1</span>]=v[<span class="number">1</span>][<span class="number">2</span>]=v[n][<span class="number">2</span>]=v[n][n+<span class="number">1</span>]=n;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n<span class="number">-2</span>;i++)v[n-i][n+<span class="number">2</span>-i]=v[n-i][n+<span class="number">1</span>-i]=n;</span><br><span class="line">            v[<span class="number">2</span>][<span class="number">1</span>]=v[<span class="number">2</span>][<span class="number">2</span>]=v[<span class="number">3</span>][<span class="number">2</span>]=v[<span class="number">3</span>][<span class="number">3</span>]=<span class="number">2</span>;</span><br><span class="line">            v[<span class="number">1</span>][<span class="number">3</span>]=v[<span class="number">4</span>][<span class="number">3</span>]=n<span class="number">-3</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">4</span>;i&lt;n;i++)v[i][i]=v[i+<span class="number">1</span>][i]=n<span class="number">-3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Yes\n&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n+<span class="number">1</span>;j++)<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,v[i][j]);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>回顾：</p>
<p>这道题目其实还是挺有难度的，回顾一下做题过程纪念纪念自己花了这么久时间做出来的一道题目。</p>
<p>而且这道题目的做题过程其实也可以推广到很多存在性构造题上。</p>
<p>首先看到一个构造题，尤其是比较难的构造题，如果直接从其的题目条件出发很多时候不一定能做，因为情况太多，太过复杂和没有规律，这个时候就需要把问题缩小到一个有规律的题目上面，只不过这种缩小有时候可能会无解。</p>
<p>例如奇数的情况我就认为一定存在一种方案使得路径能够连接成 $\frac{n+1}{2}$ 条长度为 $2n$ 的路径，从而把题目变成了一个有规律更好想的题目，但是这种缩小有时候不一定正确，思考缩小的过程也是凭直觉，比较感性，灵感往往来源于自己手动模拟多次后作出的猜想。</p>
<p>再例如，我认为偶数也可以拼成 $\frac{n}{2}$ 条长度为 $2(n-1)$ 的路径，但是却发现剩下的边构成了一个环（事实上想想也知道肯定不是路径，因为此时图中不存在奇数度的点），那么就把一条路径放回去，尝试人为的构造出三条路径。</p>
<p>而且这一步从度数的角度考虑也非常的正确，因为 $i=n$ 的路径一定会在下面创造一对奇数度点，所以我们必须把上面一条由两条路径拼成的路径拆回两条，一条占住他们本来的奇数度点，一条下来消掉 $i=n$ 创造的奇数度点。</p>
<p>然后通过这个操作，问题规模就缩小很多了，接下来就可以自己不断手模求一个通用解了，这样偶数的情况也就搞定了。</p>
<p>所以构造题，往往就是你自己再给题目加上一些约束条件，看看能否找到一个解，找不到就不断调整约束条件，直到找到为止。</p>
</div></details>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>二分图</tag>
        <tag>存在性构造</tag>
      </tags>
  </entry>
  <entry>
    <title>AGC063 A Mex Game</title>
    <url>/2023/08/25/AGC063-A-Mex-Game/</url>
    <content><![CDATA[<p>题目链接：<a href="https://atcoder.jp/contests/agc063/tasks/agc063_a">https://atcoder.jp/contests/agc063/tasks/agc063_a</a></p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>显然，如果我是 $A$ ，我一定会把数字放在最小的没被堵上的 $B$ 。</p>
<p> $B$ 同理，最终结果为最小的没有被堵上的位置上面的字符。</p>
<p>时间复杂度：$O(n)$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 210000</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">char</span> st[N];<span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> now1,now2,now3;</span><br><span class="line"><span class="type">bool</span> v[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,st);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i&amp;<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span>(now1&lt;n &amp;&amp; st[now1]!=<span class="string">&#x27;B&#x27;</span>)now1++;</span><br><span class="line">            <span class="keyword">if</span>(now1&lt;=n)v[now1++]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(now2&lt;n &amp;&amp; st[now2]!=<span class="string">&#x27;A&#x27;</span>)now2++;</span><br><span class="line">            <span class="keyword">if</span>(now2&lt;=n)v[now2++]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(now3&lt;=n &amp;&amp; v[now3])now3++;</span><br><span class="line">        <span class="keyword">if</span>(!v[now3])&#123;</span><br><span class="line">            <span class="keyword">if</span>(st[now3]==<span class="string">&#x27;A&#x27;</span>)<span class="built_in">printf</span>(<span class="string">&quot;Alice\n&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;Bob\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></details>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>博弈</tag>
      </tags>
  </entry>
  <entry>
    <title>AGC063 B Insert 1, 2, 3, ...</title>
    <url>/2023/08/25/AGC063-B-Insert-1-2-3/</url>
    <content><![CDATA[<p>题目链接：<a href="https://atcoder.jp/contests/agc063/tasks/agc063_b">https://atcoder.jp/contests/agc063/tasks/agc063_b</a></p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>对于一个序列的检验，我们可以认为是每次选择一个递增序列，删掉，看最后能不能删完，能删完就是合法序列。</p>
<p>证明两个定理：</p>
<ol>
<li>假如我在后面某步删除了某个序列，且这个序列在现在就存在且能删除，那么现在直接删除不会影响最终判断。<br>例如：1231234，我先删了 123 再删除 1234，但是其实一开始就能删除 1234，那么我一开始就删除 1234 不会影响最终判断。</li>
<li>加入我在某一步删除了一个序列，那么如果我在之前的某一步的瞬间突然删除掉了这个序列某一个后缀，不会导致将原本合法的序列判断为不合法。<br>例如：1231212456 ，显然删除顺序是：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure></div></details>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
  </entry>
  <entry>
    <title>AGC065 D Not Intersect</title>
    <url>/2024/02/11/AGC065-D-Not-Intersect/</url>
    <content><![CDATA[<p>题目链接：<a href="https://atcoder.jp/contests/agc065/tasks/agc065_d">https://atcoder.jp/contests/agc065/tasks/agc065_d</a></p>
<p>题目大意：圆上有 $n$ 个点，问有多少种连法，使得有 $m$ 条边且边不交叉（可以在端点处相交）</p>
<p>$n,m\le 10^7$ </p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>神仙组合意义，投降。</p>
<p>当 $m=0$ 或者 $m&gt;2n-3$ 时可以直接输出答案，下面默认 $n\ge 2,0&lt;m\le 2n-3$</p>
<p>设 $f_i$ 表示 $n$ 个点 $i$ 条边的答案，$g_i$ 表示 $n$ 个点 $i$ 条边且允许重边的答案。</p>
<p>显然有：$f_n=\sum\limits_{i=1}^n\binom{n-1}{i-1}g_i$</p>
<p>则由二项式反演有：$g_n=\sum\limits_{i=1}^{n}(-1)^{n-i}\binom{n-1}{i-1}f_i$ 。</p>
<p>现在考虑怎么计算 $g_i$ ，考虑边不能交叉这个条件，如果你足够智慧，你就会发现有一个结构很符合这个要求：栈。</p>
<p>现在我们用这么一个过程去描述连边的过程：</p>
<p>从 $1$ 到 $n$ ，到达 $i$ 的时候，先弹出栈内的若干元素，再往栈内加入若干个 $i$ ，到最后栈为空，如果 $i$ 在 $j$ 的时候弹出就代表了一条 $(i,j)$ 的边。</p>
<p>显然，这个过程一一对应，现在就是计数了。</p>
<p>可以发现，$1$ 只能入栈，$n$ 只能出栈，所以我们不妨改为 $n-1$ 次入栈和出栈。（接下来假设要求 $g_k$ 的值）</p>
<p>现在就是 $a_i$ 表示入栈的次数，$b_i$ 表示出栈的次数，满足：</p>
<script type="math/tex; mode=display">1\le i\le n-1,a_i\ge b_i,0\le a_i,b_i \le k,a_i\le a_{i+1},b_i\le b_{i+1},a_{n-1}=b_{n-1}=k</script><p>显然，一个合法的 $a$ 序列代表了一条从 $(0,0)$ 到 $(n-2,k)$ 只能向右或者向上的的路径，$b$ 同理。</p>
<p>则一个合法的 $a,b$ 序列对应了两条合法的路径，且满足一条路径始终在另外一条路径下端。</p>
<p>可以发现，我们设 $0$ 为向右，$1$ 为向上，假设我们能计算有 $a$ 个 $0$ ，$b$ 个 $1$ 时有多少对路径满足第二条路径在第一条路径下方，称作函数 $calc(a,b)$ ，那么我们所求的就是 $calc(n-2,k)$ 。</p>
<p>研究第 $i$ 步，可以发现就四种情况：$(0,0),(0,1),(1,0),(1,1)$ ，可以发现，就是要让每个时刻 $(1,0)$ 的数量不少于 $(0,1)$ 的数量，如果用折线法描述就是上面是：$0,-1,0,1$ ，然后不要让折线低过 $x$ 轴，显然，$-1,1$ 的数量是一样的，枚举 $1$ 的数量就可以知道四种情况的数量了：</p>
<script type="math/tex; mode=display">
\begin{align*} 
calc(a,b)&=\sum\limits_{i=0}^{min(a,b)}\frac{(2i)!}{i!(i+1)!}*\binom{a+b-2i}{a-i}*\binom{(a+b-2i)+(2i+1)-1}{(2i+1)-1}\\
&=\sum\limits_{i=0}^{min(a,b)}\frac{(2i)!}{i!(i+1)!}*\binom{a+b-2i}{a-i}*\binom{a+b}{2i}\\ 
&=\sum\limits_{i=0}^{min(a,b)}\frac{(2i)!}{i!(i+1)!}*\frac{(a+b-2i)!}{(a-i)!(b-i)!}*\frac{(a+b)!}{(2i)!(a+b-2i)!}\\ 
&=\sum\limits_{i=0}^{min(a,b)}\frac{(a+b)!}{i!(i+1)!(a-i)!(b-i)!}\\
&=\frac{(a+b)!}{a!(b+1)!}\sum\limits_{i=0}^{min(a,b)}\frac{a!}{i!(a-i)!}\frac{(b+1)!}{(i+1)!(b-i)!}\\
&=\frac{(a+b)!}{a!(b+1)!}\sum\binom{a}{i}\binom{b+1}{b-i}\\
&=\frac{(a+b)!}{a!(b+1)!}\binom{a+b+1}{b}\\
&=\frac{(a+b)!(a+b+1)!}{a!b!(a+1)!(b+1)!}
\end{align*}</script><p>然后直接算就行了。</p>
<p>时间复杂度：$O(n)$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> LL mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">3e7</span>+<span class="number">105</span>;</span><br><span class="line">LL fc[N],nfc[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> L=<span class="number">3e7</span>+<span class="number">3</span>;</span><br><span class="line">    fc[<span class="number">0</span>]=fc[<span class="number">1</span>]=nfc[<span class="number">0</span>]=nfc[<span class="number">1</span>]=<span class="number">1</span>;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=L;i++)nfc[i]=(mod-mod/i)*nfc[mod%i]%mod;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=L;i++)nfc[i]=nfc[i<span class="number">-1</span>]*nfc[i]%mod,fc[i]=fc[i<span class="number">-1</span>]*i%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n;LL m;</span><br><span class="line">LL g[N];</span><br><span class="line"><span class="function">LL <span class="title">calc</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fc[a+b+<span class="number">1</span>]*fc[a+b]%mod*nfc[a]%mod*nfc[b]%mod*nfc[a+<span class="number">1</span>]%mod*nfc[b+<span class="number">1</span>]%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">C</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fc[x]*nfc[y]%mod*nfc[x-y]%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%lld&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">if</span>(!m)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;1\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(m&gt;n+n<span class="number">-3</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;0\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//n&gt;=2</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)g[i]=<span class="built_in">calc</span>(n<span class="number">-2</span>,i);</span><br><span class="line">    LL ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>((m-i)&amp;<span class="number">1</span>)ans=(ans-g[i]*<span class="built_in">C</span>(m<span class="number">-1</span>,i<span class="number">-1</span>)%mod+mod)%mod;</span><br><span class="line">        <span class="keyword">else</span> ans=(ans+g[i]*<span class="built_in">C</span>(m<span class="number">-1</span>,i<span class="number">-1</span>))%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></details>
<h6 id="坑"><a href="#坑" class="headerlink" title="坑"></a>坑</h6><p>没有生成函数做法。</p>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>计数</tag>
      </tags>
  </entry>
  <entry>
    <title>AGC064 D Red and Blue Chips</title>
    <url>/2023/09/07/AGC064-D-Red-and-Blue-Chips/</url>
    <content><![CDATA[<p>题目链接：<a href="https://atcoder.jp/contests/agc064/tasks/agc064_d">https://atcoder.jp/contests/agc064/tasks/agc064_d</a></p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>Mad，做这道题目的时候把某个定理想错了，想的既错误又复杂，笑死，根本不会做，后面发现想错了，就简单很多了，不久就知道怎么做了。</p>
<p>定理1：假如给每个 B 标号，那么最终的芯片排列中 B 的不同排列有 $(n-1)!$ 种，因为最底下的 B 是固定的，而且每个排列对应一种操作方式（指的是 B 的操作方式）。（这个定理解决了 B 的位置）</p>
<p>定理2：我们定义最终排列中 B 下面的 R 的数量为其的权值，那么前 $i$ 个 B 的权值不超过第 $i$ 个 B 前面的 R 的数量，且只要满足这个要求，就一定能够构造出来。（这个定理解决了 R 的位置）</p>
<p>定理2的构造方法是在放第 $i$ 个 B 之前提前把芯片放到他即将覆盖的 B 的上面就行了，不难发现，在第 $i$ 个 B 放之前一定能放，不管即将被覆盖的 B 怎么移动，同时覆盖了之后一定不能再放。</p>
<p>那么接下来就是怎么做的问题了，显然求出每个 $B$ 的权值然后排列就行了，不难发现，我们可以人为的规定权值非严格单调递增。</p>
<p>接下来我的 DP 是：$dp[i][j][k]$ 表示前 $i$ 个 B 被考虑过了，前面还有 $j$ 个 R ，同时第 $i$ 个芯片的权值为 $k$ 。</p>
<p>不难发现 $k-&gt;k+1$ 的更新最多跑 $\frac{n}{k+1}$ 步，然后就会触发无法放置然后终止后续的更新。</p>
<p>所以这里有个调和级数，时间复杂度： $O(n^3\log{n})$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 310</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> LL mod=<span class="number">998244353</span>;</span><br><span class="line">LL nfc[N],fc[N];</span><br><span class="line">LL dp[N][N][N];</span><br><span class="line"><span class="type">int</span> n,m,a[N];</span><br><span class="line"><span class="type">char</span> st[N];</span><br><span class="line"><span class="function">LL <span class="title">C</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;<span class="keyword">return</span> fc[x]*nfc[y]%mod*nfc[x-y]%mod;&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%s&quot;</span>,&amp;n,st+<span class="number">1</span>);</span><br><span class="line">    fc[<span class="number">0</span>]=fc[<span class="number">1</span>]=nfc[<span class="number">0</span>]=nfc[<span class="number">1</span>]=<span class="number">1</span>;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)nfc[i]=nfc[mod%i]*(mod-mod/i)%mod;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)nfc[i]=nfc[i<span class="number">-1</span>]*nfc[i]%mod,fc[i]=fc[i<span class="number">-1</span>]*i%mod;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(st[i]==<span class="string">&#x27;B&#x27;</span>)m++;</span><br><span class="line">        <span class="keyword">else</span> a[m+<span class="number">1</span>]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)a[i]+=a[i<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">        dp[i][a[i]][<span class="number">0</span>]=<span class="built_in">C</span>(m<span class="number">-1</span>,i);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=a[i];j++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=a[m<span class="number">-1</span>];k++)dp[i][j][k]=(dp[i][j][k]+dp[i][j][k<span class="number">-1</span>])%mod;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=a[i];j++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=a[m<span class="number">-1</span>];k&gt;=<span class="number">1</span>;k--)&#123;</span><br><span class="line">                <span class="type">int</span> t=k<span class="number">-1</span>,now=j;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> q=i+<span class="number">1</span>;q&lt;m;q++)&#123;</span><br><span class="line">                    now+=a[q]-a[q<span class="number">-1</span>]-k;<span class="keyword">if</span>(now&lt;<span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">                    dp[q][now][k]=(dp[q][now][k]+dp[i][j][t]*<span class="built_in">C</span>(m<span class="number">-1</span>-i,q-i))%mod;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    LL ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=a[m<span class="number">-1</span>];i++)ans=(ans+dp[m<span class="number">-1</span>][i][a[m<span class="number">-1</span>]])%mod;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然而一翻题解，发现题解的复杂度没有 $\log$ ，于是我又去优化。</p>
<p>然后就改了一个地方，就是对于 $i$ ，实际上能够更新到答案的有效的 $i$ 只会到 $n-\frac{n}{k}$ 左右。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 310</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> LL mod=<span class="number">998244353</span>;</span><br><span class="line">LL nfc[N],fc[N];</span><br><span class="line">LL dp[N][N][N];</span><br><span class="line"><span class="type">int</span> n,m,a[N];</span><br><span class="line"><span class="type">char</span> st[N];</span><br><span class="line"><span class="function">LL <span class="title">C</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;<span class="keyword">return</span> fc[x]*nfc[y]%mod*nfc[x-y]%mod;&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%s&quot;</span>,&amp;n,st+<span class="number">1</span>);</span><br><span class="line">    fc[<span class="number">0</span>]=fc[<span class="number">1</span>]=nfc[<span class="number">0</span>]=nfc[<span class="number">1</span>]=<span class="number">1</span>;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)nfc[i]=nfc[mod%i]*(mod-mod/i)%mod;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)nfc[i]=nfc[i<span class="number">-1</span>]*nfc[i]%mod,fc[i]=fc[i<span class="number">-1</span>]*i%mod;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(st[i]==<span class="string">&#x27;B&#x27;</span>)m++;</span><br><span class="line">        <span class="keyword">else</span> a[m+<span class="number">1</span>]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)a[i]+=a[i<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">        dp[i][a[i]][<span class="number">0</span>]=<span class="built_in">C</span>(m<span class="number">-1</span>,i);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=a[i];j++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=a[m<span class="number">-1</span>];k++)dp[i][j][k]=(dp[i][j][k]+dp[i][j][k<span class="number">-1</span>])%mod;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i!=m<span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=a[i];j++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k=(a[m<span class="number">-1</span>]-a[i]+j)/(m<span class="number">-1</span>-i);k&gt;=<span class="number">1</span>;k--)&#123;</span><br><span class="line">                    <span class="type">int</span> t=k<span class="number">-1</span>,now=j;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> q=i+<span class="number">1</span>;q&lt;m;q++)&#123;</span><br><span class="line">                        now+=a[q]-a[q<span class="number">-1</span>]-k;<span class="keyword">if</span>(now&lt;<span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">                        dp[q][now][k]=(dp[q][now][k]+dp[i][j][t]*<span class="built_in">C</span>(m<span class="number">-1</span>-i,q-i))%mod;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    LL ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=a[m<span class="number">-1</span>];i++)ans=(ans+dp[m<span class="number">-1</span>][i][a[m<span class="number">-1</span>]])%mod;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么这个复杂度是多少呢？答案是 $O(n^3)$ 。</p>
<p>因为我们不妨考虑枚举 $k$ ，那么有效的 $i$ 有 $O(\frac{n}{k})$ 个，向后转移就平方 $O(n*(\sum\limits_{k=1}^n\frac{n^2}{k^2}))=O(n^3\sum\limits_{i=1}^n\frac{1}{i^2})=O(n^3)$ 。</p>
<p>奇妙吧，这就是时间复杂度分析的美妙之处，一个看似只改变常数的优化竟然能优化掉复杂度中的一个 $\log$ ，实在是奇妙无比。</p>
</div></details>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>计数</tag>
        <tag>经典trick</tag>
      </tags>
  </entry>
  <entry>
    <title>ARC172 D Distance Ranking</title>
    <url>/2024/03/18/ARC172-D-Distance-Ranking/</url>
    <content><![CDATA[<p>题目链接：<a href="https://atcoder.jp/contests/arc172/tasks/arc172_d">https://atcoder.jp/contests/arc172/tasks/arc172_d</a></p>
<p>题目大意：请你构造 $n$ 个 $n$ 维空间的整点，满足两点间距离的大小排序符合题目给的顺序。</p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>真TM人类智慧，根本想不到。</p>
<p>准确来说有想过先构造使得每条边都一样长，然后再微调，但是压根没想到微调的具体方法。</p>
<p>简单来说，设第 $i$ 个点的坐标是 $(a_{i,1},a_{i,2},…,a_{i,n})$ 。</p>
<p>先令 $a_{i,j}=[i=j]*K$ ，其中 $K$ 是一个很大的数字，显然，这样能使任意两点间的距离都等于 $\sqrt{2}K$ 。</p>
<p>现在的问题是怎么微调？我们假设给 $a_{i,1},a_{i,2},…,a_{i,n}$ 都加个相对于 $K$ 的小量，那么 $i$ 与别的点的距离会怎样变化呢?</p>
<p>将式子列出来可以发现，对于 $i,j$ 的距离的平方可以大致写成 $2K^2+c*K+O(1)$ ，其中 $c$ 与 $a_{i,i},a_{i,j}$ 有关，可以发现，这个式子的三个部分分别对应不同的量级。</p>
<p>对应任意两点的距离，都有 $2K^2$ 这一项，因此如果 $c*K$ 不一样，就可以用这一项控制相对大小了，显然此时 $O(1)$ 不影响相对大小。</p>
<p>接下来就很简单了，随便口胡一下就行了。</p>
<p>时间复杂度：$O(n^2)$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">30</span>;</span><br><span class="line"><span class="type">int</span> a[N][N];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)a[i][i]=<span class="number">1e6</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n*(n<span class="number">-1</span>)/<span class="number">2</span>;i++)&#123;</span><br><span class="line">        <span class="type">int</span> x,y;<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;x,&amp;y);</span><br><span class="line">        a[x][y]+=n*(n<span class="number">-1</span>)/<span class="number">2</span>-i+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,a[i][j]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>哎，菜就得多练了，根本想不到。</p>
<p>但多练真的有用吗？</p>
</div></details>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>构造</tag>
      </tags>
  </entry>
  <entry>
    <title>AGC063 C Add Mod Operations</title>
    <url>/2023/09/01/AGC063-C-Add-Mod-Operations/</url>
    <content><![CDATA[<p>题目链接：<a href="https://atcoder.jp/contests/agc063/tasks/agc063_c">https://atcoder.jp/contests/agc063/tasks/agc063_c</a></p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>无解的充分必要条件：</p>
<p>存在 $i,j(i≠j)$ ，使得 $a_i=a_j,b_i≠b_j$ 。</p>
<p>有解时的构造方法：</p>
<p>设 $c_i$ 表示 $a_i$ 在 $a$ 序列里面从大到小排序的位置。</p>
<p>考虑构造一个这样的序列：$b_i+c_i*K$ ，$K$ 表示一个大于所有 $a$ 的数字。</p>
<p>然后最后全部模 $K$ 就行了。</p>
<p>怎么构造这个序列呢？考虑不算次数的情况，那么先把所有数字加个 INF ，然后每次让当前最大的数字变成 $0$，并且再变成 $0$ 之前加上这个数字与前一个变成 $0$ 的数字之间的间隔，然后就做完了。</p>
<p>然后只要精细化的处理一下这个过程，就可以办到恰好 $n$ 次做完这个过程。</p>
<p>时间复杂度：$O(n\log{n})$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 1100</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;LL,LL&gt; PLL;</span><br><span class="line"><span class="type">const</span> LL inf=<span class="number">1e16</span>;</span><br><span class="line">LL a[N],b[N];<span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> top,sta[N];LL now,d[N];</span><br><span class="line">PLL c[N];LL maxcost=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;<span class="keyword">return</span> a[x]&gt;a[y];&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;a[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;<span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;b[i]);maxcost=<span class="built_in">max</span>(maxcost,b[i]+<span class="number">1</span>);&#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="type">bool</span> bk=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>((a[j]==a[i]) &amp;&amp; (b[j]!=b[i]))&#123;<span class="built_in">printf</span>(<span class="string">&quot;No\n&quot;</span>);<span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line">            <span class="keyword">if</span>(j&lt;i &amp;&amp; a[j]==a[i])bk=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!bk)sta[++top]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(sta+<span class="number">1</span>,sta+top+<span class="number">1</span>,cmp);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;top;i++)d[i]=(top-i<span class="number">-1</span>)*maxcost+b[sta[i]];</span><br><span class="line">    now=inf;LL nowx=now%maxcost;now+=(b[sta[top]]-nowx+maxcost)%maxcost;now-=a[sta[top]];</span><br><span class="line">    c[top].second=maxcost;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Yes\n%d\n&quot;</span>,top);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=top;i&gt;=<span class="number">1</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i!=top)c[i].second=now+a[sta[i]];</span><br><span class="line">        <span class="keyword">if</span>(i!=<span class="number">1</span>)c[i].first=d[i<span class="number">-1</span>]-d[i],now-=c[i].first;</span><br><span class="line">    &#125;</span><br><span class="line">    c[<span class="number">1</span>].first=now;</span><br><span class="line">    <span class="keyword">if</span>(top==<span class="number">1</span>)c[<span class="number">1</span>].first%=c[<span class="number">1</span>].second;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=top;i++)<span class="built_in">printf</span>(<span class="string">&quot;%lld %lld\n&quot;</span>,c[i].first,c[i].second);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></details>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>构造</tag>
      </tags>
  </entry>
  <entry>
    <title>ARC170 E BDFS</title>
    <url>/2024/02/20/ARC170-E-BDFS/</url>
    <content><![CDATA[<p>题目链接：<a href="https://atcoder.jp/contests/arc170/tasks/arc170_e">https://atcoder.jp/contests/arc170/tasks/arc170_e</a></p>
<p>题目大意：现在有一个 $n$ 个点的环，然后每个点的权值 $a_i$ ，一开始都是 $-1$ ，然后有个队列，初始只有一个 $(1,0)$，</p>
<p>然后每次弹出队首 $(d,v)$，若 $a_d=-1$ ，则：</p>
<ol>
<li>$a_d=v$ 。</li>
<li>从小到大考虑 $d$ 相邻的权值为 $-1$ 的邻居 $x$ ，然后有 $p$ 的概率把 $(x,v+1)$ 加入队首，否则加入队尾。</li>
</ol>
<p>问最后所有点的权值和的期望。</p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>唐，太唐了，转换完题意不会做，一个经典的二阶期望不会，唐，太烫了。</p>
<p>首先，这道题目显然可以转换成这个题意：</p>
<p>现在有一个长度为二的数组：$a[0]=-1,a[1]=0$ ，然后 $type=0$ ，现在进行 $n-1$ 轮：</p>
<ol>
<li><code>a[type]++</code> 。</li>
<li>有 $p$ 的概率不发生变化，有 $1-p$ 的概率 <code>type^=1</code> 。</li>
</ol>
<p>问最后 $\frac{a<a href="a[0]+1">0</a>}{2}+\frac{a<a href="a[1]+1">1</a>}{2}$ 的期望值。</p>
<p>首先，多少阶的期望都是能做的，开对应阶数个状态就行了，像自然数幂求和那样推一下式子就行了。</p>
<p>这里是二阶期望，开两个状态即可。</p>
<p>但这里由于数组有两个位置，所以还要再多开一个状态，总共三个状态，分别为：</p>
<p>$f_{ans}[n]$ 表示 $n$ 轮后的期望答案，$f_0[n]$ 表示 $a[type]$ 的期望值，$f_1[n]$ 表示 $a[1-type]$ 的期望值。</p>
<p>则式子为：</p>
<script type="math/tex; mode=display">
\begin{align*}
    f_{ans}[n+1]&=f_{ans}[n]+f_{0}[n]+1\\
    f_{0}[n+1]&=p(f_{0}[n]+1)+(1-p)f_{1}[n]\\
    f_{1}[n+1]&=(1-p)(f_{0}[n]+1)+pf_{1}[n]\\
\end{align*}</script><p>然后直接矩阵快速幂就行了。</p>
<p>时间复杂度：$O(T\log{n})$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> LL mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Matrix</span>&#123;</span><br><span class="line">    LL a[<span class="number">4</span>][<span class="number">4</span>];</span><br><span class="line">    <span class="built_in">Matrix</span>()&#123;</span><br><span class="line">        <span class="built_in">memset</span>(a,<span class="number">0</span>,<span class="built_in">sizeof</span>(a));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;O,tr;</span><br><span class="line">Matrix <span class="keyword">operator</span>*(Matrix x,Matrix y)&#123;</span><br><span class="line">    Matrix z;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">3</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=<span class="number">3</span>;j++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;=<span class="number">3</span>;k++)&#123;</span><br><span class="line">                z.a[i][j]=(z.a[i][j]+x.a[i][k]*y.a[k][j])%mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> z;</span><br><span class="line">&#125;</span><br><span class="line">Matrix <span class="keyword">operator</span>+(Matrix x,Matrix y)&#123;</span><br><span class="line">    Matrix z;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">3</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=<span class="number">3</span>;j++)z.a[i][j]=(x.a[i][j]+y.a[i][j])%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> z;</span><br><span class="line">&#125;</span><br><span class="line">Matrix <span class="keyword">operator</span>%(Matrix x,LL y)&#123;<span class="keyword">return</span> x;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">ksm</span><span class="params">(T x,LL y,T o)</span></span>&#123;</span><br><span class="line">    T ans=o;</span><br><span class="line">    <span class="keyword">while</span>(y)&#123;</span><br><span class="line">        <span class="keyword">if</span>(y&amp;<span class="number">1</span>)ans=ans*x%mod;</span><br><span class="line">        x=x*x%mod;y&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">3</span>;i++)&#123;</span><br><span class="line">        O.a[i][i]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> T;<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        LL n,p;<span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>,&amp;n,&amp;p);</span><br><span class="line">        p=p*<span class="built_in">ksm</span>(<span class="number">100ll</span>,mod<span class="number">-2</span>,<span class="number">1ll</span>)%mod;</span><br><span class="line">        LL pn=(<span class="number">1</span>-p+mod)%mod;</span><br><span class="line">        </span><br><span class="line">        tr.a[<span class="number">0</span>][<span class="number">0</span>]=tr.a[<span class="number">1</span>][<span class="number">0</span>]=tr.a[<span class="number">3</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        tr.a[<span class="number">1</span>][<span class="number">1</span>]=tr.a[<span class="number">3</span>][<span class="number">1</span>]=p;tr.a[<span class="number">2</span>][<span class="number">1</span>]=pn;</span><br><span class="line">        tr.a[<span class="number">1</span>][<span class="number">2</span>]=tr.a[<span class="number">3</span>][<span class="number">2</span>]=pn;tr.a[<span class="number">2</span>][<span class="number">2</span>]=p;</span><br><span class="line">        tr.a[<span class="number">3</span>][<span class="number">3</span>]=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        Matrix ans=<span class="built_in">ksm</span>(tr,n,O);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,(ans.a[<span class="number">3</span>][<span class="number">0</span>]-ans.a[<span class="number">1</span>][<span class="number">0</span>]+mod)%mod);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我当时其实写出了一个正确的式子，但我不知道怎么推了，在文章的最后放一下吧，悲。</p>
<script type="math/tex; mode=display">\frac{(n-1)n}{2}-\sum\limits_{x=1}^{n-1}(x-1)(n-x)\sum\limits_{i=1}^x\binom{x-1}{i}\binom{n-1-x}{i-1}p^{n-1-2i}(1-p)^{2i}+\binom{x-1}{i-1}\binom{n-1-x}{i-1}p^{n-2i}(1-p)^{2i-1}</script><p>唐，怎么每次碰到dp+矩阵快速幂的题都不会做啊，悲。</p>
</div></details>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>概率与期望</tag>
        <tag>dp</tag>
        <tag>矩阵</tag>
      </tags>
  </entry>
  <entry>
    <title>Bridge Elimination</title>
    <url>/2024/02/02/Bridge-Elimination/</url>
    <content><![CDATA[<p>题目链接：<a href="https://qoj.ac/contest/1499/problem/8180">https://qoj.ac/contest/1499/problem/8180</a></p>
<p>题目大意：给定 $n$ 个点的点权，求 $n$ 个点的所有图的权值和，一个图的权值定义为：如果不连通，则为 $0$ ，联通则为所有边双的点权和的乘积。</p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>知道 Cayley 公式乱做。（但是我赛时不知道这个公式 QAQ ）</p>
<p>时间复杂度：$O(n^3)$ 。</p>
<p>解释一下代码：</p>
<p>$cn[i]$ 是 $i$ 个点的联通图的数量。</p>
<p>$dp[i][j]$ 表示有 $j$ 个点，恰好有 $i$ 个连通块的图的权值和（一个图的权值定义为每个连通块大小的乘积）</p>
<p>$bn[i]$ 表示 $i$ 个点的边双联通块数量。</p>
<p>$ff[i]$ 表示 $n$ 个点中，指定的 $i$ 个点各在一个边双，且联通，且恰有 $i$ 个边双的图的数量。</p>
<p>$ge[i]$ 表示从 $n$ 个点中选 $i$ 个点的点权乘积的和。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> LL mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">4e2</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n;LL a[N];</span><br><span class="line">LL fc[N],nfc[N];</span><br><span class="line"><span class="function">LL <span class="title">ksm</span><span class="params">(LL x,LL y)</span></span>&#123;</span><br><span class="line">    LL ans=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(y)&#123;</span><br><span class="line">        <span class="keyword">if</span>(y&amp;<span class="number">1</span>)ans=ans*x%mod;</span><br><span class="line">        x=x*x%mod;y&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    fc[<span class="number">0</span>]=fc[<span class="number">1</span>]=nfc[<span class="number">0</span>]=nfc[<span class="number">1</span>]=<span class="number">1</span>;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)nfc[i]=(mod-mod/i)*nfc[mod%i]%mod;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)nfc[i]=nfc[i<span class="number">-1</span>]*nfc[i]%mod,fc[i]=fc[i<span class="number">-1</span>]*i%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">C</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;<span class="keyword">return</span> fc[x]*nfc[y]%mod*nfc[x-y]%mod;&#125;</span><br><span class="line"><span class="keyword">namespace</span> Graph&#123;</span><br><span class="line">    LL cn[N],dp[N][N],bn[N];</span><br><span class="line">    LL f[N][N],ff[N];</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cn[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            cn[i]=<span class="built_in">ksm</span>(<span class="number">2</span>,i*(i<span class="number">-1</span>)/<span class="number">2</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;i;j++)cn[i]=(cn[i]-cn[j]*<span class="built_in">ksm</span>(<span class="number">2</span>,(i-j)*(i-j<span class="number">-1</span>)/<span class="number">2</span>)%mod*<span class="built_in">C</span>(i<span class="number">-1</span>,j<span class="number">-1</span>)%mod+mod)%mod;</span><br><span class="line">        &#125;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i;j&lt;=n;j++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;j;k++)&#123;<span class="comment">//pre size</span></span><br><span class="line">                    <span class="type">int</span> cnt=j-k;</span><br><span class="line">                    dp[i][j]=(dp[i][j]+dp[i<span class="number">-1</span>][k]*cn[cnt]%mod*<span class="built_in">C</span>(j<span class="number">-1</span>,cnt<span class="number">-1</span>)%mod*cnt)%mod;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            bn[i]=cn[i];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;i;j++)&#123;<span class="comment">//1&#x27;s size</span></span><br><span class="line">                LL now=<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=i-j;k++)&#123;</span><br><span class="line">                    now=now*j%mod;</span><br><span class="line">                    bn[i]=(bn[i]-bn[j]*<span class="built_in">C</span>(i<span class="number">-1</span>,j<span class="number">-1</span>)%mod*dp[k][i-j]%mod*now%mod+mod)%mod;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        f[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i;j&lt;=n;j++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;j;k++)&#123;</span><br><span class="line">                    <span class="type">int</span> cnt=j-k;</span><br><span class="line">                    f[i][j]=(f[i][j]+f[i<span class="number">-1</span>][k]*<span class="built_in">C</span>(j-i,cnt<span class="number">-1</span>)%mod*bn[cnt]%mod*cnt)%mod;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ff[<span class="number">1</span>]=bn[n];<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)ff[i]=f[i][n]*<span class="built_in">ksm</span>(n,i<span class="number">-2</span>)%mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">LL ge[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    Graph::<span class="built_in">init</span>();</span><br><span class="line">    ge[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;a[i]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i;j&gt;=<span class="number">1</span>;j--)ge[j]=(ge[j<span class="number">-1</span>]*a[i]+ge[j])%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    LL ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        ans=(ans+ge[i]*Graph::ff[i])%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></details>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>计数</tag>
        <tag>Prüfer序列</tag>
      </tags>
  </entry>
  <entry>
    <title>CF1526 E Oolimry and Suffix Array(从后缀数组反推字符串)</title>
    <url>/2024/02/16/CF1526-E-Oolimry-and-Suffix-Array-%E4%BB%8E%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84%E5%8F%8D%E6%8E%A8%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<p>题目链接：<a href="https://codeforces.com/contest/1526/problem/E">https://codeforces.com/contest/1526/problem/E</a></p>
<p>题目大意：字符集大小为 $n$ ，询问有多少个字符串的后缀数组就是给定的后缀数组。</p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>其实我也不太清楚我是怎么想到这个做法的，反正就是想什么时候两个位置的字符能够相同，然后就知道怎么做了。</p>
<p>看到一个题解说的很有道理：<a href="https://www.luogu.com.cn/blog/namelessgugugu/solution-cf1526e">https://www.luogu.com.cn/blog/namelessgugugu/solution-cf1526e</a></p>
<p>这么说的：知道 $s[i,n]&lt;s[j,n]$ ，就知道 $s[i]\le s[j]$ ，问题是什么时候能够相等，显然是 $s[i+1,n]&lt;s[j+1,n]$ 的时候能够相等。</p>
<p>所以做法就出来了：显然后缀数组上每个位置的字符是非严格递增的，问题是相邻的位置字符能否相等，显然条件就是上面那个，假设我们已经知道了至少需要有 $now$ 个不同的字符，则答案为：</p>
<script type="math/tex; mode=display">\sum\limits_{i=0}^{\min(n,K)-now}\binom{K}{i+now}\binom{n-now}{i}</script><p>显然，这已经足以通过此题，但是还能再简化：</p>
<script type="math/tex; mode=display">
\begin{align*}
&\sum\limits_{i=0}^{\min(n,K)-now}\binom{K}{i+now}\binom{n-now}{i}\\
=& \sum\limits_{i=0}^{\min(n,K)-now}\binom{K}{i+now}\binom{n-now}{n-now-i}\\
=& \sum\limits_{i=0}^{n}\binom{K}{i}\binom{n-now}{n-i}\\
\end{align*}</script><p>最后一步是因为超出来的范围都因为组合数不合法所以值为 $0$ ，不会对结果产生影响。</p>
<p>所以显然，最终化简结果为：$\binom{K+n-now}{n}$ 。</p>
<p>时间复杂度：$O(n+K)$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> LL mod=<span class="number">998244353</span>;</span><br><span class="line">LL fc[N],nfc[N];</span><br><span class="line"><span class="type">int</span> n,K,sa[N],rk[N];</span><br><span class="line"><span class="function">LL <span class="title">C</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;<span class="keyword">return</span> fc[x]*nfc[y]%mod*nfc[x-y]%mod;&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;K);</span><br><span class="line">    fc[<span class="number">0</span>]=fc[<span class="number">1</span>]=nfc[<span class="number">0</span>]=nfc[<span class="number">1</span>]=<span class="number">1</span>;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=<span class="built_in">max</span>(n,K);i++)nfc[i]=(mod-mod/i)*nfc[mod%i]%mod;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=<span class="built_in">max</span>(n,K);i++)fc[i]=fc[i<span class="number">-1</span>]*i%mod,nfc[i]=nfc[i<span class="number">-1</span>]*nfc[i]%mod;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;sa[i]);</span><br><span class="line">        rk[sa[i]]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// rk[n+1]=0;</span></span><br><span class="line">    <span class="type">int</span> now=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(rk[sa[i<span class="number">-1</span>]+<span class="number">1</span>]&gt;rk[sa[i]+<span class="number">1</span>])&#123;</span><br><span class="line">            now++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    LL ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i+now&lt;=n &amp;&amp; i+now&lt;=K;i++)&#123;</span><br><span class="line">        ans=(ans+<span class="built_in">C</span>(K,i+now)*<span class="built_in">C</span>(n-now,i))%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></details>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>计数</tag>
        <tag>字符串</tag>
        <tag>后缀数组</tag>
      </tags>
  </entry>
  <entry>
    <title>Border学习笔记</title>
    <url>/2024/02/11/Border%E7%90%86%E8%AE%BA/</url>
    <content><![CDATA[<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://www.luogu.com.cn/blog/command-block/border-li-lun-xiao-ji">https://www.luogu.com.cn/blog/command-block/border-li-lun-xiao-ji</a></p>
<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><h2 id="Border"><a href="#Border" class="headerlink" title="Border"></a>Border</h2><p>$Border$ ：字符串的某个前缀（非原串），能与后缀完全匹配。</p>
<p>例：$S[1,m]=S[n-m+1,n]$ ，那么称 $S[1,m]$ 为 $S$ 的一个 $Border$ 。</p>
<p>接下来简称 $Border$ 为 $Bd$ 。</p>
<p>我们称 $mxBd(S)$ 为 $S$ 最长的 $Bd$ ，$Bd(S)$ 为 $S$ 的 $Bd$ 集合。</p>
<h2 id="周期"><a href="#周期" class="headerlink" title="周期"></a>周期</h2><p>若对于 $p$ ，有 $S[i]=S[i+p]$ ，称 $p$ 是 $S$ 的周期。</p>
<p>若 $p| |S|$ ，则称 $p$ 为整周期。</p>
<p>显然，$S[1,p]$ 是 $Bd$ $\Leftrightarrow$ $|S|-p$ 是周期。</p>
<h1 id="与-kmp-的关系"><a href="#与-kmp-的关系" class="headerlink" title="与 kmp 的关系"></a>与 kmp 的关系</h1><h2 id="求每个前缀的最长-Border"><a href="#求每个前缀的最长-Border" class="headerlink" title="求每个前缀的最长 Border"></a>求每个前缀的最长 Border</h2><p>显然，$fail[i]$ 表示的就是 $mxBd(S[1,i])$ 的长度。</p>
<h2 id="求一个串的-Bd-集合。"><a href="#求一个串的-Bd-集合。" class="headerlink" title="求一个串的 $Bd$ 集合。"></a>求一个串的 $Bd$ 集合。</h2><p>无脑 Hash 可以，但是有个更加有理有据的做法：</p>
<p>$Bd(S)=\{mxBd(S)\}+Bd(mxBd(S))$</p>
<p>然后直接用 kmp 的 fail 指针不断跳就行了，即 $Bd(S)$ 对应了 $fail$ 树上的一条链。</p>
<h1 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h1><h2 id="弱周期引理-Weak-Periodicity-Lemma，简称：WPL"><a href="#弱周期引理-Weak-Periodicity-Lemma，简称：WPL" class="headerlink" title="弱周期引理(Weak Periodicity Lemma，简称：WPL)"></a>弱周期引理(Weak Periodicity Lemma，简称：WPL)</h2><p>$p,q$ 都是 $S$ 的周期 ，且 $p+q\le |S|$ ，则 $gcd(p,q)$ 也是 $S$ 的周期。</p>
<p>证明：不妨假设 $p&lt;q$ 。</p>
<p>$S[i]=S[i+q]=S[i+q-p],i\le n-q$</p>
<p>$S[i]=S[i-p]=S[i+q-p],p\le n-q&lt;i\le n+q-p$</p>
<p>所以 $q-p$ 也是一个周期，辗转相减即可证明该结论。</p>
<p>PS：强周期定理：把条件改成 $p+q-gcd(p,q)\le n$ ，不会证明，大部分情况下用弱周期就行了，强周期了解即可。</p>
<p>推论：如果一个串有 $&lt;|S|$ 的整周期，则最小周期也是整周期。</p>
<h2 id="等差数列"><a href="#等差数列" class="headerlink" title="等差数列"></a>等差数列</h2><p><strong>性质 1</strong> ：$S,T,2|S|\ge |T|$ ，则 $S$ 在 $T$ 中的出现位置构成等差数列。</p>
<details class="toggle" ><summary class="toggle-button" style="">证明</summary><div class="toggle-content"><p>如果出现次数小于 $3$ 次，显然成立。</p>
<p>考虑第一次出现位置 $S1$ 、第二次出现位置 $S2$ 和任意一次（除了前两次）出现位置 $S3$ ，假设 $S2-S1=l1,S3-S2=l2$ 。</p>
<p><img src="1.png" alt=""></p>
<p>现在证明 $l1 | l2$ ，考虑 $S1\cup S2$ 这个字符串，显然 $l1,l2$ 都是一个周期，且 $l2\le |S|$ ，则 $l1+l2\le l1+|S|=|S1\cup S2|$ ，所以 $gcd(l1,l2)$ 也是一个周期，如果 $gcd(l1,l2)&lt;l1$ ，则在 $S1$ 和 $S2$ 中间显然还出现了至少一次，与假设矛盾，证毕。</p>
<p>所以 $l1 | l2$ ，则结论显然成立 ，$l1$ 就是公差。</p>
</div></details>
<p><strong>性质 2</strong> ：一个字符串 $S$ 的长度 $\ge \frac{|S|}{2}$ 的 Border 构成等差数列。</p>
<details class="toggle" ><summary class="toggle-button" style="">证明</summary><div class="toggle-content"><p>第一个证明方法是用周期和 Border 的等价性，然后用 WPL 很容易就能证明。</p>
<p>还有一个证明方法是用上面的性质 $1$ ，设 $s$ 为 $\ge \frac{|S|}{2}$ 的长度最短的 Border 。</p>
<p>考虑 $s$ 的所有出现位置，显然，一个 $\ge \frac{|S|}{2}$ 的 Border 对应一个 $s$ 的出现位置，只需要证明一个 $s$ 的出现位置（除了最后一个位置）也对应一个 Border 即可。</p>
<p>（对应方式为：除了最后一个出现位置外的出现位置，考虑这个出现位置的右端点，右端点对应的前缀就是一个 Border ，实际上，如果把原串也视作一个 border 的话，那么最后一个出现位置也有对应了）</p>
<p><img src="2.png" alt=""></p>
<p>证明方法为：观察性质 $1$ 的证明可以发现，$s$ 出现位置的公差就是 $S$ 的周期，所以显然除了最后一个位置外的每一个出现位置都对应了一个 Border 。</p>
<p>但是上面两个方法我还是推荐用周期进行考虑。</p>
</div></details>
<p><strong>性质 3</strong> ：一个字符串的 Border 从小到大排序可以划分成 $O(\log{|S|})$ 个等差数列。</p>
<details class="toggle" ><summary class="toggle-button" style="">证明</summary><div class="toggle-content"><p>考虑 $\ge \frac{|S|}{2}$ 的 Border 构成等差数列，然后考虑 $&lt;\frac{|S|}{2}$ 的最大的 Border ，显然，剩下的 Border 也是这个 Border 的 Border ，然后接着考虑就行了，所以至多 $O(\log{|S|})$ 个。</p>
</div></details>
<p>事实上，通过上面的描述，不难发现：</p>
<p>长度在 $(\frac{|S|}{2},|S|],(\frac{|S|}{4},\frac{|S|}{2}],(\frac{|S|}{8},\frac{|S|}{4}],(\frac{|S|}{16},\frac{|S|}{8}]…$ 即 $(\frac{|S|}{2^{k+1}},\frac{|S|}{2^k}]$ 的 Border 构成等差数列。</p>
<p>或者长度在 $[1,2),[2,4),…,[2^i,2^{i+1}),[2^{i+1},|S|]$ 的 Border 也构成等差数列。（ $|S|&lt;2^{i+2}$ ）</p>
<p>显然，长度在 $<a href="2a\ge b">a,b</a>$ 的 Border 都构成等差数列。</p>
<h2 id="失配树"><a href="#失配树" class="headerlink" title="失配树"></a>失配树</h2><p>对于一个串，考虑对于每个前缀建立一个节点，其父亲是其的 $mxBd$ ，这样构成的一棵根为空串的树叫做失配树，显然，Kmp 的 fail 数组就代表了这棵树。</p>
<p>这棵树有很多性质。</p>
<p><strong>性质 1</strong> ：根据 $Bd(S)=\{mxBd(S)\}+Bd(mxBd(S))$ 可以得出，一个前缀的所有 Bd 就是到父亲的这条链。</p>
<p>这个性质可以用于解决这个题目：</p>
<p><a href="https://www.luogu.com.cn/problem/P5829">https://www.luogu.com.cn/problem/P5829</a></p>
<p>题目大意：给一个串，$q$ 次询问，每次询问询问两个前缀的最长公共 border 长度。</p>
<p>显然就是失配树上找 LCA 就行了。</p>
<p><strong>性质 2</strong> ：每个点到根节点的路径可以划分成 $O(\log)$ 段，每段父子间长度差恒定。（也就是上面 $O(\log)$ 段等差数列的失配树版本）</p>
<p>这个性质可以产生上面那道题目的另外一个做法：</p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>首先，先介绍一种常数更加小的划分 Border 的方式：</p>
<p>如果 $2fail[x]\ge x$ ，令 $p=x-fail[x]$ ，那么 $x$ 到 $x\mod {p}+p$ 构成等差数列，否则 $x$ 自己就是个等差数列。</p>
<p>然后令 $x$ 跳到最大的没有被划分进等差数列的位置就行了，实操中当 $2fail[x]\ge x$ 时，往往直接跳到 $x\mod {p}+p$ ，即认为等差数列间可以有交叉，这样处理方便一些，而且显然，不难证明这么跳 $x’&lt;\frac{2x}{3}$ ，所以仍然是 $O(\log)$ 段。</p>
<p>（这个划分方式还有个小性质，如果 $2fail[x]\ge x$ ，则等差数列至少有两项，否则只有一项）</p>
<p>在划分完 Border 后，显然可以用扩展欧几里得去处理，但是这样是两个 $\log$ 的，而且写起来还没 LCA 好写。</p>
<p>考虑利用性质进行优化，现在考虑找 $x,y$ 前缀的最长公共 Bd ，不妨认为原串也算 Bd，且 $x&gt;y$ ，考虑上述划分中 $x$ 的第一个等差数列。</p>
<p>如果 $2fail[x]&lt;x$，那么显然 $x=fail[x]$ 即可。</p>
<p>如果 $2fail[x]\ge x$ ，那么显然如果 $x\equiv y\mod p$ ，则 $y$ 就是最长公共 Bd ，否则考虑 $y$ 的长度：</p>
<ol>
<li>如果 $y&lt;2p$ ，那么显然这个等差数列，也就是分配树上的这条链除了链头没有别的串可能是公共 Bd 。</li>
<li>如果 $y\ge 2p$ ，显然 $y$ 的最小周期也是 $p$ ，则根据 WPL 可以得出链上 $\ge 2p$ 的点都不可能是公共 Bd（考虑 $x,y$ $\ge 2p$ 的所有 Bd ，显然互不相同），也即只有链头还有可能成为答案，所以 $x=x\mod p+p$。</li>
</ol>
<p>不难发现，这个做法的复杂度与 $x,y$ 按照上述方法划分的等差数列个数同阶（因为上面的过程其实就是从一个等差数列的列尾，跳到下一个等差数列的列尾），也就是 $O(n+q\log{n})$ ，而且显然好写很多，空间也只用 $O(n)$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e6</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">char</span> st[N];</span><br><span class="line"><span class="type">int</span> fail[N],n,q;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,st+<span class="number">1</span>);n=<span class="built_in">strlen</span>(st+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    fail[<span class="number">0</span>]=<span class="number">-1</span>;<span class="type">int</span> now=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(now!=<span class="number">-1</span> &amp;&amp; st[now+<span class="number">1</span>]!=st[i])now=fail[now];</span><br><span class="line">        fail[i]=++now;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;q);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=q;i++)&#123;</span><br><span class="line">        <span class="type">int</span> x,y;<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;x,&amp;y);</span><br><span class="line">        x=fail[x];y=fail[y];</span><br><span class="line">        <span class="keyword">while</span>(x!=y)&#123;</span><br><span class="line">            <span class="keyword">if</span>(x&lt;y)<span class="built_in">swap</span>(x,y);</span><br><span class="line">            <span class="keyword">if</span>(fail[x]*<span class="number">2</span>&lt;x)x=fail[x];</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="built_in">assert</span>(x);</span><br><span class="line">                <span class="type">int</span> d=x-fail[x];</span><br><span class="line">                <span class="keyword">if</span>(x%d==y%d)x=y;</span><br><span class="line">                <span class="keyword">else</span> x=x%d+d;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></details>
<h2 id="一些其他性质"><a href="#一些其他性质" class="headerlink" title="一些其他性质"></a>一些其他性质</h2><ol>
<li><p>如果一个串 $S$ 有 $\ge \frac{|S|}{2}$ 的 Border，则最小的 $\ge \frac{|S|}{2}$ 的 Border 长度 $&lt;\frac{3|S|}{4}$ 。</p>
<details class="toggle" ><summary class="toggle-button" style="">证明</summary><div class="toggle-content"><p>假如最小周期 $p\le \frac{|S|}{4}$ ，则显然 Border $\ge \frac{3|S|}{4}$ 时，还能再去掉一个周期，直到 $&lt;\frac{3|S|}{4}$ 。</p>
<p>假如 $&gt;$ ，显然所有的 Border 都 $&lt;\frac{3|S|}{4}$ ，所以也显然成立。</p>
<p>证毕。</p>
</div></details>
</li>
<li><p>如果一个串 $s$ 有一个 $t$ 作为 mxBd ，且 $2|t|\ge|s|$ ，那么 $t$ 在 $s$ 中只出现了两次。</p>
<details class="toggle" ><summary class="toggle-button" style="">证明</summary><div class="toggle-content"><p>由性质 $1$ 知道出现位置是等差数列，如果出现 $3$ 次及以上可以构造出更长的 Bd ，矛盾。</p>
<p>这个证法和性质 2 的证明 2 挺像的，都是利用了某个 Bd 的出现位置和一些 Bd 的对应关系。</p>
</div></details>
<p>这个性质可以应用在某些 Bd 优化题中，以确定 mxBd 上次出现的位置。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>Border</tag>
      </tags>
  </entry>
  <entry>
    <title>Cola</title>
    <url>/2024/01/29/Cola/</url>
    <content><![CDATA[<p>题目链接：<a href="https://contest.ucup.ac/contest/1499/problem/8171">https://contest.ucup.ac/contest/1499/problem/8171</a></p>
<p>题目大意： $A$ 手里有个排列，$B$ 能问 $A$ 一个排列，如果排列完全匹配上，那就 $B$ 胜利，否则 $A$ 回答前 $x$ 个位置都是正确的，$x+1$ 的位置是错误的，如果 $m$ 次询问 $B$ 没有胜利就 $A$ 胜利。问 $B$ 在最优决策下， $A$ 随机拿到一个排列时 $B$ 的获胜概率。</p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>显然要对所有排列计数，而 $B$ 的最优策略就是变 $x+1$ 的位置，然后后面的位置从小到大排序（反正是随机拿一个排列，后面的部分随便一个都行，不会影响答案，从小到大好计数）。</p>
<p>所以问题等价于，有多少个 $n-1$ 的序列 $a$ ，满足：</p>
<p>$0\le a_i\le i,\sum\limits_{i=1}^{n-1}a_i\le m-1$ 。</p>
<p>那么等价于求：$[x^{m-1}]\frac{\prod\limits_{i=1}^{n-1}(1-x^i)}{(1-x)^{n+1}}$ ，但是注意到 $m\le n$ .</p>
<p>所以又等价于求： $[x^{m-1}]\frac{\prod\limits_{i=1}^{\infty}(1-x^i)}{(1-x)^{n+1}}$</p>
<p>分母是经典的高维前缀和，可以用组合意义快速计算 $x^i$ 的系数，分子是五边形数定理，直接算就行了。</p>
<p>时空复杂度：$O(n)$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> LL mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e7</span>+<span class="number">5</span>;</span><br><span class="line">LL fc[N],nfc[N];</span><br><span class="line"><span class="function">LL <span class="title">C</span><span class="params">(LL x,LL y)</span></span>&#123;<span class="keyword">return</span> fc[x]*nfc[y]%mod*nfc[x-y]%mod;&#125;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);n--;m--;</span><br><span class="line">    <span class="keyword">if</span>(!n)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;1\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    nfc[<span class="number">0</span>]=nfc[<span class="number">1</span>]=fc[<span class="number">0</span>]=fc[<span class="number">1</span>]=<span class="number">1</span>;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n+n+<span class="number">1</span>;i++)nfc[i]=(mod-mod/i)*nfc[mod%i]%mod;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n+n+<span class="number">1</span>;i++)nfc[i]=nfc[i<span class="number">-1</span>]*nfc[i]%mod,fc[i]=fc[i<span class="number">-1</span>]*i%mod;</span><br><span class="line">    LL ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="type">int</span> x=i*(<span class="number">3</span>*i<span class="number">-1</span>)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(x&gt;m)<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span>(i&amp;<span class="number">1</span>)ans=(ans+(mod<span class="number">-1</span>)*<span class="built_in">C</span>(n+<span class="number">1</span>+m-x,n+<span class="number">1</span>))%mod;</span><br><span class="line">        <span class="keyword">else</span> ans=(ans+<span class="built_in">C</span>(n+<span class="number">1</span>+m-x,n+<span class="number">1</span>))%mod;</span><br><span class="line">        x=i*(<span class="number">3</span>*i+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(x&gt;m || !i)<span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(i&amp;<span class="number">1</span>)ans=(ans+(mod<span class="number">-1</span>)*<span class="built_in">C</span>(n+<span class="number">1</span>+m-x,n+<span class="number">1</span>))%mod;</span><br><span class="line">        <span class="keyword">else</span> ans=(ans+<span class="built_in">C</span>(n+<span class="number">1</span>+m-x,n+<span class="number">1</span>))%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans*nfc[n+<span class="number">1</span>]%mod);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></details>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>组合意义</tag>
        <tag>五边形数定理</tag>
      </tags>
  </entry>
  <entry>
    <title>CF Round 921 Div.1 赛后总结</title>
    <url>/2024/02/01/CF-Round-921-Div-1-%E8%B5%9B%E5%90%8E%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>比赛链接：<a href="https://codeforces.com/contest/1924/problem/D">https://codeforces.com/contest/1924/problem/D</a></p>
<h1 id="A"><a href="#A" class="headerlink" title="A"></a>A</h1><p>弱智题，每次选最远就行了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e3</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M=<span class="number">26</span>;</span><br><span class="line"><span class="type">int</span> nex[N][M],las[M];</span><br><span class="line"><span class="type">char</span> st[N],ans[N];</span><br><span class="line"><span class="type">int</span> n,k,m;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">work</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;k,&amp;m);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,st+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;k;i++)las[i]=m+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=m;i&gt;=<span class="number">1</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;k;j++)nex[i][j]=las[j];</span><br><span class="line">        las[st[i]-<span class="string">&#x27;a&#x27;</span>]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;k;j++)nex[<span class="number">0</span>][j]=las[j];</span><br><span class="line">    <span class="type">int</span> now=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="type">int</span> maxpos=<span class="number">0</span>,num=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;k;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nex[now][j]&gt;maxpos)maxpos=nex[now][j],num=j;</span><br><span class="line">        &#125;</span><br><span class="line">        ans[i]=num+<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        now=maxpos;</span><br><span class="line">        <span class="keyword">if</span>(now&gt;m)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;=n;j++)ans[j]=<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            ans[n+<span class="number">1</span>]=<span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line">    <span class="comment">// T=1;</span></span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">work</span>())&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Yes\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;No\n%s\n&quot;</span>,ans+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="B"><a href="#B" class="headerlink" title="B"></a>B</h1><p>典中典线段树题，我还以为有高论，想多了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">3e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> NN=<span class="number">6e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Segment</span>&#123;</span><br><span class="line">    <span class="type">int</span> lc,rc;</span><br><span class="line">    LL lazy,c1,c2,d1,d2;</span><br><span class="line">&#125;tr[NN];<span class="type">int</span> len;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">updata</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    tr[x].c1=tr[tr[x].lc].c1+tr[tr[x].rc].c1;</span><br><span class="line">    tr[x].c2=tr[tr[x].lc].c2+tr[tr[x].rc].c2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushlazy</span><span class="params">(<span class="type">int</span> x,LL c)</span></span>&#123;</span><br><span class="line">    tr[x].c1+=c*tr[x].d1;</span><br><span class="line">    tr[x].c2+=c*tr[x].d2;</span><br><span class="line">    tr[x].lazy+=c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tr[x].lazy)&#123;</span><br><span class="line">        <span class="built_in">pushlazy</span>(tr[x].lc,tr[x].lazy);</span><br><span class="line">        <span class="built_in">pushlazy</span>(tr[x].rc,tr[x].lazy);</span><br><span class="line">        tr[x].lazy=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bt</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> x=++len;</span><br><span class="line">    tr[x].d1=r-l+<span class="number">1</span>;tr[x].d2=<span class="number">1ll</span>*(r+l)*(r-l+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(l&lt;r)&#123;</span><br><span class="line">        <span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        tr[x].lc=<span class="built_in">bt</span>(l,mid);</span><br><span class="line">        tr[x].rc=<span class="built_in">bt</span>(mid+<span class="number">1</span>,r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">change</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> ll,<span class="type">int</span> rr,LL c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ll&gt;rr || r&lt;ll || l&gt;rr)<span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">if</span>(l&gt;=ll &amp;&amp; r&lt;=rr)&#123;</span><br><span class="line">        <span class="built_in">pushlazy</span>(x,c);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pushdown</span>(x);</span><br><span class="line">    <span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">change</span>(tr[x].lc,l,mid,ll,rr,c);</span><br><span class="line">    <span class="built_in">change</span>(tr[x].rc,mid+<span class="number">1</span>,r,ll,rr,c);</span><br><span class="line">    <span class="built_in">updata</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">findans</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> id)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&gt;id)<span class="keyword">return</span> <span class="number">0ll</span>;</span><br><span class="line">    <span class="keyword">if</span>(r&lt;=id)<span class="keyword">return</span> (id+<span class="number">1</span>)*tr[x].c1-tr[x].c2;</span><br><span class="line">    <span class="built_in">pushdown</span>(x);</span><br><span class="line">    <span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">findans</span>(tr[x].lc,l,mid,id)+<span class="built_in">findans</span>(tr[x].rc,mid+<span class="number">1</span>,r,id);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,m,q;</span><br><span class="line">set&lt;<span class="type">int</span>&gt; pos;</span><br><span class="line">LL V[N];<span class="type">bool</span> v[N];<span class="type">int</span> p[N];</span><br><span class="line"><span class="type">int</span> ll[N];<span class="comment">//(ll[i],i)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modif</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,LL c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&gt;r)<span class="keyword">return</span> ;</span><br><span class="line">    <span class="built_in">change</span>(<span class="number">1</span>,<span class="number">1</span>,n,l,r,c);</span><br><span class="line">    <span class="built_in">change</span>(<span class="number">1</span>,<span class="number">1</span>,n,r+<span class="number">1</span>,r+<span class="number">1</span>,-c*(r-l+<span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld &quot;</span>,<span class="built_in">findans</span>(<span class="number">1</span>,<span class="number">1</span>,n,i)-<span class="built_in">findans</span>(<span class="number">1</span>,<span class="number">1</span>,n,i<span class="number">-1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;q);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="type">int</span> x;<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);x=n-x+<span class="number">1</span>;</span><br><span class="line">        v[x]=<span class="number">1</span>;</span><br><span class="line">        p[i]=x;</span><br><span class="line">        pos.<span class="built_in">insert</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        LL x;<span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;x);</span><br><span class="line">        V[p[i]]=x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">bt</span>(<span class="number">1</span>,n);</span><br><span class="line">    <span class="type">int</span> pre=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!v[i])<span class="keyword">continue</span>;</span><br><span class="line">        ll[i]=pre;pre=i;</span><br><span class="line">        <span class="built_in">modif</span>(ll[i]+<span class="number">1</span>,i<span class="number">-1</span>,V[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// print();</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=q;i++)&#123;</span><br><span class="line">        <span class="type">int</span> t;<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;t);</span><br><span class="line">        <span class="keyword">if</span>(t==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="type">int</span> x,val;<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;x,&amp;val);x=n-x+<span class="number">1</span>;</span><br><span class="line">            v[x]=<span class="number">1</span>;V[x]=val;pos.<span class="built_in">insert</span>(x);</span><br><span class="line">            <span class="type">int</span> nex=*pos.<span class="built_in">upper_bound</span>(x);</span><br><span class="line">            <span class="built_in">modif</span>(ll[nex]+<span class="number">1</span>,nex<span class="number">-1</span>,-V[nex]);</span><br><span class="line">            ll[x]=ll[nex];</span><br><span class="line">            <span class="built_in">modif</span>(ll[x]+<span class="number">1</span>,x<span class="number">-1</span>,V[x]);</span><br><span class="line">            ll[nex]=x;</span><br><span class="line">            <span class="built_in">modif</span>(ll[nex]+<span class="number">1</span>,nex<span class="number">-1</span>,V[nex]);</span><br><span class="line">            <span class="comment">// print();</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="type">int</span> l,r;<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;l,&amp;r);l=n-l+<span class="number">1</span>;r=n-r+<span class="number">1</span>;</span><br><span class="line">            <span class="built_in">swap</span>(l,r);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,<span class="built_in">findans</span>(<span class="number">1</span>,<span class="number">1</span>,n,r)-<span class="built_in">findans</span>(<span class="number">1</span>,<span class="number">1</span>,n,l<span class="number">-1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="C"><a href="#C" class="headerlink" title="C"></a>C</h1><p>一个显然的事情，你考虑在折过一次的的纸上，去考虑接下来折纸产生的折痕，在这一次折纸展开后会变成什么样，可以发现：</p>
<script type="math/tex; mode=display">(M,V)=(\frac{M'+V'}{\sqrt{2}},\frac{M'+V'+4}{\sqrt{2}})</script><p>赛时唐了，以为要写矩阵，但实际上不用，直接推式子就行了。</p>
<p>最终 $\frac{M}{V}=1-\frac{2}{\sqrt{2}^{n+1}+\sqrt{2}^{n}-\sqrt{2}}$ ，直接算就行了。</p>
<p>题解说奇怪的模数是为了保证分母不为 $0$ ，说是不能让 $2$ 能够开根，我推测用上面的式子精细的讨论一下 $n$ 的奇偶，可能也能分析出来，但我懒得想了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> LL mod=<span class="number">999999893</span>,ni2=(mod+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    LL x,y;<span class="comment">//x+y*sqrt(2)</span></span><br><span class="line">&#125;;</span><br><span class="line">node <span class="keyword">operator</span>*(node x,node y)&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;(x.x*y.x+x.y*y.y*<span class="number">2</span>)%mod,(x.x*y.y+x.y*y.x)%mod&#125;;</span><br><span class="line">&#125;</span><br><span class="line">node <span class="keyword">operator</span>*(node x,LL y)&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;(x.x*y)%mod,(x.y*y)%mod&#125;;</span><br><span class="line">&#125;</span><br><span class="line">node <span class="keyword">operator</span>+(node x,node y)&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;(x.x+y.x)%mod,(x.y+y.y)%mod&#125;;</span><br><span class="line">&#125;</span><br><span class="line">node <span class="keyword">operator</span>-(node x,node y)&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;(x.x-y.x+mod)%mod,(x.y-y.y+mod)%mod&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">node <span class="title">ksm</span><span class="params">(node x,LL y)</span></span>&#123;</span><br><span class="line">    node ans=&#123;<span class="number">1ll</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">while</span>(y)&#123;</span><br><span class="line">        <span class="keyword">if</span>(y&amp;<span class="number">1</span>)ans=ans*x;</span><br><span class="line">        x=x*x;y&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">ksm</span><span class="params">(LL x,LL y)</span></span>&#123;</span><br><span class="line">    LL ans=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(y)&#123;</span><br><span class="line">        <span class="keyword">if</span>(y&amp;<span class="number">1</span>)ans=ans*x%mod;</span><br><span class="line">        x=x*x%mod;y&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> T;<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="type">int</span> n;<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">        node x=&#123;<span class="number">0ll</span>,<span class="number">1</span>&#125;;</span><br><span class="line">        node y=<span class="built_in">ksm</span>(x,n+<span class="number">1</span>)-node&#123;<span class="number">0ll</span>,<span class="number">1</span>&#125;+<span class="built_in">ksm</span>(x,n);</span><br><span class="line">        node z=node&#123;y.x,mod-y.y&#125;*<span class="built_in">ksm</span>( (y.x*y.x-y.y*y.y*<span class="number">2</span>%mod+mod)%mod ,mod<span class="number">-2</span>);</span><br><span class="line">        node ans=node&#123;<span class="number">1ll</span>,<span class="number">0ll</span>&#125;-z*<span class="number">2</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans.y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="D"><a href="#D" class="headerlink" title="D"></a>D</h1><p>唐了。</p>
<p>这道题目我一开始的思路是，一个显然的事情，最终序列一定是一堆合法括号序列，然后用 $)))((($ 插入到两个合法括号序列中间，然后就有了我最开始的做法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> LL mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e4</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> L=<span class="number">10000</span>;</span><br><span class="line">LL fc[N],nfc[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    fc[<span class="number">0</span>]=fc[<span class="number">1</span>]=nfc[<span class="number">0</span>]=nfc[<span class="number">1</span>]=<span class="number">1</span>;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=L;i++)nfc[i]=(mod-mod/i)*nfc[mod%i]%mod;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=L;i++)nfc[i]=nfc[i<span class="number">-1</span>]*nfc[i]%mod,fc[i]=fc[i<span class="number">-1</span>]*i%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">C</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;y || y&lt;<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0ll</span>;</span><br><span class="line">    <span class="keyword">return</span> fc[x]*nfc[y]%mod*nfc[x-y]%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">goal_fu</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> len)</span></span>&#123;</span><br><span class="line">    x--;len--;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;<span class="number">0</span>)x=-x;</span><br><span class="line">    <span class="keyword">if</span>(x&gt;len)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">assert</span>((len&amp;<span class="number">1</span>)==(x&amp;<span class="number">1</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">C</span>(len,(len-x)&gt;&gt;<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">goal</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">goal_fu</span>(x,len)-<span class="built_in">goal_fu</span>(-x,len)+mod)%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="type">int</span> T;<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="type">int</span> n,m,k;<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;k);</span><br><span class="line">        <span class="keyword">if</span>(n&lt;k || m&lt;k)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;0\n&quot;</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        n-=k;m-=k;</span><br><span class="line">        LL ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=k;i++)&#123;</span><br><span class="line">            LL now=<span class="built_in">goal</span>(i,k+k-i);</span><br><span class="line">            ans=(ans+now*<span class="built_in">C</span>(n+m+i,i))%mod;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但实际上可以直接用折线法得到最终答案。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> LL mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e4</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> L=<span class="number">10000</span>;</span><br><span class="line">LL fc[N],nfc[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    fc[<span class="number">0</span>]=fc[<span class="number">1</span>]=nfc[<span class="number">0</span>]=nfc[<span class="number">1</span>]=<span class="number">1</span>;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=L;i++)nfc[i]=(mod-mod/i)*nfc[mod%i]%mod;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=L;i++)nfc[i]=nfc[i<span class="number">-1</span>]*nfc[i]%mod,fc[i]=fc[i<span class="number">-1</span>]*i%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">C</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;<span class="keyword">return</span> fc[x]*nfc[y]%mod*nfc[x-y]%mod;&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="type">int</span> T;<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="type">int</span> n,m,k;<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;k);</span><br><span class="line">        <span class="keyword">if</span>(n&lt;k || m&lt;k)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;0\n&quot;</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,(<span class="built_in">C</span>(n+m,k)-<span class="built_in">C</span>(n+m,k<span class="number">-1</span>)+mod)%mod);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>显然两种做法后面一种更加优秀，而且也不算难。</p>
<p>但是赛时就是没想出来，警钟敲烂。</p>
<p>已将上面两种做法的最关键部分全部写入组合计数练习，引以为戒，警钟敲烂。</p>
<h1 id="E"><a href="#E" class="headerlink" title="E"></a>E</h1><p>做法已加入《组合计数练习》。</p>
<p>简单来说就是用排列考虑就行了。</p>
<p>时间复杂度：$O(n+m)$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> LL mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e6</span>+<span class="number">5</span>;</span><br><span class="line">LL nfc[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> L=<span class="number">2e6</span>+<span class="number">1</span>;</span><br><span class="line">    nfc[<span class="number">0</span>]=nfc[<span class="number">1</span>]=<span class="number">1</span>;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=L;i++)nfc[i]=(mod-mod/i)*nfc[mod%i]%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="type">int</span> T;<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        LL n,m,k;<span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld%lld&quot;</span>,&amp;n,&amp;m,&amp;k);k--;</span><br><span class="line">        <span class="keyword">if</span>(n*m&lt;=k)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;0\n&quot;</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        LL ans=<span class="number">1</span>;</span><br><span class="line">        &#123;</span><br><span class="line">            LL l=k/n+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=l;i&lt;m;i++)ans=(ans+nfc[n<span class="number">-1</span>+i])%mod;</span><br><span class="line">        &#125;</span><br><span class="line">        &#123;</span><br><span class="line">            LL l=k/m+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=l;i&lt;n;i++)ans=(ans+nfc[i+m<span class="number">-1</span>])%mod;</span><br><span class="line">        &#125;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">                LL l=k/i+<span class="number">1</span>,r=m<span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">if</span>(l&lt;=r)ans=(ans+<span class="number">2</span>*(nfc[i+l<span class="number">-1</span>]-nfc[i+r]+mod))%mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h2><p>在想这道题目的时候发现了一个具有意思的组合意义，可惜没法扩展。</p>
<p>考虑一个弱化版的问题：</p>
<p>令 $m=1$ ，问出现 $k*1$ 的纸张的概率。</p>
<p>这么考虑这个问题：</p>
<p>现在从 $n-1$ 开始考虑，考虑到 $x$ 时，有 $\frac{1}{x}$ 的概率选中他，不难发现这与原过程等价。</p>
<p>这样，问题转化为选中 $k$ 的概率，显然就是 $\frac{1}{k}$ 了。</p>
<h1 id="F"><a href="#F" class="headerlink" title="F"></a>F</h1><p>咕咕咕。</p>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title>ECNU 2023.8 C Kaleidoscope</title>
    <url>/2023/09/02/ECNU-2023-8-C-Kaleidoscope/</url>
    <content><![CDATA[<p>题目链接：<a href="https://acm.ecnu.edu.cn/contest/695/problem/C/">https://acm.ecnu.edu.cn/contest/695/problem/C/</a></p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>我是状压 DP 做的，不难发现，我们可以把这一行被上一行占用的位置保存下来，然后转移。</p>
<p>显然如果 $x$ 转移到 $y$ ，那么 $x\And y=0$ ，而这是一个经典的 trick ，这样子转移的复杂度是 $O(3^m)$ 的，所以最终时间复杂度就是：$O(n3^m)$ 。</p>
<p>不过看题解说其实有效转移 $&lt;6000$ ？</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 310</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> M 160</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">26</span>],len,fa;</span><br><span class="line">&#125;tr[N];<span class="type">int</span> tot,last;</span><br><span class="line"><span class="type">char</span> st[M];<span class="type">int</span> n;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> c)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> p=last;<span class="type">int</span> np=last=++tot;</span><br><span class="line">    tr[np].len=tr[p].len+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(;p &amp;&amp; !tr[p].a[c];p=tr[p].fa)tr[p].a[c]=np;</span><br><span class="line">    <span class="keyword">if</span>(!p)tr[np].fa=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="type">int</span> q=tr[p].a[c];</span><br><span class="line">        <span class="keyword">if</span>(tr[q].len==tr[p].len+<span class="number">1</span>)tr[np].fa=q;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="type">int</span> nq=++tot;</span><br><span class="line">            tr[nq].fa=tr[q].fa;tr[q].fa=nq;</span><br><span class="line">            tr[nq].len=tr[p].len+<span class="number">1</span>;<span class="built_in">memcpy</span>(tr[nq].a,tr[q].a,<span class="built_in">sizeof</span>(tr[q].a));</span><br><span class="line">            tr[np].fa=nq;</span><br><span class="line">            <span class="keyword">for</span>(;p &amp;&amp; tr[p].a[c]==q;p=tr[p].fa)tr[p].a[c]=nq;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool</span> dp[N][M][M];</span><br><span class="line"><span class="type">int</span> m,X;<span class="type">char</span> ans[M];<span class="type">int</span> fuck;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getval</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> fucklen)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> cnt=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=fucklen;i&gt;=<span class="number">1</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(tr[x].a[ans[i]-<span class="string">&#x27;a&#x27;</span>])x=tr[x].a[ans[i]-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        <span class="keyword">else</span> x=tr[<span class="number">1</span>].a[ans[i]-<span class="string">&#x27;a&#x27;</span>],cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool</span> v[<span class="number">40</span>];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">work</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(fuck!=m)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=tot;i++)&#123;</span><br><span class="line">            <span class="type">int</span> x=<span class="built_in">getval</span>(i,fuck);</span><br><span class="line">            <span class="keyword">if</span>(x&lt;=X &amp;&amp; dp[i][m-fuck][X-x+<span class="number">1</span>])<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">getval</span>(tr[<span class="number">1</span>].a[ans[m]-<span class="string">&#x27;a&#x27;</span>],m<span class="number">-1</span>)==X;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> T;<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;X);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,st+<span class="number">1</span>);</span><br><span class="line">        tot=last=<span class="number">1</span>;<span class="built_in">memset</span>(tr,<span class="number">0</span>,<span class="built_in">sizeof</span>(tr));<span class="built_in">memset</span>(v,<span class="number">0</span>,<span class="built_in">sizeof</span>(v));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i+i&lt;=n;i++)<span class="built_in">swap</span>(st[i],st[n-i+<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="built_in">add</span>(st[i]-<span class="string">&#x27;a&#x27;</span>),v[st[i]-<span class="string">&#x27;a&#x27;</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="comment">// for(int i=1;i&lt;=tot;i++)&#123;</span></span><br><span class="line">        <span class="comment">//     printf(&quot;%d %d\n&quot;,tr[i].fa,tr[i].len);</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">25</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(tr[<span class="number">1</span>].a[i])dp[tr[<span class="number">1</span>].a[i]][<span class="number">1</span>][<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;m;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">2</span>;j&lt;=tot;j++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> t=<span class="number">1</span>;t&lt;=i &amp;&amp; t&lt;=X;t++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(!dp[j][i][t])<span class="keyword">continue</span>;</span><br><span class="line">                    <span class="comment">// if(i==1 &amp;&amp; j==5 &amp;&amp; t==1)printf(&quot;OK\n&quot;);</span></span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;=<span class="number">25</span>;k++)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(tr[j].a[k])dp[tr[j].a[k]][i+<span class="number">1</span>][t]=<span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span>(tr[<span class="number">1</span>].a[k] &amp;&amp; t&lt;X)dp[tr[<span class="number">1</span>].a[k]][i+<span class="number">1</span>][t+<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// for(int i=1;i&lt;=tot;i++)printf(&quot;%d:%d %d\n&quot;,i,tr[i].len,tr[i].fa);</span></span><br><span class="line">        <span class="comment">// printf(&quot;%d %d %d\n&quot;,dp[4][2][1],tr[5].a[0],dp[5][1][1]);</span></span><br><span class="line">        <span class="type">bool</span> bk=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=tot;i++)bk|=dp[i][m][X];</span><br><span class="line">        <span class="keyword">if</span>(!bk)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=tot;i++)<span class="built_in">memset</span>(dp[i],<span class="number">0</span>,<span class="built_in">sizeof</span>(dp[i]));</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;-1\n&quot;</span>);<span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ans[1]=ans[2]=&#x27;a&#x27;;printf(&quot;%d\n&quot;,getval(5,2));</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">            fuck=i;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=<span class="number">25</span>;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!v[j])<span class="keyword">continue</span>;</span><br><span class="line">                ans[i]=j+<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">work</span>()==<span class="number">1</span>)<span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans[m+<span class="number">1</span>]=<span class="string">&#x27;\0&#x27;</span>;<span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,ans+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=tot;i++)<span class="built_in">memset</span>(dp[i],<span class="number">0</span>,<span class="built_in">sizeof</span>(dp[i]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>官方做法：</p>
<p>可以发现 $(i,j)$ 至多从 $(i-1,j-1)$ 转移过来，所以可以直接轮廓线 DP ，保存所有需要位置的状态就行了。</p>
<p>时间复杂度：$O(nm2^m)$ 。</p>
</div></details>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>经典trick</tag>
        <tag>状压</tag>
        <tag>轮廓线</tag>
      </tags>
  </entry>
  <entry>
    <title>2023-2024 ICPC Asia Jakarta Regional Contest K Deck-Building Game</title>
    <url>/2024/03/21/2023-2024-ICPC-Asia-Jakarta-Regional-Contest-K-Deck-Building-Game/</url>
    <content><![CDATA[<p>题目链接：<a href="https://codeforces.com/contest/1906/problem/K">https://codeforces.com/contest/1906/problem/K</a></p>
<p>题目大意：在原数组找出两堆异或值相同的数值，问有多少种找法，可以为空，每个数字可以不在任何一堆，两堆有标号。</p>
<details class="toggle" ><summary class="toggle-button" style="">所有做法的基础</summary><div class="toggle-content"><p>一个显然的事情，这道题目相当于求 $\prod\limits_{i=1}^n(1+2x^{a_i})$ ，这里的乘法是异或卷积。</p>
<p>为了快速计算这个乘积，有了很多种搞法。</p>
</div></details>
<details class="toggle" ><summary class="toggle-button" style="">题解做法</summary><div class="toggle-content"><p>题解做法的优点就是比较自然。</p>
<p>显然这个可以分治 FWT ，但是 FWT 不同于 FFT ，分治了值域不变，不改变复杂度。</p>
<p>咋整，观察到如果分治区间是 $[l,r)$ ，那么实际上这个区间乘出来的非 $0$ 项只能落在 $[0,r-l),[l,r)$ ，直接拿出左区间的两个非 $0$ 区间和右区间的两个非 $0$ 区间互相乘一下就行了，这样能做到时间复杂度：$O(V\log^2 V)$ 。</p>
<p>代码：<a href="https://codeforces.com/contest/1906/submission/235539466">https://codeforces.com/contest/1906/submission/235539466</a></p>
</div></details>
<details class="toggle" ><summary class="toggle-button" style="">我的做法</summary><div class="toggle-content"><p>我的做法和题解想法基本一致，唯一一点不同的是，对于 $(r-l)=2^l$ ，那么二进制下 $l$ 位都是一样的，因此对于二进制位剩下的位置，要么和 $[l,r)$ 里面的每个数字一样，代表异或了奇数次，要么全是 $0$ ，代表异或了偶数次。</p>
<p>所以我们不妨给每个数字的最高位填个 $1$ ，代表了这个数字异或次数的奇偶性即可。</p>
<p>时间复杂度仍然是：$O(V\log^2 V)$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> LL mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> L=<span class="number">17</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> SN=(<span class="number">1</span>&lt;&lt;L);</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FWT</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;f,<span class="type">const</span> <span class="type">int</span> C[<span class="number">2</span>][<span class="number">2</span>],<span class="type">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(f.<span class="built_in">size</span>()==len);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> t=<span class="number">1</span>;t&lt;len;t&lt;&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">0</span>;l&lt;len;l+=t+t)&#123;</span><br><span class="line">            <span class="type">int</span> r=l+t;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;t;i++)&#123;</span><br><span class="line">                <span class="type">int</span> x=f[l+i],y=f[r+i];</span><br><span class="line">                f[l+i]=(<span class="number">1ll</span>*C[<span class="number">0</span>][<span class="number">0</span>]*x+<span class="number">1ll</span>*C[<span class="number">0</span>][<span class="number">1</span>]*y)%mod;</span><br><span class="line">                f[r+i]=(<span class="number">1ll</span>*C[<span class="number">1</span>][<span class="number">0</span>]*x+<span class="number">1ll</span>*C[<span class="number">1</span>][<span class="number">1</span>]*y)%mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> Cxor[<span class="number">2</span>][<span class="number">2</span>]=&#123;&#123;<span class="number">1</span>,<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,mod<span class="number">-1</span>&#125;&#125;;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> Ixor[<span class="number">2</span>][<span class="number">2</span>]=&#123;&#123;(mod+<span class="number">1</span>)/<span class="number">2</span>,(mod+<span class="number">1</span>)/<span class="number">2</span>&#125;,&#123;(mod+<span class="number">1</span>)/<span class="number">2</span>,mod-(mod+<span class="number">1</span>)/<span class="number">2</span>&#125;&#125;;</span><br><span class="line"><span class="type">int</span> n,a[N*<span class="number">2</span>];</span><br><span class="line">LL fc[N],nfc[N],f2[N];</span><br><span class="line"><span class="function">LL <span class="title">C</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;<span class="keyword">return</span> fc[x]*nfc[y]%mod*nfc[x-y]%mod;&#125;</span><br><span class="line">vector&lt;array&lt;<span class="type">int</span>,2&gt;&gt; <span class="built_in">solve</span>(<span class="type">int</span> dep,<span class="type">int</span> l,<span class="type">int</span> r)&#123;</span><br><span class="line">    <span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">        vector&lt;array&lt;<span class="type">int</span>,2&gt; &gt; ans;</span><br><span class="line">        ans.<span class="built_in">push_back</span>(&#123;<span class="number">0</span>,<span class="number">0</span>&#125;);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=a[l];i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i&amp;<span class="number">1</span>)ans[<span class="number">0</span>][<span class="number">0</span>]=(ans[<span class="number">0</span>][<span class="number">0</span>]+<span class="built_in">C</span>(a[l],i)*f2[i])%mod;</span><br><span class="line">            <span class="keyword">else</span> ans[<span class="number">0</span>][<span class="number">1</span>]=(ans[<span class="number">0</span>][<span class="number">1</span>]+<span class="built_in">C</span>(a[l],i)*f2[i])%mod;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">auto</span> lans=<span class="built_in">solve</span>(dep<span class="number">-1</span>,l,mid);</span><br><span class="line">    <span class="keyword">auto</span> rans=<span class="built_in">solve</span>(dep<span class="number">-1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; lf;lf.<span class="built_in">resize</span>(<span class="number">1</span>&lt;&lt;(dep+<span class="number">1</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;(<span class="number">1</span>&lt;&lt;(dep<span class="number">-1</span>));i++)&#123;</span><br><span class="line">        <span class="keyword">auto</span> [f0,f1]=lans[i];</span><br><span class="line">        lf[i]=f0;</span><br><span class="line">        lf[i+(<span class="number">1</span>&lt;&lt;dep)]=f1;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; rf;rf.<span class="built_in">resize</span>(<span class="number">1</span>&lt;&lt;(dep+<span class="number">1</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;(<span class="number">1</span>&lt;&lt;(dep<span class="number">-1</span>));i++)&#123;</span><br><span class="line">        <span class="keyword">auto</span> [f0,f1]=rans[i];</span><br><span class="line">        rf[i]=f0;</span><br><span class="line">        rf[i+(<span class="number">1</span>&lt;&lt;(dep<span class="number">-1</span>))+(<span class="number">1</span>&lt;&lt;dep)]=f1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">FWT</span>(lf,Cxor,(<span class="number">1</span>&lt;&lt;(dep+<span class="number">1</span>)));</span><br><span class="line">    <span class="built_in">FWT</span>(rf,Cxor,(<span class="number">1</span>&lt;&lt;(dep+<span class="number">1</span>)));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;(<span class="number">1</span>&lt;&lt;(dep+<span class="number">1</span>));i++)lf[i]=<span class="number">1ll</span>*lf[i]*rf[i]%mod;</span><br><span class="line">    <span class="built_in">FWT</span>(lf,Ixor,(<span class="number">1</span>&lt;&lt;(dep+<span class="number">1</span>)));</span><br><span class="line">    vector&lt;array&lt;<span class="type">int</span>,2&gt; &gt; ans;ans.<span class="built_in">resize</span>(<span class="number">1</span>&lt;&lt;dep);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;(<span class="number">1</span>&lt;&lt;dep);i++)&#123;</span><br><span class="line">        ans[i]=&#123;lf[i],lf[i+(<span class="number">1</span>&lt;&lt;dep)]&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    fc[<span class="number">0</span>]=fc[<span class="number">1</span>]=nfc[<span class="number">0</span>]=nfc[<span class="number">1</span>]=f2[<span class="number">0</span>]=<span class="number">1</span>;f2[<span class="number">1</span>]=<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)nfc[i]=(mod-mod/i)*nfc[mod%i]%mod;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)nfc[i]=nfc[i<span class="number">-1</span>]*nfc[i]%mod,fc[i]=fc[i<span class="number">-1</span>]*i%mod,f2[i]=f2[i<span class="number">-1</span>]*<span class="number">2</span>%mod;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="type">int</span> x;<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">        a[x]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">auto</span> ans=<span class="built_in">solve</span>(L,<span class="number">0</span>,(<span class="number">1</span>&lt;&lt;L)<span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,(ans[<span class="number">0</span>][<span class="number">0</span>]+ans[<span class="number">0</span>][<span class="number">1</span>])%mod);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></details>
<details class="toggle" ><summary class="toggle-button" style="">我的做法改进</summary><div class="toggle-content"><p>发现一个事情，矩阵为 $\begin{bmatrix} 1 &amp; 1\ 1 &amp; -1 \end{bmatrix}$ 的 FWT （即异或的 FWT）最终的结果其实可以写成这样：</p>
<script type="math/tex; mode=display">f[i]=\sum\limits_{i=0}^{L}(-1)^{popcount(i\And j)}a[j]</script><p>利用这个式子，可以改进分治 FWT 。</p>
<p>不妨假设：$(r-l)=2^l$ ，显然左区间的值域在 $[0,2^l)$ （高位补了 $1$ 判断奇偶性），现在要扩充到 $[0,2^{l+1})$ ，扩充规则为给原来的每个下表在最高位（算前导 $0$ ）下面塞个 $0$ （右区间塞 $1$） ，然后在剩下的位置补 $0$ 。</p>
<p>然后根据上面的式子可以利用变化前的点值，在线性时间得到变化后的点值。（具体见代码）</p>
<p>然后直接乘就行了，时间复杂度：$O(V\log{V})$ 。</p>
<p>这个做法相比较于下面的做法，或许不是最妙的，但是是最适用的，因为不依赖于系数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> LL mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> L=<span class="number">17</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> SN=(<span class="number">1</span>&lt;&lt;L);</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FWT</span><span class="params">(LL *f,<span class="type">const</span> LL C[<span class="number">2</span>][<span class="number">2</span>],<span class="type">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> t=<span class="number">1</span>;t&lt;len;t&lt;&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">0</span>;l&lt;len;l+=t+t)&#123;</span><br><span class="line">            <span class="type">int</span> r=l+t;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;t;i++)&#123;</span><br><span class="line">                LL x=f[l+i],y=f[r+i];</span><br><span class="line">                f[l+i]=(C[<span class="number">0</span>][<span class="number">0</span>]*x+C[<span class="number">0</span>][<span class="number">1</span>]*y)%mod;</span><br><span class="line">                f[r+i]=(C[<span class="number">1</span>][<span class="number">0</span>]*x+C[<span class="number">1</span>][<span class="number">1</span>]*y)%mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> LL Cxor[<span class="number">2</span>][<span class="number">2</span>]=&#123;&#123;<span class="number">1</span>,<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,mod<span class="number">-1</span>&#125;&#125;;</span><br><span class="line"><span class="type">const</span> LL Ixor[<span class="number">2</span>][<span class="number">2</span>]=&#123;&#123;(mod+<span class="number">1</span>)/<span class="number">2</span>,(mod+<span class="number">1</span>)/<span class="number">2</span>&#125;,&#123;(mod+<span class="number">1</span>)/<span class="number">2</span>,mod-(mod+<span class="number">1</span>)/<span class="number">2</span>&#125;&#125;;</span><br><span class="line"><span class="type">int</span> n,a[N*<span class="number">2</span>];</span><br><span class="line">LL fc[N],nfc[N],f2[N];</span><br><span class="line"><span class="function">LL <span class="title">C</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;<span class="keyword">return</span> fc[x]*nfc[y]%mod*nfc[x-y]%mod;&#125;</span><br><span class="line">LL f[<span class="number">2</span>][N*<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;(<span class="number">1</span>&lt;&lt;L);i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=a[i];j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(j&amp;<span class="number">1</span>)f[<span class="number">1</span>][i]=(f[<span class="number">1</span>][i]+<span class="built_in">C</span>(a[i],j)*f2[j])%mod;</span><br><span class="line">            <span class="keyword">else</span> f[<span class="number">0</span>][i]=(f[<span class="number">0</span>][i]+<span class="built_in">C</span>(a[i],j)*f2[j])%mod;</span><br><span class="line">        &#125;</span><br><span class="line">        LL lf=f[<span class="number">0</span>][i],rf=f[<span class="number">1</span>][i];</span><br><span class="line">        f[<span class="number">0</span>][i]=(lf+rf)%mod;</span><br><span class="line">        f[<span class="number">1</span>][i]=(lf+mod-rf)%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> t=<span class="number">1</span>;t&lt;=L;t++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;(<span class="number">1</span>&lt;&lt;L);i+=(<span class="number">1</span>&lt;&lt;t))&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> l=i;l&lt;i+(<span class="number">1</span>&lt;&lt;(t<span class="number">-1</span>));l++)&#123;</span><br><span class="line">                <span class="type">int</span> r=l+(<span class="number">1</span>&lt;&lt;(t<span class="number">-1</span>));</span><br><span class="line">                LL l0=f[<span class="number">0</span>][l],l1=f[<span class="number">1</span>][l];</span><br><span class="line">                LL l00=l0,l01=l0;</span><br><span class="line">                LL l10=l1,l11=l1;</span><br><span class="line">                </span><br><span class="line">                LL r0=f[<span class="number">0</span>][r],r1=f[<span class="number">1</span>][r];</span><br><span class="line">                LL r00=r0,r01=r1;</span><br><span class="line">                LL r10=r1,r11=r0;</span><br><span class="line"></span><br><span class="line">                f[<span class="number">0</span>][l]=l00*r00%mod;</span><br><span class="line">                f[<span class="number">0</span>][r]=l01*r01%mod;</span><br><span class="line">                f[<span class="number">1</span>][l]=l10*r10%mod;</span><br><span class="line">                f[<span class="number">1</span>][r]=l11*r11%mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">FWT</span>(f[<span class="number">0</span>],Ixor,(<span class="number">1</span>&lt;&lt;L));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    fc[<span class="number">0</span>]=fc[<span class="number">1</span>]=nfc[<span class="number">0</span>]=nfc[<span class="number">1</span>]=f2[<span class="number">0</span>]=<span class="number">1</span>;f2[<span class="number">1</span>]=<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)nfc[i]=(mod-mod/i)*nfc[mod%i]%mod;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)nfc[i]=nfc[i<span class="number">-1</span>]*nfc[i]%mod,fc[i]=fc[i<span class="number">-1</span>]*i%mod,f2[i]=f2[i<span class="number">-1</span>]*<span class="number">2</span>%mod;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="type">int</span> x;<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">        a[x]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,f[<span class="number">0</span>][<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></details>
<details class="toggle" ><summary class="toggle-button" style="">深刻观察法</summary><div class="toggle-content"><p>来自比赛 Announcement 评论区。</p>
<p>发现一个事情，矩阵为 $\begin{bmatrix} 1 &amp; 1\ 1 &amp; -1 \end{bmatrix}$ 的 FWT （即异或的 FWT）最终的结果其实可以写成这样：</p>
<script type="math/tex; mode=display">f[i]=\sum\limits_{i=0}^{L}(-1)^{popcount(i\And j)}a[j]</script><p>同时又观察到，结果只能是 $-1$ 或者 $3$ ，那么这有什么用呢？</p>
<p>思考一下，FWT 和 FFT 有一个很重要的不同，就是 FWT 不需要扩展数组，因为下标值域不会扩展，所以 FWT 实际上能算出所有多项式的点值表达式直接乘起来然后再逆回去，而 FFT 是不行的（除非一开始就把所有的多项式算出充足的点值）。</p>
<p>但是算出所有多项式的点值表达式的时间开销仍然很大，第一种做法采用了分治 FWT 来加速这个过程，但是这里，我们直接观察出了 FWT 后的结果长啥样，那我们是不是可以不用 FWT ，直接算出结果呢？</p>
<p>显然，求 $\prod f_k[i]$ 只需要算出有多少个 $-1$ 或者有多少个 $3$ 就行了。</p>
<p>有了这个思路，就有很多种搞法了。</p>
<p>我使用的做法是：$n=even+odd$ ，那么只需要令 $a[x]=x的出现次数$ ，然后直接跑 FWT ，就可以知道每个位置的 $even-odd$ ，然后就可以直接算出来 $-1$ 和 $3$ 的个数了。</p>
<p>还有别的搞法，例如：SOS dp，但是因为感觉这个的转移式子和 FWT 没什么本质区别，就不再赘述了，放个这个做法的代码： <a href="https://codeforces.com/contest/1906/submission/235477273">https://codeforces.com/contest/1906/submission/235477273</a> 。</p>
<p>时间复杂度：$O(V\log{V})$ 的，空间复杂度：$O(V)$，$V$ 是值域。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> LL mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> NN=<span class="number">2e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> L=(<span class="number">1</span>&lt;&lt;<span class="number">17</span>);</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FWT</span><span class="params">(LL *f,<span class="type">const</span> LL C[<span class="number">2</span>][<span class="number">2</span>],<span class="type">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> t=<span class="number">1</span>;t&lt;len;t&lt;&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">0</span>;l&lt;len;l+=t+t)&#123;</span><br><span class="line">            <span class="type">int</span> r=l+t;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;t;i++)&#123;</span><br><span class="line">                LL x=f[l+i],y=f[r+i];</span><br><span class="line">                f[l+i]=(C[<span class="number">0</span>][<span class="number">0</span>]*x+C[<span class="number">0</span>][<span class="number">1</span>]*y)%mod;</span><br><span class="line">                f[r+i]=(C[<span class="number">1</span>][<span class="number">0</span>]*x+C[<span class="number">1</span>][<span class="number">1</span>]*y)%mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">LL f3[N],a[NN];</span><br><span class="line">LL Cxor[<span class="number">2</span>][<span class="number">2</span>]=&#123;&#123;<span class="number">1</span>,<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,mod<span class="number">-1</span>&#125;&#125;;</span><br><span class="line">LL Ixor[<span class="number">2</span>][<span class="number">2</span>]=&#123;&#123;(mod+<span class="number">1</span>)/<span class="number">2</span>,(mod+<span class="number">1</span>)/<span class="number">2</span>&#125;,&#123;(mod+<span class="number">1</span>)/<span class="number">2</span>,mod-(mod+<span class="number">1</span>)/<span class="number">2</span>&#125;&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    f3[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="type">int</span> x;<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">        a[x]++;</span><br><span class="line">        f3[i]=f3[i<span class="number">-1</span>]*<span class="number">3</span>%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">FWT</span>(a,Cxor,L);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;L;i++)&#123;</span><br><span class="line">        <span class="type">int</span> num=a[i];</span><br><span class="line">        <span class="keyword">if</span>(num&gt;n)num-=mod;</span><br><span class="line">        <span class="comment">//n=f+z,num=z-f;</span></span><br><span class="line">        <span class="type">int</span> z=(n+num)/<span class="number">2</span>,f=(n-num)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(f&amp;<span class="number">1</span>)a[i]=(mod-f3[z])%mod;</span><br><span class="line">        <span class="keyword">else</span> a[i]=f3[z];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">FWT</span>(a,Ixor,L);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,a[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></details>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>计数</tag>
        <tag>FWT</tag>
        <tag>分治</tag>
      </tags>
  </entry>
  <entry>
    <title>ECNU 2023.8 B Bare Minimum Difference</title>
    <url>/2023/09/02/ECNU-2023-8-B-Bare-Minimum-Difference/</url>
    <content><![CDATA[<p>题目链接：<a href="https://acm.ecnu.edu.cn/contest/695/problem/B/">https://acm.ecnu.edu.cn/contest/695/problem/B/</a></p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>题弱智但我也弱智，看错题了，以为要求方案数，乐，而且还以为会有负数。</p>
<p>我的做法是枚举 $n^2$ 个下界，然后 DP 维护最小上界，时间复杂度：$O(n^4)$。</p>
<p>然而看了题解后发现如果二分上界的话实际上可以配合滑动窗口之类的东西做到 $O(n)$ check 。</p>
<p>所以最优秀的时间复杂度是：$o(n^3\log{n})$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 110</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf=<span class="number">999999999</span>;</span><br><span class="line"><span class="type">int</span> a[N],n,dp[N],b[N],m;</span><br><span class="line"><span class="type">int</span> ans=inf;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> type=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> limit)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)b[i]+=b[i<span class="number">-1</span>];</span><br><span class="line">    <span class="built_in">memset</span>(dp,<span class="number">20</span>,<span class="built_in">sizeof</span>(dp));</span><br><span class="line">    dp[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">            <span class="comment">// if(type)printf(&quot;OK %d\n&quot;,limit);</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;i;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(b[i]-b[j]&lt;limit)<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span>(dp[i]&gt;<span class="built_in">max</span>(dp[j],b[i]-b[j]))dp[i]=<span class="built_in">max</span>(b[i]-b[j],dp[j]);</span><br><span class="line">            <span class="comment">// if(type==1 &amp;&amp; i==3 &amp;&amp; j==0)printf(&quot;%d\n&quot;,dp[i]);</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// if(type==1)printf(&quot;%d\n&quot;,dp[m]);</span></span><br><span class="line">    <span class="keyword">return</span> dp[m];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i;j&lt;=n;j++)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// type=0;</span></span><br><span class="line"></span><br><span class="line">            sum+=a[j];<span class="keyword">if</span>(i==<span class="number">1</span> &amp;&amp; j==n)<span class="keyword">continue</span>;</span><br><span class="line">            m=i<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;i;k++)b[k]=a[k];</span><br><span class="line">            <span class="type">int</span> now=<span class="built_in">solve</span>(sum);</span><br><span class="line">            m=n-j;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=j+<span class="number">1</span>;k&lt;=n;k++)b[k-j]=a[k];</span><br><span class="line"></span><br><span class="line">            <span class="comment">// if(i==1 &amp;&amp; j==3)type=1;</span></span><br><span class="line">            <span class="comment">// else type=0;</span></span><br><span class="line"></span><br><span class="line">            now=<span class="built_in">max</span>(<span class="built_in">solve</span>(sum),now);</span><br><span class="line">            <span class="comment">// if(i==1 &amp;&amp; j==3)printf(&quot;%d\n&quot;,now);</span></span><br><span class="line">            ans=<span class="built_in">min</span>(now-sum,ans);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></details>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title>Game of Connect(Shannon&#39;s Switching Game)</title>
    <url>/2024/01/31/Game-of-Connect-Shannon-s-Switching-Game/</url>
    <content><![CDATA[<p>题目链接：<a href="https://onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=3792">https://onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=3792</a></p>
<p>题目大意：给一张图，先手先选定两个不同的点 $A,B$ ，然后开始游戏，每轮先手指定一个未固定的边删掉，后手指定一个没被固定的边固定，如果 $A,B$ 最后联通，则后手获胜，否则先手获胜，问后手是否必胜。</p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>这道题目非常经典，又叫：Shannon’s Switching Game。</p>
<p>又有个变体问题：没有指定 $A,B$ 了，后手的目的是最后要是个联通图。</p>
<p>这两个问题的后手必胜的充要条件是：图中有两个交集为 $0$ 的生成树。</p>
<p>对于变体问题的充分性是比较好证明的，采用归纳+缩边的方法就行，详情请看：<a href="https://zhuanlan.zhihu.com/p/33862629">https://zhuanlan.zhihu.com/p/33862629</a> 。</p>
<p>也可以用拟阵中的基进行证明，这里不再赘述。</p>
<p>但是必要性我不会证明，所以这道题目在此留一个坑，就此作罢。</p>
<h6 id="坑"><a href="#坑" class="headerlink" title="坑"></a>坑</h6><p>学会 Shannon’s Switching Game 。</p>
<p>知道这个判定条件后后面就好搞了，怎么判定呢？</p>
<p>要有个生成树，且在这个生成树外还有一个生成树，前者是图拟阵，后者是图拟阵的对偶拟阵，所以就是图拟阵与图拟阵的对偶拟阵的拟阵交。</p>
<p>时间复杂度：$O(Tm^3)$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">没有，不会证明，懒得写代码了。</span><br></pre></td></tr></table></figure>
</div></details>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>拟阵</tag>
      </tags>
  </entry>
  <entry>
    <title>ECNU 2023.8 D Mutton string</title>
    <url>/2023/09/02/ECNU-2023-8-D-Mutton-string/</url>
    <content><![CDATA[<p>题目链接：<a href="https://acm.ecnu.edu.cn/contest/695/problem/D/">https://acm.ecnu.edu.cn/contest/695/problem/D/</a></p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>引理 $1$ ：优先加入符合要求的最长子串。（把后一个子串的前缀拿过来显然不劣）</p>
<p>到这里其实就差不多了，子串显然能够想到那个算法：SAM 。</p>
<p>如果给你一个字符串，怎么求出其的最小操作数呢？显然是拉上 SAM 上跑一遍，现在要我们确定一个最小操作数为 $x$ 的字符串，显然也是在 SAM 上 DP 一下就行了。</p>
<p>如果没有字典序的约束，这道题目就是：$dp[i][j]<a href="bool">k</a>$ 表示是否存在一个方案满足终止位置 SAM 上的第 $i$ 个节点，目前长度为 $j$ ，已经有了 $k$ 段，然后直接转移就行了。</p>
<p>但是因为我赛时分析错了复杂度，以为是四次方的，就没有往下接着想了，但实际上是三次方的。</p>
<p>显然时间复杂度是：$O(26nmx)$ ，而且如果实现的足够精妙能够到达 $O(nmx)$ ，因为考虑固定 $j,k$ ，这样对于 $i$ 的转移分两种，跑存在的边（ SAM 边的数量级是 $O(n)$ 的），跑不存在的边（可以状压，也可以调整搜索顺序，优先跑 $26$ ，然后去找可行且不能到达的状态（因此需要提前把可行的状态记录一下））。</p>
<p>但是如果要求字典序最小的字符串呢？</p>
<p>显然，我们必须要查询对于一个前缀，是否存在满足要求的答案，为此，我们不妨考虑整个字符串是倒着加子串的，然后把 $A$ 翻转，反着跑一遍 $DP$ ，然后枚举刚好跑到前缀时位于哪个点，然后继续扔到后缀数组上跑，看看能否凑出一个 $X$ 段出来。</p>
<p>时间复杂度：$O(26nmx)$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 310</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> M 160</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">26</span>],len,fa;</span><br><span class="line">&#125;tr[N];<span class="type">int</span> tot,last;</span><br><span class="line"><span class="type">char</span> st[M];<span class="type">int</span> n;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> c)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> p=last;<span class="type">int</span> np=last=++tot;</span><br><span class="line">    tr[np].len=tr[p].len+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(;p &amp;&amp; !tr[p].a[c];p=tr[p].fa)tr[p].a[c]=np;</span><br><span class="line">    <span class="keyword">if</span>(!p)tr[np].fa=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="type">int</span> q=tr[p].a[c];</span><br><span class="line">        <span class="keyword">if</span>(tr[q].len==tr[p].len+<span class="number">1</span>)tr[np].fa=q;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="type">int</span> nq=++tot;</span><br><span class="line">            tr[nq].fa=tr[q].fa;tr[q].fa=nq;</span><br><span class="line">            tr[nq].len=tr[p].len+<span class="number">1</span>;<span class="built_in">memcpy</span>(tr[nq].a,tr[q].a,<span class="built_in">sizeof</span>(tr[q].a));</span><br><span class="line">            tr[np].fa=nq;</span><br><span class="line">            <span class="keyword">for</span>(;p &amp;&amp; tr[p].a[c]==q;p=tr[p].fa)tr[p].a[c]=nq;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool</span> dp[N][M][M];</span><br><span class="line"><span class="type">int</span> m,X;<span class="type">char</span> ans[M];<span class="type">int</span> fuck;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getval</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> fucklen)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> cnt=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=fucklen;i&gt;=<span class="number">1</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(tr[x].a[ans[i]-<span class="string">&#x27;a&#x27;</span>])x=tr[x].a[ans[i]-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        <span class="keyword">else</span> x=tr[<span class="number">1</span>].a[ans[i]-<span class="string">&#x27;a&#x27;</span>],cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool</span> v[<span class="number">40</span>];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">work</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(fuck!=m)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=tot;i++)&#123;</span><br><span class="line">            <span class="type">int</span> x=<span class="built_in">getval</span>(i,fuck);</span><br><span class="line">            <span class="keyword">if</span>(x&lt;=X &amp;&amp; dp[i][m-fuck][X-x+<span class="number">1</span>])<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">getval</span>(tr[<span class="number">1</span>].a[ans[m]-<span class="string">&#x27;a&#x27;</span>],m<span class="number">-1</span>)==X;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> T;<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;X);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,st+<span class="number">1</span>);</span><br><span class="line">        tot=last=<span class="number">1</span>;<span class="built_in">memset</span>(tr,<span class="number">0</span>,<span class="built_in">sizeof</span>(tr));<span class="built_in">memset</span>(v,<span class="number">0</span>,<span class="built_in">sizeof</span>(v));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i+i&lt;=n;i++)<span class="built_in">swap</span>(st[i],st[n-i+<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="built_in">add</span>(st[i]-<span class="string">&#x27;a&#x27;</span>),v[st[i]-<span class="string">&#x27;a&#x27;</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="comment">// for(int i=1;i&lt;=tot;i++)&#123;</span></span><br><span class="line">        <span class="comment">//     printf(&quot;%d %d\n&quot;,tr[i].fa,tr[i].len);</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">25</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(tr[<span class="number">1</span>].a[i])dp[tr[<span class="number">1</span>].a[i]][<span class="number">1</span>][<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;m;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">2</span>;j&lt;=tot;j++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> t=<span class="number">1</span>;t&lt;=i &amp;&amp; t&lt;=X;t++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(!dp[j][i][t])<span class="keyword">continue</span>;</span><br><span class="line">                    <span class="comment">// if(i==1 &amp;&amp; j==5 &amp;&amp; t==1)printf(&quot;OK\n&quot;);</span></span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;=<span class="number">25</span>;k++)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(tr[j].a[k])dp[tr[j].a[k]][i+<span class="number">1</span>][t]=<span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span>(tr[<span class="number">1</span>].a[k] &amp;&amp; t&lt;X)dp[tr[<span class="number">1</span>].a[k]][i+<span class="number">1</span>][t+<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// for(int i=1;i&lt;=tot;i++)printf(&quot;%d:%d %d\n&quot;,i,tr[i].len,tr[i].fa);</span></span><br><span class="line">        <span class="comment">// printf(&quot;%d %d %d\n&quot;,dp[4][2][1],tr[5].a[0],dp[5][1][1]);</span></span><br><span class="line">        <span class="type">bool</span> bk=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=tot;i++)bk|=dp[i][m][X];</span><br><span class="line">        <span class="keyword">if</span>(!bk)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=tot;i++)<span class="built_in">memset</span>(dp[i],<span class="number">0</span>,<span class="built_in">sizeof</span>(dp[i]));</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;-1\n&quot;</span>);<span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ans[1]=ans[2]=&#x27;a&#x27;;printf(&quot;%d\n&quot;,getval(5,2));</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">            fuck=i;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=<span class="number">25</span>;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!v[j])<span class="keyword">continue</span>;</span><br><span class="line">                ans[i]=j+<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">work</span>()==<span class="number">1</span>)<span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans[m+<span class="number">1</span>]=<span class="string">&#x27;\0&#x27;</span>;<span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,ans+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=tot;i++)<span class="built_in">memset</span>(dp[i],<span class="number">0</span>,<span class="built_in">sizeof</span>(dp[i]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>官方做法：</p>
<p>不得不说这应该是经典 trick 但是我忘了，在遇到 DP + 字符串 + 字典序最小就应该马上意识过来才对。</p>
<p>简单来说，用 BFS 更新 DP 状态，这样只要更新出了最终状态那么这条更新路径就是答案，而且不止最终状态，准确来说对于每个状态其的更新路径都是字典序最小的路径。（那这样是不是 DFS 也可以啊，只要加个记忆化就行了，本质应该是一样的）</p>
<p>原因：队列中对于两个长度相等的状态，一定满足更新路径字典序小的在前面，大的在后面，同时只要前面符合这种情况，后面也一定符合这种情况，想想就知道了，挺有意思的，</p>
<hr>
<p>队友的做法：</p>
<p>赛后讨论了一下，他的做法是正着做，反过来标记每个状态如果要到达最终状态的最优决策是什么（实际上只要处理出能否到达最终状态就行了），然后在正着处理出答案。</p>
<p><del>然而，我突然发现，实际上倒着跑就可以只跑两遍了，先倒着跑一遍 DP ，处理出每个位置的最优，然后正着跑出结果就行了。</del> (错误原因：一个点可能有多个点走同一个字符的边转移过来，因此无法在常数的时间判断出来哪个是最优决策)</p>
<hr>
<p>同机房同学的做法：</p>
<p>非常的有意思，我只能说不愧是他，A不了，但是可以看一下。</p>
<p>观察发现实际上会出问题当且仅当某个子串的下一个位置和下一个子串的首位置相等，所以一个操作次数 $≥2$ 的子串的某个前缀一定是由一个子串+某个字符构成的（且这个前缀不是一个子串），不妨考虑处理出所有这样的字符串（最多 $26n^2$ 个），然后排序，可以发现，这样的字符串具有一个性质，不存在一个字符串是另外一个字符串的前缀，这个性质后面有用。</p>
<p>然后设 $f[i][j][k]$ 表示长度为 $j$ ，首字母为 $i$ ，最小操作次数为 $k$ 的最小字典序的字符串（其实也不需要保留字符串，保留转移就行了）。</p>
<p>这样，转移的时候只需要从小到达遍历前面那个字符串，能转移就转移，不难发现这就是最优的决策。</p>
<p>但是仔细计算一下复杂度是 $O(26^2nmx)$ ，非常遗憾不能通过此题，但是我个人感觉这个思想非常的有意思，所以就把它给记录下来了，而且也很有启示意义，就是很多时候可以尝试一下脱离算法思考，可以发现这个方法并不依赖任何字符串算法，却得到了一个非常有意思的方法（这个老哥就是这个想法的忠实拥护者，不怎么学算法，坚信大部分题目都是可以用思维解决，所以他的思维就非常的厉害）。</p>
<hr>
<p>听说同机房还有基于字典树和 bitset 优化的四方做法过了，厉害厉害。</p>
</div></details>]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>经典trick</tag>
        <tag>字符串</tag>
        <tag>字典序</tag>
        <tag>SAM</tag>
      </tags>
  </entry>
  <entry>
    <title>Graffiti</title>
    <url>/2024/02/05/Graffiti/</url>
    <content><![CDATA[<p>题目链接：<a href="https://contest.ucup.ac/contest/1511/problem/8213">https://contest.ucup.ac/contest/1511/problem/8213</a></p>
<p>题目大意：</p>
<p>给一个树，给一个长度不超过 $3$ 的串，然后问：每个点填一个字母，最大化满足经过的点构成的字符串等于给定串的有向路径数量，输出数量。</p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>显然只有长度为 $3$ 的串需要思考，当只有两个不同的字母的时候，会发现如果使用 $dp[x][0/1]$ 的 dp 方式，会无法处理从 $x$ 的儿子的儿子，到 $x$ 的路径，所以我们需要再多添加一维，表示父亲填的字母，相当于提前知道了父亲填的字母，然后父亲在转移的时候直接调用就行了。</p>
<p>但是会发现我们仍然无法处理三个字母都不同的情况，因为儿子有三种选择。</p>
<p>但是注意到第一个字母和第三个字母并没有本质区别，将一个子树的第一个字母和第三个字母全部颠倒不会影响这个子树的贡献，所以也就只需要知道儿子应该选一/三字母或者第二个字母就行，排个序枚举一下就行了。</p>
<p>时间复杂度：$O(n\log{n})$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="keyword">typedef</span> vector&lt;<span class="type">int</span>&gt; VI;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">3e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> NN=<span class="number">6e5</span>+<span class="number">5</span>;</span><br><span class="line">LL dp[N][<span class="number">4</span>][<span class="number">4</span>];</span><br><span class="line"><span class="type">int</span> ss[<span class="number">4</span>],n,m,C;<span class="type">char</span> st[<span class="number">10</span>];</span><br><span class="line"><span class="type">int</span> vis[<span class="number">300</span>];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> y,next;</span><br><span class="line">&#125;a[NN];<span class="type">int</span> len,las[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ins</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;a[++len]=&#123;y,las[x]&#125;;las[x]=len;&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">pd</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(m==<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> (x==ss[<span class="number">1</span>] &amp;&amp; y==ss[<span class="number">2</span>]) || (x==ss[<span class="number">2</span>] &amp;&amp; y==ss[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">pd</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> z)</span></span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(m==<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">return</span> (x==ss[<span class="number">1</span>] &amp;&amp; y==ss[<span class="number">2</span>] &amp;&amp; z==ss[<span class="number">3</span>]) || (x==ss[<span class="number">3</span>] &amp;&amp; y==ss[<span class="number">2</span>] &amp;&amp; z==ss[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">count</span><span class="params">(LL c1,LL c2,<span class="type">int</span> fc)</span></span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(C&gt;<span class="number">1</span>);</span><br><span class="line">    LL tmp=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(C==<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">pd</span>(<span class="number">1</span>,ss[<span class="number">2</span>],<span class="number">1</span>)==<span class="number">1</span>)tmp+=c1*(c1<span class="number">-1</span>)/<span class="number">2</span>;</span><br><span class="line">        <span class="comment">// if(pd(2,ss[2],2)==1)tmp+=c2*(c2-1)/2; impossible</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">pd</span>(<span class="number">1</span>,ss[<span class="number">2</span>],<span class="number">2</span>)==<span class="number">1</span>)tmp+=c1*c2;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">pd</span>(<span class="number">1</span>,ss[<span class="number">2</span>],fc)==<span class="number">1</span>)tmp+=c1;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">pd</span>(<span class="number">2</span>,ss[<span class="number">2</span>],fc))tmp+=c2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(fc==<span class="number">1</span> || fc==<span class="number">3</span>)&#123;</span><br><span class="line">            LL c3=(c1+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">            tmp+=c3*(c1-c3)+c3;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            LL c3=c1/<span class="number">2</span>;</span><br><span class="line">            tmp+=c3*(c1-c3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line">LL sta[N];<span class="type">int</span> top;</span><br><span class="line">VI son[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> fa)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=las[x];k;k=a[k].next)&#123;</span><br><span class="line">        <span class="type">int</span> y=a[k].y;<span class="keyword">if</span>(y==fa)<span class="keyword">continue</span>;</span><br><span class="line">        son[x].<span class="built_in">push_back</span>(y);</span><br><span class="line">        <span class="built_in">dfs</span>(y,x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(m==<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=C;i++)&#123;</span><br><span class="line">            LL now=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> y:son[x])&#123;</span><br><span class="line">                LL tmp=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=C;j++)&#123;</span><br><span class="line">                    tmp=<span class="built_in">max</span>(dp[y][i][j],tmp);</span><br><span class="line">                &#125;</span><br><span class="line">                now+=tmp;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> fc=<span class="number">1</span>;fc&lt;=C;fc++)&#123;<span class="comment">//father color</span></span><br><span class="line">                <span class="keyword">if</span>(x!=<span class="number">1</span> &amp;&amp; <span class="built_in">pd</span>(i,fc))dp[x][fc][i]=now+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> dp[x][fc][i]=now;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;<span class="comment">//m=3</span></span><br><span class="line">        <span class="built_in">assert</span>(m==<span class="number">3</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=C;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i!=ss[<span class="number">2</span>])&#123;<span class="comment">//only up</span></span><br><span class="line">                LL now=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">auto</span> y:son[x])&#123;</span><br><span class="line">                    LL tmp=<span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=C;j++)&#123;</span><br><span class="line">                        tmp=<span class="built_in">max</span>(tmp,dp[y][i][j]);</span><br><span class="line">                    &#125;</span><br><span class="line">                    now+=tmp;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> fc=<span class="number">1</span>;fc&lt;=C;fc++)&#123;<span class="comment">//father color</span></span><br><span class="line">                    dp[x][fc][i]=now;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(C==<span class="number">1</span>)&#123;</span><br><span class="line">                LL siz=son[x].<span class="built_in">size</span>();</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">auto</span> y:son[x]) dp[x][<span class="number">1</span>][<span class="number">1</span>]+=dp[y][<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">                dp[x][<span class="number">1</span>][<span class="number">1</span>]+=siz*(siz<span class="number">-1</span>)/<span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span>(x!=<span class="number">1</span>)dp[x][<span class="number">1</span>][<span class="number">1</span>]+=siz;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                top=<span class="number">0</span>;</span><br><span class="line">                LL ini=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">auto</span> y:son[x])&#123;</span><br><span class="line">                    sta[++top]=dp[y][i][<span class="number">2</span>]-dp[y][i][<span class="number">1</span>];</span><br><span class="line">                    <span class="built_in">assert</span>(C!=<span class="number">3</span> || dp[y][i][<span class="number">1</span>]==dp[y][i][<span class="number">3</span>]);</span><br><span class="line">                    ini+=dp[y][i][<span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">sort</span>(sta+<span class="number">1</span>,sta+top+<span class="number">1</span>,[](LL x,LL y)&#123;<span class="keyword">return</span> x&gt;y;&#125;);</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> fc=<span class="number">1</span>;fc&lt;=C;fc++)&#123;</span><br><span class="line">                    LL now=<span class="number">0</span>,tmp=ini;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=top;j++)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(x!=<span class="number">1</span>)now=<span class="built_in">max</span>( now , tmp+<span class="built_in">count</span>(top-j,j,fc) );</span><br><span class="line">                        <span class="keyword">else</span> now=<span class="built_in">max</span>( now , tmp+<span class="built_in">count</span>(top-j,j,<span class="number">0</span>) );</span><br><span class="line">                        <span class="keyword">if</span>(j!=top) tmp+=sta[j+<span class="number">1</span>];</span><br><span class="line">                    &#125;</span><br><span class="line">                    dp[x][fc][i]=now;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">work</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,st+<span class="number">1</span>);m=<span class="built_in">strlen</span>(st+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="type">int</span> x,y;<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;x,&amp;y);</span><br><span class="line">        <span class="built_in">ins</span>(x,y);<span class="built_in">ins</span>(y,x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!vis[st[i]])vis[st[i]]=++C;</span><br><span class="line">        ss[i]=vis[st[i]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(m==<span class="number">1</span>)<span class="keyword">return</span> n;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    LL ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=C;i++)ans=<span class="built_in">max</span>(ans,dp[<span class="number">1</span>][<span class="number">1</span>][i]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ss[<span class="number">1</span>]==ss[m])ans*=<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,<span class="built_in">work</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>题外话：<br>其实这个 dp 设计非常有意思。</p>
<ol>
<li><p>从树的角度考虑，我们其实有另外一种设计思路是，多添加几维表示这个节点的每个颜色的儿子选了多少个，但是可以发现这种设计是显然会超时的。</p>
<p>这是因为一个节点的儿子数量可以很多，而父亲至多一个，因此，我们更希望通过父亲解决问题，而不是通过儿子。</p>
<p>一个类似的例子是：一个数据结构题目，每次能够给一个点周围的所有点的点权加上 $c$ ，做法为：父亲的点权直接加上，儿子的点权加在自己身上，等查询一个点点权的时候让他自己来问父亲。</p>
<p>当然，上面那个例子还有个单 log 做法，就是利用 BFS 序+线段树，因为 BFS 序上儿子的编号是连续的。</p>
</li>
<li><p>从预知未来的角度考虑：</p>
<p>每个点先预知未来的一些信息，在这道题目上的作用是，让我们能够处理了一些本来无法处理的信息。</p>
<p>当然也可以有其他作用，举个减少时间复杂度的例子（某一年提高组初赛的题目，忘记是哪一年了）：</p>
<h6 id="坑"><a href="#坑" class="headerlink" title="坑"></a>坑</h6><p>这道题目到底是哪一年的。</p>
<p>求长度恰好为 $k$ 且相邻数字的异或的和最大的子序列，输出最大的和，值域 $2^{8}-1$。</p>
<p>做法为 $dp[i][x][y]$ ，$i$ 是已经有几个数字，$x$ 表示子序列目前最后一个数字的上 $4$ 位，$y$ 表示我们期望下一个数字的下 $4$ 位是多少。</p>
<p>这样就能在 $O(n^2*2^4)$ 的复杂度处理这个问题，相较于 $dp[i][x]$ 少了 $2^4$ 。</p>
</li>
</ol>
</div></details>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>树形DP</tag>
      </tags>
  </entry>
  <entry>
    <title>MEXimum Spanning Tree</title>
    <url>/2024/01/30/MEXimum-Spanning-Tree/</url>
    <content><![CDATA[<p>题目链接：<a href="https://qoj.ac/contest/1221/problem/6402">https://qoj.ac/contest/1221/problem/6402</a></p>
<p>题目大意：求 $mex$ 最大的生成树。</p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>一个显然的事情，这道题目是拟阵交，第一个拟阵无环，第二个拟阵要求每条数字的边至多一条。</p>
<p>这个时候可以二分+拟阵交，也可以从小到达考虑 $\le c$ 的边的拟阵交，因为拟阵交的算法保证了，只要给一个交集中的元素（一般默认空集），就一定可以增广出最大的元素。</p>
<p>接下来默认用从小到大考虑的方法，因为少个 $log$ 。</p>
<p>以下时间复杂度默认点数与边数同阶。</p>
<p>暴力建图的话是 $O(n^3)$ ，虽然能过，但是能不能更加优秀？</p>
<p>这个时候有几个优化方向：</p>
<ol>
<li>bitset ，在翻代码的时候看到的，虽然没看具体怎么优化的，反正是有人这么干的。</li>
<li>等到遍历到在加入边，显然，我们没必要一开始就把图建出来，而是跑到一个点再把这个点的所有出边找到，发现由于是 BFS，所以每个点至多走一次，所以这个优化只快不慢，同时注意到图拟阵那边的出边是难的，可以采用并查集优化的方式，在 $O(n^2\alpha(n))$ 的时间解决这个特殊的拟阵交问题。</li>
<li>题解说可以 $O(n^2\sqrt{n})$ ，没懂具体咋搞的，但肯定不是一开始就把图建出来。后面经过询问，似乎是说最短路的总长度有个 bound ，又说和 Hopcroft Karp 的分析类似，但 Hopcroft Karp 我没有学过，这个方法先咕了，等以后再说吧。</li>
</ol>
<p>但我写的是最暴力的三方做法，还要乘并查集的 $\alpha(n)$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e3</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M=<span class="number">2e6</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span>&#123;</span><br><span class="line">    <span class="type">int</span> x,y,c;</span><br><span class="line">&#125;e[N];<span class="type">int</span> pf[N];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(Edge x,Edge y)</span></span>&#123;<span class="keyword">return</span> x.c&lt;y.c;&#125;</span><br><span class="line"><span class="type">bool</span> in[N],col[N];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> fa[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">findfa</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="keyword">return</span> fa[x]==x?x:fa[x]=<span class="built_in">findfa</span>(fa[x]);&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mer</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    x=<span class="built_in">findfa</span>(x);y=<span class="built_in">findfa</span>(y);</span><br><span class="line">    <span class="keyword">if</span>(x!=y)fa[x]=y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">pd</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;<span class="keyword">return</span> <span class="built_in">findfa</span>(x)==<span class="built_in">findfa</span>(y);&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">uinit</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)fa[i]=i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> y,next;</span><br><span class="line">&#125;a[M];<span class="type">int</span> len,las[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ins</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;a[++len]=&#123;y,las[x]&#125;;las[x]=len;&#125;</span><br><span class="line"><span class="type">int</span> typ[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> lim)</span></span>&#123;</span><br><span class="line">    len=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(las+<span class="number">1</span>,<span class="number">0</span>,<span class="built_in">sizeof</span>(<span class="type">int</span>)*lim);</span><br><span class="line">    <span class="built_in">memset</span>(typ+<span class="number">1</span>,<span class="number">0</span>,<span class="built_in">sizeof</span>(<span class="type">int</span>)*lim);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=lim;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!in[i])<span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">uinit</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=lim;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i!=j &amp;&amp; in[j])<span class="built_in">mer</span>(e[j].x,e[j].y);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=lim;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(in[j])<span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(!<span class="built_in">pd</span>(e[j].x,e[j].y))<span class="built_in">ins</span>(i,j);</span><br><span class="line">            <span class="keyword">if</span>(e[i].c==e[j].c || !col[e[j].c])<span class="built_in">ins</span>(j,i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">uinit</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=lim;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(in[i])<span class="built_in">mer</span>(e[i].x,e[i].y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=lim;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(in[i])<span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">pd</span>(e[i].x,e[i].y))typ[i]|=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(!col[e[i].c])typ[i]|=<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"><span class="type">int</span> pre[N];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> lim)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=lim;i++)pre[i]=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=lim;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(typ[i]&amp;<span class="number">1</span>)&#123;</span><br><span class="line">            pre[i]=<span class="number">0</span>;</span><br><span class="line">            q.<span class="built_in">push</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="type">int</span> x=q.<span class="built_in">front</span>();q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(typ[x]&amp;<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">while</span>(x)&#123;</span><br><span class="line">                col[e[x].c]^=<span class="number">1</span>;</span><br><span class="line">                in[x]^=<span class="number">1</span>;</span><br><span class="line">                x=pre[x];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k=las[x];k;k=a[k].next)&#123;</span><br><span class="line">            <span class="type">int</span> y=a[k].y;</span><br><span class="line">            <span class="keyword">if</span>(pre[y]==<span class="number">-1</span>)&#123;</span><br><span class="line">                pre[y]=x;</span><br><span class="line">                q.<span class="built_in">push</span>(y);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;e[i].x,&amp;e[i].y,&amp;e[i].c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(e+<span class="number">1</span>,e+m+<span class="number">1</span>,[](Edge x,Edge y)&#123;</span><br><span class="line">        <span class="keyword">return</span> x.c&lt;y.c;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)pf[e[i].c]=i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)pf[i]=<span class="built_in">max</span>(pf[i],pf[i<span class="number">-1</span>]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">build</span>(pf[i]);</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">solve</span>(pf[i]))&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,i);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="坑"><a href="#坑" class="headerlink" title="坑"></a>坑</h6><p>根号做法是啥。</p>
</div></details>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>拟阵</tag>
      </tags>
  </entry>
  <entry>
    <title>Milk Candy</title>
    <url>/2024/01/31/Milk-Candy/</url>
    <content><![CDATA[<p>题目链接：<a href="https://qoj.ac/contest/1386/problem/7580">https://qoj.ac/contest/1386/problem/7580</a></p>
<p>题目大意：</p>
<p>有 $n$ 个未知数字，有 $m$ 个商人，每个商人有 $c_i$ 个的线索，每个线索有个价格，同时线索内容为 $[l,r]$ 的数字的和，你可以向每个商人买线索，但是每个商人必须恰好买 $k_i$ 个线索，问最少需要多少钱才能知道所有未知数字。</p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>虽然赛时队长神力秒了，但是我来编一个比较自然的思考路线：前缀和。</p>
<p>设 $s$ 为前缀和数组，所以实际上就是要知道所有 $s_i-s_0$ 。</p>
<p>考虑每个线索实际上提供了 $s_r-s_{l-1}$ ，又 $(s_a-s_b)+(s_b-s_c)=(s_a-s_c)$ ，所以实际上就是 $r$ 与 $l-1$ 连边，最后问所有点是不是与 $0$ 联通，也就是 $n+1$ 个点的生成树。</p>
<p>问题等价于 $n+1$ 个点，然后有一些边，问符合要求的最小权连通图。</p>
<ol>
<li>第一个拟阵 ，图拟阵的对偶拟阵。</li>
<li>第二个拟阵 ，每个商人去掉的线索数量不超过 $c_i-k_i$ 。</li>
</ol>
<p>带权拟阵交。</p>
<p>时间复杂度：$O((n\sum c_i)^2)$ 。</p>
<p>记得特判图一开始是不是联通的，因为如果一开始就不联通，那么 $\emptyset\notin \mathcal{I}$ ，这与拟阵交一开始默认 $\emptyset \in \mathcal{I}$ 冲突。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf=<span class="number">1e9</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e2</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M=<span class="number">2e4</span>+<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m,K,ans,ned;</span><br><span class="line"><span class="type">int</span> bel[N],cnt[N],lim[N];</span><br><span class="line">PII e[N];<span class="type">int</span> pri[N];</span><br><span class="line"><span class="type">bool</span> in[N];</span><br><span class="line"><span class="keyword">namespace</span> Union&#123;</span><br><span class="line">    <span class="type">int</span> fa[N];</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findfa</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="keyword">return</span> fa[x]==x?x:fa[x]=<span class="built_in">findfa</span>(fa[x]);&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mer</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">        x=<span class="built_in">findfa</span>(x);y=<span class="built_in">findfa</span>(y);</span><br><span class="line">        <span class="keyword">if</span>(x!=y)fa[x]=y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">pd</span><span class="params">(<span class="type">int</span> mov,<span class="type">int</span> add)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;i++)fa[i]=i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=K;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i==mov)<span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(i!=add &amp;&amp; in[i])<span class="keyword">continue</span>;</span><br><span class="line">            <span class="built_in">mer</span>(e[i].first,e[i].second);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">findfa</span>(i)!=<span class="built_in">findfa</span>(<span class="number">0</span>))<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> Union::pd;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> y,next;</span><br><span class="line">&#125;a[M];<span class="type">int</span> len,las[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ins</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;a[++len]=&#123;y,las[x]&#125;;las[x]=len;&#125;</span><br><span class="line"><span class="type">int</span> val[N],typ[N];PII d[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    len=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(las+<span class="number">1</span>,<span class="number">0</span>,<span class="built_in">sizeof</span>(<span class="type">int</span>)*K);</span><br><span class="line">    <span class="built_in">memset</span>(typ+<span class="number">1</span>,<span class="number">0</span>,<span class="built_in">sizeof</span>(<span class="type">int</span>)*K);</span><br><span class="line">&#125;</span><br><span class="line">queue&lt;<span class="type">int</span>&gt; q;<span class="type">bool</span> v[N];</span><br><span class="line"><span class="type">int</span> pre[N];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=K;i++)d[i]=&#123;-inf,-inf&#125;;</span><br><span class="line">    <span class="built_in">assert</span>(q.<span class="built_in">empty</span>());</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=K;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(typ[i]&amp;<span class="number">1</span>)&#123;</span><br><span class="line">            d[i]=&#123;val[i],<span class="number">0</span>&#125;;</span><br><span class="line">            v[i]=<span class="number">1</span>;</span><br><span class="line">            pre[i]=<span class="number">0</span>;</span><br><span class="line">            q.<span class="built_in">push</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="type">int</span> x=q.<span class="built_in">front</span>();q.<span class="built_in">pop</span>();</span><br><span class="line">        v[x]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k=las[x];k;k=a[k].next)&#123;</span><br><span class="line">            <span class="type">int</span> y=a[k].y;</span><br><span class="line">            <span class="keyword">if</span>(PII&#123;d[x].first+val[y],d[x].second<span class="number">-1</span>&#125;&gt;d[y])&#123;</span><br><span class="line">                d[y]=PII&#123;d[x].first+val[y],d[x].second<span class="number">-1</span>&#125;;</span><br><span class="line">                pre[y]=x;</span><br><span class="line">                <span class="keyword">if</span>(!v[y])&#123;</span><br><span class="line">                    v[y]=<span class="number">1</span>;</span><br><span class="line">                    q.<span class="built_in">push</span>(y);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    PII maxval=&#123;-inf,-inf&#125;;</span><br><span class="line">    <span class="type">int</span> endpoint=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=K;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>((typ[i]&amp;<span class="number">2</span>) &amp;&amp; d[i]&gt;maxval)&#123;</span><br><span class="line">            maxval=d[i];</span><br><span class="line">            endpoint=i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!endpoint)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    ans-=maxval.first;ned--;</span><br><span class="line">    <span class="type">int</span> now=endpoint;</span><br><span class="line">    <span class="keyword">while</span>(now)&#123;</span><br><span class="line">        <span class="keyword">if</span>(in[now])cnt[bel[now]]--;</span><br><span class="line">        <span class="keyword">else</span> cnt[bel[now]]++;</span><br><span class="line">        in[now]^=<span class="number">1</span>;</span><br><span class="line">        now=pre[now];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=K;i++)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!in[i])val[i]=pri[i];</span><br><span class="line">        <span class="keyword">else</span> val[i]=-pri[i];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(in[i])&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=K;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(in[j])<span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">pd</span>(j,i))<span class="built_in">ins</span>(i,j);</span><br><span class="line">                <span class="keyword">if</span>(cnt[bel[j]]&lt;lim[bel[j]] || bel[i]==bel[j])<span class="built_in">ins</span>(j,i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">pd</span>(i,<span class="number">-1</span>))typ[i]|=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(cnt[bel[i]]&lt;lim[bel[i]])typ[i]|=<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> T;<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        ans=ned=K=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(cnt,<span class="number">0</span>,<span class="built_in">sizeof</span>(cnt));</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">            <span class="type">int</span> x;<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;x,&amp;lim[i]);</span><br><span class="line">            lim[i]=x-lim[i];</span><br><span class="line">            ned+=lim[i];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=x;j++)&#123;</span><br><span class="line">                ++K;bel[K]=i;in[K]=<span class="number">0</span>;</span><br><span class="line">                <span class="type">int</span> l,r;<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;l,&amp;r,&amp;pri[K]);</span><br><span class="line">                l--;</span><br><span class="line">                e[K]=&#123;l,r&#125;;</span><br><span class="line">                ans+=pri[K];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">pd</span>(<span class="number">-1</span>,<span class="number">-1</span>))&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;-1\n&quot;</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            <span class="built_in">build</span>();</span><br><span class="line">        &#125;<span class="keyword">while</span>(<span class="built_in">solve</span>());</span><br><span class="line">        <span class="keyword">if</span>(ned)ans=<span class="number">-1</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></details>]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>拟阵</tag>
      </tags>
  </entry>
  <entry>
    <title>Pick Your Own Nim</title>
    <url>/2024/01/31/Pick-Your-Own-Nim/</url>
    <content><![CDATA[<p>题目链接：<a href="https://codeforces.com/gym/102156/problem/D">https://codeforces.com/gym/102156/problem/D</a></p>
<p>题目大意：</p>
<p>给你 $n$ 个数字，再给你 $m$ 组数字，你要在每一组里面选一个数字，使得选出来的数字和那 $n$ 个数字，关于异或运算线性无关，如果可以，给一组方案。</p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>有限大小的线性空间本身就是拟阵，这样就很显然了。</p>
<ol>
<li>拟阵 $1$ 是线性无关。（算上那 $n$ 个数字）</li>
<li>拟阵 $2$ 是每组数字至多一个。</li>
</ol>
<p>时间复杂度：$O(60^2\sum\limits k_i)$ 。</p>
<p>记得特判一开始的 $n$ 个数字是否线性无关，否则还是老生常谈的问题：$\emptyset\notin \mathcal{I}$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N1=<span class="number">65</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N2=<span class="number">5e3</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M=<span class="number">6e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n,m,K;</span><br><span class="line">LL va[N2];<span class="type">int</span> bel[N2];</span><br><span class="line"><span class="type">bool</span> col[N1],in[N2];</span><br><span class="line"></span><br><span class="line">LL sta[N1];</span><br><span class="line"><span class="type">int</span> pos[N1],top;</span><br><span class="line">LL lin[N1],fac[N1];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">add</span><span class="params">(LL x,<span class="type">int</span> id)</span></span>&#123;</span><br><span class="line">    LL now=(<span class="number">1ll</span>&lt;&lt;(id<span class="number">-1</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">59</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">if</span>((x&gt;&gt;i)&amp;<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!lin[i])&#123;</span><br><span class="line">                lin[i]=x;</span><br><span class="line">                fac[i]=now;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> x^=lin[i],now^=fac[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">build_liner</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(lin,<span class="number">0</span>,<span class="built_in">sizeof</span>(lin));</span><br><span class="line">    <span class="built_in">memset</span>(fac,<span class="number">0</span>,<span class="built_in">sizeof</span>(fac));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=top;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">add</span>(sta[i],i))<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">findfac</span><span class="params">(LL x)</span></span>&#123;</span><br><span class="line">    LL now=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">59</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">if</span>((x&gt;&gt;i)&amp;<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!lin[i])<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">else</span> x^=lin[i],now^=fac[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> now;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> y,next;</span><br><span class="line">&#125;a[M];<span class="type">int</span> len,las[N2];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ins</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;a[++len]=&#123;y,las[x]&#125;;las[x]=len;&#125;</span><br><span class="line"><span class="type">int</span> typ[N2];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getliner</span><span class="params">()</span></span>&#123;</span><br><span class="line">    top=n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=K;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(in[i])sta[++top]=va[i],pos[top]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">assert</span>(<span class="built_in">build_liner</span>());</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">()</span></span>&#123;</span><br><span class="line">    len=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(las+<span class="number">1</span>,<span class="number">0</span>,<span class="built_in">sizeof</span>(<span class="type">int</span>)*K);</span><br><span class="line">    <span class="built_in">memset</span>(typ+<span class="number">1</span>,<span class="number">0</span>,<span class="built_in">sizeof</span>(<span class="type">int</span>)*K);</span><br><span class="line">    <span class="built_in">getliner</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> now=n+<span class="number">1</span>,i=pos[now];now&lt;=top;now++,i=pos[now])&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=K;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(in[j])<span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(bel[i]==bel[j] || !col[bel[j]])<span class="built_in">ins</span>(j,i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=K;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(in[i])<span class="keyword">continue</span>;</span><br><span class="line">        LL x=<span class="built_in">findfac</span>(va[i]);</span><br><span class="line">        <span class="keyword">if</span>(x==<span class="number">-1</span>)&#123;</span><br><span class="line">            typ[i]|=<span class="number">1</span>;</span><br><span class="line">            x=(<span class="number">1ll</span>&lt;&lt;top)<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> now=n+<span class="number">1</span>;now&lt;=top;now++)&#123;</span><br><span class="line">            <span class="keyword">if</span>((x&gt;&gt;(now<span class="number">-1</span>))&amp;<span class="number">1</span>)<span class="built_in">ins</span>(pos[now],i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!col[bel[i]])typ[i]|=<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"><span class="type">int</span> pre[N2];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=K;i++)pre[i]=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=K;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(typ[i]&amp;<span class="number">1</span>)&#123;</span><br><span class="line">            pre[i]=<span class="number">0</span>;</span><br><span class="line">            q.<span class="built_in">push</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="type">int</span> x=q.<span class="built_in">front</span>();q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(typ[x]&amp;<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">while</span>(x)&#123;</span><br><span class="line">                col[bel[x]]^=<span class="number">1</span>;</span><br><span class="line">                in[x]^=<span class="number">1</span>;</span><br><span class="line">                x=pre[x];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k=las[x];k;k=a[k].next)&#123;</span><br><span class="line">            <span class="type">int</span> y=a[k].y;</span><br><span class="line">            <span class="keyword">if</span>(pre[y]==<span class="number">-1</span>)&#123;</span><br><span class="line">                pre[y]=x;</span><br><span class="line">                q.<span class="built_in">push</span>(y);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);top=n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;sta[i]);</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">build_liner</span>())&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;-1\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="type">int</span> cnt;<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;cnt);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=cnt;j++)&#123;</span><br><span class="line">            ++K;bel[K]=i;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;va[K]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="built_in">build</span>();</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">solve</span>())&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;-1\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=K;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(in[i])<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,va[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></details>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
  </entry>
  <entry>
    <title>Rainbow Graph</title>
    <url>/2024/01/31/Rainbow-Graph/</url>
    <content><![CDATA[<p>题目链接：<a href="https://open.kattis.com/problems/rainbowgraph">https://open.kattis.com/problems/rainbowgraph</a></p>
<p>题目大意：</p>
<p>一张无向图，每条边有红绿蓝三种颜色，请选一个最小权值和的边集，使得：不看红色边图是联通的，不看蓝色边图也是联通的。</p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>两个对偶拟阵一交就做完了，需要注意的是，带权拟阵交每次增广出来的集合，都是与他同大小的权值和最大的集合，所以一遍带权拟阵交就能处理出所有的答案。</p>
<p>记得特判图一开始是不是联通的，因为如果一开始就不联通，那么 $\emptyset\notin \mathcal{I}$ ，这与拟阵交一开始默认 $\emptyset \in \mathcal{I}$ 冲突。</p>
<p>时间复杂度：$O(m^4)$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf=<span class="number">1e9</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e2</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M=<span class="number">2e4</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n,m,zans;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span>&#123;</span><br><span class="line">    <span class="type">int</span> x,y,c,typ;</span><br><span class="line">&#125;e[N];</span><br><span class="line"><span class="type">bool</span> in[N];</span><br><span class="line"><span class="keyword">namespace</span> Union&#123;</span><br><span class="line">    <span class="type">int</span> fa[N];</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findfa</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="keyword">return</span> fa[x]==x?x:fa[x]=<span class="built_in">findfa</span>(fa[x]);&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mer</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">        x=<span class="built_in">findfa</span>(x);y=<span class="built_in">findfa</span>(y);</span><br><span class="line">        <span class="keyword">if</span>(x!=y)fa[x]=y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">pd</span><span class="params">(<span class="type">int</span> ban,<span class="type">int</span> mov,<span class="type">int</span> add)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)fa[i]=i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(e[i].typ==ban || i==mov)<span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(i!=add &amp;&amp; in[i])<span class="keyword">continue</span>;</span><br><span class="line">            <span class="built_in">mer</span>(e[i].x,e[i].y);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">findfa</span>(i)!=<span class="built_in">findfa</span>(<span class="number">1</span>))<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> Union::pd;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> y,next;</span><br><span class="line">&#125;a[M];<span class="type">int</span> len,las[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ins</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;a[++len]=&#123;y,las[x]&#125;;las[x]=len;&#125;</span><br><span class="line"><span class="type">int</span> pri[N],typ[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">()</span></span>&#123;</span><br><span class="line">    len=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(las+<span class="number">1</span>,<span class="number">0</span>,<span class="built_in">sizeof</span>(<span class="type">int</span>)*m);</span><br><span class="line">    <span class="built_in">memset</span>(typ+<span class="number">1</span>,<span class="number">0</span>,<span class="built_in">sizeof</span>(<span class="type">int</span>)*m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(in[i])&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(in[j])<span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">pd</span>(<span class="number">0</span>,j,i))<span class="built_in">ins</span>(i,j);</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">pd</span>(<span class="number">2</span>,j,i))<span class="built_in">ins</span>(j,i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">pd</span>(<span class="number">0</span>,i,<span class="number">-1</span>))typ[i]|=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">pd</span>(<span class="number">2</span>,i,<span class="number">-1</span>))typ[i]|=<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!in[i])pri[i]=e[i].c;</span><br><span class="line">        <span class="keyword">else</span> pri[i]=-e[i].c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> pre[N];PII d[N];</span><br><span class="line"><span class="type">bool</span> v[N];</span><br><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(q.<span class="built_in">empty</span>());</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)d[i]=&#123;-inf,-inf&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(typ[i]&amp;<span class="number">1</span>)&#123;</span><br><span class="line">            q.<span class="built_in">push</span>(i);</span><br><span class="line">            v[i]=<span class="number">1</span>;</span><br><span class="line">            d[i]=&#123;pri[i],<span class="number">0</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="type">int</span> x=q.<span class="built_in">front</span>();q.<span class="built_in">pop</span>();</span><br><span class="line">        v[x]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k=las[x];k;k=a[k].next)&#123;</span><br><span class="line">            <span class="type">int</span> y=a[k].y;</span><br><span class="line">            <span class="keyword">if</span>(PII&#123;d[x].first+pri[y],d[x].second<span class="number">-1</span>&#125;&gt;d[y])&#123;</span><br><span class="line">                d[y]=PII&#123;d[x].first+pri[y],d[x].second<span class="number">-1</span>&#125;;</span><br><span class="line">                pre[y]=x;</span><br><span class="line">                <span class="keyword">if</span>(!v[y])&#123;</span><br><span class="line">                    v[y]=<span class="number">1</span>;</span><br><span class="line">                    q.<span class="built_in">push</span>(y);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    PII maxval=&#123;-inf,-inf&#125;;<span class="type">int</span> mp=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>((typ[i]&amp;<span class="number">2</span>) &amp;&amp; d[i]&gt;maxval)&#123;</span><br><span class="line">            maxval=d[i];</span><br><span class="line">            mp=i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!mp)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    zans-=maxval.first;</span><br><span class="line">    <span class="type">int</span> now=mp;</span><br><span class="line">    <span class="keyword">while</span>(now)&#123;</span><br><span class="line">        in[now]^=<span class="number">1</span>;</span><br><span class="line">        now=pre[now];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">char</span> ss[<span class="number">10</span>];</span><br><span class="line"><span class="type">int</span> ans[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="type">int</span> x,y,w,t;<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%s&quot;</span>,&amp;x,&amp;y,&amp;w,ss+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(ss[<span class="number">1</span>]==<span class="string">&#x27;R&#x27;</span>)t=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(ss[<span class="number">1</span>]==<span class="string">&#x27;G&#x27;</span>)t=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> t=<span class="number">2</span>;</span><br><span class="line">        e[i]=&#123;x,y,w,t&#125;;</span><br><span class="line">        zans+=w;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)ans[i]=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">pd</span>(<span class="number">0</span>,<span class="number">-1</span>,<span class="number">-1</span>) &amp;&amp; <span class="built_in">pd</span>(<span class="number">2</span>,<span class="number">-1</span>,<span class="number">-1</span>))&#123;</span><br><span class="line">        ans[m]=zans;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=m<span class="number">-1</span>;i&gt;=<span class="number">1</span>;i--)&#123;</span><br><span class="line">            <span class="built_in">build</span>();</span><br><span class="line">            <span class="keyword">if</span>(!<span class="built_in">solve</span>())<span class="keyword">break</span>;</span><br><span class="line">            ans[i]=zans;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></details>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>拟阵</tag>
      </tags>
  </entry>
  <entry>
    <title>Prüfer序列学习笔记</title>
    <url>/2024/02/02/Prufer%E5%BA%8F%E5%88%97%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p> Prüfer 序列是真好用啊。</p>
<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>对于一棵 $n(n\ge 2)$ 个点的树，每次我们选择一个编号最小的叶子节点删掉，然后将其相邻节点的编号加入到序列中，直到剩下两个点为止，这样构成的序列，就叫这棵树的 Prüfer 序列。</p>
<h1 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h1><p>Prüfer 序列构建了一个有标号无根树到序列的双射，后面会讲如何通过另方求另一方。</p>
<p>而且任意一个值域为 $n$ 长度为 $n-2$ 的序列都对应了一棵生成树，这让 Prüfer 序列在解决无根树相关的计数问题非常好用。</p>
<p>从度数的角度看 Prüfer 序列，可以发现，Prüfer 序列中的点实际上表现的是度数 $-1$ 的过程。</p>
<p>例如 ：Prüfer 序列是 $1,2,3$ ，那么表示在删除第一个叶子时，$1$ 号点度数减 $1$ ，接下来同理。</p>
<p>最后，所有度数为 $1$ 的点被删除，只剩下了 $n$ 和另外一个度数为 $1$ 的点。</p>
<p>综上，我们可以得到下面这个结论。</p>
<p><strong>结论 1</strong> ：每个点在 Prüfer 序列中的出现次数为度数$-1$ 。</p>
<h1 id="转化"><a href="#转化" class="headerlink" title="转化"></a>转化</h1><h2 id="无根树转-Prufer-序列"><a href="#无根树转-Prufer-序列" class="headerlink" title="无根树转 Prüfer 序列"></a>无根树转 Prüfer 序列</h2><p>从小到大搜索每一个点，直到 Prüfer 序列中已经有 $n-2$ 个数字，设搜索到 $p$ 号点：</p>
<ol>
<li>假如 $p$ 号点不是叶子，继续搜。</li>
<li>假如 $p$ 号点是叶子，删除，如果新增了一个叶子节点且编号小于 $p$ ，显然这个叶子节点编号最小，接着删，直到删了 $n-2$ 个点或者编号 $&gt;p$ 。</li>
</ol>
<p>时间复杂度：$O(n)$ 。</p>
<h2 id="Prufer-序列转无根树"><a href="#Prufer-序列转无根树" class="headerlink" title="Prüfer 序列转无根树"></a>Prüfer 序列转无根树</h2><p>首先，根据 Prüfer 序列可以算出每个点的度数，然后按照 Prüfer 序列，每次取出编号最小的叶子节点和 Prüfer 序列当前位置连边，然后给 Prüfer 序列当前位置度数 $-1$ ，不断重复，直到最后，就只会剩两个度数为 $1$ 的节点，连起来即可。</p>
<p>时间复杂度：$O(n\log{n})$ 。</p>
<h1 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h1><ol>
<li>$n$ 个点的有标号无根树有多少个：$n^{n-2}$ 个。</li>
<li>假设每个点的度数已知，设为 $d_i$ ，求满足这个度数限制的有标号无根树的数量：$\binom{n-2}{d_1-1,d_2-1,…,d_n-1}$ 。</li>
<li><p>Cayley 公式：给定 $m(m\ge 2)$ 个连通块，每个连通块的大小是 $s_i$ ，且 $\sum\limits_{i=1}^m=n$ ，那么用 $m-1$ 条边把这 $m$ 个联通块联通起来的方案数为 $(\prod\limits_{i=1}^m s_i)n^{m-2}$ 。</p>
<details class="toggle" ><summary class="toggle-button" style="">证明</summary><div class="toggle-content"><p>证明 1 ：考虑 $m$ 个点的树的 $Prüfer$ 序列，不妨设为 $p$ 序列，由于 $Prüfer$ 序列实际上代表了一种连边方式，所以我们只需要计算 $n-1$ 条边能够有多少种连法就行了，那么对于这个 $Prüfer$ 序列能够代表的方案数，通过计算为：$(\prod_{i=1}^m s_i)<em>(\prod_{i=1}^{m-2} s_{p_i})$ 。又 Prüfer 序列 $m-2$ 个位置都可以填 $1-m$ ，所以显然，总方案数为 $(\prod\limits_{i=1}^m s_i)</em>n^{m-2}$ 。</p>
<p>证明 2 ：代数证明（来自oiwiki）</p>
<p>考虑每个连通块的度数为 $d_i$ ，显然，只要 $d_i&gt;0,\sum\limits_{i=1}^md_i=2m-2$ ，就能算是一个合法的度数序列。</p>
<p>所以这样子的方案数为：$\binom{m-2}{d_1-1,d_2-1,…,d_m-1}\prod{s_i^{d_i}}$ 。</p>
<p>由多元二项式定理：$(x_1+x_2+…+x_p)^k=\sum\limits_{a_1,a_2,…,a_p\ge 0,a_1+a_2+…+a_p=k}\binom{k}{a_1,a_2,…,a_p}\prod\limits_{i=1}^px_i^{a_i}$ 。</p>
<p>那么 $\sum\limits_{d_i&gt;0,d_1+…+d_m=2m-2}\binom{m-2}{d_1-1,d_2-1,…,d_m-1}\prod\limits_{i=1}^m{s_i^{d_i}}$ ，令 $e_i=d_i-1$ 可以得到：$\sum\limits_{e_i\ge 0,e_1+…+e_m=m-2}\binom{m-2}{e_1,e_2,…,e_m}\prod\limits_{i=1}^m{s_i^{e_i+1}}=n^{m-2}\prod\limits_{i=1}^ms_i$</p>
<p>证毕。</p>
</div></details></li>
</ol>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>计数</tag>
        <tag>Prüfer序列</tag>
      </tags>
  </entry>
  <entry>
    <title>Strange Keyboard</title>
    <url>/2024/02/11/Strange-Keyboard/</url>
    <content><![CDATA[<p>题目链接：Strange Keyboard</p>
<p>题目大意：$Q$ 组数据，给 $n$ 个串 $S_i$ 和一个 $K$ ，还有一个空串和目标串 $T$ ，你可以对空串依次做下面两个操作的其中一个，问最少几步变成目标串。</p>
<ol>
<li>如果串长 $\ge K$ ，就删除最后 $K$ 个字符。</li>
<li>在串尾加入 $n$ 个串的其中一个。</li>
</ol>
<p>数据范围：$Q\le 100$ ，所有数据的 $\sum |S_i|\le 10^6$ ，所有数据的 $\sum |K|\le 5000$ ，$K\le 5000$ 。</p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>循序渐进的考虑这道题目怎么做：</p>
<p>考虑一种特殊情况：$T=aaa…$ ，然后只有一个串是 $abc…$ 的结构（首字母为 $a$ ，后面全都不是 $a$ ），然后其余一堆没有 $a$ 的垃圾串，那么这显然引导我们先要解决一个同余最短路的问题，即需要至少多少次数能够消掉一个长度为 $len$ 的后缀？</p>
<p>注意到，在这个问题中，我们并不关心字符串的内容是什么，我们只关心长度，不同的长度只有至多 $O(\sqrt{\sum |S_i|})$ 种。</p>
<p>设 $f_i$ 表示需要最少多少次才能让字符串恰好有 $i$ 个字符，$f_0=0$ ，这个时候发现，跑同余最短路会超时，多个 log ，怎么办呢？</p>
<p>如果你足够聪慧，就会发现，导致出现权值从而让我们不得不跑最短路的原因是我们直接做了取余操作，事实上，我们根本没必要一次性把取余操作做完，详细的说就是：</p>
<script type="math/tex; mode=display">
\begin{align*}
    f_{i-K}&=\min(f_{i-K},f_{i}+1),i\ge K\\
    f_{i+a_j}&=\min(f_{i+a_j},f_{i}+1),i<K\\
\end{align*}</script><p>这样，权值就都是 $1$ 了，直接跑 $BFS$ 即可。</p>
<p>当然，我不够聪慧，我的解决方法是直接开值域个队列，不难证明 $f$ 的最大值不超过 $\max(S_i)+K$ 。</p>
<p>上述两种方法的时空复杂度都一样，单组数据下：</p>
<p>时间复杂度：$O(max(S_i)+K\sqrt{\sum |S_i|})$</p>
<p>空间复杂度：$O(\sum |S_i|+K)$</p>
<p>后面就简单了，考虑一个事情，假如我们现在已经填了 $T$ 的一个前缀，然后现在我们要填一个字符串，并且要删掉字符串的一个后缀，那么代价可以很方便的用 $f$ 计算。</p>
<p>设 $dp[i]$ 表示填下 $T$ 的长度为 $i$ 的前缀的最小操作次数。</p>
<p>那么 $dp[i]\to dp[j]$ 的转移就是所有前缀能对上 $T[i+1\to j]$ 的 $S$ 串的转移代价的最小值，这里有个匹配前缀的要求，显然用 Trie 就行了。</p>
<p>因此这道题目就做完了：先同余最短路算 $f$ ，然后建 $Trie$ ，最后 $dp$ 转移即可。</p>
<p>单组数据下：</p>
<p>时间复杂度：$O(26\sum S_i+K\sqrt{\sum |S_i|}+T^2)$</p>
<p>空间复杂度：$O(26\sum S_i+K+T)$</p>
<p>虽然有 $100$ 组数据，但是算一下发现这个复杂度已经足以通过此题。（注意 $S$ 是所有数据的长度总和不超过 $10^6$ ，不是单组数据的）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> LL inf=<span class="number">1e15</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e6</span>+<span class="number">5e3</span>+<span class="number">105</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M=<span class="number">5e3</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n,K;</span><br><span class="line">string ss[N];<span class="type">char</span> st[N];</span><br><span class="line"><span class="type">bool</span> v[N];<span class="type">int</span> stk[N],top;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!v[x])stk[++top]=x;</span><br><span class="line">    v[x]=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> h[N];</span><br><span class="line"><span class="function">LL <span class="title">calc</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> y=x%K;</span><br><span class="line">    <span class="keyword">if</span>(!y)<span class="keyword">return</span> x/K;</span><br><span class="line">    <span class="keyword">if</span>(!h[K-y])<span class="keyword">return</span> inf;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> h[K-y]+x/K;</span><br><span class="line">&#125;</span><br><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;</span><br><span class="line">    h[<span class="number">0</span>]=<span class="number">1</span>;q.<span class="built_in">push</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="type">int</span> x=q.<span class="built_in">front</span>();q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(x&gt;=K)&#123;</span><br><span class="line">            <span class="type">int</span> y=x-K;</span><br><span class="line">            <span class="keyword">if</span>(!h[y])&#123;</span><br><span class="line">                h[y]=h[x]+<span class="number">1</span>;</span><br><span class="line">                q.<span class="built_in">push</span>(y);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=top;i++)&#123;</span><br><span class="line">                <span class="type">int</span> y=x+stk[i];</span><br><span class="line">                <span class="keyword">if</span>(!h[y])&#123;</span><br><span class="line">                    h[y]=h[x]+<span class="number">1</span>;</span><br><span class="line">                    q.<span class="built_in">push</span>(y);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Trie</span>&#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">26</span>];LL val;</span><br><span class="line">    <span class="type">int</span>&amp; <span class="keyword">operator</span>[](<span class="type">int</span> x)&#123;<span class="keyword">return</span> a[x];&#125;</span><br><span class="line">&#125;tr[N];<span class="type">int</span> tcnt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">cl</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(tr[x].a,<span class="number">0</span>,<span class="built_in">sizeof</span>(tr[x].a));</span><br><span class="line">    tr[x].val=inf;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> mxlen=<span class="number">0</span>;</span><br><span class="line">    top=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        v[ss[i].<span class="built_in">length</span>()]=<span class="number">0</span>;</span><br><span class="line">        mxlen=<span class="built_in">max</span>(mxlen,(<span class="type">int</span>)ss[i].<span class="built_in">length</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    mxlen+=K;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(h,<span class="number">0</span>,<span class="built_in">sizeof</span>(<span class="type">int</span>)*mxlen);</span><br><span class="line"></span><br><span class="line">    tcnt=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">cl</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(string &amp;s)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> len=s.<span class="built_in">length</span>();</span><br><span class="line">    <span class="type">int</span> now=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=len;i++)&#123;</span><br><span class="line">        <span class="type">int</span> x=s[i<span class="number">-1</span>]-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span>(!tr[now][x])&#123;</span><br><span class="line">            tr[now][x]=++tcnt;</span><br><span class="line">            <span class="built_in">cl</span>(tcnt);</span><br><span class="line">        &#125;</span><br><span class="line">        now=tr[now][x];</span><br><span class="line">        tr[now].val=<span class="built_in">min</span>(tr[now].val,<span class="built_in">calc</span>(len-i));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LL dp[M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> T;<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;K);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,st+<span class="number">1</span>);</span><br><span class="line">            ss[i]=st+<span class="number">1</span>;</span><br><span class="line">            <span class="built_in">add</span>(ss[i].<span class="built_in">length</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">bfs</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="built_in">add</span>(ss[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,st+<span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> m=<span class="built_in">strlen</span>(st+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)dp[i]=inf;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">            <span class="type">int</span> now=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">                now=tr[now][st[j]-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">                <span class="keyword">if</span>(!now)<span class="keyword">break</span>;</span><br><span class="line">                dp[j]=<span class="built_in">min</span>(dp[j],dp[i]+tr[now].val+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">assert</span>(dp[m]&lt;=inf);</span><br><span class="line">        <span class="keyword">if</span>(dp[m]==inf)dp[m]=<span class="number">-1</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,dp[m]);</span><br><span class="line">        <span class="built_in">init</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></details>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>同余最短路</tag>
        <tag>BFS</tag>
        <tag>Trie</tag>
      </tags>
  </entry>
  <entry>
    <title>UR1 外星人</title>
    <url>/2023/08/22/UR1-%E5%A4%96%E6%98%9F%E4%BA%BA/</url>
    <content><![CDATA[<p>题目链接：<a href="https://uoj.ac/problem/22">https://uoj.ac/problem/22</a></p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>经典 trick 。</p>
<p>简单来说，对于 $x$ 个有标号的数字，让指定的数字站在开头的概率是多少？</p>
<p>答案：$\frac{1}{x}$ 。</p>
<p>证法：</p>
<ol>
<li>从随机性的角度考虑，第一个位置是某个数字的概率为 $\frac{1}{x}$ 。</li>
<li>从式子的角度分析：$\frac{(x-1)!}{x!}=\frac{1}{x}$ 。</li>
</ol>
<p>现在规定有 $y$ 个数字必须在某些数字前面，且对于第 $i$ 个数字，其必须在前面的数字包括其自己所构成的集合为 $S_i$ 。</p>
<p>如果满足：$S_{i}\subseteq S_{i-1}$ 。</p>
<p>那么概率的计算公式为：$\prod \frac{1}{|S_{i}|}$ 。</p>
<p>证法：</p>
<p>我们顺序考虑，假如第一个数字是 $x$ ，$S_1/x$ 的元素都要在其后面，那么为 $\frac{1}{S_1}$ ，显然剩下元素仍然是随机的，现在把 $S_1/S_2$ 的元素删掉，考虑 $S_2$ 的元素，其仍然是随机的，且不受前面影响，完全是一个子问题，那么直接乘就行了。</p>
<p>证毕。</p>
<p>这是一个很经典的概率 trick ，但是一定要谨记其的使用范围。</p>
<p>比如我稍微改变一下上面的条件，让 $S_i$ 不包含 $x$ 就已经错了。</p>
<p>例如：$1,2$ 都要在 $3$ 前面，那么：$\frac{1}{4}$ ，显然是错的。</p>
<p>为什么？原因是接下来的序列并不是一个完全的子问题，原因是：</p>
<p>例如 $13$ ，这个时候放 $2$ ，$23$ 的情况有两种：$213,123$ ，而 $32$ 的情况只有一种：$132$ ，所以并不满足不受前面影响这句话。</p>
<p>当然，也可以采用式子严谨证明：</p>
<p>显然，结果为：</p>
<p>定义 $|S_0|=n+1$ 。</p>
<p>公式为：$(\prod\limits_{i=1}^{m} C_{|S_{i-1}|-1}^{|S_i|}<em>(|S_{i-1}|-1-|S_{i}|)!)</em>\frac{(S_{m}-1)!}{S_{m}!}$ 。</p>
<p>展开可以发现就是结论中的式子。而上面的反例显然就是不满足这条计算公式，所以也就不能使用结论中的计算式进行计算。</p>
<p>利用这个 trick ，这道题目就随便做了，做法就不详写了，自己想想。</p>
<p>UPD：看了官方题解突然发现，貌似这道题目不用这个 trick 也能做，本质上是把官方题解的式子优化了一下。</p>
</div></details>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>经典trick</tag>
        <tag>dp</tag>
        <tag>概率</tag>
      </tags>
  </entry>
  <entry>
    <title>Treelection</title>
    <url>/2024/02/11/Treelection/</url>
    <content><![CDATA[<p>题目链接：<a href="https://qoj.ac/contest/1259/problem/6638">https://qoj.ac/contest/1259/problem/6638</a></p>
<p>题目大意：给一棵以 $1$ 为根的树，举办一场投票，每个人只能向祖先投票，问每个点存不存在一种情况使得这个点的得票数严格大于其他点的得票数。（根不投票）</p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>考虑一个事情，一个子树大小为 $x$ 的点可以当选，那么显然一个子树大小 $y&gt;x$ 的点也一定可以当选，但是 $y=x$ 呢？</p>
<p>显然如果子树大小为 $x$ 的点的形状不是菊花就行，如果是菊花的话就还得另外考虑。</p>
<p>于是我们就发现，答案结构应该是存在一个 $limit$ ，$siz&gt;limit$ 一定可以，$siz=limit$ 得看情况（且必要条件是子树得是个菊花），考虑怎么找这个 limit ，显然得二分，但是怎么判断 $&gt;mid$ 的子树全都可以呢？</p>
<p>观察上述结论的证明过程，发现关键在于对于一个点 $x$ ，子树大小为 $siz$ ，要求每个点的得票数 $&lt;siz-1$ 时，这个子树能内部消化自己的得票数（也就是不是菊花），也就是说，存在一种情况使得整棵树的得票数的最大值 $&lt;siz-1$ ，因此做法就出来了。</p>
<p>如果存在一个情况，使得整棵树的得票数最大值 $\le mid-1$ ，那么 $limit \le mid$ ，显然树形DP即可。</p>
<p>在找到 $limit$ 后，考虑处理 $siz=limit$ 的点，用树形 DP 跑一遍每个点的最大容量只有 $limit-2$ 的情况，显然，只有当根节点得票数为 $limit-1$ 且这个点的 $siz=limit$ 且这个点到根节点这条路径上一直存在 $dp$ 值的有效转移时，这个点才是可以当选的点，否则不符合这种情况。（显然，能符合上述要求的点，子树一定是个菊花，这也符合上面的讨论）</p>
<p>时间复杂度：$O(n\log{n})$ </p>
<p>注：代码的实现思路和上面说的略有不同。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e6</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> p[N],siz[N],n;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="built_in">memset</span>(siz+<span class="number">1</span>,<span class="number">0</span>,<span class="built_in">sizeof</span>(<span class="type">int</span>)*n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;p[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=n;i&gt;=<span class="number">1</span>;i--)&#123;</span><br><span class="line">        siz[i]+=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(i!=<span class="number">1</span>)siz[p[i]]+=siz[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> f[N];<span class="type">bool</span> v[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">check</span><span class="params">(<span class="type">int</span> U)</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(f+<span class="number">1</span>,<span class="number">0</span>,<span class="built_in">sizeof</span>(<span class="type">int</span>)*n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=n;i&gt;=<span class="number">2</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(f[i]&lt;=U)v[i]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> v[i]=<span class="number">1</span>;</span><br><span class="line">        f[p[i]]+=<span class="built_in">max</span>(f[i]-U,<span class="number">0</span>)+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f[<span class="number">1</span>]-U;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">char</span> ac[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;1\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> l=<span class="number">3</span>,r=n+<span class="number">1</span>,mid,ans;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;=r)&#123;</span><br><span class="line">        mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">check</span>(mid<span class="number">-2</span>)&lt;=<span class="number">0</span>)r=mid<span class="number">-1</span>,ans=mid;</span><br><span class="line">        <span class="keyword">else</span> l=mid+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(siz[i]&gt;=ans)ac[i]=<span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">        <span class="keyword">else</span> ac[i]=<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ac[<span class="number">1</span>]=<span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">    <span class="keyword">if</span>(ans!=<span class="number">2</span> &amp;&amp; <span class="built_in">check</span>(ans<span class="number">-3</span>)==<span class="number">1</span>)&#123;</span><br><span class="line">        v[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(v[p[i]] &amp;&amp; v[i])v[i]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> v[i]=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(v[i] &amp;&amp; siz[i]==ans<span class="number">-1</span>)ac[i]=<span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ac[n+<span class="number">1</span>]=<span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,ac+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> T;<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></details>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>二分</tag>
        <tag>树形DP</tag>
      </tags>
  </entry>
  <entry>
    <title>UR3-铀仓库</title>
    <url>/2023/08/25/UR3-%E9%93%80%E4%BB%93%E5%BA%93/</url>
    <content><![CDATA[<p>题目链接：<a href="https://uoj.ac/contest/5/problem/49">https://uoj.ac/contest/5/problem/49</a></p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>CNM，血压高了，一直卡在官方题解中的算法 2 ，根本就没有想到是二分答案，悲。</p>
<p>首先，一个十分显然的事情，这题有两种不同的二分方法：</p>
<ol>
<li>如果指定左右两边最远的到达距离，你可以在 $O(n)$ 的时间内对所有位置处理出其对应的区间，但是由于二分最远到达距离只能作用在一个数上，所以时间复杂度是： $O(n\log{n}\log_{X})$ ，也就是算法二。</li>
<li>既然答案要求箱子数，就二分箱子数 $K$ ，同理，可以在 $O(n)$ 的时间处理出对应的区间，然后算一下最小代价就行了，时间复杂度：$O(n\log{X})$ ，这就是题解的做法。</li>
</ol>
<p>为什么啊，纯二分题没有做出来，你真的是越来越菜了QAQ。</p>
<p>处理细节：考虑处理出包含 $x$ 的最长的区间，满足两个要求：</p>
<ol>
<li>区间内的箱子数和 $&lt;K$。</li>
<li>区间为这个位置搬箱子最优方案的一种。</li>
</ol>
<p>什么叫搬箱子的最优方案，显然：优先搬最近的。</p>
<p>所以每次把最近的不在区间中的位置加入区间所得到的任意一个方案都是最优方案。</p>
<p>可以证明，这个区间的左右端点会随着位置右移而非严格递增。</p>
<p>然后直接写就行了。</p>
<p>时间复杂度：$O(n\log{X})$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 510000</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line">LL a[N],fa[N],ff[N],b[N],sum,T;</span><br><span class="line">LL limit;</span><br><span class="line"><span class="type">int</span> n,left,right;</span><br><span class="line"><span class="function">LL <span class="title">dis</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;<span class="keyword">return</span> b[y]-b[x];&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve1</span><span class="params">(<span class="type">int</span> i)</span></span>&#123;<span class="keyword">while</span>(<span class="built_in">dis</span>(left,i)&gt;<span class="built_in">dis</span>(i,right) &amp;&amp; sum&gt;limit)sum-=a[left++];&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">()</span></span>&#123;</span><br><span class="line">    sum=<span class="number">0</span>;left=<span class="number">1</span>;right=<span class="number">0</span>;</span><br><span class="line">    LL mincost=T+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(right&lt;i)right++,sum+=a[right];</span><br><span class="line">        <span class="built_in">solve1</span>(i);</span><br><span class="line">        <span class="keyword">while</span>(right&lt;n &amp;&amp; (left==<span class="number">1</span> || <span class="built_in">dis</span>(left<span class="number">-1</span>,i)&gt;<span class="built_in">dis</span>(i,right+<span class="number">1</span>)) &amp;&amp; sum&lt;=limit)&#123;</span><br><span class="line">            right++,sum+=a[right];</span><br><span class="line">            <span class="built_in">solve1</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(sum&gt;limit)sum-=a[right--];</span><br><span class="line">        LL now=ff[right]-ff[i]-b[i]*(fa[right]-fa[i])+b[i]*(fa[i<span class="number">-1</span>]-fa[left<span class="number">-1</span>])-(ff[i<span class="number">-1</span>]-ff[left<span class="number">-1</span>]);</span><br><span class="line">        LL fnow=T+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(left&gt;<span class="number">1</span>)fnow=<span class="built_in">min</span>(<span class="built_in">dis</span>(left<span class="number">-1</span>,i)*(limit-sum),fnow);</span><br><span class="line">        <span class="keyword">if</span>(right&lt;n)fnow=<span class="built_in">min</span>(<span class="built_in">dis</span>(i,right+<span class="number">1</span>)*(limit-sum),fnow);</span><br><span class="line">        <span class="keyword">if</span>(left==<span class="number">1</span> &amp;&amp; right==n)fnow=<span class="number">0</span>;</span><br><span class="line">        mincost=<span class="built_in">min</span>(mincost,now+fnow);</span><br><span class="line">        <span class="comment">// printf(&quot;%d:%d %d %lld %lld %lld %lld\n&quot;,i,left,right,sum,mincost,now,fnow);</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mincost*<span class="number">2</span>&lt;=T;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// freopen(&quot;std.in&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%lld&quot;</span>,&amp;n,&amp;T);</span><br><span class="line">    LL l=<span class="number">0</span>,r=<span class="number">0</span>,ans;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;b[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;<span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;a[i]);l=<span class="built_in">max</span>(a[i],l);r+=a[i];fa[i]=fa[i<span class="number">-1</span>]+a[i];&#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)ff[i]=ff[i<span class="number">-1</span>]+b[i]*a[i];</span><br><span class="line">    <span class="comment">// printf(&quot;%lld %lld\n&quot;,l,r);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// limit=11;printf(&quot;%d\n&quot;,check());</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(l&lt;=r)&#123;</span><br><span class="line">        limit=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">check</span>())ans=limit,l=limit+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> r=limit<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></details>]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title>UR1 缩进优化</title>
    <url>/2023/08/22/UR1-%E7%BC%A9%E8%BF%9B%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<p>题目链接：<a href="https://uoj.ac/contest/3/problem/21">https://uoj.ac/contest/3/problem/21</a></p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
</div></details>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>调和级数</tag>
      </tags>
  </entry>
  <entry>
    <title>UR4-元旦三侠的游戏</title>
    <url>/2023/08/25/UR4-%E5%85%83%E6%97%A6%E4%B8%89%E4%BE%A0%E7%9A%84%E6%B8%B8%E6%88%8F/</url>
    <content><![CDATA[<p>题目链接：<a href="https://uoj.ac/problem/51">https://uoj.ac/problem/51</a></p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>这道题目主要涉及到了一个转化的问题。</p>
<p> SG 函数一般是使用在了没得走的时候为必败态，但是如果题目是走到了某个状态就输了要怎么转化呢？</p>
<p>答案是，我们认为玩家绝顶聪明，那显然不会去走那些输了的状态，也就是状态树中只会去走那些不会立即输的状态。（对应在本题中就是走后一定要 $a^b\le n$） </p>
<p>那么显然，当一个点没的走的时候，其是不是就一定输了，因为其下一步必定要走到判定为输的局面，这样我们就转化为了 $SG$ 的常见模型：没得走的状态为必败态。</p>
<p>这道题目也是同理，经过这种转化后，就是一个非常裸的 SG 函数了。</p>
<p>可以直接按题解写的做：$O(\sqrt{n}\log{n})$ ，但是感觉也存在更加优秀的做法。</p>
<p>就是观察发现状态只有 $0,1,2$ 三种，而且 $2$ 不会相邻，观察不难发现，同一个 $b$ 至多一个 $2$ ，记录一下 $2$ 的位置以及同一个 $b$ 的 SG 函数的一些参数，应该是可以做到 $O(\text{预处理}+m\log{n})$ 的时间做出来这道题目的。</p>
<p>但是感觉上就非常难写，以及有很多细节，有兴趣的读者可以自行尝试，我就不尝试了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 110000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> M 40</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n,m,a[M][N];</span><br><span class="line"><span class="type">int</span> b[M],top;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ksm</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> now=n;</span><br><span class="line">    <span class="keyword">while</span>(y)&#123;</span><br><span class="line">        <span class="keyword">if</span>(y&amp;<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(now&lt;x)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            now/=x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(y!=<span class="number">1</span> &amp;&amp; now/x&lt;x)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        x=x*x;y&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(y==<span class="number">1</span> &amp;&amp; x&gt;b[<span class="number">2</span>])<span class="keyword">return</span> (n-x)&amp;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> a[y][x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">findans</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> now=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(now==x || now==y)now++;</span><br><span class="line">    <span class="keyword">return</span> now;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// printf(&quot;%d\n&quot;,ksm(2,31));</span></span><br><span class="line"></span><br><span class="line">    b[top=<span class="number">1</span>]=n;</span><br><span class="line">    <span class="keyword">while</span>(b[top]&gt;<span class="number">1</span>)&#123;</span><br><span class="line">        b[++top]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">ksm</span>(b[top]+<span class="number">1</span>,top))b[top]++;</span><br><span class="line">    &#125;</span><br><span class="line">    top--;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=top;i&gt;=<span class="number">1</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="built_in">min</span>(b[i],b[<span class="number">2</span>]);j&gt;=<span class="number">2</span>;j--)&#123;</span><br><span class="line">            <span class="type">int</span> x=<span class="number">-1</span>,y=<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">if</span>(!(i==top || j&gt;b[i+<span class="number">1</span>]))x=a[i+<span class="number">1</span>][j];</span><br><span class="line">            <span class="keyword">if</span>(j!=b[i] &amp;&amp; !(i==<span class="number">1</span> &amp;&amp; j&gt;b[<span class="number">2</span>]))y=a[i][j+<span class="number">1</span>];</span><br><span class="line">            a[i][j]=<span class="built_in">findans</span>(x,y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// for(int i=1;i&lt;=top;i++)&#123;</span></span><br><span class="line">    <span class="comment">//     printf(&quot;%d %d: &quot;,i,b[i]);</span></span><br><span class="line">    <span class="comment">//     for(int j=2;j&lt;=b[i];j++)printf(&quot;%d &quot;,a[i][j]);</span></span><br><span class="line">    <span class="comment">//     printf(&quot;\n&quot;);</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="type">int</span> a,b;<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a,&amp;b);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">solve</span>(a,b))<span class="built_in">printf</span>(<span class="string">&quot;Yes\n&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;No\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></details>]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>博弈</tag>
        <tag>SG</tag>
        <tag>经典模型转化</tag>
      </tags>
  </entry>
  <entry>
    <title>UR4 元旦激光炮</title>
    <url>/2023/08/24/UR4-%E5%85%83%E6%97%A6%E6%BF%80%E5%85%89%E7%82%AE/</url>
    <content><![CDATA[<p>题目链接：<a href="https://uoj.ac/problem/52">https://uoj.ac/problem/52</a></p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>题解做法不难想到，每次把 $K$ 均摊到三个数组，查询三次，最小的那个数字显然一定在 $\le K$  的范围内。</p>
<p>操作次数：$n\log_{\frac{n}{n-1}}{K}$ 左右。</p>
<p>但是这个做法存在优化的空间：</p>
<ol>
<li>我们每次查询三个数组位置的和为 $K$ ，这个限制太强了，可以考虑放宽这个限制。</li>
<li>我们只利用到了最小的数字一定在 $\le K$ 的性质，没有利用到 最大的数字一定在 $\ge K$ 的性质。（但是上面那个做法每个数组查询的位置非严格单调递减，所以上面那个算法无法利用该性质进行优化。）</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;kth.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> cnt[<span class="number">3</span>],ff[<span class="number">3</span>],fucknow[<span class="number">3</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getans</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> type)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(type==<span class="number">0</span>)<span class="keyword">return</span> <span class="built_in">get_a</span>(x);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(type==<span class="number">1</span>)<span class="keyword">return</span> <span class="built_in">get_b</span>(x);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">get_c</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> lastans=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">solve1</span><span class="params">(<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(k)&#123;</span><br><span class="line">        <span class="type">int</span> pre=<span class="number">-1</span>,preval=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">2</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cnt[i]&lt;ff[i])&#123;</span><br><span class="line">                <span class="type">int</span> now=<span class="built_in">getans</span>(cnt[i],i);</span><br><span class="line">                <span class="keyword">if</span>(pre==<span class="number">-1</span> || <span class="built_in">now</span>&lt;preval)preval=now,pre=i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cnt[pre]++;k--;</span><br><span class="line">        lastans=preval;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> lastans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> id[<span class="number">10</span>];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;<span class="keyword">return</span> (ff[x]-cnt[x])&gt;(ff[y]-cnt[y]);&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">solve2</span><span class="params">(<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">2</span>;i++)id[i]=i;</span><br><span class="line">    <span class="keyword">while</span>(k&gt;<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="type">int</span> now=k;</span><br><span class="line">        <span class="built_in">sort</span>(id,id+<span class="number">3</span>,cmp);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="type">int</span> x=id[i],s=<span class="built_in">min</span>(ff[x]-cnt[x],now/(i+<span class="number">1</span>));</span><br><span class="line">            now-=s;fucknow[x]=cnt[x]+s;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> pre=<span class="number">-1</span>,preval=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">2</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cnt[i]==ff[i])<span class="keyword">continue</span>;</span><br><span class="line">            <span class="type">int</span> now=<span class="built_in">getans</span>(fucknow[i]<span class="number">-1</span>,i);</span><br><span class="line">            <span class="keyword">if</span>(pre==<span class="number">-1</span> || preval&gt;now)preval=now,pre=i;</span><br><span class="line">        &#125;</span><br><span class="line">        k-=fucknow[pre]-cnt[pre];cnt[pre]=fucknow[pre];</span><br><span class="line">        lastans=preval;</span><br><span class="line">        <span class="comment">// printf(&quot;%d\n&quot;,k);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">solve1</span>(k);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query_kth</span><span class="params">(<span class="type">int</span> n_a, <span class="type">int</span> n_b, <span class="type">int</span> n_c, <span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">    ff[<span class="number">0</span>]=n_a;ff[<span class="number">1</span>]=n_b;ff[<span class="number">2</span>]=n_c;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">solve2</span>(k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>基于二分的做法：</p>
<p>接下来阐释做法时默认数字不同，相同的情况加个浮动可以转化为不同的情况。</p>
<p>每个数组都有个 $[L,R]$ ,考虑查询每个数组的 $mid$ ，$mid$ 总和为 $sum$ ， $sum\ge sum$ ，那么最大的数字一定在 $\ge sum$ 的位置。</p>
<p>$&lt;sum$ ，那么最小的位置一定在 $&lt;sum$ 的位置。</p>
<p>然后二分就行了。</p>
<p>最后把所有 $\ge K$ 的数字拉出来跑个最小值就行了。（不用搜索次数，之前自动记录）</p>
<p>至于为什么是对的？</p>
<p>证明：</p>
<p>首先，最后每个数字都会分为两类 $&lt;K,\ge K$ ，那么显然 $\ge K$ 的数字中最小的那个就是 $=K$ 的数字，证毕。</p>
<p>注：准确来说，$\ge K$ 又分为 $\ge K$ 和 $\ge K+1$ ，同时，根据过程和定义，显然 $&lt;K$ 里面有恰好 $K-1$ 个数字。</p>
<p>操作次数：$n\log_{2}{K}$ 左右，显然，这个做法完全优于上面的做法。</p>
<p>还没有明白怎么做的可以直接看代码，很好看懂的，我讲的确实有点抽象。</p>
<p>代码来自：<a href="https://uoj.ac/submission/243331">https://uoj.ac/submission/243331</a> 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kth.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">   </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i,s,t) for(int i=(s),_t=(t);i&lt;_t;++i)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> per(i,s,t) for(int i=(t)-1,_s=(s);i&gt;=_s;--i)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> bug(x) cerr&lt;&lt;#x&lt;&lt;<span class="string">&quot; = &quot;</span>&lt;&lt;(x)&lt;&lt;<span class="string">&quot; &quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug(x) cerr&lt;&lt;#x&lt;&lt;<span class="string">&quot; = &quot;</span>&lt;&lt;(x)&lt;&lt;<span class="string">&quot;\n&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">double</span> db;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; pii;</span><br><span class="line">   </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;<span class="function"><span class="type">void</span> <span class="title">rd</span><span class="params">(T &amp;x)</span></span>&#123;</span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> f;<span class="type">static</span> <span class="type">char</span> c;</span><br><span class="line">	f=<span class="number">1</span>;x=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(c=<span class="built_in">getchar</span>(),c&lt;<span class="number">48</span>)<span class="keyword">if</span>(c==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">do</span> x=x*<span class="number">10</span>+(c&amp;<span class="number">15</span>);</span><br><span class="line">	<span class="keyword">while</span>(c=<span class="built_in">getchar</span>(),c&gt;<span class="number">47</span>);</span><br><span class="line">	x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;<span class="function"><span class="type">void</span> <span class="title">prin</span><span class="params">(T x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x&lt;<span class="number">0</span>)<span class="built_in">putchar</span>(<span class="string">&#x27;-&#x27;</span>),x=-x;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(!x)&#123;<span class="built_in">putchar</span>(<span class="string">&#x27;0&#x27;</span>);<span class="keyword">return</span> ;&#125;</span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> stk[<span class="number">100</span>],tp;</span><br><span class="line">	<span class="keyword">while</span>(x)stk[tp++]=x%<span class="number">10</span>,x/=<span class="number">10</span>;</span><br><span class="line">	<span class="keyword">while</span>(tp)<span class="built_in">putchar</span>(stk[--tp]^<span class="number">48</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;<span class="function"><span class="type">void</span> <span class="title">ptk</span><span class="params">(T x)</span></span>&#123;<span class="built_in">prin</span>(x);<span class="built_in">putchar</span>(<span class="string">&#x27; &#x27;</span>);&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;<span class="function"><span class="type">void</span> <span class="title">ptn</span><span class="params">(T x)</span></span>&#123;<span class="built_in">prin</span>(x);<span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;<span class="function"><span class="type">void</span> <span class="title">Min</span><span class="params">(T &amp;a,T b)</span></span>&#123;<span class="keyword">if</span>(b&lt;a)a=b;&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;<span class="function"><span class="type">void</span> <span class="title">Max</span><span class="params">(T &amp;a,T b)</span></span>&#123;<span class="keyword">if</span>(a&lt;b)a=b;&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=(<span class="type">int</span>)<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> A[N],B[N],C[N];</span><br><span class="line"><span class="comment">//int get_a(int x);</span></span><br><span class="line"><span class="comment">//int get_b(int x);</span></span><br><span class="line"><span class="comment">//int get_c(int x);</span></span><br><span class="line"><span class="comment">//int get_a(int x)&#123;</span></span><br><span class="line"><span class="comment">//	return 1;</span></span><br><span class="line"><span class="comment">//	</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//int get_b(int x)&#123;</span></span><br><span class="line"><span class="comment">//	return 1;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//int get_c(int x)&#123;</span></span><br><span class="line"><span class="comment">//	return 1;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Find_a</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(A[x])<span class="keyword">return</span> A[x];</span><br><span class="line">	<span class="keyword">return</span> A[x]=<span class="built_in">get_a</span>(x<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Find_b</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(B[x])<span class="keyword">return</span> B[x];</span><br><span class="line">	<span class="keyword">return</span> B[x]=<span class="built_in">get_b</span>(x<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Find_c</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(C[x])<span class="keyword">return</span> C[x];</span><br><span class="line">	<span class="keyword">return</span> C[x]=<span class="built_in">get_c</span>(x<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query_kth</span><span class="params">(<span class="type">int</span> na, <span class="type">int</span> nb, <span class="type">int</span> nc, <span class="type">int</span> K)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> L[<span class="number">3</span>]=&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,R[<span class="number">3</span>]=&#123;na,nb,nc&#125;,mid[<span class="number">3</span>],could[<span class="number">3</span>];</span><br><span class="line">	<span class="type">int</span> ans=(<span class="type">int</span>)<span class="number">1e9</span>;pii arr[<span class="number">3</span>];</span><br><span class="line">	<span class="keyword">while</span>(L[<span class="number">0</span>]&lt;=R[<span class="number">0</span>]||L[<span class="number">1</span>]&lt;=R[<span class="number">1</span>]||L[<span class="number">2</span>]&lt;=R[<span class="number">2</span>])&#123;</span><br><span class="line">		<span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">		<span class="built_in">rep</span>(i,<span class="number">0</span>,<span class="number">3</span>)&#123;</span><br><span class="line">			<span class="keyword">if</span>(L[i]&lt;=R[i])mid[i]=(L[i]+R[i])&gt;&gt;<span class="number">1</span>;</span><br><span class="line">			<span class="keyword">else</span> mid[i]=could[i];</span><br><span class="line">			sum+=mid[i];</span><br><span class="line">		&#125;</span><br><span class="line">		arr[<span class="number">0</span>]=<span class="built_in">pii</span>(<span class="built_in">Find_a</span>(mid[<span class="number">0</span>]),<span class="number">0</span>);</span><br><span class="line">		arr[<span class="number">1</span>]=<span class="built_in">pii</span>(<span class="built_in">Find_b</span>(mid[<span class="number">1</span>]),<span class="number">1</span>);</span><br><span class="line">		arr[<span class="number">2</span>]=<span class="built_in">pii</span>(<span class="built_in">Find_c</span>(mid[<span class="number">2</span>]),<span class="number">2</span>);</span><br><span class="line">		<span class="built_in">sort</span>(arr,arr+<span class="number">3</span>);</span><br><span class="line">		<span class="keyword">if</span>(sum&gt;=K)&#123;<span class="comment">//找最大的 </span></span><br><span class="line">			<span class="built_in">Min</span>(ans,arr[<span class="number">2</span>].fi);</span><br><span class="line">			<span class="built_in">per</span>(i,<span class="number">0</span>,<span class="number">3</span>)&#123;</span><br><span class="line">				<span class="keyword">if</span>(L[arr[i].se]&lt;=R[arr[i].se])&#123;</span><br><span class="line">					R[arr[i].se]=mid[arr[i].se]<span class="number">-1</span>;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;<span class="comment">//找最小的 </span></span><br><span class="line">			<span class="built_in">rep</span>(i,<span class="number">0</span>,<span class="number">3</span>)&#123;</span><br><span class="line">				<span class="keyword">if</span>(L[arr[i].se]&lt;=R[arr[i].se])&#123;</span><br><span class="line">					could[arr[i].se]=mid[arr[i].se];</span><br><span class="line">					L[arr[i].se]=mid[arr[i].se]+<span class="number">1</span>;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></details>]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>二分</tag>
        <tag>交互</tag>
      </tags>
  </entry>
  <entry>
    <title>UR5 怎样提高智商</title>
    <url>/2023/08/29/UR5-%E6%80%8E%E6%A0%B7%E6%8F%90%E9%AB%98%E6%99%BA%E5%95%86/</url>
    <content><![CDATA[<p><a href="https://uoj.ac/contest/7/problem/60">https://uoj.ac/contest/7/problem/60</a></p>
<span id="more"></span>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>非常有意思的一道题目，结论不难猜，但是非常难证。</p>
<p>首先，答案为 $4*3^{n-1}$ ，达到上界也非常的简单，搞一堆 ‘A 0 0 0 0’ 就行了。</p>
<p>时间复杂度：$O(n)$ 。</p>
<details class="toggle" ><summary class="toggle-button" style="">证明</summary><div class="toggle-content"><p>我们认为如果一道题目的四个答案都是一样的，我们称其为 SB 题。</p>
<p>假设最早出现的 SB 题在第 $i$ 道。</p>
<p>那么显然。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> LL mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    LL ans=<span class="number">4</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)ans=ans*<span class="number">3</span>%mod;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="built_in">printf</span>(<span class="string">&quot;A 0 0 0 0\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></details></div></details>]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>构造</tag>
        <tag>思维</tag>
      </tags>
  </entry>
  <entry>
    <title>WC2016 论战捆竹竿</title>
    <url>/2024/03/18/WC2016-%E8%AE%BA%E6%88%98%E6%8D%86%E7%AB%B9%E7%AB%BF/</url>
    <content><![CDATA[<p>题目链接：<a href="https://www.luogu.com.cn/problem/P4156">https://www.luogu.com.cn/problem/P4156</a></p>
<p>题目大意：每一开始你有一个字符串 $s$ ，然后你可以在字符串末尾加入 $s$ 并删除末尾一个 $s$ 的 Border ，问你最终能得到多少个不超过 $w$ 的不同长度。</p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>首先，如何计数？观察到我们只要知道对于 $\forall k\in \{0,1,…,n-1\}$ ，最小的长度 $len_k$ 满足：$len_k\equiv k\mod{n}$ 。</p>
<p>这样就能够在 $O(n)$ 的时间内计算答案了。</p>
<p>这时一个很暴力的想法是求出所有的 Border 然后做同余最短路，时间复杂度 $O(n^2)$ 。</p>
<p>这个时候就要利用 Border 的性质做一些优化了，Border 有一个性质：能够把所有 Border 划分成恰好 $\log$ 段等差数列。</p>
<p>不妨将长度设为 $l,l+d,l+2d,…,l+(s-1)d$ 。</p>
<p>这时候还要观察到一个事情：如果把这个问题想象成背包，这个背包的体积和价值是一样的，这能够产生一个什么性质呢？不妨认为 $len_k\equiv t\mod{l}$ ，我们只要先在$\mod{l}$ 意义下跑出最小的 $len’_t$ ，然后再用 $len’_t$ 去更新 $len_k$ 即可。</p>
<p>前一部分可以用单调队列，后一部分连单调队列都不用。</p>
<p>时间复杂度：$O(Tn\log{n})$ 。</p>
<p>空间复杂度：$O(n)$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">5e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> NN=<span class="number">1e6</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> LL inf=<span class="number">1e18</span>+<span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;<span class="keyword">return</span> !x?y:<span class="built_in">gcd</span>(y%x,x);&#125;</span><br><span class="line"><span class="type">int</span> fail[N],n;LL m,dp[N],tmp[N];</span><br><span class="line"><span class="type">char</span> st[N];</span><br><span class="line">PII lis[NN];</span><br><span class="line"><span class="type">int</span> head,tail;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> s,<span class="type">int</span> d)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;l;i++)tmp[i]=inf+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)tmp[dp[i]%l]=<span class="built_in">min</span>(tmp[dp[i]%l],dp[i]);</span><br><span class="line">    <span class="type">int</span> g=<span class="built_in">gcd</span>(l,d);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;g;i++)&#123;</span><br><span class="line">        head=<span class="number">1</span>;tail=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> now=i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> lim=l/g*<span class="number">2</span>,ti=<span class="number">0</span>;lim;lim--,ti++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(head&lt;=tail &amp;&amp; ti-lis[head].second+<span class="number">1</span>&gt;s)head++;</span><br><span class="line">            <span class="keyword">if</span>(head&lt;=tail)tmp[now]=<span class="built_in">min</span>(tmp[now],tmp[lis[head].first]+<span class="number">1ll</span>*(ti-lis[head].second)*d+l);</span><br><span class="line">            <span class="keyword">while</span>(head&lt;=tail &amp;&amp; tmp[lis[tail].first]+(ti-lis[tail].second)*d&gt;tmp[now])tail--;</span><br><span class="line">            lis[++tail]=&#123;now,ti&#125;;</span><br><span class="line">            now=(now+d)%l;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;l;i++)&#123;</span><br><span class="line">        dp[tmp[i]%n]=<span class="built_in">min</span>(dp[tmp[i]%n],tmp[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    g=<span class="built_in">gcd</span>(l,n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;g;i++)&#123;</span><br><span class="line">        <span class="type">int</span> now=i;LL mi=inf;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> lim=n/g*<span class="number">2</span>;lim;lim--)&#123;</span><br><span class="line">            dp[now]=<span class="built_in">min</span>(dp[now],mi);</span><br><span class="line">            mi=<span class="built_in">min</span>(mi,dp[now])+l;</span><br><span class="line">            now=(now+l)%n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> T;<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%lld&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,st+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(m&lt;n)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;0\n&quot;</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        m-=n;</span><br><span class="line">        fail[<span class="number">0</span>]=<span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> now=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(now!=<span class="number">-1</span> &amp;&amp; st[now+<span class="number">1</span>]!=st[i])now=fail[now];</span><br><span class="line">            fail[i]=++now;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)dp[i]=inf+<span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        now=fail[n];</span><br><span class="line">        <span class="keyword">while</span>(now)&#123;</span><br><span class="line">            <span class="type">int</span> nex=fail[now];</span><br><span class="line">            <span class="keyword">if</span>(nex+nex&lt;now)<span class="built_in">solve</span>(n-now,<span class="number">1</span>,<span class="number">1</span>),now=nex;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="type">int</span> p=now-nex;</span><br><span class="line">                <span class="type">int</span> l=now%p+p;</span><br><span class="line">                <span class="built_in">solve</span>(n-now,(now-l)/p+<span class="number">1</span>,p);</span><br><span class="line">                now=l;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        LL ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dp[i]&lt;=m)ans+=(m-dp[i])/n+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我没做出来，我的评价是：菜就多练。</p>
<p>训，狠狠地训。</p>
</div></details>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>Border</tag>
        <tag>同余最短路</tag>
        <tag>单调队列</tag>
      </tags>
  </entry>
  <entry>
    <title>ZJOI2017 字符串</title>
    <url>/2024/02/18/ZJOI2017-%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<p>题目链接：<a href="https://loj.ac/p/2572">https://loj.ac/p/2572</a></p>
<p>题目大意：</p>
<p>一个长度为 $n$ ，字符集大小为 $10^9$ 的字符串，要求完成 $m$ 次操作。</p>
<p>两种操作：</p>
<ol>
<li>区间 $+d$ ，$d$ 可以为负。</li>
<li>求区间的字典序最小的后缀。</li>
</ol>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>太唐了，都已经知道了 Significant Suffixes 都还不会，感觉自从高三回归课内搞了一年后，我信息学的许多基本功都下降了好多，悲。</p>
<p>首先，一个显然的事情，我们得先处理子串比较的问题，这个显然可以 二分+线段树+Hash 解决，时间复杂度：$O(n\log^2{n})$ 。（修改复杂度：$O(n\log{n})$）</p>
<p>其次，我们可以在线段树上维护每个区间的 Significant Suffixes 的集合，但是问题是怎么求 Significant Suffixes？</p>
<p>其实压根没有必要保证集合里面都是 Significant Suffixes，只需要保证 Significant Suffixes 一定在集合里面就行了，同时保证集合大小在 $O(\log)$ 即可。（当确定一个东西是什么十分困难时，不妨尝试确定一个东西不是什么）</p>
<p>根据 Significant Suffixes 的相关证明以及线段树的性质，不难发现，线段树上合并节点时，左节点只会贡献一个可能是 Significant Suffixes 的后缀。</p>
<p>而找到这个后缀的方法就是：在左节点的集合中找一种奇怪字典序最小的后缀，这种字典序最小是认为空字符大于所有字符，即如果 $A$ 是 $B$ 的真前缀且 $A$，则 $B&lt;A$ 。</p>
<p>但是可以发现，一次修改的时间复杂度高达：$O(\log^4)$ ，但如果你足够聪慧，你可以发现，Hash 修改的时间开销很小，但是查询的时间开销很大，所以我们希望牺牲一下修改复杂度，从而降低查询复杂度，不难想到分块，分块+Hash 修改复杂度 $O(\sqrt{n})$ ，查询复杂度 $O(1)$ ，这样修改的最终复杂度就能优化到：$O(\log^3{n}+\sqrt{n})$ 。</p>
<p>那查询咋整，如果和修改一样合并节点，就没法保证左右节点长度几乎相等的性质，那个做法就不能用了，虽然也能补救，就是从右往左合并，如果左边的长度大于右边的长度+1，那么就把左边那个节点变成这个节点的左儿子和又儿子再进行合并，显然这样的时间复杂度是 $O(\log^3)$ 的，但是比较麻烦，有没有简单点的方法。</p>
<p>变换思路，不合并了，反正就 $O(\log)$ 个节点，则集合的并的大小也就 $O(\log^2)$ 大小，直接比较大小就行了，时间复杂度：$O(\log^3)$ 。</p>
<p>所以，最终复杂度就出来：$O(n\log^2{n}+m(\sqrt{n}+\log^3{n}))$</p>
<p>空间复杂度：$O(n\log{n})$ </p>
<p>什么时候我能自己独立做出来一道这么牛逼的字符串题啊。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;LL,<span class="type">int</span>&gt; PLI;</span><br><span class="line"><span class="type">const</span> LL mod=<span class="number">2000000239</span>;</span><br><span class="line"><span class="type">const</span> LL A=<span class="number">2000000137</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> NN=<span class="number">4e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> B=<span class="number">950</span>;</span><br><span class="line"><span class="type">int</span> n,q;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getz</span><span class="params">(<span class="type">int</span> &amp;x)</span></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">int</span> f=<span class="number">1</span>;<span class="type">char</span> c=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(c&gt;<span class="string">&#x27;9&#x27;</span> || c&lt;<span class="string">&#x27;0&#x27;</span>)c==<span class="string">&#x27;-&#x27;</span>?f=<span class="number">-1</span>:<span class="number">1</span>,c=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(c&lt;=<span class="string">&#x27;9&#x27;</span> &amp;&amp; c&gt;=<span class="string">&#x27;0&#x27;</span>)x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+c-<span class="string">&#x27;0&#x27;</span>,c=<span class="built_in">getchar</span>();</span><br><span class="line">    x=x*f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">mt</span><span class="params">(LL x)</span></span>&#123;<span class="keyword">return</span> x&gt;=mod?x-mod:(x&lt;<span class="number">0</span>?x+mod:x);&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Hash</span>&#123;</span><br><span class="line">    LL fb[N],ff[N];</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">        fb[<span class="number">0</span>]=<span class="number">1</span>;fb[<span class="number">1</span>]=A;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)fb[i]=fb[i<span class="number">-1</span>]*A%mod;</span><br><span class="line">        ff[<span class="number">0</span>]=<span class="number">1</span>;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)ff[i]=<span class="built_in">mt</span>(ff[i<span class="number">-1</span>]+fb[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;has;</span><br><span class="line">PLI <span class="keyword">operator</span>+(PLI x,PLI y)&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;(x.first*has.fb[y.second]+y.first)%mod,x.second+y.second&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> bel[N],lazy[N],ll[N],rr[N],val[N];</span><br><span class="line">PLI fl[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">maintain</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=ll[x];i&lt;=rr[x];i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i==ll[x])fl[i]=PLI&#123;val[i],<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">else</span> fl[i]=fl[i<span class="number">-1</span>]+PLI&#123;val[i],<span class="number">1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">change</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> d)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=ll[x];i&lt;=rr[x];i++)&#123;</span><br><span class="line">        val[i]+=lazy[x];</span><br><span class="line">        <span class="keyword">if</span>(i&gt;=l &amp;&amp; i&lt;=r)val[i]+=d;</span><br><span class="line">    &#125;</span><br><span class="line">    lazy[x]=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">maintain</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">change</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> d)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(bel[l]==bel[r])<span class="built_in">change</span>(bel[l],l,r,d);</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">change</span>(bel[l],l,r,d);</span><br><span class="line">        <span class="built_in">change</span>(bel[r],l,r,d);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=bel[l]+<span class="number">1</span>;i&lt;bel[r];i++)lazy[i]+=d;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">PLI <span class="title">queryhash_nl</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l==ll[bel[l]])<span class="keyword">return</span> fl[r];</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> &#123;<span class="built_in">mt</span>(fl[r].first-fl[l<span class="number">-1</span>].first*has.fb[ r-l+<span class="number">1</span> ]%mod),r-l+<span class="number">1</span>&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">PLI <span class="title">hashplus</span><span class="params">(PLI x,LL d)</span></span>&#123;<span class="keyword">return</span> &#123;<span class="built_in">mt</span>(x.first+has.ff[x.second<span class="number">-1</span>]*d%mod),x.second&#125;;&#125;<span class="comment">/*x+dval*/</span></span><br><span class="line"><span class="function">PLI <span class="title">queryhash_l</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;<span class="keyword">return</span> <span class="built_in">hashplus</span>(<span class="built_in">queryhash_nl</span>(l,r),lazy[bel[l]]);&#125;</span><br><span class="line"><span class="function">PLI <span class="title">queryhas</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    PLI ans=&#123;<span class="number">0ll</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=bel[l];i&lt;=bel[r];i++)&#123;</span><br><span class="line">        ans=ans+<span class="built_in">queryhash_l</span>(<span class="built_in">max</span>(l,ll[i]),<span class="built_in">min</span>(rr[i],r));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> lim,<span class="type">int</span> typ=<span class="number">0</span>)</span></span>&#123;<span class="comment">//return x&lt;y</span></span><br><span class="line">    <span class="type">int</span> l=<span class="number">1</span>,r=lim-<span class="built_in">max</span>(x,y)+<span class="number">1</span>,mid,ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;=r)&#123;</span><br><span class="line">        mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">queryhas</span>(x,x+mid<span class="number">-1</span>)!=<span class="built_in">queryhas</span>(y,y+mid<span class="number">-1</span>))r=mid<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">else</span> l=mid+<span class="number">1</span>,ans=mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(ans==lim-<span class="built_in">max</span>(x,y)+<span class="number">1</span>)<span class="keyword">return</span> typ?x&lt;y:x&gt;y;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> val[x+ans]+lazy[bel[x+ans]]&lt;val[y+ans]+lazy[bel[y+ans]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Segment</span>&#123;</span><br><span class="line">    <span class="type">int</span> lc,rc;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; sign;</span><br><span class="line">&#125;tr[NN];<span class="type">int</span> cnt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">updata</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="comment">// tr[x].sign.clear();</span></span><br><span class="line">    tr[x].sign=tr[tr[x].rc].sign;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> y:tr[tr[x].lc].sign)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!ans || <span class="built_in">cmp</span>(y,ans,r,<span class="number">1</span>))ans=y;</span><br><span class="line">    &#125;</span><br><span class="line">    tr[x].sign.<span class="built_in">push_back</span>(ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bt</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> x=++cnt;</span><br><span class="line">    <span class="keyword">if</span>(l==r)tr[x].sign.<span class="built_in">push_back</span>(l);</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        tr[x].lc=<span class="built_in">bt</span>(l,mid);</span><br><span class="line">        tr[x].rc=<span class="built_in">bt</span>(mid+<span class="number">1</span>,r);</span><br><span class="line">        <span class="built_in">updata</span>(x,r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">change</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> ll,<span class="type">int</span> rr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ll&gt;rr || rr&lt;l || ll&gt;r || (l&gt;=ll &amp;&amp; r&lt;=rr))<span class="keyword">return</span> ;</span><br><span class="line">    <span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">change</span>(tr[x].lc,l,mid,ll,rr);</span><br><span class="line">    <span class="built_in">change</span>(tr[x].rc,mid+<span class="number">1</span>,r,ll,rr);</span><br><span class="line">    <span class="built_in">updata</span>(x,r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> zans;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">query</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> ll,<span class="type">int</span> rr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ll&gt;rr || rr&lt;l || ll&gt;r)<span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">if</span>(l&gt;=ll &amp;&amp; r&lt;=rr)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> y:tr[x].sign)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!zans || <span class="built_in">cmp</span>(y,zans,rr))zans=y;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">query</span>(tr[x].lc,l,mid,ll,rr);</span><br><span class="line">    <span class="built_in">query</span>(tr[x].rc,mid+<span class="number">1</span>,r,ll,rr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">getz</span>(n);<span class="built_in">getz</span>(q);</span><br><span class="line">    has.<span class="built_in">init</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">getz</span>(val[i]);</span><br><span class="line">        val[i]+=<span class="number">1000000001</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        bel[i]=i/B+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(!ll[bel[i]])ll[bel[i]]=i;</span><br><span class="line">        rr[bel[i]]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=bel[n];i++)<span class="built_in">maintain</span>(i);</span><br><span class="line">    <span class="built_in">bt</span>(<span class="number">1</span>,n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=q;i++)&#123;</span><br><span class="line">        <span class="type">int</span> typ;<span class="built_in">getz</span>(typ);</span><br><span class="line">        <span class="keyword">if</span>(typ==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="type">int</span> l,r,d;<span class="built_in">getz</span>(l);<span class="built_in">getz</span>(r);<span class="built_in">getz</span>(d);</span><br><span class="line">            <span class="built_in">change</span>(l,r,d);</span><br><span class="line">            <span class="built_in">change</span>(<span class="number">1</span>,<span class="number">1</span>,n,l,r);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="type">int</span> l,r;<span class="built_in">getz</span>(l);<span class="built_in">getz</span>(r);</span><br><span class="line">            zans=<span class="number">0</span>;</span><br><span class="line">            <span class="built_in">query</span>(<span class="number">1</span>,<span class="number">1</span>,n,l,r);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,zans);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个题目有点卡常，这里说一下我是怎么卡常的：</p>
<ol>
<li>模数等量改成常数，同时将一些取模改成判断和加减的组合。</li>
<li>调调块长，在 $2\sqrt{n}$ 左右会快很多。</li>
<li>加快读。</li>
</ol>
</div></details>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>数据结构</tag>
        <tag>Hash</tag>
        <tag>分块</tag>
        <tag>线段树</tag>
        <tag>Significant Suffixes</tag>
      </tags>
  </entry>
  <entry>
    <title>tag说明</title>
    <url>/2023/09/04/tag%E8%AF%B4%E6%98%8E/</url>
    <content><![CDATA[<p>帮助更好的使用本网站的 tag 找到你想找到的内容。</p>
<details class="toggle" ><summary class="toggle-button" style="">字典序</summary><div class="toggle-content"><p>这里你会看到各种处理题目中最小字典序要求的做法，例如 DP 题要求最小字典序，字符串要求最小字典序等等。</p>
</div></details>
<details class="toggle" ><summary class="toggle-button" style="">存在性构造</summary><div class="toggle-content"><p>判断一种情况是否存在，如果存在，给出其中一种构造。</p>
</div></details>]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>ACM杂类</tag>
      </tags>
  </entry>
  <entry>
    <title>lzqy_ の Strings Round 赛后总结</title>
    <url>/2024/03/21/lzqy-%E3%81%AE-Strings-Round-%E8%B5%9B%E5%90%8E%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="A-好奇心宝宝"><a href="#A-好奇心宝宝" class="headerlink" title="A 好奇心宝宝"></a>A 好奇心宝宝</h1><p><a href="https://www.luogu.com.cn/problem/P10270?contestId=155684">https://www.luogu.com.cn/problem/P10270?contestId=155684</a></p>
<p>题目大意：给一个网格，求两条从左上到右下的路径满足最长公共前缀最短，输出最短公共前缀长度。</p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>显然等价于找 $\{(x,y)|x+y=t\}$ 中最小的 $t$ 满足这个集合中的点的字符集大小 $&gt;1$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e3</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">char</span> st[N][N];</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,st[i]+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n<span class="number">-1</span>+m<span class="number">-1</span>;i++)&#123;</span><br><span class="line">        <span class="type">int</span> pre=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> x=<span class="number">1</span>;x&lt;=i+<span class="number">1</span>;x++)&#123;</span><br><span class="line">            <span class="type">int</span> y=i-(x<span class="number">-1</span>)+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(x&gt;=<span class="number">1</span> &amp;&amp; y&gt;=<span class="number">1</span> &amp;&amp; x&lt;=n &amp;&amp; y&lt;=m)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!pre)pre=st[x][y];</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(pre!=st[x][y])&#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,i);</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,n+m<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></details>
<h1 id="B-漫长悄悄话"><a href="#B-漫长悄悄话" class="headerlink" title="B 漫长悄悄话"></a>B 漫长悄悄话</h1><p><a href="https://www.luogu.com.cn/problem/P10270?contestId=155684">https://www.luogu.com.cn/problem/P10270?contestId=155684</a></p>
<p>题目大意：对于 $i,j$ ，贡献为 $i,j$ 前缀的翻转和后缀的 $LCP$ （四个串的 LCP ），求最大贡献。</p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>等价于找最长的奇数长度回文串满足出现了至少两次。</p>
<p>接下来各显神通了，可以马拉车+Hash，可以回文自动机，也可以Hash+二分。</p>
<p>我用了回文自动机。</p>
<p>Hash+二分的做法详见官方题解：<a href="https://www.luogu.com/article/sfxeve97。（需要用到本质不同的回文串只有至多">https://www.luogu.com/article/sfxeve97。（需要用到本质不同的回文串只有至多</a> $n$ 个的性质）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e3</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">char</span> st[N][N];</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,st[i]+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n<span class="number">-1</span>+m<span class="number">-1</span>;i++)&#123;</span><br><span class="line">        <span class="type">int</span> pre=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> x=<span class="number">1</span>;x&lt;=i+<span class="number">1</span>;x++)&#123;</span><br><span class="line">            <span class="type">int</span> y=i-(x<span class="number">-1</span>)+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(x&gt;=<span class="number">1</span> &amp;&amp; y&gt;=<span class="number">1</span> &amp;&amp; x&lt;=n &amp;&amp; y&lt;=m)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!pre)pre=st[x][y];</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(pre!=st[x][y])&#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,i);</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,n+m<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></details>
<h1 id="C-在四方城外"><a href="#C-在四方城外" class="headerlink" title="C 在四方城外"></a>C 在四方城外</h1><p><a href="https://www.luogu.com.cn/problem/P10272?contestId=155684">https://www.luogu.com.cn/problem/P10272?contestId=155684</a></p>
<p>题目大意：每次操作在 $S$ 后面添加 $S$ 的 mxBd ，求第 $L$ 次操作和第 $R$ 次操作之间所有操作后的字符串长度之和。</p>
<details class="toggle" ><summary class="toggle-button" style="">我的做法</summary><div class="toggle-content"><p>引理 1 ：若 $ST=TS$ ，则 $S,T$ 有相同的整周期。</p>
<p><details class="toggle" ><summary class="toggle-button" style="">情况1：无Bd</summary><div class="toggle-content"><p>若原串的 $mxBd=0$ ，则答案为 $|S|*(r-l+1)$ 。</p>
</div></details></p>
<p><details class="toggle" ><summary class="toggle-button" style="">情况2：有整周期</summary><div class="toggle-content"><p>若原串有最小整周期 $p$ ，那么每次添加的长度必然是：$|S|-p$ ，否则一定会出现下面的情况：</p></p>
<p><p><img src="1.png" alt=""></p></p>
<p><p>那么根据引理，原串存在更小的整周期，矛盾，证毕。</p><br>&lt;/div&gt;&lt;/details&gt;</p>
<p><details class="toggle" ><summary class="toggle-button" style="">情况3：无整周期但有Bd</summary><div class="toggle-content"><p>这里给一些例子：abababababcab 、aaaaaaaba 。</p></p>
<p><p>为了方便下面叙述，我们设 $S_m$ 表示第 $m$ 操作后的字符串，$S_0=S$ ，然后设 $T_m=S_m-S,T_m’=(mxBd(S)+T_m)$ ，字符串 $S-T$ 定义为 $S$ 删去 $LCP(S,T)$ 。</p></p>
<p><p>显然，$|T_{m+1}|-|T_{m}|=|T’_{m+1}|-|T’_{m}|$ ，$|T_{m+1}|-|T_{m}|\le |T_{m+2}|-|T_{m+1}|$ </p></p>
<p><p>接下来先说结论，整个增长过程可以分成两个部分，先是 $|T’_{m+1}|=2|T’_m|$ ，然后 $|T_{m+1}|-|T_m|$ 恒定。</p></p>
<p><p>定理 1 ：$|mxBd(T_{m})|\le |T’_{m}|$ 。（显然，归纳一下就行了）</p></p>
<p><p>因此，$|T’_{m+1}|\le 2|T’_m|$ 。</p></p>
<p><p>定理 2 ： $|T’_{m+1}|&lt;2|T’_m|$ 时，则后面 $|T_{m+1}|-|T_m|$ 恒定。</p></p>
<p><p><details class="toggle" ><summary class="toggle-button" style="">证明</summary><div class="toggle-content"><p>设 $U=mxBd(T’_{0})$ 。</p>&lt;/p&gt;</p>
<p><p>$T_{m}-T_{m-1},T_{m+1}-T_m$ 是 $S$ 的一个 Bd ，显然 $T_{m}-T_{m-1}$ 是 $T_{m+1}-T_m$ 的一个 Bd 。可以得到 $T’_{0}$ 是 $T_{m+1}-T_m$ 的一个 Bd 。</p></p>
<p><p>根据引理 $1$ 可以得到 $U$ 是 $T_{m+1}-T_{m}$ 的最小整周期。</p></p>
<p><p>这个时候，可以把 $T’_{m+1},T’_{m}$ 等字符串想象成若干 $U$ 的拼接，显然 $U$ 也是 $T’_{m+1}$ 等字符串的最小整周期，否则最小整周期也是 $U$ 的整周期，与前面矛盾。</p></p>
<p><p><img src="3.png" alt=""></p></p>
<p><p>则 $|T’_{m+1}|&lt;2|T’_m|$ ，就已经说明了 $S_{m}$ 前面只有 $\frac{|T’_{m+1}|}{|U|}$ 个 $U$ ，没有 $\frac{|T’_{m+1}|}{|U|}+1$ 个 $U$ ，若 $|T_{m+2}|-|T_{m-1}|&gt;|T_{m+2}|-|T_{m-1}|$ ，则与 $U$ 的个数矛盾，证毕。</p><br>&lt;/div&gt;&lt;/details&gt;</p>
<p><p>定理 3 ：若 $|T’_{m+1}|=2|T’_m|$ ，那么 $|T_{m+1}|-|T_{m}|&lt;|S|$。</p></p>
<p><details class="toggle" ><summary class="toggle-button" style="">证明</summary><div class="toggle-content"><p>反证法，若 $\ge n$ 。</p></p>
<p><p>显然 $T’_{0}$ 是 $T_{m+1}-T_{m}$ 的一个周期，即 $S_{m}$ 一个 $\ge n$ 的 Bd 的周期是 $T’_{0}$ ，注意到 $T’_{0}$ 也出现在 $S$ 的末尾，根据引理 $1$ 知道 $S$ 有整周期，矛盾，证毕。</p><br>&lt;/div&gt;&lt;/details&gt;</p>
<p><p>推论： $m=\left \lfloor \log_2{|S|} \right \rfloor+1$ ，则一定有 $|T’_{m+1}|&lt;2|T’_m|$ 。</p></p>
<p><p>于是就有很多种搞法了。</p></p>
<p><p>我的方法是直接 Kmp ，注意到长度 $\le 3n$ ，所以时间复杂度为：$O(n\log{n})$ ，空间复杂度为 : $O(n)$ 。</p></p>
<p><p>当然，根据上面的证明，有更加快速的搞法：求出 $U$ ，然后从左到右找至多有多少个 $U$ ，这样就可以在 $O(n)$ 的时间解决这个问题了。</p>&lt;/div&gt;&lt;/details&gt;</p>
<p><p>注意：上面的时间复杂度都忽略了快速幂计算答案的时间。</p></p>
<p><p>综上，时间复杂度为：$O(n\log{n}+\log{R})$ ，空间复杂度：$O(n)$。</p></p>
<p><p>当然，时间复杂度可以优化到：$O(n+\log{R})$ 。</p><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> LL mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e6</span>+<span class="number">5</span>;</span><br><span class="line"><span class="function">LL <span class="title">ksm</span><span class="params">(LL x,LL y)</span></span>&#123;</span><br><span class="line">    LL ans=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(y)&#123;</span><br><span class="line">        <span class="keyword">if</span>(y&amp;<span class="number">1</span>)ans=ans*x%mod;</span><br><span class="line">        x=x*x%mod;y&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">char</span> st[N*<span class="number">3</span>];</span><br><span class="line"><span class="type">int</span> fail[N*<span class="number">3</span>],n;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">gp</span><span class="params">(<span class="type">int</span> len)</span></span>&#123;</span><br><span class="line">    fail[<span class="number">0</span>]=<span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> now=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=len;i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(now!=<span class="number">-1</span> &amp;&amp; st[now+<span class="number">1</span>]!=st[i])now=fail[now];</span><br><span class="line">        fail[i]=++now;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fail[len];</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> len[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,st+<span class="number">1</span>);n=<span class="built_in">strlen</span>(st+<span class="number">1</span>);</span><br><span class="line">    <span class="type">int</span> d=<span class="built_in">gp</span>(n),p=n-d;</span><br><span class="line">    <span class="keyword">if</span>(!d)&#123;</span><br><span class="line">        LL l,r;<span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>,&amp;l,&amp;r);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,(r-l+<span class="number">1</span>)*n%mod);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n%p==<span class="number">0</span>)&#123;</span><br><span class="line">        LL l,r;<span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>,&amp;l,&amp;r);</span><br><span class="line">        LL ans=<span class="built_in">ksm</span>(<span class="number">2</span>,l)*(<span class="built_in">ksm</span>(<span class="number">2</span>,r-l+<span class="number">1</span>)<span class="number">-1</span>+mod)%mod*(n-p)%mod;</span><br><span class="line">        ans=(ans+p*(r-l+<span class="number">1</span>))%mod;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> pred,m=<span class="number">0</span>;</span><br><span class="line">    len[m]=n;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        m++;</span><br><span class="line">        len[m]=len[m<span class="number">-1</span>];</span><br><span class="line">        <span class="built_in">assert</span>(len[m]+d&lt;=n*<span class="number">3</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=d;i++)st[++len[m]]=st[i];</span><br><span class="line">        pred=d;</span><br><span class="line">        d=<span class="built_in">gp</span>(len[m]);</span><br><span class="line">        p=len[m]-d;</span><br><span class="line">    &#125;<span class="keyword">while</span>(d==pred*<span class="number">2</span>);</span><br><span class="line">    <span class="comment">//d is key;</span></span><br><span class="line">    LL l,r;<span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>,&amp;l,&amp;r);</span><br><span class="line">    LL ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=l;i&lt;=m &amp;&amp; i&lt;=r;i++)ans=(ans+len[i])%mod;</span><br><span class="line">    <span class="keyword">if</span>(m&lt;r)&#123;</span><br><span class="line">        l=<span class="built_in">max</span>(l-m,<span class="number">1ll</span>);</span><br><span class="line">        r-=m;</span><br><span class="line">        ans=(ans+len[m]*(r-l+<span class="number">1</span>))%mod;</span><br><span class="line">        ans=(ans+(r+l)*(r-l+<span class="number">1</span>)/<span class="number">2</span>%mod*d)%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</div></details>
<details class="toggle" ><summary class="toggle-button" style="">官方做法</summary><div class="toggle-content"></div></details>]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title>一句话题解.md</title>
    <url>/2023/08/22/%E4%B8%80%E5%8F%A5%E8%AF%9D%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<ol>
<li>UR 2 猪猪侠再战括号序列：<a href="https://uoj.ac/problem/31">https://uoj.ac/problem/31</a> 。</li>
<li>UR 3 核聚变反应强度：<a href="https://uoj.ac/problem/48">https://uoj.ac/problem/48</a> 。做法：把 $a_1$ 所有质因数找出来判一下就行了，时间复杂度：$O(n\log{V}+\sqrt{V})$ 。</li>
<li>ECNU 2023.8 A Extra Large Knapsack：<a href="https://acm.ecnu.edu.cn/contest/695/problem/A/">https://acm.ecnu.edu.cn/contest/695/problem/A/</a> 显然所有数字的异或和必须为 $0$ ，然后随便拉出一个数字出来就行了，记得特判 $n=1$ 的情况。</li>
<li>UR 8 赴京赶考：<a href="https://uoj.ac/problem/118">https://uoj.ac/problem/118</a> ，想想网格图长成啥样就知道怎么做了，时间复杂度：$O(n+m+q)$ 。</li>
</ol>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>杂题</tag>
      </tags>
  </entry>
  <entry>
    <title>博客食用指北</title>
    <url>/2024/01/19/%E5%8D%9A%E5%AE%A2%E9%A3%9F%E7%94%A8%E6%8C%87%E5%8C%97/</url>
    <content><![CDATA[<p>我写博客有以下目的：</p>
<ol>
<li><strong>帮助我重新梳理一遍做法。</strong>（必要）（我自己写过的博客一般是不会自己再看一遍的，所以复习作用很小，更多的作用是帮助梳理）</li>
<li><strong>锻炼自己用简短语言描述做法的能力。</strong>（重要）（打ACM被队友吐槽表达能力不行，而且能简洁说明的事情为啥要长篇大论，还能节省写博客的时间）</li>
<li><strong>用更加标准公式化的方式描述做法，比如把某个题的做法和其他题目联系起来，总结成一类做法。</strong>（重要）（有助于能力提升）</li>
<li><strong>尝试扩展题目以及做法，学习更多的做法。</strong>（适当）（因为有些做法和题目就是没法扩展的，强行扩展可能浪费时间，但收益还行，学习做法这个事情也是两面的，有点显然，缺点是浪费时间，很多时候某些复杂做法其实就是简单做法的同构，但是需要等到看了很久才能发现这一点，这就会浪费很多时间，尤其是数据结构题）</li>
<li><strong>让读者看懂。</strong>（最次）（我的博客首先肯定是基于我自己再看一遍能懂的，所以肯定阅读门槛就是我自己的水平，或者比自己再弱一点的水平，如果你不能看懂请移步别人的博客。因为我写博客的初衷就是为了自己的提升，当作自己的笔记本用的，而不是造福广大OIer的。当然，如果几乎大部分人都看不懂的话我就有必要反思自己的语言表达能力了）</li>
</ol>
<p>至于第5条，对我自己最重要的警告就是，写博客要明白什么东西是要写的，什么东西是不用写的（我一定懂的），深刻明白这一点能够节省我很多时间，最大化博客对我的作用。（毕竟我之前经常放弃写博客的原因就是浪费时间，而且我写博客一贯的作风就是冗杂，对读者对我都不好，这点一定要改）</p>
<p>一个经典的例子是：一个题目有很多证明，不需要什么证明都写，写一两个个人认为最优美的证明就行了。不否认每个证明都有其自己的价值，但实际上有很多证明我自己心里也清楚，我绝对不会再想看他第二次了，感觉不如 ** 证明。（有很多做法的情况也是同理）</p>
<p>至于反思总结的工作，我会自己在本地机子上用excel编写，写在博客上一来我自己不会看，而且多篇博客的形式很不方便重新浏览这些总结，二来这些极具个人色彩的东西放在博客里也十分影响观感，而写在excel上清晰明了，方便反复查看，作用最大化。</p>
<p>比较简单的题目不会写博客，有时候可能会提一嘴。</p>
<h1 id="暂未解决"><a href="#暂未解决" class="headerlink" title="暂未解决"></a>暂未解决</h1><p>按照如下步骤进行：</p>
<ol>
<li>在文章的小标题（不是文章标题）中使用“坑”的标记。（结合第二条方便定位在文章中的位置）</li>
<li>在博客“待解决”中加入需要解决的事宜。（方便定位）</li>
<li>在本地机子的计划中写上期望解决的日期，到达这个日期就就将这个“坑”的解决提上日程。</li>
</ol>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>ACM杂类</tag>
      </tags>
  </entry>
  <entry>
    <title>卡常的辅助方法</title>
    <url>/2024/02/20/%E5%8D%A1%E5%B8%B8%E7%9A%84%E8%BE%85%E5%8A%A9%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<ol>
<li><p>使用能够测量代码时间的代码辅助卡常。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> begin = std::chrono::high_resolution_clock::<span class="built_in">now</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> end = std::chrono::high_resolution_clock::<span class="built_in">now</span>();</span><br><span class="line"><span class="keyword">auto</span> elapsed = std::chrono::<span class="built_in">duration_cast</span>&lt;std::chrono::nanoseconds&gt;(end - begin);</span><br><span class="line">cerr &lt;&lt; B &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; elapsed.<span class="built_in">count</span>() * <span class="number">1e-9</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br></pre></td></tr></table></figure></li>
<li>警告：别开O3，那不真实，万一比赛ban了O3你就完了，老老实实卡常，练习卡常技巧。</li>
</ol>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>卡常</tag>
      </tags>
  </entry>
  <entry>
    <title>可以尝试解决的题目</title>
    <url>/2023/09/04/%E5%8F%AF%E4%BB%A5%E5%B0%9D%E8%AF%95%E8%A7%A3%E5%86%B3%E7%9A%84%E9%A2%98%E7%9B%AE/</url>
    <content><![CDATA[<ol>
<li><a href="https://acm.ecnu.edu.cn/contest/695/problem/E/">https://acm.ecnu.edu.cn/contest/695/problem/E/</a></li>
</ol>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>杂题</tag>
        <tag>待解决</tag>
      </tags>
  </entry>
  <entry>
    <title>实验</title>
    <url>/2023/08/08/%E5%AE%9E%E9%AA%8C/</url>
    <content><![CDATA[<h1 id="喜"><a href="#喜" class="headerlink" title="喜"></a>喜</h1><h2 id="怒"><a href="#怒" class="headerlink" title="怒"></a>怒</h2><h3 id="哀"><a href="#哀" class="headerlink" title="哀"></a>哀</h3><h2 id="乐"><a href="#乐" class="headerlink" title="乐"></a>乐</h2><h1 id="典"><a href="#典" class="headerlink" title="典"></a>典</h1><p>$a_{i}=1$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>$good$<br>good</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hello world.</span><br></pre></td></tr></table></figure>
<p><img src="1.png" alt="1.png"></p>
<p>😀</p>
<div class="tabs" id="test1"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test1-1">test1 1</button></li><li class="tab"><button type="button" data-href="#test1-2">test1 2</button></li><li class="tab"><button type="button" data-href="#test1-3">test1 3</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test1-1"><p><strong>This is Tab 1.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-2"><p><strong>This is Tab 2.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-3"><p><strong>This is Tab 3.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>
<p>现在已经知道 hidetoggle 和代码块嵌套会导致渲染出错。</p>
<p>会积极寻找解决方法。</p>
<p>悲。</p>
<details class="toggle" ><summary class="toggle-button" style="">1</summary><div class="toggle-content"><p><details class="toggle" ><summary class="toggle-button" style="">2</summary><div class="toggle-content"><details class="toggle" ><summary class="toggle-button" style="">3</summary><div class="toggle-content"></div></details>&lt;/div&gt;&lt;/details&gt;<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br></pre></td></tr></table></figure></p>
</div></details>]]></content>
      <categories>
        <category>杂项</category>
      </categories>
  </entry>
  <entry>
    <title>感悟</title>
    <url>/2023/09/01/%E6%84%9F%E6%82%9F/</url>
    <content><![CDATA[<ol>
<li>锻炼在写 DP 之前先把转移方程写出来的能力，方便自己写代码，也方便队友 Debug ，还有就是变量名一定要和代码中的是一样的。</li>
<li>要多锻炼动笔想题的能力，防止一动笔脑子就宕机。</li>
<li>赛时只要证明了做法是对的就直接写，赛后可以思考一下更加优美的证明，但是不要太久，思考太久的话还不如直接去多做几道题目。</li>
<li>即使 AC 了题目，也要看看题解，因为题解中可能会有值得学习的点，如果一直沉浸在自己的世界，不去接受一些别人的东西，进步起来是非常慢的。</li>
</ol>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>ACM杂类</tag>
      </tags>
  </entry>
  <entry>
    <title>五边形数定理学习笔记</title>
    <url>/2024/01/29/%E4%BA%94%E8%BE%B9%E5%BD%A2%E6%95%B0%E5%AE%9A%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<script type="math/tex; mode=display">\prod\limits_{i=1}^{\infty}(1-x^i)=\sum\limits_{k=-\infty}^{\infty}(-1)^{k}x^{\frac{k(3k-1)}{2}}=1+\sum\limits_{k=1}^{\infty}(-1)^{k}x^{\frac{k(3k\pm 1)}{2}}</script><details class="toggle" ><summary class="toggle-button" style="">证明</summary><div class="toggle-content"><p>这个证明太厉害了，拍案叫绝。</p>
<p>首先，不难发现，$x^i$ 的系数是：偶数个不同正整数的拆分数的方案-奇数个不同正整数的拆分数的方案。</p>
<p>所以要证明这个定理就得找到一个关于偶数拆分和奇数拆的双射。</p>
<p>现在用一个点阵表示一个拆分，考虑把拆分数从大到小排序，然后第 $i$ 行的点的数量表示数的大小。（这玩意又叫Ferrers图）</p>
<p>下面是拆分：$6,5,3,1$ 的例子。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0 0 0 0 0 0</span><br><span class="line">0 0 0 0 0</span><br><span class="line">0 0 0</span><br><span class="line">0</span><br></pre></td></tr></table></figure>
<p>考虑把最下面一行点的数量，也就是最小的数字设为 $s$ ，最右边 $45$ 度斜线的点的数量设为 $m$ 。</p>
<p>为了方便理解，对上面那个例子做了标记，$1$ 表示 $s$ ，$2$ 表示 $m$。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0 0 0 0 0 2</span><br><span class="line">0 0 0 0 2</span><br><span class="line">0 0 0</span><br><span class="line">1</span><br></pre></td></tr></table></figure>
<p>如果 $s&gt;m$ 就把 $m$ 个元素放到最下面一行，否则把 $s$ 个元素放到 $m$ 个元素右边。</p>
<p>例如上面那个例子就是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0 0 0 0 0 2 1</span><br><span class="line">0 0 0 0 2</span><br><span class="line">0 0 0</span><br></pre></td></tr></table></figure>
<p>可以发现，这大部分情况下是一个双射，但是有一些特殊情况：</p>
<ol>
<li>$s=m+1$ ，同时拆分数的数字个数也就恰好 $m$ 个，这个时候如果拆出来就会有相同的两行：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0 0 0 0</span><br><span class="line">0 0 0</span><br></pre></td></tr></table></figure>
这个时候数字总数为 ：$\frac{m(3m+1)}{2}$ ，系数为 $(-1)^m$ 。</li>
<li>$s=m$ ，同时拆分数的数字个数也就恰好 $m$ 个：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0 0 0</span><br><span class="line">0 0</span><br></pre></td></tr></table></figure>
这个时候数字总数为 ：$\frac{m(3m-1)}{2}$ ，系数为 $(-1)^m$ 。</li>
</ol>
<p>综上，结论得证，证毕。</p>
<p>这个证明真的是太优美了。</p>
</div></details>
<p>参考资料：<a href="https://blog.csdn.net/visit_world/article/details/52734860">https://blog.csdn.net/visit_world/article/details/52734860</a></p>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>五边形数定理</tag>
        <tag>组合数学</tag>
      </tags>
  </entry>
  <entry>
    <title>待解决</title>
    <url>/2024/01/20/%E5%BE%85%E8%A7%A3%E5%86%B3/</url>
    <content><![CDATA[<p>学习书籍 《A course in combinatorial optimization》，在网上突然看到的，感觉这一本书还是很有学习的必要的。</p>
<ol>
<li>“MEXimum Spanning Tree” 中的根号做法是什么。（解决条件：学会 Hopcroft Karp 的复杂度分析）</li>
<li>“拟阵学习笔记”：<ol>
<li>匹配拟阵交换性的证明。（用增广路的证明）</li>
<li>用基的定义能不能再弱一点。</li>
<li>带权拟阵交。</li>
<li>学习剩下的内容。</li>
</ol>
</li>
<li>Game of Connect(Shannon’s Switching Game) 学会 Shannon’s Switching Game 。</li>
<li>Graffiti 那个dp分块到底是哪一年提高组初赛的题目。</li>
<li>Not Intersect 的生成函数做法。</li>
</ol>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>ACM杂类</tag>
      </tags>
  </entry>
  <entry>
    <title>楼房重建</title>
    <url>/2024/03/20/%E6%A5%BC%E6%88%BF%E9%87%8D%E5%BB%BA/</url>
    <content><![CDATA[<p>题目链接：<a href="https://www.luogu.com.cn/problem/P4198">https://www.luogu.com.cn/problem/P4198</a></p>
<p>题目大意：维护有多少个不同的前缀最大值（相同数值但是位置更靠后的认为更大且两数不同，即认为每个数字加上与位置成正比的浮动）</p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>非常经典的题目，众所周知，信息学有一类题目的出题方法就是打破常规。</p>
<p>这道题目就是个经典的打破常规的题目，当然你也可以从别的角度去看他。</p>
<p>正常的线段树 updata 都是 $O(1)$ 的，但是这道题目的 updata 是 $\log$ 的。</p>
<p>更详细的来说，维护这么一个函数 $g(x,k)$ ，能够维护 $x$ 所管理的区间中 $\ge k$ 的不同前缀最大值个数。</p>
<p>这个函数可以 $\log$ ，当左区间的最大值 $&lt;k$ ，那么直接去右区间，左区间贡献为 $0$ 。否则，说明考虑左区间的话，对右区间的不同前缀最大值没有影响，直接去左区间就行了，而右区间的贡献就是 $x$ 的不同前缀最大值个数，减去左儿子的。（满足可减性）</p>
<p>用这个函数可以在 $\log$ 的时间轻松实现 updata ，这样就可以在 $O(\log^2)$ 的时间解决这个问题。</p>
<p>显然，这个做法还能轻松实现区间不同的前缀最大值个数。</p>
<p>时间复杂度： $O(n+q\log^2n)$ 。</p>
<p>空间复杂度： $O(n)$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> NN=<span class="number">2e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> eps=<span class="number">1e-8</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Fac</span>&#123;LL a,b;&#125;;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>&lt;(Fac x,Fac y)&#123;<span class="keyword">return</span> x.a*y.b&lt;x.b*y.a;&#125;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>&lt;=(Fac x,Fac y)&#123;<span class="keyword">return</span> !(y&lt;x);&#125;</span><br><span class="line">Fac a[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> lc,rc,c;</span><br><span class="line">    Fac mx;</span><br><span class="line">&#125;tr[NN];<span class="type">int</span> len;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">findans</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> l,<span class="type">int</span> r,Fac k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l==r)<span class="keyword">return</span> k&lt;=tr[x].mx &amp;&amp; tr[x].mx.a;</span><br><span class="line">    <span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(tr[tr[x].lc].mx&lt;k)<span class="keyword">return</span> <span class="built_in">findans</span>(tr[x].rc,mid+<span class="number">1</span>,r,k);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> tr[x].c-tr[tr[x].lc].c+<span class="built_in">findans</span>(tr[x].lc,l,mid,k);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">updata</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> l,<span class="type">int</span> mid,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(tr[x].lc &amp;&amp; tr[x].rc);</span><br><span class="line">    tr[x].mx=<span class="built_in">max</span>(tr[tr[x].lc].mx,tr[tr[x].rc].mx);</span><br><span class="line">    tr[x].c=tr[tr[x].lc].c+<span class="built_in">findans</span>(tr[x].rc,mid+<span class="number">1</span>,r,tr[tr[x].lc].mx);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bt</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> x=++len;</span><br><span class="line">    <span class="keyword">if</span>(l&lt;r)&#123;</span><br><span class="line">        <span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        tr[x].lc=<span class="built_in">bt</span>(l,mid);</span><br><span class="line">        tr[x].rc=<span class="built_in">bt</span>(mid+<span class="number">1</span>,r);</span><br><span class="line">        <span class="built_in">updata</span>(x,l,mid,r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> tr[x].mx=a[l];</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">change</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> id,Fac k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">        tr[x].mx=k;</span><br><span class="line">        tr[x].c=k.a&gt;<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(id&lt;=mid)<span class="built_in">change</span>(tr[x].lc,l,mid,id,k);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">change</span>(tr[x].rc,mid+<span class="number">1</span>,r,id,k);</span><br><span class="line">    <span class="built_in">updata</span>(x,l,mid,r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,q;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;q);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)a[i]=&#123;<span class="number">0</span>,<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="built_in">bt</span>(<span class="number">1</span>,n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=q;i++)&#123;</span><br><span class="line">        <span class="type">int</span> x,y;<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;x,&amp;y);</span><br><span class="line">        a[x]=&#123;y,x&#125;;</span><br><span class="line">        <span class="built_in">change</span>(<span class="number">1</span>,<span class="number">1</span>,n,x,a[x]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,tr[<span class="number">1</span>].c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然，这个问题还能扩展。</p>
<p>思考一下，假如维护的信息不满足可减性怎么办呢？</p>
<p>答案是每个点不维护区间的答案，而是维护在考虑左区间的情况下右区间的贡献即可。</p>
<p>这个方法又有个别名，叫兔队线段树。</p>
<p>原链接在这：<a href="https://www.cnblogs.com/PinkRabbit/p/Segment-Tree-and-Prefix-Maximums.html">https://www.cnblogs.com/PinkRabbit/p/Segment-Tree-and-Prefix-Maximums.html</a></p>
<p>一道练习题在这：<a href="https://codeforces.com/contest/671/problem/E">https://codeforces.com/contest/671/problem/E</a></p>
<p>具体做法看原链接吧，我感觉粉兔已经说的很明白了。<del>其实是因为我懒</del></p>
</div></details>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>经典问题</tag>
      </tags>
  </entry>
  <entry>
    <title>拟阵初级学习笔记</title>
    <url>/2024/01/26/%E6%8B%9F%E9%98%B5%E5%88%9D%E7%BA%A7%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>建议直接去看原论文，哪篇论文放在参考文献了。</p>
<p>前排提示，本篇中对于集合操作 $+$ 和 $\cup$ 没有区分，都表示<strong>并</strong>的意思，$-$ 和 $\setminus$ 同理。</p>
<h1 id="拟阵的入门"><a href="#拟阵的入门" class="headerlink" title="拟阵的入门"></a>拟阵的入门</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><h3 id="幂集"><a href="#幂集" class="headerlink" title="幂集"></a>幂集</h3><p> $2^S$ 称作 $S$ 的拟阵当且仅当 $2^S$ 是 $S$ 所有子集构成的集合。</p>
<p> 例如：$\{1,2\}$ 的幂集是 $\{\{1,2\},\{1\},\{2\},\emptyset\}$ 。</p>
<h3 id="拟阵"><a href="#拟阵" class="headerlink" title="拟阵"></a>拟阵</h3><p>记 $M=(S,\mathcal{I})$ 表示一个定于在有限集合 $S$ 且独立集的集合为 $\mathcal{I}$ 的当且仅当满足以下三条：</p>
<ol>
<li>$\mathcal{I}\subset 2^S$</li>
<li><strong>遗传性</strong> ：如果 $J\subset I\in \mathcal{I}$，那么 $J\in \mathcal{I}$ 。</li>
<li><strong>交换性/扩张性</strong> ：如果 $I,J\in\mathcal{I},|J|&lt;|I|$，那么 ${\exists}z\in J\setminus I , I\cup z\in \mathcal{I}$ 。</li>
</ol>
<p>为了方便，我们一般认为 $\emptyset \in \mathcal{I}$ ，即认为独立集的集合是非空的。</p>
<p>我们称 $\mathcal{I}$ 的元素为独立集。</p>
<p>例子：</p>
<p><strong>均匀拟阵</strong> ：$U^k_n=(S,\mathcal{I})$，其中 $|S|=n,\mathcal{I}=\{I\subset S : |I| \le k \}$ 。</p>
<p><strong>图拟阵</strong> ：令无向图 $G=(V,E)$，令图拟阵：$M=(E,\mathcal{I})$ ，其中 $\mathcal{I}=\{F\subset E : F 无环\}$ 。</p>
<p>为啥是拟阵这件事不难自证，不再赘述。</p>
<p>图拟阵非常的重要，因为他提供了一个形象想象拟阵的工具，在前期学习拟阵在图拟阵上想想是非常有用的方法。</p>
<p>不过图拟阵在有向图上不一定成立，一样的定义，只不过把无向图换成有向图。</p>
<p><img src="1.png" alt=""></p>
<p><strong>匹配拟阵</strong> ：令无向图 $G=(V,E)$，匹配拟阵：$M=(V,\mathcal{I})$ ，其中一个点集是独立集当且仅当存在一个匹配能够覆盖点集中的所有点（可以覆盖点集外的点）。</p>
<p>遗传性显然，交换性不会。</p>
<p>拟阵同时还可以与高代联动，对于一个有限的向量空间，一个独立集定义为线性无关的向量组，非常有意思的是，此时下面基的定义就是高代中基的定义，环是最小的线性相关的向量组，而引理1.2对应的就是基扩张定理。（从这个角度来看，很多拿到一个子空间的极大独立集，直接扩张成大空间的极大独立集的证明，突然就熟悉多了，这也能与课内联动？）</p>
<p>这么说的话，用线性空间来作为拟阵的例子辅助思考貌似也是一个不错的选择。</p>
<h6 id="坑1"><a href="#坑1" class="headerlink" title="坑1"></a>坑1</h6><p>不会交换性的证明。</p>
<h3 id="基"><a href="#基" class="headerlink" title="基"></a>基</h3><p>独立集 $I$ 是基当且仅当加入 $S/I$ 中的任何一个元素都不是独立集。</p>
<p>这种拟阵中的极大元素，在拟阵的研究中发挥着至关重要的作用。</p>
<h3 id="环"><a href="#环" class="headerlink" title="环"></a>环</h3><p>一个非独立集 $I’$ 是环当且仅当 $I’$ 删除其中任意一个元素都是独立集。</p>
<p>例子：图拟阵中的简单环。</p>
<p>我们用 $C(M)$ 表示拟阵 $M$ 中所有的环。</p>
<h2 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h2><p><strong>引理 1.1</strong> ：基的大小相同。（用交换性显然）</p>
<p><strong>引理 1.2</strong> ：${\forall} J \in \mathcal{I},{\exists} 基I:J\in I$ 。（用交换性显然）</p>
<p>该引理说明任意一个元素都属于一个基，所以对于一个拟阵，只要知道基，加上遗传性就可以知道所有独立集。</p>
<p>但是能不能凭借此定义独立集的集合呢？</p>
<p>还需要一个定理：</p>
<p><strong>定理 1.3(基交换定理)</strong> ：${\forall}基A,B,A\ne B,{\forall} z\in A\setminus B,{\exists} y\in B\setminus A:A-\{z\}+\{y\}\in \mathcal{I}$ 。（用遗传性显然）</p>
<p>满足基交换定律且大小相同的基的集合可以定义一个拟阵。（可以证明交换性成立，并不困难，在此不再赘述，证明过程类似【完美匹配那个证明】）</p>
<p>这种定义相较于原来定义的优势在于检验拟阵的工作量小了，本来对于每一对独立集都要检验，现在只需要检验基，尤其是对于自己随手写的拟阵，例如：$\{\{1,3,4\},\{2,3,4\}\}$ 。</p>
<h6 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h6><p>完美匹配定理的编号。</p>
<h6 id="坑2"><a href="#坑2" class="headerlink" title="坑2"></a>坑2</h6><p>其实我觉得这里的大小相同的限制可以改得再弱一点：基之间没有包含关系，我严重怀疑没有包含关系可以推出大小相同，但是水平有限，目前我证不出来。</p>
<p>基交换定理可以放宽一下条件，仍然成立：</p>
<p>${\forall}A,B\in \mathcal{I},|A|\le|B|,{\forall} z\in A,{\exists} y\in B\setminus (A-\{z\}):A-\{z\}+\{y\}\in \mathcal{I}$ 。</p>
<p><strong>引理 1.4</strong> ：$I$ 不是独立集，则一定有一个子集是环 。（显然）</p>
<p><strong>引理 1.5</strong> ：${\forall}X,Y\in C(M),X\subset Y:X=Y$ 。（显然）</p>
<p><strong>引理 1.6</strong> ：${\forall}X,Y\in C(M),X\ne Y,e\in X\cap Y:{\exists} C\in C(M),C\subset X\cup Y-\{e\}$ 。</p>
<details class="toggle" ><summary class="toggle-button" style="">证明</summary><div class="toggle-content"><p>等价于证明 $X\cup Y-\{e\}$ 不是独立集。</p>
<p>证明一个集合不是独立集，思考一下条件：环、一个已知的集合。因此我们考虑利用这个已知的集合用反证法，通过构造与环产生矛盾。</p>
<p>反证法：已知 $X\cap Y \in \mathcal{I}$ ，然后用 $X\cup Y-\{e\}$ 扩大这个集合到同样的大小，由于环的限制， $X\setminus Y,Y\setminus X$ 都要丢掉一个元素，所以集合大小最大是 $|X|+|Y|-2$ ，然而可以扩展到 $|X|+|Y|-1$ ，矛盾，证毕。</p>
<p>至于更加严谨的写法，这里引用一下2018国集论文（根据引理编号对内容做了一点更改）：</p>
<p>证明：由引理 1.5 可得， $X\setminus Y$ 非空，设 $f \in X\setminus Y$ 。假设 $X\cup Y − \{e\}$ 是独立集。由于 $X$ 是环，<br>所以 $X − \{f\}$ 是独立集，假设 $X\cup Y$ 中最大的包含 $X − \{f\}$ 的独立集是 $Z$ 。由于 $Y$ 不是独立<br>集，所以 $Y \not\subset Z$ 。由此可得 $|Z|\le |X\cup Y − \{f\}| − 1 \le |X \cup Y| − 2 &lt; |X \cup Y − \{e\}|$ 。因为 $Z$ 已经<br>是最大的独立集了，所以 $X\cup Y − \{e\}$ 不可能是独立集（否则由交换性可以扩大 $Z$ ），命题得证。</p>
</div></details>
<p><strong>引理 1.7</strong> ：$I$ 是基，$e\notin I$ ，那么 $I+\{e\}$ 包含一个唯一的环。</p>
<details class="toggle" ><summary class="toggle-button" style="">证明</summary><div class="toggle-content"><p>至少有一个环是显然的，每个环都有 $e$ 是显然的。</p>
<p>引理 1.6 告诉我们只要有两个环，就可以构造出不含 $e$ 的环，所以至多只有一个环。</p>
<p>证毕。</p>
</div></details>
<h1 id="秩函数"><a href="#秩函数" class="headerlink" title="秩函数"></a>秩函数</h1><h2 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h2><p>对于拟阵 $M=(S,\mathcal{I})$ ，基的元素的个数称为拟阵的秩，对于任意一个 $U\subset S$，定义秩函数 $r(U)$ 表示 $U$ 中极大独立集的大小。</p>
<h2 id="性质-1"><a href="#性质-1" class="headerlink" title="性质"></a>性质</h2><p><strong>定理 2.1(有界性)</strong> ：${\forall}U\subset S, 0\le r(U)\le|U|$</p>
<p><strong>定理 2.2 (单调性)</strong> ：${\forall}A\subset B\subset S,r(A)\le r(B)$</p>
<p><strong>定理 2.3 (次模性)</strong> ：${\forall}A,B\subset S,r(A\cup B)+r(A\cap B)\le r(A)+r(B)$</p>
<p>定理1,2都是显然的，下面证明定理3。</p>
<details class="toggle" ><summary class="toggle-button" style="">证明</summary><div class="toggle-content"><p>首先，我们使用构造方法，证明一个集合的秩的下界是更加容易的（构造一个独立集总比说明独立集大小的上界要容易得多），根据这个方向，我们得到这个证明：</p>
<p>先找到 $A\cap B$ 的极大独立集，然后用交换性扩大成 $A\cup B$ 的极大独立集，然后把扩大的部分，按照 $A\setminus B,B\setminus A$ 分成两部分，和 $A\cap B$ 的极大独立集合成 $A,B$ 的独立集，然后就证完了。</p>
<p>更加严谨的写法看国集论文，这里懒得复制粘贴了，思路是一样的。</p>
</div></details>
<p>那么问题来了，我们能否用秩函数定义拟阵？答案是：可以。</p>
<p>如果我们有一个函数 $r$ ；$2^S\to \mathbb{Z}$，定义 $\mathcal{I}={I:r(I)=|I|}$ 。</p>
<details class="toggle" ><summary class="toggle-button" style="">遗传性证明</summary><div class="toggle-content"><p>在遗传性的证明中，我们更希望证明一个集合是独立集，也就是证明 $r(I)=I$ ，显然，我们其实是需要证明 $r(I)\ge I$ ，所以在证明中应该更多的将目标集合放在 $\le$ 的右边。</p>
<p>$A=J,B=I\setminus J$，即可证明。</p>
</div></details>
<details class="toggle" ><summary class="toggle-button" style="">交换性证明</summary><div class="toggle-content"><p>在交换性的证明中，由于找到具体哪个集合是独立集有点困难，采用反证，则考虑限制集合秩的上界，去证明大集合（$I$）并不是独立集，此时把目标集合（$I$）放在 $le$ 左边限制上界。</p>
<p>令 $\{b_1,b_2,…,b_n\}=I\setminus J$</p>
<p>考虑 ：$A=J+\{b_1\},B=J+\{b_2\}$，则可以证明 $r(J+\{b_1,b_2\})=|J|$，然后将其作为新的 $A$，令 $B=J+\{b_3\}$ ，不断往下做，直到合成出 $I\cup J$ 为止，此时 $r(I\cup J)=|J|&lt;|I|=r(I)$ ，矛盾，证毕。</p>
</div></details>
<p>说点抽象的话：</p>
<p>事实上，定理 3 变换一下可以得到另外一个形式：$r(A\cup B)-r(A)\le r(B)-r(A\cap B)$ ，然后变个符号：$r(A\cup C)-r(A)\le r(B\cup C)-r(B),B\subset A$ 。</p>
<p>在面对一个集合时，小集合的增量要不劣于大集合的增量，这说明小集合比起大集合具有更大的增长潜力，在后面闭包算子中会反复提及这一点。</p>
<p>当然，对于这一点，可以这么理解，现在假设有个空集，他可以到达任何的基，但是随着元素一个个被确定，能到达的基越来越少，选择也越来越少，因此增长潜力也在减小，极端的，当为基的时候，没有选择，增长不了，增长潜力达到最低值。</p>
<h1 id="拟阵最优化"><a href="#拟阵最优化" class="headerlink" title="拟阵最优化"></a>拟阵最优化</h1><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>定义函数 $w:S\to \mathbb{R}$ ，定义一个集合的权值为：$w(I)=\sum\limits_{e\in I}w(e)$，找 $\mathcal{I}$ 中最大的 $w(I)$ 。</p>
<p>例子：最小生成树。</p>
<h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p><del>最小生成树plus版</del></p>
<p>以下先默认权值非负，因此显然权值最大的基就是权值最大的独立集。</p>
<ol>
<li>把 $S$ 中的元素按照从大到小的顺序排序，记作 $s_1,s_2,s_3,…,s_n$ 。</li>
<li>维护一个集合 $I$ ，初始为空，按顺序考虑 $s_i$ ，如果 $I$ 加上 $s_i$ 是独立集就加入，否则就不加入。</li>
</ol>
<details class="toggle" ><summary class="toggle-button" style="">证明</summary><div class="toggle-content"><p>没看懂论文第二步的证明，自己瞎掰了一个。</p>
<p>记 $U_i=\{s_1,s_2,…,s_i\}$，$I_i$ 为考虑完 $s_i$ 后的 $I$ 。</p>
<p>$|I_i|=r(U_i)$ ，否则$|I_i|$ 可以扩大，加入的元素为 $s_j(j\le i)$ ，则一定会在考虑到 $s_j$ 的时候加入该元素，矛盾，所以成立。</p>
<p>所以最后 $I$ 是一个基。</p>
<p>考虑把每个独立集用其所含元素的下标从小到大呈现，例如：$\{1,2,4\}$ 表示其含有 $s_1,s_2,s_4$ 。</p>
<p>那么对于 $I$ ，假设其呈现出来是：$a_1,a_2,…,a_t$ , 对于任意一个基而言，是：$a’_1,a’_2,…,a’_t$ ，那么显然有 $a_i\le a’_i$ ，则显然 $I$ 是权值最大的基。</p>
</div></details>
<p>事实上，同样的证明方法，不一定要 $I$ 是基，可以扩展，当 $|I|$ 的大小为 $t$ 时，$I$ 就是所有大小为 $t$ 的独立集中权值最大的。</p>
<p>所以就算权值是非负的，如果指定了目标独立集的大小，仍然可以用此算法。（不过如果已经指定了大小，令总体权值加减一个数字只会让答案改变 $siz*val$，也能把问题转化到非负情形下）</p>
<p>但是如果权值可以是负数呢？</p>
<p>显然当 $s_i\le 0$ 时推出就行了，显然正确，考虑答案只可能出在 $I_i$ 就行了。（显然，$I_i$ 是同集合大小的独立集中权值最大的，只考虑他就行了）</p>
<h1 id="拟阵交"><a href="#拟阵交" class="headerlink" title="拟阵交"></a>拟阵交</h1><h2 id="问题-1"><a href="#问题-1" class="headerlink" title="问题"></a>问题</h2><p>对于 $M_1=(S,\mathcal{I}_1)$，$M_2=(S,\mathcal{I}_2)$ ，定义 $M_1,M_2$ 的交是所有 $I$ 的集合 ，$I$ 满足在两个集合中都是独立集。</p>
<p>首先，拟阵的交是拟阵吗？不是。</p>
<p>反例：$S=\{1,2,3\},\mathcal{I}_1=\{\emptyset,\{1\},\{2\},\{3\},\{1,2\},\{1,3\}\},\mathcal{I}_2=\{\emptyset,\{1\},\{2\},\{3\},\{1,2\},\{2,3\}\}$ 。</p>
<p>交为：$\{\emptyset,\{1\},\{2\},\{3\},\{1,2\}\}$</p>
<p>显然不是拟阵。</p>
<p>不过拟阵交虽然不是拟阵，但是显然是个集合，那问题来了，这个集合中大小最大的独立集有多大？并且求出一个合法解。</p>
<p>这个问题在两个拟阵的交时有多项式求法，但是三个以上是 NP-hard 的。</p>
<p>所以接下来的讨论默认是两个拟阵的交。</p>
<h2 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h2><h3 id="闭包算子"><a href="#闭包算子" class="headerlink" title="闭包算子"></a>闭包算子</h3><p>对于 $A\subset S$ ，我们定义 $A$ 的闭包算子 $cl(A)=\{e\in S : r(A\cup \{e\})=e(A)\}$ 。</p>
<p>也就是加入后不会影响 $A$ 的秩的元素。</p>
<p>一个显然的事情：$A\subset cl(A)$ 。</p>
<h3 id="交换图"><a href="#交换图" class="headerlink" title="交换图"></a>交换图</h3><p>对于 $I\in \mathcal{I}$，定义一个二分图，一边是 $I$ ，一边是 $S\setminus I$ ，存在边 $(x,y)(x\in I,y\in S\setminus I)$ 当且仅当 ：$I-\{x\}+\{y\}\in \mathcal{I}$ 。</p>
<p>称此二分图为 $I$ 的交换图，记作 $D_M(I)$ 。</p>
<h2 id="性质-2"><a href="#性质-2" class="headerlink" title="性质"></a>性质</h2><p><strong>引理 4.1</strong> ：如果 $A\subset B$ ，那么 $cl(A)\subset cl(B)$ 。</p>
<details class="toggle" ><summary class="toggle-button" style="">证明</summary><div class="toggle-content"><p>兄弟，来一个极其富有高代特色的证明。</p>
<p>对于任意一个 $z\in cl(A)$ ，找到 $A$ 的一个极大独立集，然后在 $B+\{z\}$ 中扩大，那么一定会得到一个不含 $z$ 的极大独立集，所以 $z$ 不会扩大 $B$ 的秩。</p>
<p>这个证明用到了一个显然正确的结论：如果加入 $z$ 后，存在一个极大独立集不包含 $z$ ，那么 $z$ 一定在该集合的闭包算子中，否则不在。</p>
<p>论文采用秩函数证明：</p>
<p>$r(A+\{z\})+r(B)\ge r((A+\{z\})\cap B)+r(B+\{z\})\ge r(A)+r(B+\{z\})$ 。（也可以由 $r(A+\{z\})-r(A)\ge r(B+\{z\})-r(B)$ 得到，这个式子在上面的次模性的变形中给出过）</p>
<p>又 $r(A+\{z\})=r(A)$ ，所以 $r(B)\ge r(B+\{z\})$，所以 $r(B)=r(B+\{z\})$ ，证毕。</p>
</div></details>
<p>这个定理同样反映了小集合比大集合更加具有增长潜力，一个元素对小集合没有贡献，那么对大集合同样没有贡献。</p>
<p><strong>引理 4.2</strong> ：$A\subset S,e\in cl(A)$ ，那么 $cl(A)=cl(A\cup \{e\})$ 。</p>
<details class="toggle" ><summary class="toggle-button" style="">证明</summary><div class="toggle-content"><p>${\forall} z \in cl(A\cup \{e\}),r(A)=r(A+\{z\})=r(A+\{e,z\})$，则 $r(A)\le r(A+\{z\})\le r(A+\{e,z\})$ ，所以 $r(A)=r(A+z)$ ，证毕。</p>
<p>人话讲就是，如果加到大集合秩不变，由于大集合秩等于小集合，大集合的秩本来就比小集合大，如果小集合变大了，就比大集合大了，所以加入到小集合中秩也不能变大。</p>
<p>所以如果 $r(A)=r(B),A\subset B$，那么 $cl(A)=cl(B)$ 。（引出下文）</p>
</div></details>
<p><strong>引理 4.3</strong> ：$cl(A)=cl(cl(A)),r(A)=r(cl(A))$ 。（反复用 引理 4.2 就行了）</p>
<p>上面两个引理说明了个什么事呢？（包括证明过程）</p>
<p>显然的事情：</p>
<ol>
<li>$A\subset B,r(A)=r(B)$，那么 $cl(A)=cl(B),B\setminus A \subset B\subset cl(B)=cl(A)$ 。（秩相同则 $cl$ 相同）</li>
<li>${\forall} B\subset cl(A):cl(A\cup B)=cl(A),r(A\cup B)=r(A)$ 。（这一条主要是对引理4.3的扩展）</li>
<li>$A\subset B,cl(A)=cl(B):r(A)=r(B)$ 。（因为 $B\subset cl(B)=cl(A)$，所以 $r(B)=r(A\cup B)=r(A)$ ）（ $cl$ 相同则秩相同）</li>
</ol>
<p>因此，如果子集之间相互包含，那么秩相同和 $cl$ 相同同时成立，也很符合直觉，集合变大，秩不变，那一定是你一直在加一些没有贡献的元素进来。同时，加入没有贡献的元素进来，也并不会改变没贡献的元素的集合，也就是说没贡献的元素之间不会产生联动，突然就产生贡献了，没用就是一直没用，直到秩增大。</p>
<p>这几个引理还可以从另外一个视角看：若 $C\subset cl(B)$ ，$B\subset cl(A)$ ，那么 $C\subset cl(A)$ ，这体现了闭包的传递性。</p>
<p>这也说明了一个事情：在产生秩增量这件事情上， $B$ 没用，$C$ 一定没用，$C$ 有用，$B$ 一定有用，也就是说某种程度上讲 $B$ 覆盖了 $C$ 的功能，这在后面的某些证明中有所体现。</p>
<p>在图拟阵中的一个体现就是：$(x,y)$ 和一个简单路径 $x\to y$ 形成了一个简单环，$(x,y)$ 的作用是有他在的边集合中，最大的独立集 $x,y$ 一定是联通的，而 $x\to y$ 一样能办到这件事。（此时 $(x,y)\in cl(x\to y))$）</p>
<p>注意一个特殊的集合：环，对于环 $I’,{\forall} z\in I’:z\in cl(I’-\{z\})$ ，这在后面的证明中会用到。</p>
<p><strong>定理 4.4(强基交换定理)</strong> ：对于两个不同的基 $A,B$ ，${\forall}x\in A\setminus B,{\exists} y\in B\setminus A : A-\{x\}+\{y\},B-\{y\}+\{x\}$ 都是基 。</p>
<details class="toggle" ><summary class="toggle-button" style="">证明</summary><div class="toggle-content"><p>先写论文的证法：</p>
<p>将 $x$ 加入 $B$ 中得到一个环 $C$ 。</p>
<p>则 $x\in cl(C-\{x\})$ ，则 $x\in cl((A\cup C)-\{x\})$ ，那么 $cl((A\cup C)-\{x\})=cl(A\cup C)$ ，所以 $r((A\cup C)-\{x\})=r(A\cup C)$ ，综上，存在 $y\in C-\{x\}$ ，满足 $A-\{x\}+\{y\}$ 是基，同时因为 $y$ 是环中的一个元素，所以 $B-\{y\}+\{x\}$ 也是环中的一个基。</p>
<p>这里其实就是用 $C-\{x\}$ 去代替 $x$ 的作用，然后找到是哪个元素起到了作用，将他作为 $y$ 。</p>
<p>当然，可以从染色的视角去看这个问题：</p>
<p>如果把这个问题放在图拟阵，也就是 $A$ 的一条边 $(x,y)$ 放到 $B$ 中，然后需要我去证明在 $B$ 的环中存在一条不是刚刚加入进来的边，满足能够填补 $A$ 的空缺。（一般的，我们认为 $A,B$ 都是生成树，就算是生成森林，边所在的联通块是一致的）</p>
<p>那么把 $A$ 中 $(x,y)$ 切断，与 $x$ 联通染蓝色， $y$ 联通染红色，显然，$B$ 中与 $(x,y)$ 形成环的路径上一定存在一条边，一端红色，一端蓝色，他就是我们要找的边。（因为路径两端一端红色，一端蓝色）</p>
<p>但是对点染色貌似和拟阵没什么关系，但是不妨换个角度看，我们要找的是路径上两端异色的边，所以我们不妨对边也染色，两端同色染为白色，异色染为黑色，观察一下这是什么？这就是 $cl(A-\{x\})$ ，也就是说 $cl$ 其实可以看成一种染色，无用染白，有用染黑。</p>
<p>有了这个想法，证明就轻松多了，显然在图拟阵中，一个环不能只有恰好一条黑边，否则从 $x$ 的联通块走黑边到达 $y$ 联通块，就没有另外一条黑边走回来了，与简单环的定义矛盾。所以去掉这条黑边是一个独立集（环的定义），加上这条黑边还是个独立集，与环矛盾，证毕。</p>
<p>用拟阵的话就是：反证法，如果 $C-\{x\}\subset cl(A-\{x\})$ ，那么 $x\notin cl(A-\{x\})$ ，则 $x\notin cl(C-\{x\})$ ，与环的定义矛盾，证毕。</p>
<p>所以 $cl$ 某种角度上可以算是拟阵的染色法。（先从图拟阵的角度思考是有道理的，直观）</p>
</div></details>
<p>当然，由上面的证明过程，可以放宽定理条件：$A,B$ 不一定得是基，只要满足 $|A|\le|B|$ 即可。</p>
<p>即：</p>
<p>${\forall}A,B\in \mathcal{I},|A|\le|B|,{\forall} x\in A,{\exists} y\in B\setminus (A-\{x\}):A-\{x\}+\{y\}，B+\{x\}-\{y\}\in \mathcal{I}$ 。</p>
<details class="toggle" ><summary class="toggle-button" style="">证明</summary><div class="toggle-content"><p>$B+\{x\}$ 不是独立集就类似上面证明就行了，小改即可。</p>
<p>是独立集，则 $|B+\{x\}|=|B|+1&gt;|A|$ ，则有交换性，存在 $y\in B:A+\{y\}\in\mathcal{I}$ 。</p>
<p>则 $A+\{y\}-\{x\}\in \mathcal{I}$ 。</p>
<p>这里还有个非常有意思的想法，用上面的思路证完 $|A|=|B|$ 的情况，然后对于 $|A|&lt;|B|$ 的情况，先用 $B$ 把 $A$ 扩大到相同大小，然后强交换，由于用于扩大的集合是两个集合的交集，所以不会出现在 $x,y$ 中，所以可以直接用遗传性再缩小回去，从而完成 $|A|&lt;|B|$ 的证明。</p>
<p>但是上面的思路可以直接把两种情况都证了，也就不需要多此一举了。</p>
</div></details>
<p><strong>引理 4.5</strong> ：对于独立集 $I,J,I\ne J,|I|=|J|$ ，则 $I\setminus J$ 与 $J \setminus I$ 存在完美匹配。</p>
<details class="toggle" ><summary class="toggle-button" style="">证明</summary><div class="toggle-content"><p>很有意思的构造性解，反正我没有证出来，思路确实新奇，小清新构造。（mad，没有证出来真TM不爽）</p>
<p>对于元素 $y\in J\setminus I$ ，由强交换定理可知存在 $x\in I\setminus J$ ，使得 $I-\{x\}+\{y\},J-\{y\}+\{x\}$ 仍然是独立集。</p>
<p>则认为 $x,y$ 匹配，然后令 $J=J+\{x\}-\{y\}$ ，接着构造，直到 $I=J$ ，构造完毕。</p>
</div></details>
<p><strong>引理 4.6</strong> ：对于独立集 $I$ 和集合 $J,I\ne J,|I|=|J|$ ，且 $I\setminus J$ 与 $J \setminus I$ 存在唯一的完美匹配，则 $J$ 也是独立集。</p>
<details class="toggle" ><summary class="toggle-button" style="">证明</summary><div class="toggle-content"><p>显然，要直接证明 $J$ 是不是独立集这件事情非常的困难，所以我的思路是构造+归纳，通过已有的信息，把 $I$ 构造出 $J$ 。</p>
<p>我们考虑把 $I\setminus J$ 换成 $J\setminus I$ 的一个元素，变成 $I’$ ，使得 $I’$ 与 $J$ 仍然只存在唯一的完美匹配。</p>
<p>考虑对于 $(x,y),x\in I\setminus J,y\in J\setminus I$ ，如果 唯一匹配是 $(x,y)$ ，则认为是 $x\to y$ ，否则认为是 $y\to x$ ，由于无环，所以是拓扑图。（因为是唯一匹配，所以无环，唯一匹配这个信息，显然是要往无环的角度去靠）</p>
<p>所以一定存在一个点 $x\in I\setminus J$ ，$x$ 没有入边，即在由 $I\setminus J$ 与 $J\setminus I$ 的导出子图中，$x$ 只有一条边。</p>
<p>考虑直接把 $x$ 换成与他匹配的 $y$ 。</p>
<p>不难证明（用交换性搞搞就行了），在 $D_M(I’)$ 中 $I’\setminus J$ 与 $J\setminus I’$ 的导出子图中的边一定在 $D_M(I)$ 中出现，同时 原来的匹配边也一定在新的导出子图中，所以仍然是唯一匹配。（匹配边还在，非匹配边减少了）</p>
<p>然后归纳就行了。</p>
<p>不过论文给了种更加简单的证明，不过我觉得本质应该差不多。</p>
<p>首先把匹配写成 $(x_1,y_1),(x_2,y_2),…,(x_t,y_t)$ 的形式，一般的，当 $i&lt;j$ 时， $x_i,y_j$ 没有边。（把 $x$ 按照拓扑序从小到大排就行了） </p>
<p>然后假设 $J$ 不是独立集，那么就存在环，假设为 $C$ ，并且其中下标最小的是 $y_i$ （显然一定有 $J\setminus I$ 的元素）。</p>
<p>考虑 $I-\{x_i\}$ ，那么 $C-y_i\subset cl(I-\{x_i\})$ ，又 $y_i\subset cl(C-y_i)\subset cl(cl(I-\{x_i\}))=cl(I-\{x_i\})$ ，这与 $x_i,y_i$ 匹配矛盾，证毕。</p>
<p>本质上就是 $C-\{y_i\}$ 能够替代 $y_i$ 的功能，但是由唯一匹配可以导出不能替代，从而导致了矛盾。</p>
</div></details>
<p><strong>引理 4.7</strong> ：$I,J\in \mathcal{I},|I|=|J|,{\forall} z\in J\setminus I,I+\{z\}\notin\mathcal{I},x\in S\setminus I,I+\{x\}\in \mathcal{I}$ ，那么 $J+\{x\}\in \mathcal{I}$ 。</p>
<details class="toggle" ><summary class="toggle-button" style="">证明</summary><div class="toggle-content"><p>$J\setminus I\subset cl(I)$ ，如果 $x\in cl(J)$ ，那么 $x\in cl(I)$ ，矛盾，证毕。</p>
</div></details>
<p><strong>定理 4.8(最小最大定理)</strong> ：$\max\limits_{I\in \mathcal{I_1}\cap\mathcal{I_2}} |I|=\min\limits_{U\subset S}(r_1(U)+r_2(S\setminus U))$</p>
<p>这里证明 $\le$ 是显然的，$|I\cap U|\le r_1(U)$ ，另一边同理，加起来就行了。</p>
<p>但是证明相等比较麻烦，后面在算法中用构造性方法证明。</p>
<h2 id="算法-1"><a href="#算法-1" class="headerlink" title="算法"></a>算法</h2><p>现在给出算法流程。</p>
<p>现有集合 $I,X_1=\{x\in S\setminus I:I+\{x\}\in \mathcal{I_1}\},X_2=\{x\in S\setminus I:I+\{x\}\in \mathcal{I_2}\}$ ，初始时 $I=\emptyset$ 。</p>
<p>定义交换图（有向图） $D_{M_1,M_2}(I)$ 为 ：</p>
<ol>
<li>$x\in I,y\in S\setminus I$ ，如果 $(x,y)\in D_{M_1}(I)$ ，那么 $x\to y\in D_{M_1,M_2}(I)$ 。</li>
<li>$x\in I,y\in S\setminus I$ ，如果 $(x,y)\in D_{M_2}(I)$ ，那么 $y\to x\in D_{M_1,M_2}(I)$ 。</li>
</ol>
<p>重复进行算法流程：</p>
<ol>
<li>在 $D_{M_1,M_2}(I)$ 找到一条起点属于 $X_1$ ，终点属于 $X_2$ 的最短路 $P$。（没有就结束算法）</li>
<li>令 $I=I∆P$ 。（ $∆$ 表示集合的对称差操作）</li>
</ol>
<p>最后得到的 $I$ 就是一个最大大小的拟阵交，同时 $U=\{x\in S:x 在D_{M_1,M_2}(I)能够到达 X_2 中的点\}$ 。</p>
<p>这个算法的正确性要证明两件事：</p>
<ol>
<li>$I$ 为什么仍然是拟阵交。</li>
<li>为什么 $|I|=r_1(U)+r_2(S\setminus U)$ 。</li>
</ol>
<details class="toggle" ><summary class="toggle-button" style="">证明1</summary><div class="toggle-content"><p>先证明新的 $I\in \mathcal{I_1}$ 。</p>
<p>令路径 $P=\{y_0,x_1,y_1,…,y_t\}$ ，令 $J=I-\{x_1,x_2,…,x_t\}+\{y_1,y_2,…,y_t\}$ ，由最短路可以导出是唯一匹配（因为 $D_{M_1}(I)$ 的结构类似 DAG 那样，BFS图），所以 $J$ 也是独立集，且同时可以直到 $y_1,y_2,…,y_t\in cl(I)$ ，由引理 4.7可知 $I+\{x\}\in \mathcal{I_1}$ 。</p>
<p>同理可证 $I\in \mathcal{I_2}$ 。</p>
<p>证毕。</p>
</div></details>
<details class="toggle" ><summary class="toggle-button" style="">证明2</summary><div class="toggle-content"><p>假设 $r_1(U)&gt;|I\cap U|$ ，则 ${\exists} z\in U\setminus I,(I\cap U)+\{z\}\in\mathcal{I_1}$ ，如果 $I+\{z\}\in \mathcal{I_1}$ ，则显然存在路径 $P$ ，否则，显然，$|I|&gt;|I\cap U|$ ，所以用 $I$ 把 $I\cap U +\{z\}$ 扩大，则显然存在 $x\in S\setminus U,I-\{x\}+\{z\}\in\mathcal{I_1}$ ，所以存在 $x\to z$ ，这与 $x\notin S$ 矛盾。</p>
<p>另外一边类似，不再赘述。</p>
<p>证毕。</p>
</div></details>
<p>这样，就证明了最小最大定理，同时也给出了一个求一组 $I,U$ 的多项式算法。</p>
<p>分析一下时间复杂度。</p>
<p>不计建 $D_{M_1,M_2}(I)$ 的复杂度，令 $n=|S|,r=\max(r_1(S),r_2(S))$ ，每次增广的代价是 $O(rn)$ ，每轮 $|I|$ 增大 $1$ ，所以至多进行 $r$ 轮，所以时间复杂度为 $O(r^2n)$ 。</p>
<p>非常优秀的时间复杂度。</p>
<h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><h3 id="三个以上的拟阵交为什么是-NP-Hard-的"><a href="#三个以上的拟阵交为什么是-NP-Hard-的" class="headerlink" title="三个以上的拟阵交为什么是 NP-Hard 的"></a>三个以上的拟阵交为什么是 NP-Hard 的</h3><p>可以证明难于哈密顿路径：</p>
<p>对于有向图 $G=(V,E)$ ，求 $s\to t$ 的哈密顿路径。</p>
<p>构造拟阵：</p>
<ol>
<li>令 $M_1$ 为边集满足把有向边看成无向边，则无环。</li>
<li>令 $M_2$ 为 $s$ 的入度为 $0$ ，其余点入度至多为 $1$ 。</li>
<li>令 $M_3$ 为 $t$ 的出度为 $0$ ，其余点出度至多为 $1$ 。</li>
</ol>
<p>求出这三个拟阵的拟阵交显然就能求出哈密顿路径，或者证明无解。</p>
<p>所以求三个及以上的拟阵交是 NP-Hard 的。</p>
<h3 id="带权拟阵交"><a href="#带权拟阵交" class="headerlink" title="带权拟阵交"></a>带权拟阵交</h3><p>定义权值函数：$w:S\to \mathbb{R}$ ，求 $\max\limits_{I\in \mathcal{I_1}\cap\mathcal{I_2}}\sum\limits_{e\in I}w(e)$ 。</p>
<p>扩展版本的最小最大定理我没看懂，这一部分建议自己去看论文。我没看懂这一部分，就不在这里胡说八道了。</p>
<p>算法流程就是把最短路径换成，以点权和最大为第一关键字，最少边数为第二关键字找路径。</p>
<p>其中 $I$ 的点权为 $-w(e)$ ，$S\setminus I$ 为 $w(e)$ 。</p>
<p>论文里写的是点权和最小，但是一个很简单的例子，所有独立集大小最大为 $1$ ，然后让这个拟阵自己和自己做交，那么最大值是什么？显然是权值最大的元素，但是按照论文里写的会找权值最小的元素，这显然是错误的。</p>
<p>更重要的是，在做题的时候，我写最长路过了。</p>
<p>至于为什么不会有正环，为什么算法一定会停止，为什么这个算法对，我一概不知，我只知道写最长路能过，仅此而已，现在当黑盒用了。</p>
<p>时间复杂度：$O(r^2n^2)$ 。</p>
<h6 id="坑3"><a href="#坑3" class="headerlink" title="坑3"></a>坑3</h6><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>兄弟，学了这么久，该做做题了，不然你学拟阵干什么。</p>
<p>拟阵交的题目一般是题目的条件无法直接使用拟阵，但是单看其中的一部分条件是满足拟阵要求的，所以就搞两个拟阵交起来，获得一个满足多个条件的集合，这种题目最难的就是怎么去构造合适的拟阵。</p>
<h3 id="二分图匹配"><a href="#二分图匹配" class="headerlink" title="二分图匹配"></a>二分图匹配</h3><p>虽然二分图匹配的匹配点集本身就是个拟阵，但是检验一个子集是否是独立集，就需要判断是否被一个匹配覆盖，这显然是难的。（我都能找匹配了，为什么还要多此一举再用个拟阵=.=）</p>
<p>所以构造拟阵。</p>
<ol>
<li>第一个拟阵 $M_1=(E,\mathcal{I_1})$ ，满足左部点的每个点的度数至多为 $1$ 。</li>
<li>第二个拟阵 $M_2=(E,\mathcal{I_2})$ ，满足右部点的每个点的度数至多为 $1$ 。</li>
</ol>
<p>拟阵交即可。</p>
<p>其实如果思考一下，会发现拟阵交找的增广路和匈牙利算法找的是一样的。</p>
<h3 id="最小树形图"><a href="#最小树形图" class="headerlink" title="最小树形图"></a>最小树形图</h3><p>给定带权有向图 $G=(V,E)$ ，求以 $root$ 为根的最小权外向树。</p>
<ol>
<li>第一个拟阵 $M_1=(E,\mathcal{I_1})$ ，满足把有向边看成无向边无环。</li>
<li>第二个拟阵 $M_2=(E,\mathcal{I_2})$ ，除 $root$ 之外入度至多为 $1$ ，$root$ 入度为 $0$ 。</li>
</ol>
<p>然后用带权拟阵交。</p>
<h3 id="Colorful-Tree"><a href="#Colorful-Tree" class="headerlink" title="Colorful Tree"></a>Colorful Tree</h3><p>给定带权无向图 $G=(V,E)$ ，每条边有一个 $1$ 到 $n-1$ 的颜色，求一个最大权的生成树，满足每个颜色恰好出现一次。</p>
<ol>
<li>第一个拟阵 $M_1=(E,\mathcal{I_1})$ ，无环。</li>
<li>第二个拟阵 $M_2=(E,\mathcal{I_2})$ ，每个颜色至多出现一次。</li>
</ol>
<p>带权拟阵交。</p>
<h1 id="一些拟阵的操作"><a href="#一些拟阵的操作" class="headerlink" title="一些拟阵的操作"></a>一些拟阵的操作</h1><p>在理解接下来的操作时，推荐用基的定义去理解，优先考虑基的变化，会很有助于理解这个拟阵在这个操作后会发生什么变化。</p>
<h2 id="对偶拟阵"><a href="#对偶拟阵" class="headerlink" title="对偶拟阵"></a>对偶拟阵</h2><p>定义：对于拟阵 $M=(S,\mathcal{I})$ ，定义 $M$ 的对偶拟阵 $M^{<em>}=(S,\mathcal{I^</em>})$ ，其中 $I^*=\{U\subset S:{\exists}基I\in \mathcal{I},I\subset S\setminus U\}$ 。</p>
<p>遗传性显然，现在证明交换性：</p>
<details class="toggle" ><summary class="toggle-button" style="">交换性的证明</summary><div class="toggle-content"><p>假设 $|U_1|&gt;|U_2|$ ，设基 $I_1\subset S\setminus U_1,I_2\subset S\setminus U_2$ 。</p>
<p>设基 $I_3=I_1\setminus U2$ ，然后用 $I_2$ 去扩张 $I_3$ 成基 $I_4$ 。</p>
<p>那么 $|I_4\cap U_1|\le|I_4\setminus I_3|\le |U_2|-|U_1\cap U_2|&lt; |U_1|-|U_1\cap U_2|$ 。</p>
<p>显然 $I_4\subset S\setminus U_2$ ，所以显然 ${\exists} z\in U_1\setminus U_2: U_2+\{z\}\in \mathcal{I_2}$ 。</p>
</div></details>
<p>对偶拟阵的秩函数：</p>
<p>$r^<em>(U)=\max\limits_{I\subset U,I\subset I^</em>}|I|=\max\limits_{B是M中的基}|U\setminus B|=|U|-\min\limits_{B是M中的基}|U\cap B|=|U|-r(S)+\max\limits_{B是M中的基}|B\cap (S\setminus U)|=|U|-r(S)+r(S\setminus U)$</p>
<p>也可以用秩函数证明这是个拟阵，在这里就不展开讲了，不是很麻烦，可以自证。</p>
<p>对偶拟阵的用途很广，他代表了一般拟阵的另外一个方面，举个例子：图拟阵的对偶就是去掉哪些边仍能保证图是联通的。</p>
<p>对偶拟阵实际上就是把所有基的补集作为了基的集合定义的拟阵。</p>
<h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><p>对于拟阵 $M=(S,I)$ ，和 $Z\subset S$ ，定义拟阵 $M$ 删除子集 $Z$ 的拟阵为 $(S\setminus Z,\mathcal{I’}), \mathcal{I’}=\{I:I\subset S\setminus Z, I\in \mathcal{I}\}$ 。记为 $M\setminus Z$ 。</p>
<p>这个操作非常好理解，就是只考虑和 $Z$ 没有交集的独立集，秩函数直接用原来的就行，非常的简单。</p>
<h2 id="收缩"><a href="#收缩" class="headerlink" title="收缩"></a>收缩</h2><p>对于拟阵 $M=(S,I)$ ，和 $Z\subset S$ ，定义拟阵 $M$ 删除子集 $Z$ 的拟阵为 $(M^<em>\setminus Z)^</em>$ 。记为 $M/Z$ 。</p>
<p>由于是用上面两个操作定义的，所以显然是个拟阵。</p>
<p>这个操作理解起来会比较困难。</p>
<p>考虑 $M/Z$ 的基，首先得是 $M^<em>\setminus Z$ 的基的补集，$M^</em>\setminus Z$ 的基又得是 $M^<em>$ 中和 $Z$ 交集最小的基去掉交集部分的集合，而 $M^</em>$ 中和 $Z$ 交集最小的基对应的是 $M$ 中和 $Z$ 交集最大的基的补集。</p>
<p>综上，可以得出，$M/Z$ 的基是原来和 $Z$ 交集最大的基去掉交集的部分，同理，独立集也是类似的。</p>
<p>当然也可以从秩的角度考虑，这里不再赘述，直接给出秩函数的式子：</p>
<p>$r_{M/Z}(U)=r_M(Z\cup U)-r_M(Z)$ 。</p>
<p>例子：图拟阵中的缩边操作。</p>
<h2 id="极小元"><a href="#极小元" class="headerlink" title="极小元"></a>极小元</h2><p>对于一个拟阵，经过一系列删除和收缩操作得到的任意拟阵 $M’$ ，称作拟阵 $M$ 的极小元。</p>
<h1 id="拟阵并"><a href="#拟阵并" class="headerlink" title="拟阵并"></a>拟阵并</h1><h2 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a>定义</h2><p>对于给定的 $k$ 个拟阵 $M_i=(S_i,\mathcal{I_i}),1\le i\le k$ 。定义这 $k$ 个拟阵的并为 $M=(S,\mathcal{I})$ ，其中 $S=\bigcup\limits_{i=1}^k S_i,\mathcal{I}=\{\bigcup\limits_{i=1}^k I_i:I_i\in \mathcal{I_i}\}$ 。</p>
<p>遗传性非常简单，重点是交换性。</p>
<details class="toggle" ><summary class="toggle-button" style="">交换性的证明</summary><div class="toggle-content"><p>不妨认为 $|I|&lt;|I’|$</p>
<p>不妨这么考虑一个事情，首先不妨认为：$I_i\cap I_j=\emptyset,i\ne j$ 。</p>
<p>同理对于 $I’_i$ 也是。</p>
<p>这样 $|I|=\sum\limits|I_i|,|I’|=\sum\limits|I’_i|$ 。</p>
<p>所以一定存在 $i:|I’_i|&gt;|I_i|$ ,所以考虑一定存在 $x\in I’_i,I_i+\{x\}\in \mathcal{I_i}$ ，如果 $x\in \mathcal{I}$ ，则说明 $x\in I_j,i\ne j$ ，所以令 $I_j$ 删掉 $x$ ，$I_i$ 加上 $x$ ，然后重新进行这个过程，反之，则交换性成立。</p>
<p>由于 $\sum\limits |I_i\cap I’_i|$ 会不断变大，所以这个过程一定会停下来，即交换性一定成立，证毕。</p>
<p>论文是一开始就找使 $\sum\limits |I_i\cap I’_i|$ 最大的 $I_i$ ，所以不用重复这个过程。</p>
</div></details>
<h2 id="秩函数-1"><a href="#秩函数-1" class="headerlink" title="秩函数"></a>秩函数</h2><script type="math/tex; mode=display">r_M(U)=\min\limits_{T\subset U}(|T|+\sum\limits_{i=1}^k r_{M_i}((U\setminus T)\cap S_i))</script><p>要证明这个定理，我们需要证明一个引理：</p>
<p><strong>引理 6.1</strong> ：拟阵 $\hat{M}=(\hat{S},\hat{\mathcal{I}})$ ，定义函数 $f:\hat{S}\to S$ ，定义拟阵 $M=(S,\mathcal{I}),I=\{f(\hat{I})\:\hat{I}\in\hat{\mathcal{I}}\}$ ，则 $M$ 的秩函数为：</p>
<script type="math/tex; mode=display">r_M(U)=\min\limits_{T\subset U}(r_{\hat{M}}(f^{-1}(U\setminus T))+|T|)</script><p>注 ： $f^{-1}(T)=\{x\in\hat{U}:f(x)\in T\}$ 。</p>
<details class="toggle" ><summary class="toggle-button" style="">证明</summary><div class="toggle-content"><p>这个证明不需要证明这是个拟阵，但是这并不难证，交换性的证明，和拟阵并交换性的证明是几乎一样的。（也可以先证了秩函数再导出其是个拟阵）</p>
<p>考虑构造一个划分拟阵 $(\hat{S},\mathcal{I_p})$ ，其中 $I\in \mathcal{I_p}$ 当且仅当 $I$ 中不存在两个元素 $f$ 的映射值相等。</p>
<p>这样的话，$r_M(U)$ 实际上就是拟阵 $\hat{M}$ 和 $(\hat{S},\mathcal{I_p})$ 限制在 $f^{-1}(U)$ 集合的拟阵交，用最小最大定理便可证明。</p>
</div></details>
<p>用引理证明秩函数并不困难，令 $S_i$ 中的元素 $e$ 变成二元元素 $(e,i)$ ，从而区分开所有的元素，再构造函数 $f((e,i))=e$ 即可得证。</p>
<h6 id="坑4"><a href="#坑4" class="headerlink" title="坑4"></a>坑4</h6><p>后面那些判断独立集啥的，还有表示法啥的还没有学，以后再说，先咕咕了，得去做些题目了，太久没敲代码手感不对了，现在。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>国家集训队2018论文：《浅谈拟阵的一些拓展及其应用》—- 江苏省淮阴中学 杨乾澜</p>
<p>图片生成：<a href="https://csacademy.com/app/graph_editor/">https://csacademy.com/app/graph_editor/</a></p>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>拟阵</tag>
      </tags>
  </entry>
  <entry>
    <title>组合计数练习</title>
    <url>/2024/02/01/%E7%BB%84%E5%90%88%E8%AE%A1%E6%95%B0%E7%BB%83%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="括号序列和折线法"><a href="#括号序列和折线法" class="headerlink" title="括号序列和折线法"></a>括号序列和折线法</h1><p>一个经典的问题：一个括号序列的最长的合法括号子序列有多长。</p>
<h2 id="折线法解决经典问题"><a href="#折线法解决经典问题" class="headerlink" title="折线法解决经典问题"></a>折线法解决经典问题</h2><p>不难发现，每一个左括号，也就是上升的部分，我们总能指定他右边和他同高度的右括号，然后消掉。</p>
<p><img src="1.png" alt=""></p>
<p>所以消到最后，我们总是会得到一条先下降后上升的折线，可以发现，这样子消不会改变整个折线的最低点，所以，<strong>一个指定起终点的折线，其最长的合法括号子序列取决于这条折线的最低点</strong> 。</p>
<p>这也是用折线法解决括号序列问题会非常方便的原因。</p>
<h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><ol>
<li><p>指定起终点，问最低点低于某个高度的折线数量。</p>
<p>对应在括号序列：指定左括号和右括号的数量，限制最长合法括号序列的长度小于某个值。</p>
<p>做法就是折一下就行了。</p>
</li>
<li><p>有多少个折线满足 $(0,0)\to(len,0)$ 且在 $y=0$ 上方，且恰好有 $m$ 个点在 $y$ 轴上。</p>
<p>对应在括号序列：有多少个合法的括号序列满足可以恰好分成 $m-1$ 份，使得满足每一份都是：$(A)$ ，$A$ 是一个合法的括号序列。</p>
<p>做法就是：考虑每次要到 $y=0$ 的那一段就去掉，认为起点是在 $(1,1)$ ，同时整条折线不能碰到 $y=0$ 这条线，则答案等价于从 $(1,1)\to (len-m+1,m-1)$ 的折线数量。（认为起点在 $(1,1)$ 是因为我们要求这条线不能碰到 $y=0$ ）</p>
<p><img src="3.png" alt=""></p>
</li>
</ol>
<h1 id="使用排列计算概率的方法"><a href="#使用排列计算概率的方法" class="headerlink" title="使用排列计算概率的方法"></a>使用排列计算概率的方法</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>有些时候，一些问题会涉及到等概率选择一些剩余的点，并且删除这个点和一些与这个点有关联的点集，然后问关于这个过程的一些概率或者是数量问题，就可以尝试使用这个方法。</p>
<p>这个方法的关键在于：考虑将被删除这个操作看成一个删除标记，只有当一个点被选中，才会被真正的删除，这样每个点恰好被选一次，只不过，如果选中了一个点有删除标记，就重新选（这个点也视作已经被选了，真正删除掉），直到选到没有标记的为止，由于没有标记的点数量不变，所以每个点在各种情况下被选中的概率不变。</p>
<p>形式化的表述就是：对于任意一个排列，其对应的情况为：每个点有被选中当且仅当能删除他的节点都在他后面，而选中的先后顺序就是排列的先后顺序。</p>
<p>则一种情况的概率就是能对应到这种情况的排列的出现概率。</p>
<p>这样，就把计算概率，变成了统计符合条件的排列数量。</p>
<h2 id="练习-1"><a href="#练习-1" class="headerlink" title="练习"></a>练习</h2><ol>
<li><p>现在有 $n$ 个数字，每次选择一个没被删除的数字，并且删除这个数字的所有倍数，问每个数字被选中的概率。</p>
<p>设 $d(i)$ 为 $i$ 的约数个数，显然答案就是 $\frac{1}{d(i)}$ 。</p>
</li>
<li><p>给定一个 $DAG$ ，每次选择一个没被删除的点，然后删除他能到达的所有点，问期望进行几轮。</p>
<p>期望可以转化为求每个点被选中的概率和，一个点被选中的概率为 $\frac{1}{能到达他的点的数量}$ 。</p>
</li>
<li><p>给定一个数字 $n$ ，令 $n=等概率选择1到n-1中的一个数字$ ，直到 $n\le k$ ，问期望轮数。</p>
<p>同理：可以看成是每个点可以删除所有 $\ge$ 他的点，和上一题基本一样，答案就是所有 $&gt;k$ 的点的经过概率之和。</p>
<p>答案为：$1+\sum\limits_{i=k+1}^{n-1}\frac{1}{i}$ 。</p>
<p>这道题目还有个加强版，但是做法基本一样，讨论一下就行了：<a href="https://codeforces.com/contest/1924/problem/E">Codeforces Round 921 Div.1 E.Paper Cutting Again</a></p>
<p>题目大意：给定 $n*m$ 的纸，每次可以等概率选择 $n-1$ 条整数横线或者 $m-1$ 条整数竖线，剪开然后丢掉下面或者右边的部分，问当面积小于 $k$ 时至多需要多少轮。</p>
<p>$n,m\le 10^{6},2\le k\le 10^{12}$  </p>
</li>
</ol>
<h1 id="图计数"><a href="#图计数" class="headerlink" title="图计数"></a>图计数</h1><h2 id="练习-2"><a href="#练习-2" class="headerlink" title="练习"></a>练习</h2><ol>
<li><p>求 $n$ 个有标号点的无向图的数量。</p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>容斥原理，枚举 $1$ 号点的连通块大小就行了。</p>
<script type="math/tex; mode=display">f_i=2^{\frac{i(i-1)}{2}}-\sum\limits_{j=1}^{i-1}\binom{i-1}{j-1}*f_{j}*2^{\frac{(i-j)(i-j-1)}{2}}</script><p>时间复杂度：$O(n^2)$ 。</p>
</div></details></li>
<li><p>求 $n$ 个有标号的点的边双联通图的数量。</p>
<details class="toggle" ><summary class="toggle-button" style="">DP做法</summary><div class="toggle-content"><p>方法 1 ：设 $dp[i][j]$ 表示有 $j$ 个点，恰好有 $i$ 个连通块的图的权值和（一个图的权值定义为每个连通块大小的乘积），然后枚举 $1$ 号点所在的边双大小进行容斥。</p>
<p>设 $f_i$ 表示 $i$ 个点的联通块数量， $g_i$ 表示 $i$ 个点的边双联通块数量。</p>
<script type="math/tex; mode=display">g_i=f_i-\sum\limits_{j=1}^{i-1}\binom{i-1}{j-1}*g_{j}*\sum\limits_{k=1}^{i-j}dp[k][i-j]*j^{k}</script><p>方法 2 ：设 $dp[i][j]$ 表示有 $j$ 个点，恰好有 $i$ 个点双连通块且点双之间不连通的图的权值和（一个图的权值定义，为每个点双连通块大小的乘积）。</p>
<p>显然：$dp[i][j]=\sum\limits_{k=1}^{j-(i-1)}dp[i-1][j-k]<em>\binom{j-1}{k-1}</em>k*g_k$ 。</p>
<p>注意到，先固定一个 $j$ ，除了 $dp[1][j]$ 以外的 $dp[i][j]$ 的转移都不依赖 $g_j$ ，所以考虑先处理出 $dp[i][j],(i\ne 1)$ ，然后用容斥算出 $g_j$ ，然后再求 $dp[1][j]$ ，从而完成 $dp[i][j]$ 对所有 $i$ 的转移。</p>
<p>实现上就是 $j$ 从小到达枚举，每一层先对 $i\ne 1$进行转移，再求 $g_j$ ，再求 $dp[1][j]$ 即可。</p>
<p>至于容斥的式子：$g_j=f_j-\sum\limits_{i=2}^{i}dp[i][j]*j^{i-2}$ 。</p>
<p>时间复杂度：$O(n^3)$ 。</p>
<p>方法 $1$ 更加自然，方法 $2$ 主要是感觉 $dp$ 顺序非常的奇妙，所以就记录一下。</p>
</div></details>
</li>
</ol>
<h1 id="一些奇奇怪怪的方法"><a href="#一些奇奇怪怪的方法" class="headerlink" title="一些奇奇怪怪的方法"></a>一些奇奇怪怪的方法</h1><h2 id="必定经过的事件集"><a href="#必定经过的事件集" class="headerlink" title="必定经过的事件集"></a>必定经过的事件集</h2><p>想法来自：</p>
<p><a href="https://www.luogu.com.cn/blog/xuanxuan001/solution-cf1924e">https://www.luogu.com.cn/blog/xuanxuan001/solution-cf1924e</a></p>
<h3 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h3><p>当你想要求一个事件的概率时，可以找一些其他事件，使得这个事件集必然发生，且在这个事件集发生的条件下，这个事件集内的每个事件的发生概率固定，那么就可以知道我们想要的事件的概率。</p>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><ol>
<li><p><a href="https://codeforces.com/contest/1924/problem/E">Codeforces Round 921 Div.1 E.Paper Cutting Again</a></p>
<p>题目大意：给定 $n*m$ 的纸，每次可以等概率选择 $n-1$ 条整数横线或者 $m-1$ 条整数竖线，剪开然后丢掉下面或者右边的部分，问当面积小于 $k$ 时至多需要多少轮。</p>
<p>$n,m\le 10^{6},2\le k\le 10^{12}$  </p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>假设纸张为 $(n’,m’)$。</p>
<p>不难想到先转化为 $(n’=x,m’=y):xy\ge k$ 的事件的经过概率之和。</p>
<p>那么经过 $(x,y)$ 的概率有多少呢？</p>
<p>不妨先假设 $m=y$ 。</p>
<p>不难发现，第一次使得 $n’\le x$ 或者 $m’&lt;m$ 的事件集构成了一个必然事件集，且内部的事件都是等概率的。</p>
<p>所以使得 $n’=x,m’=m$ 的概率为：$\frac{1}{x+m-1}$ 。</p>
<p>那么当 $x&lt;n,y&lt;m$ 如何处理？</p>
<p>首先，我们得求得第一次使得 $n’=x,m’=y$ 的概率，类似的，令第一次 $n’\le x$ 或者 $m’\le y$ 构成一个事件集，所以 $n’=x$ 或者 $m’=y$ 的概率为 $\frac{2}{x+y}$ ，然后剩下的情况就和前面的情况一样了，概率为 $\frac{1}{x+y-1}$ ，乘在一起就是：$\frac{2}{(x+y)(x+y-1)}$ 。</p>
<p>然后裂项求个和就可以在 $O(n+m)$ 的时间得到答案了。</p>
</div></details></li>
</ol>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>计数</tag>
      </tags>
  </entry>
  <entry>
    <title>求图上最大异或和路径的证明</title>
    <url>/2024/02/27/%E6%B1%82%E5%9B%BE%E4%B8%8A%E6%9C%80%E5%A4%A7%E5%BC%82%E6%88%96%E5%92%8C%E8%B7%AF%E5%BE%84%E7%9A%84%E8%AF%81%E6%98%8E/</url>
    <content><![CDATA[<p>还记得 OI 时期有一道典的不能再典的题目：给一张图，求一条从 $s$ 到 $t$ 的最大异或和的路径。</p>
<p>一个很典的结论是：跑一棵生成树，然后把这棵生成树上的环全部拿下来做个线性基，然后用任意一条 $s\to t$ 的路径丢进线性基里求最大值。</p>
<p>之前一直不知道怎么证明。</p>
<p>现在来证明一手：</p>
<p>不妨假设图中只有一个联通图。</p>
<p>可以发现，答案路径和随便一条路径的对称差满足每个点的度数都为  $0$ ，我们不妨把所有满足所有点度数为 $0$ 的边集集中到一个集合 $S$ 。</p>
<p>显然，不仅路径的对称差属于 $S$ ，$S$ 的任意一个元素都显然可以称为路径的对称差，因此，任意一条路径的异或和，和答案的异或值，可以且仅可以是 $S$ 中某个元素的异或值。</p>
<p>然后在这个集合上定义一种类似异或的运算：对应两个集合 $X,Y$ ，这种运算的返回结果为：$(X\cup Y)\setminus(X\cap Y)$ ，下面直接称这种运算为异或。</p>
<p>显然这个运算是封闭的（即结果还在这个集合内），显然这个结构能够像线性基一样定义基（把存在或不存在看成 $0/1$ 就可以直接看成线性基了），如果能够证明基的大小是 $m-(n-1)$ ，那么这个问题就解决了。</p>
<p>考虑生成树用到的边集 $E_1$ ，那么显然 $E\setminus E_1$ 中的每个元素都会生成一个环，这下环构成的集合我们称为 $S’$ ，显然 $S’\subset S$ ，且 $S’$ 线性无关，现在我们证明这个组合能够表示出 $S$ 就行了。</p>
<p>对于任意一个 $S$ 的元素 $L$，对于 $L$ 中非 $E_1$ 的元素，我们将他们拉出来异或，得到元素 $L’$ ，显然 $L,L’$ 在 $E\setminus  E_1$ 的部分是相同的，而在 $E_1$ 的部分，显然也能根据树的结构以及度数都为 $0$ 这一性质证明是相同的，这样，就构造性的证明了 $L’=L$ ，因此 $S’$ 就是 $S$ 的一组基。</p>
<p>证毕。</p>
<p>说起来，现在用异或的角度观察图的结构发现，图的结构其实和向量空间很像，不过只有一个运算。</p>
<p>同时从拟阵的角度来看，图拟阵和有限的向量空间都是拟阵。</p>
<p>太神奇了，可惜碍于我浅薄的知识面，无法看见更加深层次的联系，实在可惜。</p>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
  </entry>
  <entry>
    <title>经典trick汇总</title>
    <url>/2023/09/04/%E7%BB%8F%E5%85%B8trick%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<details class="toggle" ><summary class="toggle-button" style="">时间复杂度</summary><div class="toggle-content"><details class="toggle" ><summary class="toggle-button" style="">分数之和</summary><div class="toggle-content"><ol>
<li>$O(\sum\limits_{i=1}^{n})=O(\log{n})$ （调和级数）</li>
<li>$O(\sum\limits_{i=1}^n)=O(1)$ （可以用积分、裂项证明，也可以搜搜’巴塞尔问题’，这个式子收敛于 $\frac{\pi^2}{6}$ ）</li>
</ol>
</div></details></div></details>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>ACM杂类</tag>
      </tags>
  </entry>
</search>
