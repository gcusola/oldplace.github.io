<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>2023-2024 ICPC Asia Jakarta Regional Contest K. Deck-Building Game</title>
    <url>/2024/03/21/2023-2024-ICPC-Asia-Jakarta-Regional-Contest-K-Deck-Building-Game/</url>
    <content><![CDATA[<p>题目链接：<a href="https://codeforces.com/contest/1906/problem/K">https://codeforces.com/contest/1906/problem/K</a></p>
<p>题目大意：在原数组找出两堆异或值相同的数值，问有多少种找法，可以为空，每个数字可以不在任何一堆，两堆有标号。</p>
<details class="toggle" ><summary class="toggle-button" style="">所有做法的基础</summary><div class="toggle-content"><p>一个显然的事情，这道题目相当于求 $\prod\limits_{i=1}^n(1+2x^{a_i})$ ，这里的乘法是异或卷积。</p>
<p>为了快速计算这个乘积，有了很多种搞法。</p>
</div></details>
<details class="toggle" ><summary class="toggle-button" style="">题解做法</summary><div class="toggle-content"><p>题解做法的优点就是比较自然。</p>
<p>显然这个可以分治 FWT ，但是 FWT 不同于 FFT ，分治了值域不变，不改变复杂度。</p>
<p>咋整，观察到如果分治区间是 $[l,r)$ ，那么实际上这个区间乘出来的非 $0$ 项只能落在 $[0,r-l),[l,r)$ ，直接拿出左区间的两个非 $0$ 区间和右区间的两个非 $0$ 区间互相乘一下就行了，这样能做到时间复杂度：$O(V\log^2 V)$ 。</p>
<p>代码：<a href="https://codeforces.com/contest/1906/submission/235539466">https://codeforces.com/contest/1906/submission/235539466</a></p>
</div></details>
<details class="toggle" ><summary class="toggle-button" style="">我的做法</summary><div class="toggle-content"><p>我的做法和题解想法基本一致，唯一一点不同的是，对于 $(r-l)=2^l$ ，那么二进制下 $l$ 位都是一样的，因此对于二进制位剩下的位置，要么和 $[l,r)$ 里面的每个数字一样，代表异或了奇数次，要么全是 $0$ ，代表异或了偶数次。</p>
<p>所以我们不妨给每个数字的最高位填个 $1$ ，代表了这个数字异或次数的奇偶性即可。</p>
<p>时间复杂度仍然是：$O(V\log^2 V)$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> LL mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> L=<span class="number">17</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> SN=(<span class="number">1</span>&lt;&lt;L);</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FWT</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;f,<span class="type">const</span> <span class="type">int</span> C[<span class="number">2</span>][<span class="number">2</span>],<span class="type">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(f.<span class="built_in">size</span>()==len);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> t=<span class="number">1</span>;t&lt;len;t&lt;&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">0</span>;l&lt;len;l+=t+t)&#123;</span><br><span class="line">            <span class="type">int</span> r=l+t;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;t;i++)&#123;</span><br><span class="line">                <span class="type">int</span> x=f[l+i],y=f[r+i];</span><br><span class="line">                f[l+i]=(<span class="number">1ll</span>*C[<span class="number">0</span>][<span class="number">0</span>]*x+<span class="number">1ll</span>*C[<span class="number">0</span>][<span class="number">1</span>]*y)%mod;</span><br><span class="line">                f[r+i]=(<span class="number">1ll</span>*C[<span class="number">1</span>][<span class="number">0</span>]*x+<span class="number">1ll</span>*C[<span class="number">1</span>][<span class="number">1</span>]*y)%mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> Cxor[<span class="number">2</span>][<span class="number">2</span>]=&#123;&#123;<span class="number">1</span>,<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,mod<span class="number">-1</span>&#125;&#125;;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> Ixor[<span class="number">2</span>][<span class="number">2</span>]=&#123;&#123;(mod+<span class="number">1</span>)/<span class="number">2</span>,(mod+<span class="number">1</span>)/<span class="number">2</span>&#125;,&#123;(mod+<span class="number">1</span>)/<span class="number">2</span>,mod-(mod+<span class="number">1</span>)/<span class="number">2</span>&#125;&#125;;</span><br><span class="line"><span class="type">int</span> n,a[N*<span class="number">2</span>];</span><br><span class="line">LL fc[N],nfc[N],f2[N];</span><br><span class="line"><span class="function">LL <span class="title">C</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;<span class="keyword">return</span> fc[x]*nfc[y]%mod*nfc[x-y]%mod;&#125;</span><br><span class="line">vector&lt;array&lt;<span class="type">int</span>,2&gt;&gt; <span class="built_in">solve</span>(<span class="type">int</span> dep,<span class="type">int</span> l,<span class="type">int</span> r)&#123;</span><br><span class="line">    <span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">        vector&lt;array&lt;<span class="type">int</span>,2&gt; &gt; ans;</span><br><span class="line">        ans.<span class="built_in">push_back</span>(&#123;<span class="number">0</span>,<span class="number">0</span>&#125;);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=a[l];i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i&amp;<span class="number">1</span>)ans[<span class="number">0</span>][<span class="number">0</span>]=(ans[<span class="number">0</span>][<span class="number">0</span>]+<span class="built_in">C</span>(a[l],i)*f2[i])%mod;</span><br><span class="line">            <span class="keyword">else</span> ans[<span class="number">0</span>][<span class="number">1</span>]=(ans[<span class="number">0</span>][<span class="number">1</span>]+<span class="built_in">C</span>(a[l],i)*f2[i])%mod;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">auto</span> lans=<span class="built_in">solve</span>(dep<span class="number">-1</span>,l,mid);</span><br><span class="line">    <span class="keyword">auto</span> rans=<span class="built_in">solve</span>(dep<span class="number">-1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; lf;lf.<span class="built_in">resize</span>(<span class="number">1</span>&lt;&lt;(dep+<span class="number">1</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;(<span class="number">1</span>&lt;&lt;(dep<span class="number">-1</span>));i++)&#123;</span><br><span class="line">        <span class="keyword">auto</span> [f0,f1]=lans[i];</span><br><span class="line">        lf[i]=f0;</span><br><span class="line">        lf[i+(<span class="number">1</span>&lt;&lt;dep)]=f1;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; rf;rf.<span class="built_in">resize</span>(<span class="number">1</span>&lt;&lt;(dep+<span class="number">1</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;(<span class="number">1</span>&lt;&lt;(dep<span class="number">-1</span>));i++)&#123;</span><br><span class="line">        <span class="keyword">auto</span> [f0,f1]=rans[i];</span><br><span class="line">        rf[i]=f0;</span><br><span class="line">        rf[i+(<span class="number">1</span>&lt;&lt;(dep<span class="number">-1</span>))+(<span class="number">1</span>&lt;&lt;dep)]=f1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">FWT</span>(lf,Cxor,(<span class="number">1</span>&lt;&lt;(dep+<span class="number">1</span>)));</span><br><span class="line">    <span class="built_in">FWT</span>(rf,Cxor,(<span class="number">1</span>&lt;&lt;(dep+<span class="number">1</span>)));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;(<span class="number">1</span>&lt;&lt;(dep+<span class="number">1</span>));i++)lf[i]=<span class="number">1ll</span>*lf[i]*rf[i]%mod;</span><br><span class="line">    <span class="built_in">FWT</span>(lf,Ixor,(<span class="number">1</span>&lt;&lt;(dep+<span class="number">1</span>)));</span><br><span class="line">    vector&lt;array&lt;<span class="type">int</span>,2&gt; &gt; ans;ans.<span class="built_in">resize</span>(<span class="number">1</span>&lt;&lt;dep);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;(<span class="number">1</span>&lt;&lt;dep);i++)&#123;</span><br><span class="line">        ans[i]=&#123;lf[i],lf[i+(<span class="number">1</span>&lt;&lt;dep)]&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    fc[<span class="number">0</span>]=fc[<span class="number">1</span>]=nfc[<span class="number">0</span>]=nfc[<span class="number">1</span>]=f2[<span class="number">0</span>]=<span class="number">1</span>;f2[<span class="number">1</span>]=<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)nfc[i]=(mod-mod/i)*nfc[mod%i]%mod;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)nfc[i]=nfc[i<span class="number">-1</span>]*nfc[i]%mod,fc[i]=fc[i<span class="number">-1</span>]*i%mod,f2[i]=f2[i<span class="number">-1</span>]*<span class="number">2</span>%mod;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="type">int</span> x;<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">        a[x]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">auto</span> ans=<span class="built_in">solve</span>(L,<span class="number">0</span>,(<span class="number">1</span>&lt;&lt;L)<span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,(ans[<span class="number">0</span>][<span class="number">0</span>]+ans[<span class="number">0</span>][<span class="number">1</span>])%mod);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></details>
<details class="toggle" ><summary class="toggle-button" style="">我的做法改进</summary><div class="toggle-content"><p>发现一个事情，矩阵为 $\begin{bmatrix} 1 &amp; 1\ 1 &amp; -1 \end{bmatrix}$ 的 FWT （即异或的 FWT）最终的结果其实可以写成这样：</p>
<script type="math/tex; mode=display">f[i]=\sum\limits_{i=0}^{L}(-1)^{popcount(i\And j)}a[j]</script><p>利用这个式子，可以改进分治 FWT 。</p>
<p>不妨假设：$(r-l)=2^l$ ，显然左区间的值域在 $[0,2^l)$ （高位补了 $1$ 判断奇偶性），现在要扩充到 $[0,2^{l+1})$ ，扩充规则为给原来的每个下表在最高位（算前导 $0$ ）下面塞个 $0$ （右区间塞 $1$） ，然后在剩下的位置补 $0$ 。</p>
<p>然后根据上面的式子可以利用变化前的点值，在线性时间得到变化后的点值。（具体见代码）</p>
<p>然后直接乘就行了，时间复杂度：$O(V\log{V})$ 。</p>
<p>这个做法相比较于下面的做法，或许不是最妙的，但是是最适用的，因为不依赖于系数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> LL mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> L=<span class="number">17</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> SN=(<span class="number">1</span>&lt;&lt;L);</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FWT</span><span class="params">(LL *f,<span class="type">const</span> LL C[<span class="number">2</span>][<span class="number">2</span>],<span class="type">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> t=<span class="number">1</span>;t&lt;len;t&lt;&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">0</span>;l&lt;len;l+=t+t)&#123;</span><br><span class="line">            <span class="type">int</span> r=l+t;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;t;i++)&#123;</span><br><span class="line">                LL x=f[l+i],y=f[r+i];</span><br><span class="line">                f[l+i]=(C[<span class="number">0</span>][<span class="number">0</span>]*x+C[<span class="number">0</span>][<span class="number">1</span>]*y)%mod;</span><br><span class="line">                f[r+i]=(C[<span class="number">1</span>][<span class="number">0</span>]*x+C[<span class="number">1</span>][<span class="number">1</span>]*y)%mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> LL Cxor[<span class="number">2</span>][<span class="number">2</span>]=&#123;&#123;<span class="number">1</span>,<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,mod<span class="number">-1</span>&#125;&#125;;</span><br><span class="line"><span class="type">const</span> LL Ixor[<span class="number">2</span>][<span class="number">2</span>]=&#123;&#123;(mod+<span class="number">1</span>)/<span class="number">2</span>,(mod+<span class="number">1</span>)/<span class="number">2</span>&#125;,&#123;(mod+<span class="number">1</span>)/<span class="number">2</span>,mod-(mod+<span class="number">1</span>)/<span class="number">2</span>&#125;&#125;;</span><br><span class="line"><span class="type">int</span> n,a[N*<span class="number">2</span>];</span><br><span class="line">LL fc[N],nfc[N],f2[N];</span><br><span class="line"><span class="function">LL <span class="title">C</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;<span class="keyword">return</span> fc[x]*nfc[y]%mod*nfc[x-y]%mod;&#125;</span><br><span class="line">LL f[<span class="number">2</span>][N*<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;(<span class="number">1</span>&lt;&lt;L);i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=a[i];j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(j&amp;<span class="number">1</span>)f[<span class="number">1</span>][i]=(f[<span class="number">1</span>][i]+<span class="built_in">C</span>(a[i],j)*f2[j])%mod;</span><br><span class="line">            <span class="keyword">else</span> f[<span class="number">0</span>][i]=(f[<span class="number">0</span>][i]+<span class="built_in">C</span>(a[i],j)*f2[j])%mod;</span><br><span class="line">        &#125;</span><br><span class="line">        LL lf=f[<span class="number">0</span>][i],rf=f[<span class="number">1</span>][i];</span><br><span class="line">        f[<span class="number">0</span>][i]=(lf+rf)%mod;</span><br><span class="line">        f[<span class="number">1</span>][i]=(lf+mod-rf)%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> t=<span class="number">1</span>;t&lt;=L;t++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;(<span class="number">1</span>&lt;&lt;L);i+=(<span class="number">1</span>&lt;&lt;t))&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> l=i;l&lt;i+(<span class="number">1</span>&lt;&lt;(t<span class="number">-1</span>));l++)&#123;</span><br><span class="line">                <span class="type">int</span> r=l+(<span class="number">1</span>&lt;&lt;(t<span class="number">-1</span>));</span><br><span class="line">                LL l0=f[<span class="number">0</span>][l],l1=f[<span class="number">1</span>][l];</span><br><span class="line">                LL l00=l0,l01=l0;</span><br><span class="line">                LL l10=l1,l11=l1;</span><br><span class="line">                </span><br><span class="line">                LL r0=f[<span class="number">0</span>][r],r1=f[<span class="number">1</span>][r];</span><br><span class="line">                LL r00=r0,r01=r1;</span><br><span class="line">                LL r10=r1,r11=r0;</span><br><span class="line"></span><br><span class="line">                f[<span class="number">0</span>][l]=l00*r00%mod;</span><br><span class="line">                f[<span class="number">0</span>][r]=l01*r01%mod;</span><br><span class="line">                f[<span class="number">1</span>][l]=l10*r10%mod;</span><br><span class="line">                f[<span class="number">1</span>][r]=l11*r11%mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">FWT</span>(f[<span class="number">0</span>],Ixor,(<span class="number">1</span>&lt;&lt;L));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    fc[<span class="number">0</span>]=fc[<span class="number">1</span>]=nfc[<span class="number">0</span>]=nfc[<span class="number">1</span>]=f2[<span class="number">0</span>]=<span class="number">1</span>;f2[<span class="number">1</span>]=<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)nfc[i]=(mod-mod/i)*nfc[mod%i]%mod;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)nfc[i]=nfc[i<span class="number">-1</span>]*nfc[i]%mod,fc[i]=fc[i<span class="number">-1</span>]*i%mod,f2[i]=f2[i<span class="number">-1</span>]*<span class="number">2</span>%mod;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="type">int</span> x;<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">        a[x]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,f[<span class="number">0</span>][<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></details>
<details class="toggle" ><summary class="toggle-button" style="">深刻观察法</summary><div class="toggle-content"><p>来自比赛 Announcement 评论区。</p>
<p>发现一个事情，矩阵为 $\begin{bmatrix} 1 &amp; 1\ 1 &amp; -1 \end{bmatrix}$ 的 FWT （即异或的 FWT）最终的结果其实可以写成这样：</p>
<script type="math/tex; mode=display">f[i]=\sum\limits_{i=0}^{L}(-1)^{popcount(i\And j)}a[j]</script><p>同时又观察到，结果只能是 $-1$ 或者 $3$ ，那么这有什么用呢？</p>
<p>思考一下，FWT 和 FFT 有一个很重要的不同，就是 FWT 不需要扩展数组，因为下标值域不会扩展，所以 FWT 实际上能算出所有多项式的点值表达式直接乘起来然后再逆回去，而 FFT 是不行的（除非一开始就把所有的多项式算出充足的点值）。</p>
<p>但是算出所有多项式的点值表达式的时间开销仍然很大，第一种做法采用了分治 FWT 来加速这个过程，但是这里，我们直接观察出了 FWT 后的结果长啥样，那我们是不是可以不用 FWT ，直接算出结果呢？</p>
<p>显然，求 $\prod f_k[i]$ 只需要算出有多少个 $-1$ 或者有多少个 $3$ 就行了。</p>
<p>有了这个思路，就有很多种搞法了。</p>
<p>我使用的做法是：$n=even+odd$ ，那么只需要令 $a[x]=x的出现次数$ ，然后直接跑 FWT ，就可以知道每个位置的 $even-odd$ ，然后就可以直接算出来 $-1$ 和 $3$ 的个数了。</p>
<p>还有别的搞法，例如：SOS dp，但是因为感觉这个的转移式子和 FWT 没什么本质区别，就不再赘述了，放个这个做法的代码： <a href="https://codeforces.com/contest/1906/submission/235477273">https://codeforces.com/contest/1906/submission/235477273</a> 。</p>
<p>时间复杂度：$O(V\log{V})$ 的，空间复杂度：$O(V)$，$V$ 是值域。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> LL mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> NN=<span class="number">2e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> L=(<span class="number">1</span>&lt;&lt;<span class="number">17</span>);</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FWT</span><span class="params">(LL *f,<span class="type">const</span> LL C[<span class="number">2</span>][<span class="number">2</span>],<span class="type">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> t=<span class="number">1</span>;t&lt;len;t&lt;&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">0</span>;l&lt;len;l+=t+t)&#123;</span><br><span class="line">            <span class="type">int</span> r=l+t;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;t;i++)&#123;</span><br><span class="line">                LL x=f[l+i],y=f[r+i];</span><br><span class="line">                f[l+i]=(C[<span class="number">0</span>][<span class="number">0</span>]*x+C[<span class="number">0</span>][<span class="number">1</span>]*y)%mod;</span><br><span class="line">                f[r+i]=(C[<span class="number">1</span>][<span class="number">0</span>]*x+C[<span class="number">1</span>][<span class="number">1</span>]*y)%mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">LL f3[N],a[NN];</span><br><span class="line">LL Cxor[<span class="number">2</span>][<span class="number">2</span>]=&#123;&#123;<span class="number">1</span>,<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,mod<span class="number">-1</span>&#125;&#125;;</span><br><span class="line">LL Ixor[<span class="number">2</span>][<span class="number">2</span>]=&#123;&#123;(mod+<span class="number">1</span>)/<span class="number">2</span>,(mod+<span class="number">1</span>)/<span class="number">2</span>&#125;,&#123;(mod+<span class="number">1</span>)/<span class="number">2</span>,mod-(mod+<span class="number">1</span>)/<span class="number">2</span>&#125;&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    f3[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="type">int</span> x;<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">        a[x]++;</span><br><span class="line">        f3[i]=f3[i<span class="number">-1</span>]*<span class="number">3</span>%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">FWT</span>(a,Cxor,L);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;L;i++)&#123;</span><br><span class="line">        <span class="type">int</span> num=a[i];</span><br><span class="line">        <span class="keyword">if</span>(num&gt;n)num-=mod;</span><br><span class="line">        <span class="comment">//n=f+z,num=z-f;</span></span><br><span class="line">        <span class="type">int</span> z=(n+num)/<span class="number">2</span>,f=(n-num)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(f&amp;<span class="number">1</span>)a[i]=(mod-f3[z])%mod;</span><br><span class="line">        <span class="keyword">else</span> a[i]=f3[z];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">FWT</span>(a,Ixor,L);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,a[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></details>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>FWT</tag>
        <tag>计数</tag>
        <tag>分治</tag>
      </tags>
  </entry>
  <entry>
    <title>AGC035 赛后总结</title>
    <url>/2024/05/25/AGC035-%E8%B5%9B%E5%90%8E%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>比赛链接：<a href="https://atcoder.jp/contests/agc035/tasks">https://atcoder.jp/contests/agc035/tasks</a></p>
<h1 id="A-XOR-Circle"><a href="#A-XOR-Circle" class="headerlink" title="A. XOR Circle"></a>A. XOR Circle</h1><p>题目链接：<a href="https://atcoder.jp/contests/agc035/tasks/agc035_a">https://atcoder.jp/contests/agc035/tasks/agc035_a</a></p>
<p>题目大意：把 $n$ 个数字放在一个环上，满足任意相邻的三个数字 $A,B,C$ 都满足： $A\otimes C = B$ 。</p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>不妨假设前三个数字为 $A,B,A\otimes B$ ，那么我们可以得到后面的数字为：$A,B,A\otimes B…$ ，可以看到 $3$ 是这个圆的周期。</p>
<p>因此，如果 $n$ 是 $3$ 的倍数，就是有三组 $n$ 个数字且异或和为 $0$ 。</p>
<p>否则就是所有数字都是 $0$ 。</p>
<p>时间复杂度：$O(n\log{n})$ ，而且不难做到 $O(n)$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n, a[N];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">pd</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a[l] == a[r];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(a + <span class="number">1</span>, a + n + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(n % <span class="number">3</span> != <span class="number">0</span>) <span class="keyword">return</span> <span class="built_in">pd</span>(<span class="number">1</span>, n) &amp;&amp; !a[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">pd</span>(<span class="number">1</span>, n / <span class="number">3</span>) &amp;&amp; <span class="built_in">pd</span>(n / <span class="number">3</span> + <span class="number">1</span>, n / <span class="number">3</span> * <span class="number">2</span>) &amp;&amp; <span class="built_in">pd</span>(n / <span class="number">3</span> * <span class="number">2</span> + <span class="number">1</span>, n) &amp;&amp; (a[n / <span class="number">3</span>] ^ a[n / <span class="number">3</span> * <span class="number">2</span>] ^ a[n]) == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">solve</span>()) cout &lt;&lt; <span class="string">&quot;Yes\n&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;No\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></details>
<h1 id="B-Even-Degrees"><a href="#B-Even-Degrees" class="headerlink" title="B. Even Degrees"></a>B. Even Degrees</h1><p>题目链接：<a href="https://atcoder.jp/contests/agc035/tasks/agc035_b">https://atcoder.jp/contests/agc035/tasks/agc035_b</a></p>
<p>题目大意：给每条边定个向，满足每个点的出度为偶数。</p>
<details class="toggle" ><summary class="toggle-button" style="">题解</summary><div class="toggle-content"><p>这个问题可以等价的转化为一个经典问题：能不能进行边匹配，满足匹配边之间有一个公共点。（无重边）</p>
<p>这个问题有解的条件是：连通且边数为偶数。</p>
<p>做法是：把 $DFS$ 树建出来，然后把所有返祖边存在子树内，然后从下到上，依次把每个点的非父亲边两两匹配，如果剩下一条就和父亲边匹配，如果没有，就把父亲边像返祖边一样丢给父亲，显然在边数为偶数的情况下，这样一定能匹配完所有的边。</p>
<p>时间复杂度：$O(n)$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> y, next;</span><br><span class="line">&#125;a[N * <span class="number">2</span>]; <span class="type">int</span> len, las[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ins</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    a[++len] = &#123;y, las[x]&#125;;</span><br><span class="line">    las[x] = len;</span><br><span class="line">&#125;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; gfa[N];</span><br><span class="line"><span class="type">int</span> fa[N], dfn[N], ti;</span><br><span class="line"><span class="type">int</span> n, m, sta[N], top;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    dfn[x] = ++ti;</span><br><span class="line">    sta[++top] = x;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k = las[x]; k; k = a[k].next)&#123;</span><br><span class="line">        <span class="type">int</span> y = a[k].y;</span><br><span class="line">        <span class="keyword">if</span>(y == fa[x]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(dfn[y] &amp;&amp; dfn[y] &lt; dfn[x]) gfa[x].<span class="built_in">push_back</span>(y);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(!dfn[y])&#123;</span><br><span class="line">            fa[y] = x;</span><br><span class="line">            <span class="built_in">dfs</span>(y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; y &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">if</span>(m &amp; <span class="number">1</span>)&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;-1\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">        <span class="type">int</span> x, y;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        <span class="built_in">ins</span>(x, y);</span><br><span class="line">        <span class="built_in">ins</span>(y, x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(gfa[i].<span class="built_in">size</span>() &gt;= <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="type">int</span> x = gfa[i].<span class="built_in">back</span>();</span><br><span class="line">            gfa[i].<span class="built_in">pop_back</span>();</span><br><span class="line">            <span class="type">int</span> y = gfa[i].<span class="built_in">back</span>();</span><br><span class="line">            gfa[i].<span class="built_in">pop_back</span>();</span><br><span class="line">            <span class="built_in">print</span>(i, x);</span><br><span class="line">            <span class="built_in">print</span>(i, y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = n; i &gt;= <span class="number">1</span>; i--)&#123;</span><br><span class="line">        <span class="type">int</span> now = sta[i];</span><br><span class="line">        <span class="keyword">while</span>(gfa[now].<span class="built_in">size</span>() &gt;= <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="type">int</span> x = gfa[now].<span class="built_in">back</span>();</span><br><span class="line">            gfa[now].<span class="built_in">pop_back</span>();</span><br><span class="line">            <span class="type">int</span> y = gfa[now].<span class="built_in">back</span>();</span><br><span class="line">            gfa[now].<span class="built_in">pop_back</span>();</span><br><span class="line">            <span class="built_in">print</span>(now, x);</span><br><span class="line">            <span class="built_in">print</span>(now, y);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!gfa[now].<span class="built_in">size</span>()) gfa[fa[now]].<span class="built_in">push_back</span>(now);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">print</span>(now, gfa[now][<span class="number">0</span>]), <span class="built_in">print</span>(now, fa[now]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>update ：</p>
<p>在看完题解后，感觉自己像个小丑，我这个做法完全可以这么翻译：</p>
<p>我在 $DFS$ 树上给非树边定向后，从下到上，对于每个点，如果出边为奇数，那么就把父亲边调转，何必多次一举去做匹配的过程。</p>
<p>或者说可以这么考虑，发现匹配过程得到的匹配对是完全没有用的，我们完全可以假装我们匹配过了，然后直接把点的所有非父亲边弹出，并根据数量决定需不需要父亲边。</p>
<p>还是写复杂了。</p>
</div></details>
<h1 id="C-Skolem-XOR-Tree"><a href="#C-Skolem-XOR-Tree" class="headerlink" title="C. Skolem XOR Tree"></a>C. Skolem XOR Tree</h1><p>题目链接：<a href="https://atcoder.jp/contests/agc035/tasks/agc035_c">https://atcoder.jp/contests/agc035/tasks/agc035_c</a></p>
<p>题目大意：给你 $2n$ 个点，$i,i+n$ 的权值都是 $n$ ，要求你构造一棵树，满足 $i,i+n$ 路径（包括端点）的异或和为 $i$ 。</p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>不懂，感觉现在不会构造题啊，比赛时被这道题卡了一路。</p>
<p>首先注意到一个事情：$n=2^n$ 无解。</p>
<p>剩下的情况，如果 $n$ 是奇数的话，我们注意到可以：</p>
<p>$1$ 放中间，然后 $2k,2k+1$ 这样子放：$2k, 2k+1, 1, 2k, 2k+1$ 。</p>
<p>而 $1$ 的匹配可以随便找一个 $2k,2k+1$ 放在其屁股后面。</p>
<p>如果 $n$ 是偶数，那么假设 $n = k + t$ ，其中 $k,t$ 的或为 $0$ ，那么可以通过走 $k,k+1$ 和 $t,t+1$ 的路来跑出 $n$ 的路。</p>
<p><img src="1.png" alt=""></p>
<p>时间复杂度：$O(n)$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="keyword">return</span> x &amp; -x;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; y &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">lowbit</span>(n) == n)&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;No\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Yes\n&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">3</span>; i &lt;= n; i += <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="built_in">print</span>(i - <span class="number">1</span>, i);</span><br><span class="line">        <span class="built_in">print</span>(i, <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">print</span>(<span class="number">1</span>, i - <span class="number">1</span> + n);</span><br><span class="line">        <span class="built_in">print</span>(i - <span class="number">1</span> + n, i + n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">print</span>(n + <span class="number">1</span>, n + <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">if</span>(n % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="type">int</span> x = <span class="built_in">lowbit</span>(n);</span><br><span class="line">        <span class="type">int</span> y = n ^ x;</span><br><span class="line">        <span class="built_in">print</span>(n, x + <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">print</span>(n + n, y + n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></details>
<h1 id="D-Add-and-Remove"><a href="#D-Add-and-Remove" class="headerlink" title="D. Add and Remove"></a>D. Add and Remove</h1><p>题目链接：<a href="https://atcoder.jp/contests/agc035/tasks/agc035_d">https://atcoder.jp/contests/agc035/tasks/agc035_d</a></p>
<p>题目大意：给你 $n$ 个数字，每次可以选择相邻的三个数字，把中间的数字删掉并且加到旁边两个数字，问最后剩下的两个数字之和的最小值。</p>
<details class="toggle" ><summary class="toggle-button" style="">我的做法</summary><div class="toggle-content"><p>一种很新的状压 $dp$ 。</p>
<p>首先不大可能同时考虑整个序列，毕竟被删的位置没法决定当前的状态，和删除的顺序也有关，因此逐个位置考虑。</p>
<p>发现一个事情，一个数字删除后在的位置一定是相邻的两个格子，而其对最终答案的贡献取决于其这两个格子左右删除的顺序。</p>
<p>因此我们可以设一个 $dp[state]$ ，$state$ 表示当前这个数字对应的删除顺序。</p>
<p>然后直接转移就行了。</p>
<p>时间复杂度：$O(n2^n)$ 。</p>
<p>感觉这个状压 $dp$ 非常的有意思。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> B = <span class="number">16</span>;</span><br><span class="line">LL dp[<span class="number">2</span>][(<span class="number">1</span> &lt;&lt; B)];</span><br><span class="line">LL cnt[(<span class="number">1</span> &lt;&lt; B)], a[B + <span class="number">5</span>];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">gethighbit</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="keyword">return</span> <span class="number">31</span> - __builtin_clz(x);&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getbit</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>&#123;<span class="keyword">return</span> (x &gt;&gt; y) &amp; <span class="number">1</span>;&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">changebit</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> k)</span></span>&#123;<span class="keyword">return</span> x ^ ((<span class="built_in">getbit</span>(x, y) ^ k) &lt;&lt; y);&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="keyword">return</span> x &amp; -x;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cnt[<span class="number">1</span>] = <span class="number">2ll</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> x = <span class="number">0</span>; x &lt; (<span class="number">1</span> &lt;&lt; i); x++)&#123;</span><br><span class="line">            <span class="type">int</span> tmp = x;</span><br><span class="line">            LL lc = <span class="number">1ll</span>, rc = <span class="number">1ll</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; j++)&#123;</span><br><span class="line">                <span class="type">int</span> now = tmp &amp; <span class="number">1</span>;</span><br><span class="line">                tmp &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(!now) rc = rc + lc;</span><br><span class="line">                <span class="keyword">else</span> lc = lc + rc;</span><br><span class="line">            &#125;</span><br><span class="line">            cnt[<span class="built_in">changebit</span>(x, i, <span class="number">1</span>)] = lc + rc;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    n -= <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n + <span class="number">1</span>; i++)&#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">0</span>)&#123;</span><br><span class="line">        cout &lt;&lt; a[<span class="number">0</span>] + a[<span class="number">1</span>] &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> now = <span class="number">0</span>, pre = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">memset</span>(dp[now], <span class="number">20</span>, <span class="built_in">sizeof</span>(dp[now]));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) dp[now][(<span class="number">1</span> &lt;&lt; i) - <span class="number">1</span>] = a[<span class="number">0</span>] + a[n + <span class="number">1</span>] + cnt[(<span class="number">1</span> &lt;&lt; i) - <span class="number">1</span>] * a[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        now ^= <span class="number">1</span>; pre ^= <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">memset</span>(dp[now], <span class="number">20</span>, <span class="built_in">sizeof</span>(dp[now]));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> state = <span class="number">1</span>; state &lt; (<span class="number">1</span> &lt;&lt; (n - <span class="number">1</span>)); state++)&#123;</span><br><span class="line">            <span class="type">int</span> nexstate = state &lt;&lt; <span class="number">1</span>;</span><br><span class="line">            dp[now][nexstate] = <span class="built_in">min</span>(dp[now][nexstate], dp[pre][state]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> state = <span class="number">1</span>; state &lt; (<span class="number">1</span> &lt;&lt; (n - <span class="number">1</span>)); state++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(__builtin_popcount(state) &gt; (n - i)) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="type">int</span> nexstate = (state &lt;&lt; <span class="number">1</span>) | <span class="number">1</span>;</span><br><span class="line">            dp[now][nexstate] = <span class="built_in">min</span>(dp[now][nexstate], dp[now][state]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> state = <span class="number">1</span>; state &lt; (<span class="number">1</span> &lt;&lt; n); state++)&#123;</span><br><span class="line">            <span class="type">int</span> next1 = <span class="built_in">lowbit</span>(state);</span><br><span class="line">            <span class="keyword">if</span>(next1 != state)&#123;</span><br><span class="line">                next1 = __lg(next1);</span><br><span class="line">                <span class="type">int</span> nexstate = (state &gt;&gt; (next1 + <span class="number">1</span>));</span><br><span class="line">                dp[now][nexstate] = <span class="built_in">min</span>(dp[now][nexstate], dp[pre][state]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> state = <span class="number">1</span>; state &lt; (<span class="number">1</span> &lt;&lt; n); state++)&#123;</span><br><span class="line">            dp[now][state] += a[i] * cnt[state];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    LL ans = dp[now][<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; (<span class="number">1</span> &lt;&lt; n); i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(__builtin_popcount(i) == <span class="number">1</span>) ans = <span class="built_in">min</span>(ans, dp[now][i]);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是这个做法又可以优化的空间吗？</p>
<p>我们来精细计算一下：</p>
<p>对于一个 $k$ 位的状态，其有效的区间是 $n-k$ 。</p>
<p>因此实际上有效的状态为：$\sum\limits_{i=0}^n 2^{i}(n-i)=\sum\limits_{i=0}^{n-1}\sum\limits_{j=0}^i2^{j}=\sum\limits_{i=0}^{n-1}2^{i+1}-1=2^{n+1}-(n+2)$ 。</p>
<p>所以如果在 $dp$ 的时候只考虑有效状态的话，实际上是 $O(2^n)$ 的。</p>
<p>能够实现出来吗？$cnt$ 的计算使用位运算技巧可以做到 $2^n$ ，而 $dp$ 如果使用 vector 提前把所有可行状态存下来，也同样可以做到 $O(状态数)$，也就是 $O(2^n)$ 。</p>
<p>因此，上述 $dp$ 完全可以做到 $O(2^n)$ 的空间和时间，但是会比较难写。</p>
<p>对此我的评价是，完全不如正解。</p>
</div></details>
<details class="toggle" ><summary class="toggle-button" style="">正解</summary><div class="toggle-content"><p>有一种形式的 $dp$ 非常的好写，相较于其余的 $dp$ 。</p>
<p>就是记忆化形式的 $dp$ ，甚至有的时候可以去掉记忆化，那样就更好写了。</p>
<p>首先把 $a_1,a_n$ 给删掉，然后在数组两边放上两个变量 $L,R$ ，这样就变成了每次删除一个数字，然后把这个数字给放到两边，这样删完这个数组后得到的答案就是 $L+R$ 。</p>
<p>因此，倒着考虑每个区间最后被删除的数字是啥，我们就可以得到如下的 dp ：</p>
<p>$dp[l][r][cl][cr]$ 表示 $[l,r]$ 区间中的数字删完后，贡献为 $L<em>cl+R</em>cr$ 后的贡献最小值。</p>
<p>然后 $dp[l][r][cl][cr]=\min\limits_{l\le i\le r}(dp[l][i-1][cl][cl+cr]+dp[i+1][r][cl+cr][cr]+(cl+cr)*a[i])$ 。</p>
<p>然后用这个式子 $dp$ 就行了。</p>
<p>最后答案就是 $dp[1][n][1][1]+a[1]+a[n]$ 。</p>
<p>那么状态是多少呢？注意到这个的状态数计算和我的做法一样，都是 $\sum\limits_{i=0}^{n}2^{i}(n-i)$ ，也就是 $O(2^n)$ 。</p>
<p>而合法的转移数是 $\sum\limits_{i=0}^{n}2^{i}(n-i)^2$ ，也是 $O(2^n)$ 的.</p>
<p>注：$\sum\limits_{i=0}^{n}2^{i}(n-i)^k$ 都是 $O(2^n)$ 的。</p>
<p>因此如果使用记忆化的话时间复杂度为：$O(2^n*T)$ ，$T$ 为使用的数据结构的储存时间。</p>
<p>但是使用数据结构储存还是麻烦了，如果使用 map 还得自己写个四元组作为键。（貌似也可以使用 array<int,4>）</p>
<p>因此不妨考虑不记忆化，那么不记忆化的复杂度是多少呢？</p>
<p>设 $T(n)$ 表示一个长度为 $r-l+1=n$ 的递归复杂度，那么 $T(n)$ 满足：</p>
<p>$T(n)=\sum\limits_{i=0}^{n-1}2T(i)$</p>
<p>那么可以得到 $T(n)=3T(n-1)$ ，从而知道复杂度就是 $O(3^n)$ 。</p>
<p>这样代码就好写很多了。</p>
<p>这里粘一份别人的代码。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> a[<span class="number">25</span>];</span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> xl,<span class="type">int</span> xr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="keyword">if</span>(r-l&lt;=<span class="number">1</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> <span class="type">long</span> <span class="type">long</span> ans=<span class="number">1e18</span>;</span><br><span class="line"> <span class="keyword">for</span>(<span class="type">int</span> i=l+<span class="number">1</span>;i&lt;=r<span class="number">-1</span>;i++)</span><br><span class="line">  ans=<span class="built_in">min</span>(ans,<span class="built_in">dfs</span>(l,i,xl,xl+xr)+<span class="built_in">dfs</span>(i,r,xl+xr,xr)+a[i]*(xl+xr));</span><br><span class="line"> <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="type">int</span> n;</span><br><span class="line"> cin&gt;&gt;n;</span><br><span class="line"> <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">  cin&gt;&gt;a[i];</span><br><span class="line"> cout&lt;&lt;a[<span class="number">1</span>]+a[n]+<span class="built_in">dfs</span>(<span class="number">1</span>,n,<span class="number">1</span>,<span class="number">1</span>)&lt;&lt;endl;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//代码来源：https://www.luogu.com.cn/article/nuav36aw</span></span><br><span class="line"><span class="comment">//代码作者：StudyingFather</span></span><br></pre></td></tr></table></figure>
<p>怎么能想出这么好写的做法？</p>
<p>我不知道，我没想出来。</p>
<p>不过我觉得答案应该是：积累。</p>
</div></details>]]></content>
      <categories>
        <category>信息学</category>
      </categories>
  </entry>
  <entry>
    <title>AGC036 赛后总结</title>
    <url>/2024/05/27/AGC036-%E8%B5%9B%E5%90%8E%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>比赛链接：<a href="https://atcoder.jp/contests/agc036/tasks">https://atcoder.jp/contests/agc036/tasks</a></p>
<h1 id="A-Triangle"><a href="#A-Triangle" class="headerlink" title="A. Triangle"></a>A. Triangle</h1><p>题目链接：<a href="https://atcoder.jp/contests/agc036/tasks/agc036_a">https://atcoder.jp/contests/agc036/tasks/agc036_a</a></p>
<p>题目大意：要求构造一个整点三角形满足面积是 $\frac{S}{2}$ 。</p>
<details class="toggle" ><summary class="toggle-button" style="">我的做法</summary><div class="toggle-content"><p>首先注意到有一边平行于坐标轴就肯定构造不出 $S$ 是素数解的情况。</p>
<p>因此考虑这么一张图：</p>
<p><img src="1.png" alt=""></p>
<p>注意到上面的三角形在面积乘 $2$ 后相比正方形会删去浅蓝色区域，于是考虑以此为基础给一组构造。</p>
<p>于是就得到下面这么一个构造：</p>
<p>给一个 $h$ ，得到宽度：$w=\left \lceil \frac{S}{h} \right \rceil$ 。</p>
<p>设 $\epsilon = hw-S$ 。</p>
<p>那么其中一个点在 $(0,\epsilon)$ ，一个点在 $(w-1,h)$ ，一个点在 $(w,0)$ 。</p>
<p>由于长宽还有范围要求，所以建议直接把 $h$ 拉到能拉到的最大，但是在比赛时我的选择是 $\left\lceil\sqrt{n}\right\rceil$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(LL x, LL y)</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; y &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    LL n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    LL l = <span class="number">1</span>, r = <span class="number">1e9</span>, mid, ans;</span><br><span class="line">    <span class="keyword">while</span>(l &lt;= r)&#123;</span><br><span class="line">        mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(mid * mid &gt;= n)&#123;</span><br><span class="line">            ans = mid;</span><br><span class="line">            r = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    LL wide = (n + ans - <span class="number">1</span>) / ans;</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">0ll</span>, ans * wide - n);</span><br><span class="line">    <span class="built_in">print</span>(wide - <span class="number">1</span>, ans);</span><br><span class="line">    <span class="built_in">print</span>(wide, <span class="number">0</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还是麻烦了，可以不用写这个二分的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(LL x, LL y)</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; y &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    LL n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    LL ans = <span class="built_in">min</span>((LL)<span class="number">1e9</span>, n);</span><br><span class="line">    LL wide = (n + ans - <span class="number">1</span>) / ans;</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">0ll</span>, ans * wide - n);</span><br><span class="line">    <span class="built_in">print</span>(wide - <span class="number">1</span>, ans);</span><br><span class="line">    <span class="built_in">print</span>(wide, <span class="number">0</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></details>
<details class="toggle" ><summary class="toggle-button" style="">其余做法</summary><div class="toggle-content"><p>每日一个求三角形面积小技巧。</p>
<p>对于三点 $(x_1,y_1),(x_2,y_2),(x_3,y_3)$ ，其的面积就是 $|\frac12\begin{vmatrix}x_1&amp;y_1&amp;1\\x_2&amp;y_2&amp;1\\x_3&amp;y_3&amp;1\end{vmatrix}|$ 。</p>
<p>原理就是添加一个高度 $1$ ，然后在三维用行列式算其体积。</p>
<p>当然，如果 $x_1=y_1=0$ ，可以直接在二维中利用叉积计算面积，就是：$\frac{1}{2}|x_2y_3-x_3y_2|$ 。</p>
<p>因此，在本题中，我们不妨假设 $x_2=10^9,y_2=1$ 。</p>
<p>这样就可以得到 ：$y_3=\left\lceil\frac{S}{10^9}\right\rceil$ ，然后 $y_2=x_2y_3-S$ 。</p>
<p>显然不需要担心共线问题，因此共线的话上面算出来会是 $0$ ，不是 $0$ 就说明 $(x_2,y_2),(x_3,y_3)$。 不是共线的。</p>
</div></details>
<h1 id="B-Do-Not-Duplicate"><a href="#B-Do-Not-Duplicate" class="headerlink" title="B. Do Not Duplicate"></a>B. Do Not Duplicate</h1><p>题目链接：<a href="https://atcoder.jp/contests/agc036/tasks/agc036_b">https://atcoder.jp/contests/agc036/tasks/agc036_b</a></p>
<p>题目大意：给你一个长度为 $n$ 的数组和一个空栈，然后你可以对栈执行一个操作：</p>
<p>如果 $x$ 在栈，弹出到 $x$ 不在栈中，否则加入栈。</p>
<p>依次对数组从左到右每个元素执行此操作，重复这个过程 $K$ 次，问最后栈是啥。</p>
<details class="toggle" ><summary class="toggle-button" style="">我的做法</summary><div class="toggle-content"><p>注意到一个事情，一个栈会从非空到空当且仅当栈底元素进行了操作。</p>
<p>因此当栈为空加入 $x$ 时，下一次栈为空就是 $x$ 下一次入栈的时候，因此可以在数组上维护每个位置下一个出现相同数字的位置，实现出现空栈的位置的快速转移，而这个过程对于数组中每个位置，下一次出现空栈的位置是固定的。</p>
<p>所以会有循环，直接快速计算就行了。</p>
<p>等到最后不会出现空栈时，肯定只会剩下不超过 $n$ 个元素，直接模拟就行了。</p>
<p>时间复杂度：$O(n)$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> nex[N], n, las[N], m = <span class="number">2e5</span>;</span><br><span class="line"><span class="type">int</span> a[N * <span class="number">2</span>];</span><br><span class="line">LL pre[N], K;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getpos</span><span class="params">(LL x)</span></span>&#123;<span class="keyword">return</span> (x - <span class="number">1</span>) % n + <span class="number">1</span>;&#125;</span><br><span class="line"><span class="type">int</span> sta[N], top;</span><br><span class="line"><span class="type">bool</span> v[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = x; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!v[a[i]])&#123;</span><br><span class="line">            v[a[i]] = <span class="number">1</span>;</span><br><span class="line">            sta[++top] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(a[sta[top]] != a[i]) v[a[sta[top--]]] = <span class="number">0</span>;</span><br><span class="line">            v[a[sta[top--]]] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= top; i++) cout &lt;&lt; a[sta[i]] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; K;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">        a[i + n] = a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n + n; i++)&#123;</span><br><span class="line">        <span class="type">int</span> x = a[i];</span><br><span class="line">        <span class="keyword">if</span>(las[x] &amp;&amp; las[x] &lt;= n) nex[las[x]] = i - las[x] + <span class="number">1</span>;</span><br><span class="line">        las[x] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">fill</span>(pre + <span class="number">1</span>, pre + n + <span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">    <span class="type">int</span> pos;</span><br><span class="line">    LL limit = (K - <span class="number">1</span>) * n + <span class="number">1</span>, now = <span class="number">1ll</span>;</span><br><span class="line">    <span class="keyword">while</span>(now &lt; limit &amp;&amp; pre[pos = <span class="built_in">getpos</span>(now)] == <span class="number">-1</span>)&#123;</span><br><span class="line">        pre[pos] = now;</span><br><span class="line">        now += nex[pos];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(now &lt; limit)&#123; <span class="comment">//circle</span></span><br><span class="line">        LL T = now - pre[pos];</span><br><span class="line">        now += (limit - now) / T * T;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(now &lt; limit)&#123;</span><br><span class="line">        pos = <span class="built_in">getpos</span>(now);</span><br><span class="line">        now += nex[pos];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">solve</span>(<span class="built_in">getpos</span>(now));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>update：注意到这个有向图不只是每个点出度为 $1$ ，入度也为 $1$ ，因此每个点都在一个环上，所以代码可以更短更好写。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> nex[N], n, las[N], m = <span class="number">2e5</span>;</span><br><span class="line"><span class="type">int</span> a[N * <span class="number">2</span>];</span><br><span class="line">LL K;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getpos</span><span class="params">(LL x)</span></span>&#123;<span class="keyword">return</span> (x - <span class="number">1</span>) % n + <span class="number">1</span>;&#125;</span><br><span class="line"><span class="type">int</span> sta[N], top;</span><br><span class="line"><span class="type">bool</span> v[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = x; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!v[a[i]])&#123;</span><br><span class="line">            v[a[i]] = <span class="number">1</span>;</span><br><span class="line">            sta[++top] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(a[sta[top]] != a[i]) v[a[sta[top--]]] = <span class="number">0</span>;</span><br><span class="line">            v[a[sta[top--]]] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= top; i++) cout &lt;&lt; a[sta[i]] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; K;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">        a[i + n] = a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n + n; i++)&#123;</span><br><span class="line">        <span class="type">int</span> x = a[i];</span><br><span class="line">        <span class="keyword">if</span>(las[x] &amp;&amp; las[x] &lt;= n) nex[las[x]] = i - las[x] + <span class="number">1</span>;</span><br><span class="line">        las[x] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    LL ti = <span class="number">1ll</span>;</span><br><span class="line">    <span class="type">int</span> pos = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        ti += nex[pos];</span><br><span class="line">    &#125; <span class="keyword">while</span>((pos = <span class="built_in">getpos</span>(ti)) != <span class="number">1</span>);</span><br><span class="line">    K %= (ti - <span class="number">1</span>) / n;</span><br><span class="line">    <span class="keyword">if</span>(!K) K += (ti - <span class="number">1</span>) / n;</span><br><span class="line">    ti = <span class="number">1ll</span>;</span><br><span class="line">    <span class="keyword">while</span>(K * n - ti &gt;= n)&#123;</span><br><span class="line">        pos = <span class="built_in">getpos</span>(ti);</span><br><span class="line">        ti += nex[pos];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">solve</span>(<span class="built_in">getpos</span>(ti));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></details>
<h1 id="C-GP-2"><a href="#C-GP-2" class="headerlink" title="C. GP 2"></a>C. GP 2</h1><p>题目链接：<a href="https://atcoder.jp/contests/agc036/tasks/agc036_c">https://atcoder.jp/contests/agc036/tasks/agc036_c</a></p>
<p>题目大意：每次你可以选择两个数字进行操作，一个 $+1$ ，一个 $+2$ ，问进行 $M$ 次后有多少种不同的结果。</p>
<details class="toggle" ><summary class="toggle-button" style="">我的做法</summary><div class="toggle-content"><p>很有感觉的一道题目，难在既要找条件又要计数。</p>
<p>首先注意到一个事情：最大值必须 $\le 2M$ ，但是这显然不是充要的，注意到如果有超过 $M$ 个 $1$ ，那么肯定不是可行解。</p>
<p>由此又注意到只会有和 $M$ 奇偶性相同且 $\le M$ 个数字是奇数（事实上在和为 $3M$ 时这句话可以直接换成：$\le M$ 个数字是奇数）</p>
<p>那么这是充要的吗？是的，用归纳法证明一下就行了。</p>
<p>接下来就是计数，注意到我们可以枚举奇数的个数，然后把剩下的数字两个两个分，但是这样最大值可能爆 $2M$ ，但是注意到如果最大值 $&gt;2M$ ，那么奇数个数一定 $\le M$ ，所以所有最大值 $&gt;2M$ 的分配都会被恰好记一次，直接删去即可。</p>
<p>所以答案就是：$\sum\limits_{i=0}^{min(n,M)}\binom{n}{i}\binom{\frac{3M-i}{2}+n-1}{n-1}-\sum\limits_{i=2M+1}^{3M}\binom{n}{1}\binom{3M-i+n-2}{n-2}$ 。</p>
<p>时间复杂度：$O(n)$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e6</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> LL mod = <span class="number">998244353</span>;</span><br><span class="line">LL fc[N], nfc[N];</span><br><span class="line"><span class="function">LL <span class="title">C</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>&#123;<span class="keyword">return</span> fc[x] * nfc[y] % mod * nfc[x - y] % mod;&#125;</span><br><span class="line"><span class="function">LL <span class="title">xuan</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!y) <span class="keyword">return</span> <span class="number">0ll</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">C</span>(x + y - <span class="number">1</span>, y - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> lim)</span></span>&#123;</span><br><span class="line">    fc[<span class="number">0</span>] = fc[<span class="number">1</span>] = nfc[<span class="number">0</span>] = nfc[<span class="number">1</span>] = <span class="number">1ll</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= lim; i++) nfc[i] = (mod - mod / i) * nfc[mod % i] % mod;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= lim; i++) nfc[i] = nfc[i - <span class="number">1</span>] * nfc[i] % mod, fc[i] = fc[i - <span class="number">1</span>] * i % mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="built_in">init</span>(n + m + m);</span><br><span class="line">    LL ans = <span class="number">0ll</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= m &amp;&amp; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>((i &amp; <span class="number">1</span>) != (m &amp; <span class="number">1</span>)) <span class="keyword">continue</span>;</span><br><span class="line">        ans += <span class="built_in">xuan</span>((m * <span class="number">3</span> - i) / <span class="number">2</span>, n) * <span class="built_in">C</span>(n, i);</span><br><span class="line">        ans %= mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">        ans = (ans - n * <span class="built_in">xuan</span>(i, n - <span class="number">1</span>));</span><br><span class="line">        ans = (ans % mod + mod) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>update：最后容斥那个部分，还有一个组合意义，就是如果我直接把最大值减去 $2m+1$ ，那么就变成 $m-1$ 个数字分配，因此又可以写成：$n\binom{M+n-2}{n-1}$ 。</p>
<p>再看前面容斥的那个式子，可以写成：$n\sum\limits_{i=0}^{M-1}\binom{i+n-2}{n-2}$ ，在杨辉三角形上，其对应的一条斜线，所以可以写成：$n\binom{M+n-2}{n-1}$ 。</p>
<p>注意到上面的等式为：$\frac{1}{(n-2)!}\sum\limits_{i=0}^{M-1}\frac{(i+n-2)!}{i!}=\binom{M+n-2}{n-1}$ 。</p>
<p>这启示我们连续 $n$ 个数字相乘的和可以用组合数进行快速计算。</p>
</div></details>
<h1 id="D-Negative-Cycle"><a href="#D-Negative-Cycle" class="headerlink" title="D. Negative Cycle"></a>D. Negative Cycle</h1><p>题目链接：<a href="https://atcoder.jp/contests/agc036/tasks/agc036_d">https://atcoder.jp/contests/agc036/tasks/agc036_d</a></p>
<p>题目大意：现在有 $n-1$ 条不能删的边 ：$(i,i+1,0)$ ，同时又有 $n(n-1)$ 条边，对于 $i\to j$ ，如果 $i&lt;j$ ，边权就是 $-1$ ，反之为 $1$ ，问需要花多少代价删边后图中没有负环。</p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>非常有意思的一道题目，需要注意到负环和最短路之间密切的关系。</p>
<p>我们令 $d$ 数组为从 $1$ 开始跑最短路得到的数组，由于不能删的边的存在，$d$ 是非升的，显然，任何一个不存在负环的图都对应这么一个 $d$ ，我们希望在知道 $d$ 的情况下保留尽可能多的边。</p>
<p>注意到只能保留非同段的 $-1$ 和同段或者相邻段的 $1$ 。</p>
<p>因此直接设 $dp[i][j]$ 表示最后一段为 $[j+1][i]$ 的最小代价就行了。</p>
<p>时间复杂度：$O(n^3)$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> LL mod = <span class="number">998244353</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">5e2</span> + <span class="number">5</span>;</span><br><span class="line">LL dp[N][N], a[N][N], f[N];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="function">LL <span class="title">findans</span><span class="params">(<span class="type">int</span> l1, <span class="type">int</span> r1, <span class="type">int</span> l2, <span class="type">int</span> r2)</span></span>&#123;<span class="keyword">return</span> a[r1][r2] - a[l1 - <span class="number">1</span>][r2] - a[r1][l2 - <span class="number">1</span>] + a[l1 - <span class="number">1</span>][l2 - <span class="number">1</span>];&#125;</span><br><span class="line"><span class="function">LL <span class="title">queryf</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span>&#123;<span class="keyword">return</span> f[r] - f[l - <span class="number">1</span>];&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i == j) <span class="keyword">continue</span>;</span><br><span class="line">            cin &gt;&gt; a[i][j];</span><br><span class="line">            <span class="keyword">if</span>(i &lt; j) f[j] += a[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) f[i] += f[i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) a[i][j] += a[i - <span class="number">1</span>][j] + a[i][j - <span class="number">1</span>] - a[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">30</span>, <span class="built_in">sizeof</span>(dp));</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0ll</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= i; j++)&#123;<span class="comment">//j + 1 ~ i</span></span><br><span class="line">            <span class="comment">// if(i &amp;&amp; i == j) continue;</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k = i + <span class="number">1</span>; k &lt;= n; k++)&#123;</span><br><span class="line">                dp[k][i] = <span class="built_in">min</span>(dp[k][i], </span><br><span class="line">                        dp[i][j] + (<span class="built_in">queryf</span>(i + <span class="number">1</span>, k) - <span class="built_in">findans</span>(<span class="number">1</span>, i, i + <span class="number">1</span>, k)) + <span class="built_in">findans</span>(i + <span class="number">1</span>, k, <span class="number">1</span>, j));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    LL ans = dp[n + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) ans = <span class="built_in">min</span>(ans, dp[n][i]);</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></details>
<h1 id="E-ABC-String"><a href="#E-ABC-String" class="headerlink" title="E. ABC String"></a>E. ABC String</h1><p>题目链接：<a href="https://atcoder.jp/contests/agc036/tasks/agc036_e">https://atcoder.jp/contests/agc036/tasks/agc036_e</a></p>
<p>题目大意：给你一个只有 $A,B,C$ 的字符串，要求找到最长的一个子序列，满足相邻字符不同，而且每个字符出现次数相同。</p>
<details class="toggle" ><summary class="toggle-button" style="">我的做法</summary><div class="toggle-content"><p>又是屎中屎讨论，吐了。</p>
<p>注意到可以先把原串变成相邻字符不同，毕竟相邻的相同字符无论如果只会出现一次，因此这样子变换不会影响最终答案。</p>
<p>换一下字符，满足 $A\ge B\ge C$ （出现次数）。</p>
<p>然后注意到在不管 $A$ 的情况下，剩下的 $BC$ 可以分成若干段 $BCBCB…$ ，相邻段满足首位字母相同，例如：$BCB,BC,CB$ 。</p>
<p>注意到每一段中间的 $A$ 都可以删完，所以 $A$ 个数此时的下界为段数 $-1$ ，而且显然当前 $A$ 的个数和下界中间任何一个数字都能取到。</p>
<p>我们考虑先让 $B=C$ ，为了降低 $A$ 的下界（后面会看到，$A$ 的下界比较高的话，可能会在后面产生浪费），我们希望能最小化段数，因此明智的删法就是删每一段开头结尾的 $C$ ，然后缝合两段，由于 $C&gt;B$ ，总是存在这样的 $C$ 直到只剩下一段，这个时候就只能删开头了。</p>
<p>注意到这个过程中，每次删一个 $C$ ，也可能会删一个 $A$ ，但不会影响 $A\ge B\ge C$ 的偏序关系。</p>
<p>在 $B=C$ 后，如果下界 $\le C$ ，那么我们就可以得到一个取到上界的解，就是 $3C$ ，但是如果不是，注意到此时一定会有孤立的 $B,C$ ，删一个 $B,C$ （其实只要删 $B,C$ 的时候能让段数减少就行，但是直接删孤立的 $B,C$ 是最方便的），直到下界等于 $C$ 即可。</p>
<p>但是这为什么是对的呢？ $ans=3C$ 的情况可以理解，但是 $ans&lt;3C$ 的呢？注意到另外一个限制条件：段数，显然最终答案的段数 $-1$ 必须 $\le C$ ，而删一个 $B$ 或 $C$ 只能使段数 $-1$ ，由此可以证明这种情况已经取得了最优解。</p>
<p>理论上这就做完了，但是确实不好写。</p>
<p>我的实现思路是：</p>
<p>如果我们一直在字符串上操作，那不太好操作，因此我希望直接在段信息上操作，忽略所有的 $A$ ，然后在最后再通过匹配等方式补上一个合法的填 $A$ 的方案。</p>
<p>同时注意到上面那个做法删除的 $B,C$ 位置都是非常有讲究的。</p>
<p>不妨给去掉 $A$ 后的字符串每个 $B,C$ 贴上个原来的位置标签，然后在每次要删除 $B$ 或者 $C$ 时，找到最后面的同字符，满足这两个位置间的字符都是相同的，将操作变成删除这个字符，例如：$BBBBC$ ，本来要删除第一个 $B$ ，现在变成删除第四个 $B$ 。</p>
<p>这样子操作后，我们对剩下的字符串在原串中做能匹就匹的匹配，则每个字符的匹配位置和其位置标签一致。</p>
<p>不妨设匹配完后的位置为 $x_1,x_2,x_3…$ ，那么 $(x_1,x_2)$ 区间内，肯定只由 $B$ 或者 $C$ 和 $A$ 构成，具体是 $B$ 还是 $C$ 取决于 $x_1$ 是啥，其余区间同理。</p>
<p>例如：<strong>B</strong>ABABABA<strong>C</strong> ，加粗表示匹配上的位置。</p>
<p>那么在 $ans=3C$ 的时候，每个区间里面只有 $C$ ，因此我们删除 $C$ 后导致 $A$ 碰撞而必须删除的 $A$ 的数量 $\le C$ ，因此在 $x1,x2,…$ 之间可以塞的 $A$ 的数量 $\ge C$ 。</p>
<p>同理，如果 $ans&lt;3C$ ，那么下界也就是 $A$ 的数量和 $C$ 相等，此时不需要多塞，直接将 $A$ 塞入原来的 $BC$ 串直接做匹配就可以得到结果。</p>
<p>因此这样就得到了一种相对好写的复原方案的方法。</p>
<p>时间复杂度：$O(n)$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span> + <span class="number">5</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_char_array</span><span class="params">(<span class="type">char</span> *s)</span></span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">char</span> ss[N];</span><br><span class="line">    cin &gt;&gt; ss;</span><br><span class="line">    <span class="built_in">memcpy</span>(s + <span class="number">1</span>, ss, <span class="built_in">sizeof</span>(<span class="type">char</span>) * <span class="built_in">strlen</span>(ss));</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">char</span> st[N];</span><br><span class="line"><span class="type">int</span> n, a[N], cnt[<span class="number">4</span>], id[<span class="number">4</span>], be[<span class="number">4</span>];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;<span class="type">int</span> lt, rt, len;&#125; sta[N]; <span class="type">int</span> top;</span><br><span class="line">string ans, zans;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// assert(false);</span></span><br><span class="line">    <span class="built_in">get_char_array</span>(st);</span><br><span class="line">    n = <span class="built_in">strlen</span>(st + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">2</span>; i++) id[i] = i;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> pre = <span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="type">int</span> now = st[i] - <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span>(now != pre) a[++tmp] = now, cnt[now]++;</span><br><span class="line">            pre = now;</span><br><span class="line">        &#125;</span><br><span class="line">        n = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(id, id + <span class="number">3</span>, [](<span class="type">int</span> x, <span class="type">int</span> y)&#123;<span class="keyword">return</span> cnt[x] &gt; cnt[y];&#125;);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">2</span>; i++) be[id[i]] = i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) a[i] = be[a[i]];</span><br><span class="line">    <span class="built_in">sort</span>(cnt, cnt + <span class="number">3</span>, [](<span class="type">int</span> x, <span class="type">int</span> y)&#123;<span class="keyword">return</span> x &gt; y;&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> l = <span class="number">1</span>; l &lt;= n; l++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(l &lt;= n &amp;&amp; !a[l]) l++;</span><br><span class="line">        <span class="keyword">if</span>(l &gt; n) <span class="keyword">break</span>;</span><br><span class="line">        <span class="type">int</span> cnt0 = <span class="number">0</span>, now = a[l], r = l;</span><br><span class="line">        <span class="keyword">while</span>(r &lt; n &amp;&amp; a[r + <span class="number">1</span>] != now)&#123;</span><br><span class="line">            r++;</span><br><span class="line">            <span class="keyword">if</span>(a[r]) now = a[r];</span><br><span class="line">            <span class="keyword">else</span> cnt0++;</span><br><span class="line">        &#125;</span><br><span class="line">        sta[++top] = &#123;a[l], now, r - l + <span class="number">1</span> - cnt0&#125;;</span><br><span class="line">        l = r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= top; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!tmp || cnt[<span class="number">1</span>] == cnt[<span class="number">2</span>] || sta[i].lt == <span class="number">2</span>) sta[++tmp] = sta[i];</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                sta[tmp].rt = sta[i].rt;</span><br><span class="line">                sta[tmp].len += sta[i].len - <span class="number">1</span>;</span><br><span class="line">                cnt[<span class="number">1</span>]--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cnt[<span class="number">1</span>] == cnt[<span class="number">2</span>] + <span class="number">1</span> &amp;&amp; sta[<span class="number">1</span>].lt == <span class="number">1</span>)&#123;</span><br><span class="line">            cnt[<span class="number">1</span>]--;</span><br><span class="line">            sta[<span class="number">1</span>].lt = <span class="number">2</span>;</span><br><span class="line">            sta[<span class="number">1</span>].len--;</span><br><span class="line">            <span class="keyword">if</span>(!sta[<span class="number">1</span>].len)&#123;</span><br><span class="line">                <span class="built_in">assert</span>(tmp == <span class="number">1</span>);</span><br><span class="line">                tmp--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">assert</span>(cnt[<span class="number">1</span>] == cnt[<span class="number">2</span>]);</span><br><span class="line">        top = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!top)&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(top - <span class="number">1</span> &gt; cnt[<span class="number">1</span>])&#123;</span><br><span class="line">        <span class="type">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> goal = cnt[<span class="number">1</span>] - ((top - <span class="number">1</span>) - cnt[<span class="number">1</span>]);</span><br><span class="line">        <span class="built_in">assert</span>(goal &gt;= <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= top; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(sta[i].len == <span class="number">1</span> &amp;&amp; cnt[sta[i].lt] &gt; goal) cnt[sta[i].lt]--;</span><br><span class="line">            <span class="keyword">else</span> sta[++tmp] = sta[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">assert</span>(cnt[<span class="number">1</span>] == goal &amp;&amp; cnt[<span class="number">2</span>] == goal &amp;&amp; cnt[<span class="number">1</span>] == tmp - <span class="number">1</span>);</span><br><span class="line">        top = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= top; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>, now = sta[i].lt; j &lt;= sta[i].len; j++, now = <span class="number">3</span> - now) ans += now + <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span>(i != top) ans += <span class="string">&quot;A&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cnt[<span class="number">0</span>] = cnt[<span class="number">1</span>] - (top - <span class="number">1</span>);</span><br><span class="line">    <span class="type">int</span> now = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(now &lt; ans.<span class="built_in">length</span>() &amp;&amp; a[i] == ans[now] - <span class="string">&#x27;A&#x27;</span>)&#123;</span><br><span class="line">            zans += ans[now++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(!a[i] &amp;&amp; cnt[<span class="number">0</span>] &amp;&amp; (zans.<span class="built_in">empty</span>() || zans.<span class="built_in">back</span>() != <span class="string">&#x27;A&#x27;</span>) &amp;&amp; (now == ans.<span class="built_in">length</span>() || ans[now] != <span class="string">&#x27;A&#x27;</span>))&#123;</span><br><span class="line">            zans += <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">            cnt[<span class="number">0</span>]--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">assert</span>(!cnt[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">memset</span>(cnt, <span class="number">0</span>, <span class="built_in">sizeof</span>(cnt));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;c : zans) c = id[c - <span class="string">&#x27;A&#x27;</span>] + <span class="string">&#x27;A&#x27;</span>, cnt[c - <span class="string">&#x27;A&#x27;</span>]++;</span><br><span class="line">    <span class="built_in">assert</span>(cnt[<span class="number">0</span>] == cnt[<span class="number">1</span>] &amp;&amp; cnt[<span class="number">1</span>] == cnt[<span class="number">2</span>]);</span><br><span class="line">    cout &lt;&lt; zans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是即使相对好写，还是很难写，考场上我是肯定写不出来的。</p>
</div></details>
<details class="toggle" ><summary class="toggle-button" style="">正解</summary><div class="toggle-content"><p>上面的做法虽然说比较自然，但是正确性和实现都不好想。</p>
<p>不妨换个角度看待问题。</p>
<p>第一部分使 $C=B$ ，等价于如果有 $CAC$ 就删除到只剩下 $C$ 。</p>
<p>如果没有 $CAC$ ，但是 $B&gt;C$ ，那么就说明原串变成：$CBCBCB….C$ ，把开头或者结尾的 $C$ 删了就行。</p>
<p>然后对于第二部分，显然我们可以提前计算出我们需要删多少的 $B,C$ ，然后进行等量的 $BAB\to B,CAC\to C$ 的操作。</p>
<p>然后就是删 $A$ ，开头的 $A$ ，结尾的 $A$ ，以及 $BAC,CAB$ 中的 $A$ 删一下，删到 $A=C$ 为止，这样再看这个过程，是不是就清晰很多了呢？</p>
<p>虽然看起来还是很大便，但是实现上的细节少了很多，而且正确性更加容易理解了。</p>
<p>要是我在考场写这个做法，写出来的概率要比我原来的做法高得多。</p>
</div></details>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
  </entry>
  <entry>
    <title>AGC037 赛后总结</title>
    <url>/2024/05/28/AGC037-%E8%B5%9B%E5%90%8E%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>比赛链接：<a href="https://atcoder.jp/contests/agc037">https://atcoder.jp/contests/agc037</a></p>
<h1 id="A-Dividing-a-String"><a href="#A-Dividing-a-String" class="headerlink" title="A. Dividing a String"></a>A. Dividing a String</h1><p>题目链接：<a href="https://atcoder.jp/contests/agc037/tasks/agc037_a">https://atcoder.jp/contests/agc037/tasks/agc037_a</a></p>
<p>题目大意：将字符串分成若干个部分，满足相邻两个部分不相同。</p>
<details class="toggle" ><summary class="toggle-button" style="">我的做法</summary><div class="toggle-content"><p>我一开始的想法是基于贪心，有相同的字符就让后一个变成长度为 $2$ 的字符串。</p>
<p>然后如果在 $n-1$ 就直接把 $n-1,n$ 合并了。</p>
<p>但是在写博客的时候发现我当时漏考虑了一种情况：$aaaaa$ ，这种情况我的想法会分出：$a|aa|aa$ 。</p>
<p>但最终结果还是一样的，为啥？因为对于最后以个串，假设分成了：$a|aa|a|aa…|aa|aa$ ，那么一定能变成：$aa|a|aa|a…|a|aa$ 。</p>
<p>但是为什么这是最优解呢？</p>
<p>我们不妨先想一个弱化版问题，如果 $abcd$ 中 $b=c$ ，那么必须有 $ab,bc,cd$ 中的其中一个满足（$ab$ 指 $ab$ 在一个部分，其余同理）</p>
<p>这样，我们可以把原问题看成 $n-1$ 个数字，然后有一堆要求 $[l,r]$ 中必须删除一个数字的要求，而这个问题的答案显然是删除剩下区间中 $r$ 最小的区间的 $r$ 位置。</p>
<p>显然任何一个合法解都满足上述要求，而上面求出了在这个要求下需要的最小合并数，如果这个能够是解，则就是最优解。</p>
<p>然后讨论易证上面的这个最小合并数能够构造出一个合法解，然后就做完了。</p>
<p>时间复杂度：$O(n)$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">char</span> st[N];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_char_array</span><span class="params">(<span class="type">char</span> *s)</span></span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">char</span> ss[N];</span><br><span class="line">    cin &gt;&gt; ss;</span><br><span class="line">    <span class="built_in">memcpy</span>(s + <span class="number">1</span>, ss, <span class="built_in">sizeof</span>(<span class="type">char</span>) * <span class="built_in">strlen</span>(ss));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">get_char_array</span>(st);</span><br><span class="line">    n = <span class="built_in">strlen</span>(st + <span class="number">1</span>);</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i != n &amp;&amp; st[i] == st[i + <span class="number">1</span>])&#123;</span><br><span class="line">            <span class="keyword">if</span>(i == n - <span class="number">1</span>)&#123;</span><br><span class="line">                cnt += <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                cnt += <span class="number">2</span>;</span><br><span class="line">                i += <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; cnt &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></details>
<h1 id="B-RGB-Balls"><a href="#B-RGB-Balls" class="headerlink" title="B. RGB Balls"></a>B. RGB Balls</h1><p>题目链接：<a href="https://atcoder.jp/contests/agc037/tasks/agc037_b">https://atcoder.jp/contests/agc037/tasks/agc037_b</a></p>
<p>题目大意：给 $3N$ 个球， 红蓝黄个数相同，要求你给 $N$ 个人分球，满足每个人每个颜色各一个球，最小化每个人拿到的球的下标最大值减最小值之和。</p>
<details class="toggle" ><summary class="toggle-button" style="">我的做法</summary><div class="toggle-content"><p>我们可以这么想这个过程（用 $A,B,C$ 代表三个颜色）。</p>
<p>我们现在有一堆 $AB,A,AC…$ 然后进来一个新的颜色，我们希望去拿它匹配。</p>
<p>就比如说进来一个 $A$ 吧，那么，如果有现成的 $BC/CB$ 一定会去匹配，因为答案可以写成：$\sum\limits_{e_i-s_i}$ （$e_i$ 表示结束时间，$s_i$ 表示开始时间）。</p>
<p>证明就是交换，无论这个 $A$ 去和其他什么乱七八糟的东西匹配，最后和 $BC/CB$ 匹配的 $A’$ 交换，都会使答案下降。</p>
<p>同理，如果没有 $BC/CB$ ，但是有 $B/C$ ，也会去匹配，而不是单开一个，证明也是交换。</p>
<p>因此做法就出来了，当前剩下的对是固定的，而且和前缀每个颜色的个数有关，例如 $A&gt;B&gt;C$ ，那么就有 $A-B$ 个 $A$ ，$B-C$ 个 $AB/BA$ 。</p>
<p>根据这个 $dp$ 计数就行了。</p>
<p>时间复杂度：$O(n)$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> LL mod = <span class="number">998244353</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> B = <span class="number">5</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_char_array</span><span class="params">(<span class="type">char</span> *s)</span></span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">char</span> ss[N * <span class="number">3</span>];</span><br><span class="line">    cin &gt;&gt; ss;</span><br><span class="line">    <span class="built_in">memcpy</span>(s + <span class="number">1</span>, ss, <span class="built_in">sizeof</span>(<span class="type">char</span>) * <span class="built_in">strlen</span>(ss));</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n, now;</span><br><span class="line"><span class="type">char</span> st[N * <span class="number">3</span>];</span><br><span class="line"><span class="type">int</span> cnt[B], id[B], be[B];</span><br><span class="line"><span class="type">char</span> num[<span class="number">300</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    num[<span class="string">&#x27;R&#x27;</span>] = <span class="number">0</span>;</span><br><span class="line">    num[<span class="string">&#x27;G&#x27;</span>] = <span class="number">1</span>;</span><br><span class="line">    num[<span class="string">&#x27;B&#x27;</span>] = <span class="number">2</span>;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="built_in">get_char_array</span>(st);</span><br><span class="line">    LL ans = <span class="number">1ll</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">2</span>; i++) id[i] = i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n * <span class="number">3</span>; i++)&#123;</span><br><span class="line">        now = num[st[i]];</span><br><span class="line">        <span class="built_in">sort</span>(id, id + <span class="number">3</span>, [](<span class="type">int</span> x, <span class="type">int</span> y)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cnt[x] == cnt[y]) <span class="built_in">return</span> (x == now) &gt; (y == now);</span><br><span class="line">            <span class="keyword">return</span> cnt[x] &gt; cnt[y];</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= <span class="number">2</span>; j++) be[id[j]] = j;</span><br><span class="line">        <span class="keyword">if</span>(be[now] == <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">else</span> ans = ans * (cnt[id[be[now] - <span class="number">1</span>]] - cnt[now]) % mod;</span><br><span class="line">        cnt[now]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) ans = ans * i % mod;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不过这个做法在 $4$ 个及以上的颜色就爆了，只能 $3$ 个。</p>
<p>原因是：$ABACC$ ，在有了 $AB,A$ 后，由于 $ABC$ 不是成品，所以 $CC$ 可以以任意顺序匹配现有的串，导致性质失效，所以无法再用上述的方法计数。</p>
</div></details>
<h1 id="C-Numbers-on-a-Circle"><a href="#C-Numbers-on-a-Circle" class="headerlink" title="C. Numbers on a Circle"></a>C. Numbers on a Circle</h1><p>题目链接：<a href="https://atcoder.jp/contests/agc037/tasks/agc037_c">https://atcoder.jp/contests/agc037/tasks/agc037_c</a></p>
<p>题目大意：所有数字在环上，可以进行一个操作，选择一个数字，令其加上相邻两个数字之和，所有数字为正数，问能不能使所有数字由 $a\to b$ 。</p>
<details class="toggle" ><summary class="toggle-button" style="">我的做法</summary><div class="toggle-content"><p>注意到一个事情，由于所有数字都是正数，那么 $b$ 中的局部极大值都一定是这个局部最后操作的，或者说以他为中心的相邻三个数字中最后一个操作的，因此我们可以直接尝试从 $b$ 还原到 $a$ 。</p>
<p>注意到等价于用局部最大值去模相邻两个数字之和，每次取模一定会少一半，因此次数上界为 $O(n\log{V})$ 。</p>
<p>注意到最大值一定是局部极大值，直接用堆就行了。</p>
<p>时间复杂度：$O(n\log{V}\log{n})$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PLI;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line">priority_queue&lt;PLI&gt; p;</span><br><span class="line"><span class="type">int</span> a[N], b[N];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">preid</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="keyword">return</span> x == <span class="number">1</span> ? n : x - <span class="number">1</span>;&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">nexid</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="keyword">return</span> x == n ? <span class="number">1</span> : x + <span class="number">1</span>;&#125;</span><br><span class="line"><span class="function">LL <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        cin &gt;&gt; b[i];</span><br><span class="line">        p.<span class="built_in">push</span>(&#123;b[i], i&#125;);</span><br><span class="line">        <span class="keyword">if</span>(b[i] &lt; a[i]) <span class="keyword">return</span> <span class="number">-1ll</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    LL cnt = <span class="number">0ll</span>;</span><br><span class="line">    <span class="keyword">while</span>(!p.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="keyword">auto</span> [d, id] = p.<span class="built_in">top</span>();</span><br><span class="line">        p.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="type">int</span> pid = <span class="built_in">preid</span>(id);</span><br><span class="line">        <span class="type">int</span> nid = <span class="built_in">nexid</span>(id);</span><br><span class="line">        LL val = b[pid] + b[nid];</span><br><span class="line">        LL T = <span class="built_in">min</span>( (b[id] - a[id]) / val, (b[id] - <span class="built_in">max</span>(b[pid], b[nid])) / val + <span class="number">1</span>);</span><br><span class="line">        cnt += T;</span><br><span class="line">        b[id] -= T * val;</span><br><span class="line">        <span class="keyword">if</span>(b[id] &gt; a[id] &amp;&amp; b[id] &gt;= <span class="built_in">max</span>(b[pid], b[nid])) <span class="keyword">return</span> <span class="number">-1ll</span>;</span><br><span class="line">        <span class="keyword">if</span>(b[id] &gt; a[id]) p.<span class="built_in">push</span>(&#123;b[id], id&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">solve</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></details>
<h1 id="D-Sorting-a-Grid"><a href="#D-Sorting-a-Grid" class="headerlink" title="D. Sorting a Grid"></a>D. Sorting a Grid</h1><p>题目链接：<a href="https://atcoder.jp/contests/agc037/tasks/agc037_d">https://atcoder.jp/contests/agc037/tasks/agc037_d</a></p>
<p>题目大意：给一个矩形，矩形中的数字都是 $[1,nm]$ 且不同，然后有三次操作，第一次对所有行重排，第二次对所有列重排，第三次对所有行重排，给一种方案使得最后矩形变成 $1,2,3,….$ 的矩形。</p>
<details class="toggle" ><summary class="toggle-button" style="">我的做法</summary><div class="toggle-content"><p>很有意思的一道题目，注意到问题可以等价于在第一步行排列的时候，让每一行的数字在每一列都有一个，即把最终矩阵中每一行的数字给同一个颜色，不同行不同颜色，然后希望在行排列后，每一列中的颜色都是不一样的。</p>
<p>这个时候有一个二分图匹配的感觉，很可惜的是，建不出能过的图。</p>
<p>那么怎么做呢？注意到在列数只有两个的时候，等价于将每一行的两个颜色连边然后找环，这启示我们是与图相关的算法。<del>那还能不是二分图匹配？</del></p>
<p>又注意到，如果一定有解的话，我们可以归纳，即先摆出一列，剩下的部分就是一个子问题，因此问题是怎么摆出一列。</p>
<p>注意到这个时候用二分图匹配就可以，至于为什么二分图匹配一定有解，可以使用 Hall 定理证明。</p>
<p>时间复杂度：$O(n^4)$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e2</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> NN = <span class="number">1e4</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; cnt[N][N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getid</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="keyword">return</span> (x - <span class="number">1</span>) / m + <span class="number">1</span>;&#125;</span><br><span class="line"><span class="keyword">namespace</span> Graph&#123;</span><br><span class="line">    <span class="type">int</span> mat[N];</span><br><span class="line">    <span class="type">bool</span> e[N][N], v[N];</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ins</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>&#123;e[x][y] = <span class="number">1</span>;&#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">findmatch</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">        v[x] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!e[x][i]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(!mat[i] || (!v[mat[i]] &amp;&amp; <span class="built_in">findmatch</span>(mat[i])))&#123;</span><br><span class="line">                mat[i] = x;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="built_in">memset</span>(v, <span class="number">0</span>, <span class="built_in">sizeof</span>(v));</span><br><span class="line">            <span class="built_in">assert</span>(<span class="built_in">findmatch</span>(i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(e, <span class="number">0</span>, <span class="built_in">sizeof</span>(e));</span><br><span class="line">        <span class="built_in">memset</span>(mat, <span class="number">0</span>, <span class="built_in">sizeof</span>(mat));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> Graph::ins;</span><br><span class="line"><span class="keyword">using</span> Graph::init;</span><br><span class="line"><span class="keyword">using</span> Graph::solve;</span><br><span class="line"><span class="keyword">using</span> Graph::mat;</span><br><span class="line"><span class="type">int</span> ans1[N][N], ans2[N][N];</span><br><span class="line"><span class="type">int</span> id[N];</span><br><span class="line"><span class="type">int</span> tmp;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++)&#123;</span><br><span class="line">            <span class="type">int</span> x;</span><br><span class="line">            cin &gt;&gt; x;</span><br><span class="line">            cnt[i][<span class="built_in">getid</span>(x)].<span class="built_in">push_back</span>(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> t = <span class="number">1</span>; t &lt;= m; t++)&#123;</span><br><span class="line">        Graph::<span class="built_in">init</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!cnt[i][j].<span class="built_in">empty</span>()) <span class="built_in">ins</span>(j, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Graph::<span class="built_in">solve</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="type">int</span> col = mat[i];</span><br><span class="line">            ans1[i][t] = cnt[i][col].<span class="built_in">back</span>();</span><br><span class="line">            cnt[i][col].<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) id[i] = i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++)&#123;</span><br><span class="line">        tmp = j;</span><br><span class="line">        <span class="built_in">sort</span>(id + <span class="number">1</span>, id + n + <span class="number">1</span>, [](<span class="type">int</span> x, <span class="type">int</span> y)&#123;<span class="keyword">return</span> <span class="built_in">getid</span>(ans1[x][tmp]) &lt; <span class="built_in">getid</span>(ans1[y][tmp]);&#125;);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) ans2[i][j] = ans1[id[i]][j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++) cout &lt;&lt; ans1[i][j] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++) cout &lt;&lt; ans2[i][j] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></details>
<h1 id="E"><a href="#E" class="headerlink" title="E"></a>E</h1><p>题目链接：<a href="https://atcoder.jp/contests/agc037/tasks/agc037_e">https://atcoder.jp/contests/agc037/tasks/agc037_e</a></p>
<p>题目大意：你可以对字符串进行以下操作 $K$ 次：</p>
<p>$S$ 翻转得到 $S’$ ，在 $SS’$ 中找到长度为 $n$ 的字符串替代 $S$ 。</p>
<p>问最后得到的最小字典序的字符串。</p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>这是题？</p>
<p>显然一个事情，设 $maxlen=SS’$ 中最长的连续最小字符。</p>
<p>那么显然最后得到的字符串的前缀一定 $\le maxlen*2^{K-1}$ ，而且等号成立当且仅当每一步中都选择最长的连续最小字符段为后缀（最后一次为前缀）.</p>
<p>可以注意到，除了第一次有多种选择，后面都只有唯一选择。</p>
<p>因此直接暴力就行了，时间复杂度：$O(n^2)$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">5e3</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">char</span> st[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_char_array</span><span class="params">(<span class="type">char</span> *s)</span></span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">char</span> ss[N];</span><br><span class="line">    cin &gt;&gt; ss;</span><br><span class="line">    <span class="built_in">memcpy</span>(s + <span class="number">1</span>, ss, <span class="built_in">sizeof</span>(<span class="type">char</span>) * <span class="built_in">strlen</span>(ss));</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">char</span> ans[N], now[N], tmp[N];</span><br><span class="line"><span class="type">int</span> n, K;</span><br><span class="line"><span class="function"><span class="type">char</span> <span class="title">query</span><span class="params">(<span class="type">int</span> pos)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> pos &gt; n ? st[n + n - pos + <span class="number">1</span>] : st[pos];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">rev</span><span class="params">(<span class="type">char</span> *s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i + i &lt;= n; i++) <span class="built_in">swap</span>(s[i], s[n - i + <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">char</span> *s1, <span class="type">char</span> *s2)</span></span>&#123; <span class="comment">// s1 &lt; s2</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s1[i] != s2[i]) <span class="keyword">return</span> s1[i] &lt; s2[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">updata</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">cmp</span>(now, ans)) <span class="built_in">swap</span>(ans, now);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; K;</span><br><span class="line">    <span class="built_in">get_char_array</span>(st);</span><br><span class="line">    <span class="type">char</span> minchar = <span class="string">&#x27;z&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) minchar = <span class="built_in">min</span>(minchar, st[i]);</span><br><span class="line">    <span class="type">int</span> maxlen = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> l = <span class="number">1</span>; l &lt;= n; l++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(st[l] != minchar) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="type">int</span> r = l;</span><br><span class="line">        <span class="keyword">while</span>(r &lt; n &amp;&amp; st[r + <span class="number">1</span>] == minchar) r++;</span><br><span class="line">        <span class="keyword">if</span>(r == n) maxlen = <span class="built_in">max</span>((r - l + <span class="number">1</span>) * <span class="number">2</span>, maxlen);</span><br><span class="line">        <span class="keyword">else</span> maxlen = <span class="built_in">max</span>(maxlen, r - l + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) ans[i] = st[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> l = <span class="number">1</span>; l &lt;= n; l++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(st[l] != minchar) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="type">int</span> r = l;</span><br><span class="line">        <span class="keyword">while</span>(r &lt; n &amp;&amp; st[r + <span class="number">1</span>] == minchar) r++;</span><br><span class="line">        <span class="keyword">if</span>((r != n &amp;&amp; (r - l + <span class="number">1</span>) == maxlen) || (r == n &amp;&amp; (r - l + <span class="number">1</span>) * <span class="number">2</span> == maxlen))&#123;</span><br><span class="line">            <span class="type">int</span> endpos = n + (n - l + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> t = <span class="number">0</span>; t &lt; n; t++) tmp[n - t] = <span class="built_in">query</span>(endpos - t);</span><br><span class="line">            <span class="type">int</span> startpos = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(K &gt;= <span class="number">14</span> || maxlen * (<span class="number">1</span> &lt;&lt; (K - <span class="number">1</span>)) &gt;= n) startpos = n + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> startpos += maxlen * (<span class="number">1</span> &lt;&lt; (K - <span class="number">1</span>)) - maxlen;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> t = <span class="number">0</span>; t &lt; n; t++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(t + startpos &lt;= n) now[t + <span class="number">1</span>] = tmp[t + startpos];</span><br><span class="line">                <span class="keyword">else</span> now[t + <span class="number">1</span>] = minchar;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">rev</span>(now);</span><br><span class="line">            <span class="built_in">updata</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans + <span class="number">1</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>幽默题目。</p>
</div></details>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>dp</tag>
        <tag>Hall定理</tag>
        <tag>二分图匹配</tag>
      </tags>
  </entry>
  <entry>
    <title>AGC039 赛后总结</title>
    <url>/2024/05/28/AGC039-%E8%B5%9B%E5%90%8E%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="A-Connection-and-Disconnection"><a href="#A-Connection-and-Disconnection" class="headerlink" title="A. Connection and Disconnection"></a>A. Connection and Disconnection</h1><p>题目链接：<a href="https://atcoder.jp/contests/agc039/tasks/agc039_a">https://atcoder.jp/contests/agc039/tasks/agc039_a</a></p>
<p>题目大意：字符串 $S$ 放置 $K$ 次，对字符串修改最少的字符满足使相邻字符不同。</p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>我的做法是找到所有相同的字符构成的连续段，然后统计答案，开头和结尾特判一下就行了。</p>
<p>时间复杂度：$O(n)$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e2</span> + <span class="number">5</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_char_array</span><span class="params">(<span class="type">char</span> *s)</span></span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">char</span> ss[N];</span><br><span class="line">    cin &gt;&gt; ss;</span><br><span class="line">    <span class="built_in">memcpy</span>(s + <span class="number">1</span>, ss, <span class="built_in">sizeof</span>(<span class="type">char</span>) * (<span class="built_in">strlen</span>(ss) + <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">char</span> st[N];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">LL K;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">get_char_array</span>(st);</span><br><span class="line">    n = <span class="built_in">strlen</span>(st + <span class="number">1</span>);</span><br><span class="line">    cin &gt;&gt; K;</span><br><span class="line">    <span class="type">int</span> len0 = <span class="number">0</span>;</span><br><span class="line">    LL ans = <span class="number">0ll</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> l = <span class="number">1</span>; l &lt;= n; l++)&#123;</span><br><span class="line">        <span class="type">int</span> r = l;</span><br><span class="line">        <span class="keyword">while</span>(r &lt; n &amp;&amp; st[r + <span class="number">1</span>] == st[l]) r++;</span><br><span class="line">        <span class="keyword">if</span>(l &gt; <span class="number">1</span> &amp;&amp; r &lt; n) ans += (r - l  + <span class="number">1</span>) / <span class="number">2</span> * K;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(l == <span class="number">1</span> &amp;&amp; r &lt; n)&#123;</span><br><span class="line">            len0 = r - l + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(st[<span class="number">1</span>] != st[n]) ans += (r - l + <span class="number">1</span>) / <span class="number">2</span> * K;</span><br><span class="line">            <span class="keyword">else</span> ans += (r - l + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(l &gt; <span class="number">1</span> &amp;&amp; r == n)&#123;</span><br><span class="line">            <span class="keyword">if</span>(st[<span class="number">1</span>] != st[n]) ans += (r - l + <span class="number">1</span>) / <span class="number">2</span> * K;</span><br><span class="line">            <span class="keyword">else</span> ans += (r - l + <span class="number">1</span>) / <span class="number">2</span> + (r - l + <span class="number">1</span> + len0) / <span class="number">2</span> * (K - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> ans += n * K / <span class="number">2</span>;</span><br><span class="line">        l = r;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></details>
<details class="toggle" ><summary class="toggle-button" style="">其余做法</summary><div class="toggle-content"><p>看到一个很有意思的搞法：先统计 $S$ 的答案，再统计 $SS$ 的答案，两者相减得到在已经有字符串的情况下再添加字符串的贡献。</p>
<p>需要特判所有字符相同的情况。</p>
<p>这个做法感觉很牛啊。</p>
</div></details>
<h1 id="B-Graph-Partition"><a href="#B-Graph-Partition" class="headerlink" title="B. Graph Partition"></a>B. Graph Partition</h1><p>题目链接：<a href="https://atcoder.jp/contests/agc039/tasks/agc039_b">https://atcoder.jp/contests/agc039/tasks/agc039_b</a></p>
<p>题目大意：给你一张无向图，将点分成尽可能多的部分满足任何一条边只会出现在相邻两个部分之间。</p>
<details class="toggle" ><summary class="toggle-button" style="">我的做法</summary><div class="toggle-content"><p>首先注意到一个事情，这个图没有奇环是这个图有解的充要条件。（证明方法就是沿着奇数走一圈）</p>
<p>换个角度来看：题目的要求等价于相邻两个点的部分编号奇偶性不同，由这一点可以很自然的联想到二分图染色，从而知道如果二分图染色失败则无解，从而自然的想到有解的充要条件。</p>
<p>然后发现，$x\to y$ 的任何一条路径的边数都一定 $\ge |id_x-id_y|$ 。</p>
<p>我们不妨考虑从部分 $1$ 的角度来看，由于这个图是联通的，设 $h_x$ 表示 $1$ 中的点到 $x$ 的最短路，那么 $id_x\le h_x+1$ 。</p>
<p>我们不妨直接拉满，就设置一个中心 $st$ ，$id_x=h_x+1$，可以发现，在二分图上，这样子划分是一定合法的。</p>
<p>而且不难证明最优解一定长这样。</p>
<p>直接枚举 $st$ 就行了。</p>
<p>时间复杂度：$O(n^3)$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e2</span> + <span class="number">5</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_char_array</span><span class="params">(<span class="type">char</span> *s)</span></span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">char</span> ss[N];</span><br><span class="line">    cin &gt;&gt; ss;</span><br><span class="line">    <span class="built_in">memcpy</span>(s + <span class="number">1</span>, ss, <span class="built_in">sizeof</span>(<span class="type">char</span>) * (<span class="built_in">strlen</span>(ss) + <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">char</span> st[N][N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> y, next;</span><br><span class="line">&#125;a[N * N]; <span class="type">int</span> len, las[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ins</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>&#123;a[++len] = &#123;y, las[x]&#125;; las[x] = len;&#125;</span><br><span class="line"><span class="type">int</span> h[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bfs</span><span class="params">(<span class="type">int</span> spos)</span></span>&#123;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(spos);</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">0</span>, <span class="built_in">sizeof</span>(h));</span><br><span class="line">    h[spos] = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> laspos = spos;</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="type">int</span> x = q.<span class="built_in">front</span>();</span><br><span class="line">        laspos = x;</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k = las[x]; k; k = a[k].next)&#123;</span><br><span class="line">            <span class="type">int</span> y = a[k].y;</span><br><span class="line">            <span class="keyword">if</span>(!h[y])&#123;</span><br><span class="line">                h[y] = h[x] + <span class="number">1</span>;</span><br><span class="line">                q.<span class="built_in">push</span>(y);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>((h[y] &amp; <span class="number">1</span>) == (h[x] &amp; <span class="number">1</span>)) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> h[laspos];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="built_in">get_char_array</span>(st[i]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(st[i][j] == <span class="string">&#x27;1&#x27;</span>) <span class="built_in">ins</span>(i, j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) ans = <span class="built_in">max</span>(ans, <span class="built_in">bfs</span>(i));</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></details>
<h1 id="C-Division-by-Two-with-Something"><a href="#C-Division-by-Two-with-Something" class="headerlink" title="C. Division by Two with Something"></a>C. Division by Two with Something</h1><p>题目链接：<a href="https://atcoder.jp/contests/agc039/tasks/agc039_c">https://atcoder.jp/contests/agc039/tasks/agc039_c</a></p>
<p>题目大意：给 $n,X(X&lt;2^{n})$ ，求 $[0,X]$ 的权值和，权值定义为一个数字 $x$ 经过下述操作最少花几次回到自己。</p>
<p>操作：$x$ 是奇数就除二向下取整，偶数就除二后，加上 $2^{n-1}$ 。</p>
<details class="toggle" ><summary class="toggle-button" style="">我的做法</summary><div class="toggle-content"><p>注意到一个事情，上面这个操作等价于把一个 $n$ 位二进制的最低位翻转放到最高位。</p>
<p>于是，所有数字都一定会在 $2n$ 次操作后回到自己。</p>
<p>注意到，如果存在 $x,y(x&lt;y)$ 都能让 $x$ 回到自己，那么 $y-x$ 也可以，因此存在一个最小的次数 $ans$ 整除所有可行的次数，且 $ans$ 的所有倍数都可行。</p>
<p>也就是答案一定是 $2n$ 的因子。</p>
<p>又注意到 $n$ 次后一定回不到自己，因此 $ans$ 是 $2n$ 的因子而不是 $n$ 的因子。</p>
<p>注意到 $\frac{ans}{2}$ 整除于 $n$ ，我们不妨以 $\frac{ans}{2}$ 审视 $S$ ，可以发现 $S$ 可以写成 $010101010…0$ 。</p>
<p>即在 $len|n$ 的条件下，$S$ 可以以 $len$ 为单位写成 $010101…0$ 等价于 $S$ 在 $2len$ 后会回到自己。</p>
<p>综上可以得到以 $len$ 为单位的 $0101…0$ 的字符串数量等于 $ans|2len$ 的字符串数量。</p>
<p>容斥一下就可以得到每个 $ans$ 对应的字符串数量了。</p>
<p>时间复杂度：$O(n\log{n})$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> LL mod = <span class="number">998244353</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_char_array</span><span class="params">(<span class="type">char</span> *s)</span></span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">char</span> ss[N];</span><br><span class="line">    cin &gt;&gt; ss;</span><br><span class="line">    <span class="built_in">memcpy</span>(s + <span class="number">1</span>, ss, <span class="built_in">sizeof</span>(<span class="type">char</span>) * (<span class="built_in">strlen</span>(ss) + <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">char</span> st[N], t[N];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="function">LL <span class="title">solve</span><span class="params">(<span class="type">int</span> len)</span></span>&#123;</span><br><span class="line">    LL now = <span class="number">0ll</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= len; i++) now = (now * <span class="number">2</span> + st[i] - <span class="string">&#x27;0&#x27;</span>) % mod;</span><br><span class="line">    <span class="type">int</span> pos = <span class="number">1</span>, type = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        t[i] = ((st[pos] - <span class="string">&#x27;0&#x27;</span>) ^ type) + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span>(pos == len) pos = <span class="number">1</span>, type ^= <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> pos++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(t[i] &lt; st[i]) <span class="keyword">return</span> (now + <span class="number">1</span>) % mod;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(t[i] &gt; st[i]) <span class="keyword">return</span> now;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (now + <span class="number">1</span>) % mod;</span><br><span class="line">&#125;</span><br><span class="line">LL cnt[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="built_in">get_char_array</span>(st);</span><br><span class="line">    LL ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n % i == <span class="number">0</span> &amp;&amp; n % (i * <span class="number">2</span>) != <span class="number">0</span>)&#123;</span><br><span class="line">            cnt[i] = (cnt[i] + <span class="built_in">solve</span>(i)) % mod;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">2</span>; k &lt;= n / i; k++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(n / i % k == <span class="number">0</span>) cnt[i * k] = (cnt[i * k] - cnt[i] + mod) % mod;</span><br><span class="line">            &#125;</span><br><span class="line">            ans += cnt[i] * i * <span class="number">2</span>;</span><br><span class="line">            ans %= mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></details>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
  </entry>
  <entry>
    <title>AGC041 赛后总结</title>
    <url>/2024/05/28/AGC041-%E8%B5%9B%E5%90%8E%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>比赛链接：<a href="https://atcoder.jp/contests/agc041">https://atcoder.jp/contests/agc041</a></p>
<h1 id="A-Table-Tennis-Training"><a href="#A-Table-Tennis-Training" class="headerlink" title="A. Table Tennis Training"></a>A. Table Tennis Training</h1><p>题目链接：<a href="https://atcoder.jp/contests/agc041/tasks/agc041_a">https://atcoder.jp/contests/agc041/tasks/agc041_a</a></p>
<p>题目大意：有 $n$ 场比赛，每次比完，$i$ 的胜者去 $i-1$ ，败者去 $i+1$ ，$1$ 的胜者和 $n$ 的败者不动，问 $A$ 和 $B$ 赛场的两个人相遇需要至少多少次比赛。</p>
<details class="toggle" ><summary class="toggle-button" style="">我的做法</summary><div class="toggle-content"><p>注意到，能改变奇偶性的只有 $1,n$ 赛场。</p>
<p>所以讨论一下就行了。</p>
<p>如果奇偶性相同就直接相遇，否则去一次 $1$ 或者 $n$ 改一下就行了。</p>
<p>时间复杂度：$O(1)$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line">LL n, A, B;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; A &gt;&gt; B;</span><br><span class="line">    <span class="keyword">if</span>((A &amp; <span class="number">1</span>) == (B &amp; <span class="number">1</span>)) cout &lt;&lt; <span class="built_in">abs</span>(A - B) / <span class="number">2</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="built_in">min</span>((A + B - <span class="number">1</span>) / <span class="number">2</span> , (n + n - A - B + <span class="number">1</span>) / <span class="number">2</span>) &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></details>
<h1 id="B-Voting-Judges"><a href="#B-Voting-Judges" class="headerlink" title="B. Voting Judges"></a>B. Voting Judges</h1><p>题目链接：<a href="https://atcoder.jp/contests/agc041/tasks/agc041_b">https://atcoder.jp/contests/agc041/tasks/agc041_b</a></p>
<p>题目大意：有 $n$ 道题目，有 $m$ 个裁判选择恰好 $V$ 个题目投票，然后每道题目基础有 $a_i$ 票，得票数最高的 $P$ 道题目会入选比赛，问每道题目有没有机会入选。</p>
<details class="toggle" ><summary class="toggle-button" style="">我的做法</summary><div class="toggle-content"><p>先从大到小排序。</p>
<p>如果我们想要让 $a_{i}$ 有可能能成为前 $P$ 个，贪心来看，投给 $a_{i}$ 优先级最高，其次是前 $P-1$ 个和 $\le a_i$ 的题目，最后才是介于 $P$ 名和 $&gt;a_i$ 的题目。</p>
<p>别人加等于我减，所以可以看成对这些题目的减法，因此问题能够转换成问 $[P,i-1]$ 区间中的数字，有 $m$ 次操作能够选择若干数字 $-1$ ，问能不能全部 $\le a_i$ 。（不难证明这是充要条件）</p>
<p>然后就做完了。</p>
<p>时间复杂度：$O(n\log{n})$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n, m, a[N], P, V;</span><br><span class="line">LL sum[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; V &gt;&gt; P;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    V = n - V;</span><br><span class="line">    <span class="built_in">sort</span>(a + <span class="number">1</span>, a + n + <span class="number">1</span>, [](<span class="type">int</span> x, <span class="type">int</span> y)&#123;<span class="keyword">return</span> x &gt; y;&#125;);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) sum[i] = sum[i - <span class="number">1</span>] + a[i];</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i &lt;= P) ans++;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="type">int</span> len = <span class="built_in">min</span>(i - P, V);</span><br><span class="line">            ans += ((sum[i - <span class="number">1</span>] - sum[P - <span class="number">1</span>] - <span class="number">1ll</span> * a[i] * (i - P)) &lt;= <span class="number">1ll</span> * len * m &amp;&amp; </span><br><span class="line">            a[P] - m &lt;= a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></details>
<h1 id="C-Domino-Quality"><a href="#C-Domino-Quality" class="headerlink" title="C. Domino Quality"></a>C. Domino Quality</h1><p>题目链接：<a href="https://atcoder.jp/contests/agc041/tasks/agc041_c">https://atcoder.jp/contests/agc041/tasks/agc041_c</a></p>
<p>题目大意：可以放一些 $1<em>2$ 的方块在矩阵里面，要求每一行每一列涉及的 $1</em>2$ 的方块数一样而且不为 $0$ 。</p>
<details class="toggle" ><summary class="toggle-button" style="">我的做法</summary><div class="toggle-content"><p>首先 $\le 2$ 是无解的。</p>
<p>$\ge 3$ 时呢？</p>
<p>一个想法是发现我们可以像矩阵那样，分成左上角和右下角，所以可以把 $n$ 写成 $n_1+n_2+…$ 的形式，只要每一部分中每行每列的涉及的方块数一样就行。</p>
<p>首先可以构造出偶数时每行每列为 $3$ 的情况：</p>
<p><img src="1.png" alt=""></p>
<p>还有 $5$ 时的情况：</p>
<p><img src="2.png" alt=""></p>
<p>$7$ 的情况：</p>
<p><img src="3.png" alt=""></p>
<p>然后就做完了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e3</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">char</span> st[N][N];</span><br><span class="line"><span class="type">char</span> ans[][<span class="number">6</span>] = &#123;<span class="string">&quot;aabbc&quot;</span> ,</span><br><span class="line">                 <span class="string">&quot;f.ggc&quot;</span> ,</span><br><span class="line">                 <span class="string">&quot;fkk.d&quot;</span> ,</span><br><span class="line">                 <span class="string">&quot;de..d&quot;</span> ,</span><br><span class="line">                 <span class="string">&quot;de.ee&quot;</span>&#125;;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">3</span>)&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;aa.\n&quot;</span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;..b\n&quot;</span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;..b\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(n == <span class="number">7</span>)&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;a..yykk\n&quot;</span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;ayy.tt.\n&quot;</span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;bkkp...\n&quot;</span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;b..p..g\n&quot;</span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;....pqg\n&quot;</span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;....pqf\n&quot;</span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;ccee..f\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(n &lt;= <span class="number">2</span>)&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;-1\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) st[i][j] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> n5 = n;</span><br><span class="line">        <span class="keyword">if</span>(n &amp; <span class="number">1</span>) n5 -= <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n5; i += <span class="number">2</span>)&#123;</span><br><span class="line">            st[i][i] = st[i + <span class="number">1</span>][i] = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            st[i][i + <span class="number">1</span>] = st[i + <span class="number">1</span>][i + <span class="number">1</span>] = <span class="string">&#x27;b&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span>(i != n5 - <span class="number">1</span>)&#123;</span><br><span class="line">                st[i][i + <span class="number">2</span>] = st[i][i + <span class="number">3</span>] = <span class="string">&#x27;c&#x27;</span>;</span><br><span class="line">                st[i + <span class="number">1</span>][i + <span class="number">2</span>] = st[i + <span class="number">1</span>][i + <span class="number">3</span>] = <span class="string">&#x27;d&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                st[i][<span class="number">1</span>] = st[i][<span class="number">2</span>] = <span class="string">&#x27;c&#x27;</span>;</span><br><span class="line">                st[i + <span class="number">1</span>][<span class="number">1</span>] = st[i + <span class="number">1</span>][<span class="number">2</span>] = <span class="string">&#x27;d&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(n &amp; <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">5</span>; j++) st[n5 + i + <span class="number">1</span>][n5 + j + <span class="number">1</span>] = ans[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) cout &lt;&lt; st[i] + <span class="number">1</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></details>
<h1 id="D-Problem-Scores"><a href="#D-Problem-Scores" class="headerlink" title="D. Problem Scores"></a>D. Problem Scores</h1><p>题目链接：<a href="https://atcoder.jp/contests/agc041/tasks/agc041_d">https://atcoder.jp/contests/agc041/tasks/agc041_d</a></p>
<p>题目大意：问有多少个数组满足非递降且任意 $k+1$ 个数字之和 $&gt;$ $k$ 个数字之和。</p>
<details class="toggle" ><summary class="toggle-button" style="">我的做法</summary><div class="toggle-content"><p>很有感觉的一道题目，每个地方设置的刚刚好。</p>
<p>首先注意到一个事情，这个条件可以的等价的写成：$k=\left \lceil \frac{n-1}{2} \right \rceil$ ，前 $k+1$ 个数字之和要 $&gt;$ 后 $k$ 个数字之和。</p>
<p>不妨以第 $k+1$ 个数字为中心，这么写：前第 $k$ 个数字和后第 $k$ 个数字的差值 + 前第 $k-1$ 个数字和后第 $k-1$ 个数字的差值 … + 第 $k+1$ 个数字。</p>
<p>可以把整个过程想象成在 $k+1$ 这个位置左边放一个数字，右边放一个数字。</p>
<p>但是这样子想，怎么设 $dp$ 都会带上一个十分讨厌的 $\log$ ，这个 $\log$ ，于是想到一个经典问题，摆阶梯。</p>
<p>如果竖着 $dp$ ，就避不开这个 $\log$ ，但是如果横着 $dp$ ，就可以避免这个 $\log$ 。</p>
<p><img src="4.png" alt=""></p>
<p>再联系到这道题目就可以得到最终的做法：</p>
<p>dp[i][r] 表示放置了 $i$ 个数字后最右边的数字处在 $r$ 而且这 $i$ 的数字的权值和为 $0$ 。</p>
<p>然后每次会在中心的数字上面放一个左边的数字和右边的数字，然后可以把左边的数字往左边推一格，右边同理，同时，在推完后把中心位置调到使权值和恰好为 $0$ 的位置。</p>
<p>可以发现，对于任意一个个数 $\ge 3$ 的方案，只要权值和为 $0$ ，就一定不会有数字 $\le 0$ 。</p>
<p>所以不用容斥就可以计算出最终答案。</p>
<p>时间复杂度：$O(n^2)$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">5e3</span> + <span class="number">5</span>;</span><br><span class="line">LL dp[N], mod;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">trans</span><span class="params">(<span class="type">int</span> cnt)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i + cnt &lt;= n; i++) dp[i + cnt] = (dp[i + cnt] + dp[i]) % mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; mod;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>)&#123;</span><br><span class="line">        cout &lt;&lt; <span class="number">1</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(n == <span class="number">2</span>)&#123;</span><br><span class="line">        cout &lt;&lt; <span class="number">3</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    dp[<span class="number">1</span>] = <span class="number">1ll</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> t = <span class="number">1</span>; t &lt;= (n - <span class="number">1</span>) / <span class="number">2</span>; t++)&#123;</span><br><span class="line">        <span class="built_in">trans</span>(t);</span><br><span class="line">        <span class="built_in">trans</span>(t + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n &amp; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">trans</span>(n / <span class="number">2</span>);</span><br><span class="line">    LL ans = <span class="number">0ll</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) ans = (dp[i] * (n - i + <span class="number">1</span>) + ans) % mod;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></details>
<h1 id="E-Balancing-Network"><a href="#E-Balancing-Network" class="headerlink" title="E. Balancing Network"></a>E. Balancing Network</h1><p>题目链接：<a href="https://atcoder.jp/contests/agc041/tasks/agc041_e">https://atcoder.jp/contests/agc041/tasks/agc041_e</a></p>
<p>题目大意：给你 $n$ 条横着的电线，然后从左到右有若干条通道，每条通道连接两根电线，然后你需要给每条通道指定向上或者向下的方向，使其满足：</p>
<p>当 $T=1$ 时，要求任何一根电线左端出发最终能到达一根电线上。</p>
<p>当 $T=2$ 时，要求不会都到一根电线上。</p>
<p>如果不存在输出无解。</p>
<details class="toggle" ><summary class="toggle-button" style="">我的做法</summary><div class="toggle-content"><p>分类讨论真的是。</p>
<p><details class="toggle" ><summary class="toggle-button" style="">$T = 1$</summary><div class="toggle-content"><p>当你想着这个问题足够久或者手动的模拟过一会后，你会感到一种熟悉的感觉从脑袋中流淌。</p></p>
<p>没错，它就是可达性统计。</p>
<p>这个部分分神似可达性统计。</p>
<p>所以你可能会想，我能不能设 $dp[x]$ 表示前 $i$ 条边能到达 $x$ 的集合，然后当存在边 $(x,y)$ 时。</p>
<p>就更新：$dp[x]=dp[y]=dp[x]|dp[y]$ ？</p>
<p>这为什么是对的？</p>
<p><details class="toggle" ><summary class="toggle-button" style="">证明</summary><div class="toggle-content"><p>归纳证明，我们先认为 $\exists$ 一种局面使得前 $i$ 条边过后 $dp[x]$ 中的电线都能到达 $x$ 这条电线，其中设 $E_x$ 表示与 $dp[x]$ 有关的边，即从 $dp[x]$ 回溯回去，任何和产生 $dp[x]$ 有关的边。</p></p>
<p>而 $dp[x],E_x$ 显然可以通过从 $x$ 的当前位置倒着 BFS 回去得到。</p>
<p>从而可以得到这么一个结论：无论任何局面，$dp[x]$ 外的点都不会经过 $E_x$ 中的边，也不会到达 $x$ 。</p>
<p>而在 $E_x$ 固定正确的方向后， $E_x$ 外的边满足更改方向不会影响 $dp[x]$ 中的点到达 $x$ ，换句话说，$E_x$ 外的边不会影响最终到达电线 $x$ 的集合，且该集合就等于 $dp[x]$ 。</p>
<p>然后当出现边 $(x,y)$ 时，显然 $x,y$ 外的点不受影响，关键是 $x,y$ 。</p>
<p>不妨只证明新的 $dp[x]$ 仍然满足要求。</p>
<p>构造一种新的局面：$E_x$ 的边方向照旧，$E_y\setminus E_x$ 的边方向同样照旧，其余随意。</p>
<p>首先知道 $dp[x]$ 一定能到达 $x$ ，然后是 $dp[y]\setminus dp[x]$ ，对于 $z\in dp[y]\setminus dp[x]$ ，$z$ 到 $y$ 的路径只会在 $E_y\setminus E_x$ 中，而不会有 $E_x$ ，否则 $z\in dp[x]$ ，所以 $z$ 能到达 $y$ ，然后走到 $x$ 。对于 $dp[x],dp[y]$ 之外的点，根据上面的性质，在去掉 $(x,y)$ 时，其永远到不了 $x,y$ ，加上显然也到不了，因此这种局面下到达 $x$ 的集合就是 $dp[x]\cup dp[y]$ 。</p>
<p>证毕。</p>
<p>那么为什么是最优解呢？</p>
<p>可以注意到 $dp[x]$ 可以由 $x$ 倒着 BFS 得到，因此如果 $y$ 存在一种局面可以到达 $x$ ，根据路径可逆，$x$ 一定能倒着 BFS 到 $y$ ，因此所有局面中到达 $x$ 的集合一定是 $dp[x]$ 的子集。</p>
<p>从而得到 $dp[x]$ 就是最优集合，证毕。</p>
<p>综上，该 $dp$ 正确，证毕。</p>
</div></details>
<p>然后在跑完 $dp$ 后得到谁可以是那个汇聚万物的电线，最后直接倒着 $BFS$ 回去还原一下方案就行了，时间复杂度：$O(\frac{nm}{w})$ 。</p></div></details>
<details class="toggle" ><summary class="toggle-button" style="">$T = 2$</summary><div class="toggle-content"><p>首先 $n\le 2$ 的时候一定无解。</p>
<p>当 $n&gt;2$ 时，我们考虑为什么 $n=2$ 时无解，是不是我们能够知道一开始 $(1,2)$ 是两个合法终点，但是如果存在一条边给他们两个连起来，就寄了。</p>
<p>但是如果我们能够存储两对不一样的合法终点呢？这样每次连至多终结其中一个，而另外一个手动模拟一下就知道，可以重新生成两对不一样的合法终点，然后就做完了。</p>
<p>时间复杂度：$O(n)$ 。</p>
</div></details>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">5e4</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n, m, T;</span><br><span class="line"><span class="keyword">namespace</span> Solve1&#123;</span><br><span class="line">    PII e[M];</span><br><span class="line">    bitset&lt;N&gt; f[N];</span><br><span class="line">    <span class="type">char</span> st[M];</span><br><span class="line">    <span class="type">bool</span> v[N];</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) f[i][i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">            <span class="keyword">auto</span>&amp; [x, y] = e[i];</span><br><span class="line">            cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">            f[x] |= f[y];</span><br><span class="line">            f[y] |= f[x];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(f[i].<span class="built_in">count</span>() == n)&#123;</span><br><span class="line">                ans = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!ans)&#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;-1\n&quot;</span>;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        v[ans] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = m; i &gt;= <span class="number">1</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">auto</span> [x, y] = e[i];</span><br><span class="line">            <span class="keyword">if</span>(!v[x] &amp;&amp; !v[y]) st[i] = <span class="string">&#x27;^&#x27;</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(!v[x] &amp;&amp; v[y])&#123;</span><br><span class="line">                st[i] = <span class="string">&#x27;v&#x27;</span>;</span><br><span class="line">                v[x] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(v[x] &amp;&amp; !v[y])&#123;</span><br><span class="line">                st[i] = <span class="string">&#x27;^&#x27;</span>;</span><br><span class="line">                v[y] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> st[i] = <span class="string">&#x27;v&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; st + <span class="number">1</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> Solve2&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">        <span class="type">int</span> x, y;</span><br><span class="line">        string type;</span><br><span class="line">    &#125;p1, p2;</span><br><span class="line">    string ans;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">pd</span><span class="params">(<span class="type">int</span> x, <span class="type">const</span> node &amp;y)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x == y.x) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(x == y.y) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getp</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">const</span> node &amp;z)</span></span>&#123;<span class="keyword">return</span> (<span class="type">int</span>) (<span class="built_in">pd</span>(x, z) &gt; <span class="number">0</span>) + (<span class="type">int</span>) (<span class="built_in">pd</span>(y, z) &gt; <span class="number">0</span>);&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">cl</span><span class="params">(node &amp;x)</span></span>&#123;</span><br><span class="line">        node y = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="string">&quot;&quot;</span>&#125;;</span><br><span class="line">        <span class="built_in">swap</span>(x, y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">2</span>)&#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;-1\n&quot;</span>;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        p1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="string">&quot;&quot;</span>&#125;;</span><br><span class="line">        p2 = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="string">&quot;&quot;</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">            <span class="type">int</span> x, y;</span><br><span class="line">            cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">            node now;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">getp</span>(x, y, p1) == <span class="number">1</span> || <span class="built_in">getp</span>(x, y, p2) == <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">getp</span>(x, y, p1) == <span class="number">1</span>)&#123;</span><br><span class="line">                    ans += p1.type;</span><br><span class="line">                    now = &#123;p1.x, p1.y, <span class="string">&quot;&quot;</span>&#125;;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    ans += p2.type;</span><br><span class="line">                    now = &#123;p2.x, p2.y, <span class="string">&quot;&quot;</span>&#125;;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">cl</span>(p1); <span class="built_in">cl</span>(p2);</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">pd</span>(x, now) == <span class="number">1</span>)&#123;</span><br><span class="line">                    p2 = &#123;x, now.y, <span class="string">&quot;^&quot;</span>&#125;;</span><br><span class="line">                    p1 = &#123;<span class="built_in">min</span>(now.y, y), <span class="built_in">max</span>(now.y, y), <span class="string">&quot;v&quot;</span>&#125;;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">pd</span>(x, now) == <span class="number">2</span>)&#123;</span><br><span class="line">                    p1 = &#123;now.x, now.y, <span class="string">&quot;^&quot;</span>&#125;;</span><br><span class="line">                    p2 = &#123;now.x, y, <span class="string">&quot;v&quot;</span>&#125;;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">pd</span>(y, now) == <span class="number">1</span>)&#123;</span><br><span class="line">                    p1 = &#123;x, now.y, <span class="string">&quot;^&quot;</span>&#125;;</span><br><span class="line">                    p2 = &#123;now.x, now.y, <span class="string">&quot;v&quot;</span>&#125;;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">pd</span>(y, now) == <span class="number">2</span>)&#123;</span><br><span class="line">                    p1 = &#123;<span class="built_in">min</span>(now.x, x), <span class="built_in">max</span>(now.x, x), <span class="string">&quot;^&quot;</span>&#125;;</span><br><span class="line">                    p2 = &#123;now.x, now.y, <span class="string">&quot;v&quot;</span>&#125;;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                p1.type += <span class="string">&quot;^&quot;</span>;</span><br><span class="line">                p2.type += <span class="string">&quot;^&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans += p1.type;</span><br><span class="line">        cout &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; T;</span><br><span class="line">    <span class="keyword">if</span>(T == <span class="number">1</span>) Solve1::<span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">else</span> Solve2::<span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>好屎的分类讨论，能在考场写出来的人真是神仙吧。</p>
<p>update ：$T=1$ 的证明写了这么久，其实我都忽略了一个最关键的东西：$dp[x]$ 就是由 $x$ 倒着 BFS 得到的终点集合，我只需要构造出一种局面使得 $dp[x]$ 能全部到达 $x$ ，再说明一下最优性，就可以直接把问题转换成求 $x$ 倒着 BFS 能到达的集合，这样就可以很轻松的证明这个做法的正确性了，根本不用搞得那么繁琐。</p>
<p>而构造一种局面使得 $dp[x]$ 能全部到达 $x$ 是简单的，倒着考虑就行了。</p></div></details>
<details class="toggle" ><summary class="toggle-button" style="">其他题解</summary><div class="toggle-content"><ol>
<li>$T=1$ 的做法和我的做法一样，但证明比我的证明更加简单，已经更新到我的做法最后的 update 部分。</li>
<li><p>同样做复杂了，我们设 $ed_x$ 表示第 $x$ 条线最后到哪条线，设 $cnt_i$ 表示 $ed_x=i$ 的 $x$ 的个数，倒着跑，注意到每次添加 $(x,y)$ 后，定向只会导致两个 $cnt$ 加减一，因此在 $n&gt;2$ 的情况下，一定存在一种定向，使得不存在 $i$ 满足 $cnt_i=n$ 。</p>
<p>这种做法相较于我的做法没有繁杂的讨论，非常的好写。</p>
</li>
</ol>
<p>这种讨论题难就难在想出好写的做法，反正我没想出来，投降 ┗( T﹏T )┛ 。</p>
</div></details>]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>构造</tag>
      </tags>
  </entry>
  <entry>
    <title>AGC043 C. Giant Graph</title>
    <url>/2024/06/03/AGC043-C-Giant-Graph/</url>
    <content><![CDATA[<p>题目链接：<a href="https://atcoder.jp/contests/agc043/tasks/agc043_c">https://atcoder.jp/contests/agc043/tasks/agc043_c</a></p>
<p>题目大意：给三张无向图 $X,Y,Z$，满足点数为 $n$ ，边数分别为 $M_1,M_2,M_3$ ，然后构造一个点数为 $N^3$ 的图，满足其中的节点 $(x,y,z)$ 。</p>
<p>且其中的边为：</p>
<p>若 $(x_1,x_2)\in E_X$ ，则 $\forall y,z:((x_1,y,z),(x_2,y,z))\in E$</p>
<p>对于 $E_Y,E_Z$ 同理。</p>
<p>然后点 $(x,y,z)$ 的权值为 $10^{18(x+y+z)}$ ，问最大权值和的独立集的最大权值和是多少。</p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>注意到 $10^{18(x+y+z)}=10^{18x}10^{18y}10^{18z}$ ，由于 $10^{18}$ 很大，所以可以注意到两个独立集权值的比较，可以看成是 $(x+y+z)$ 从大到小排序后比较数组字典序。</p>
<p>首先不难证明一个结论（由于和相同的点不会互相删除，所以直接用贪心的思路证明就行了）：</p>
<p>一个独立集是最优解，当且仅当所有点 $(x,y,z)$ 要么在独立集里，要么存在 $(x’,y’,z’)(x’+y’+z’\ge x+y+z)$ 在独立集里且与他有连边。</p>
<p>因此只要能构造出这样的独立集就行了。</p>
<p>在构造的过程中，我们可以发现图中同时有一些点总是同时存在。</p>
<p>什么意思呢？我们将每条边从大到小连边，然后每次将这个 DAG 中入度为 $0$ 的点作为一个集合，然后在 DAG 上删除这个集合，重复这个过程。可以发现，每个集合中的点总是同时存在不妨按照时间顺序给每个集合编号：$X_1,X_2,X_3…$ ，则 $\forall i&lt;j:\forall x\in X_j:\exists y\in X_i:y\to x$ 。</p>
<p>从而知道 $X$ 集合的至多 $O(\sqrt{m})$ 个，同理 $Y$ 集合和 $Z$ 集合也是。</p>
<p>现在可以将原来的 $X,Y,Z$ 图等价的同构成由 $\{X_i\},\{Y_i\},\{Z_i\}$ 构成的图，其中每个图都是 $i\to j(i<j)$ ，其中权值关系为：$X_i>X_j(i&lt;j)$ （从上面的构造不难看出）。</p>
<p>由于此时的点数只有 $m\sqrt{m}$ ，直接暴力枚举就行了，可以证明此时得到的解在原图上一定满足上面说的是最优解的条件，所以我们就得到了最优解。</p>
<p>时间复杂度：$O(m\sqrt{m})$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span>  LL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> B = <span class="number">455</span>;</span><br><span class="line"><span class="type">const</span> LL mod = <span class="number">998244353</span>, base = (LL)<span class="number">1e18</span> % mod;</span><br><span class="line">vector&lt;LL&gt; val[<span class="number">3</span>];</span><br><span class="line"><span class="type">bool</span> vis[B][B][B];</span><br><span class="line">LL f[N];</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">bool</span> v[N];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; out[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    f[<span class="number">0</span>] = <span class="number">1ll</span>; <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) f[i] = f[i - <span class="number">1</span>] * base % mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> id)</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">        <span class="type">int</span> x, y;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        <span class="keyword">if</span>(x &lt; y) <span class="built_in">swap</span>(x, y);</span><br><span class="line">        out[x].<span class="built_in">push_back</span>(y);</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; pos;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = n; i &gt;= <span class="number">1</span>; i--) pos.<span class="built_in">push_back</span>(i);</span><br><span class="line">    <span class="keyword">while</span>(!pos.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; tmp;</span><br><span class="line">        LL now = <span class="number">0ll</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> x : pos)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!v[x])&#123;</span><br><span class="line">                now = (now + f[x]) % mod;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">auto</span> y : out[x]) v[y] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> tmp.<span class="built_in">push_back</span>(x);</span><br><span class="line">        &#125;</span><br><span class="line">        val[id].<span class="built_in">push_back</span>(now);</span><br><span class="line">        <span class="built_in">swap</span>(pos, tmp);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> x : pos) v[x] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) v[i] = <span class="number">0</span>, out[i].<span class="built_in">clear</span>();</span><br><span class="line">    <span class="built_in">assert</span>(val[id].<span class="built_in">size</span>() &lt;= B);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> t = <span class="number">0</span>; t &lt;= <span class="number">2</span>; t++) <span class="built_in">solve</span>(t);</span><br><span class="line">    LL ans = <span class="number">0ll</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> sum = <span class="number">0</span>; sum + <span class="number">3</span> &lt;= val[<span class="number">0</span>].<span class="built_in">size</span>() + val[<span class="number">1</span>].<span class="built_in">size</span>() + val[<span class="number">2</span>].<span class="built_in">size</span>(); sum++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= sum &amp;&amp; i &lt; val[<span class="number">0</span>].<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span> ; i + j &lt;= sum &amp;&amp; j &lt; val[<span class="number">1</span>].<span class="built_in">size</span>(); j++)&#123;</span><br><span class="line">                <span class="type">int</span> k = sum - i - j;</span><br><span class="line">                <span class="keyword">if</span>(k &gt;= val[<span class="number">2</span>].<span class="built_in">size</span>() || vis[i][j][k]) <span class="keyword">continue</span>;</span><br><span class="line">                ans = (ans + val[<span class="number">0</span>][i] * val[<span class="number">1</span>][j] % mod * val[<span class="number">2</span>][k]) % mod;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> t = i + <span class="number">1</span>; t &lt; val[<span class="number">0</span>].<span class="built_in">size</span>(); t++) vis[t][j][k] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> t = j + <span class="number">1</span>; t &lt; val[<span class="number">1</span>].<span class="built_in">size</span>(); t++) vis[i][t][k] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> t = k + <span class="number">1</span>; t &lt; val[<span class="number">2</span>].<span class="built_in">size</span>(); t++) vis[i][j][t] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></details>
<details class="toggle" ><summary class="toggle-button" style="">官方做法</summary><div class="toggle-content"><p>吐槽：不是哥们，我怎么又嗯做做出来一道题目啊。</p>
<p>这道题目的正经做法是这样子的：</p>
<p>注意到最优方案一定是每次选可选的 $i+j+k$ 中最大的，我们可以对边定向，由小指向大，那么可以注意到我们能选到的点当且仅当，将这个图当成一个博弈状态图，这个点是一个必败态。</p>
<p>然后又注意到这其实是三个图的的组合游戏，所以就是异或。</p>
<p>直接求一下 SG 函数，然后不难发现，一个图中的 SG 的上限是根号的，所以直接 $O(m)$ 求一下就行了。</p>
<p>总时间复杂度：$O(n+m)$ 。</p>
<p>反思：</p>
<p>回到我的做法中，我把每个小图中的某些点归为一类，那么这个分类代表什么呢？我当时觉得这玩意可能有实际意义，但是当时我没有看出来。</p>
<p>没看出来的一个很重要的原因：我只对小图求了等价类，但是没有对大图做等价类，因此没有注意到大图的等价类就是小图等价类的组合这个性质。</p>
<p>还有一个很重要的原因：我的建图是从大指向小的。</p>
<p>只能说做题确实需要建模，这题目基本只要想出和 SG 的联系基本就做完了。但是我觉得这并不是我的问题，因为我确实想不到其和 SG 的联系。不能说没有建，只能说建不出来，不是方法问题，是实力问题。</p>
<p>就这样吧，我觉得目前来看，在我的思考过程中，方法没有问题，要真要说优化的话，只能说希望下次做类似的题能做的快一点吧，其余没啥了。</p>
<p>收获：</p>
<p>已知现在有几个有向图游戏，那么这多个游戏同时进行，既可以表示成每个游戏上你都在一个点上，然后每次移动一个点，其意义就是多个游戏同时进行，例子：多个石堆，每次只能在一个石堆上移除石子；也可以像这道题目一样，用 $(x_1,x_2,…,x_n)$ 来表示，边也像这道题目一样标，其意义为直接将这多个游戏同时进行的这场游戏视为一个整体，一个有向图游戏。</p>
<p>这道题目给我的收获就是：发现多个同时进行的有向图游戏还可以用后面那种表示，同时也加深了一下我对有向图游戏的理解。</p>
<p>我认为这是一道好题。</p>
</div></details>]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>SG</tag>
      </tags>
  </entry>
  <entry>
    <title>AGC043 赛后总结</title>
    <url>/2024/05/30/AGC043-%E8%B5%9B%E5%90%8E%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>比赛链接：<a href="https://atcoder.jp/contests/agc043">https://atcoder.jp/contests/agc043</a></p>
<h1 id="A-Range-Flip-Find-Route"><a href="#A-Range-Flip-Find-Route" class="headerlink" title="A. Range Flip Find Route"></a>A. Range Flip Find Route</h1><p>题目链接：<a href="https://atcoder.jp/contests/agc043/tasks/agc043_a">https://atcoder.jp/contests/agc043/tasks/agc043_a</a></p>
<p>题目大意：一个 01 矩阵，每次可以选择一个子矩阵翻转，问最少需要多少次操作能够存在一条 $(1,1)$ 到 $(n,m)$ 的全 $1$ 路径。（只能向右向下走）</p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>对于一条固定的路径，可以变成一个序列考虑，发现每次操作最多少一段 $0$ ，因此就是找到一条路径最小化 $0$ 的段数。</p>
<p>时间复杂度：$O(nm)$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e2</span> + <span class="number">5</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_char_array</span><span class="params">(<span class="type">char</span> *ss)</span></span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">char</span> s[N];</span><br><span class="line">    cin &gt;&gt; s;</span><br><span class="line">    <span class="built_in">memcpy</span>(ss + <span class="number">1</span>, s, <span class="built_in">sizeof</span>(<span class="type">char</span>) * (<span class="built_in">strlen</span>(s) + <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">char</span> st[N][N];</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> dp[N][N];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">pd</span><span class="params">(<span class="type">char</span> x, <span class="type">char</span> y)</span></span>&#123;<span class="keyword">return</span> x == <span class="string">&#x27;#&#x27;</span> &amp;&amp; y == <span class="string">&#x27;.&#x27;</span>;&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">get_char_array</span>(st[i]);</span><br><span class="line">    dp[<span class="number">1</span>][<span class="number">1</span>] = st[<span class="number">1</span>][<span class="number">1</span>] == <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">1</span> &amp;&amp; j == <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="type">int</span> now = <span class="number">1e9</span>;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">1</span>) now = <span class="built_in">min</span>(now, dp[i - <span class="number">1</span>][j] + <span class="built_in">pd</span>(st[i][j], st[i - <span class="number">1</span>][j]));</span><br><span class="line">            <span class="keyword">if</span>(j &gt; <span class="number">1</span>) now = <span class="built_in">min</span>(now, dp[i][j - <span class="number">1</span>] + <span class="built_in">pd</span>(st[i][j], st[i][j - <span class="number">1</span>]));</span><br><span class="line">            dp[i][j] = now;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; dp[n][m] &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>和官方题解一样。</p>
</div></details>
<h1 id="B-123-Triangle"><a href="#B-123-Triangle" class="headerlink" title="B. 123 Triangle"></a>B. 123 Triangle</h1><p>题目链接：<a href="https://atcoder.jp/contests/agc043/tasks/agc043_b">https://atcoder.jp/contests/agc043/tasks/agc043_b</a></p>
<p>题目大意：给你一个只包含 $1,2,3$ 的序列，每次操作会将这个序列相邻两个数字相减并取绝对值，得到一个长度 $-1$ 的序列，操作到只剩下一个值，问这个值是多少。</p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>首先答案只能是 $0,1,2$ 。</p>
<p>所以先把初始序列减 $1$ ，这样全局过程中我们都只需要考虑 $0,1,2$ 。</p>
<p>注意到 $\mod 2$ 意义下可以把 $|x-y|$ 变成 $x+y$ ，从而可以直接用组合数算出最终数字的奇偶性。</p>
<p>现在问题是怎么区分 $0/2$ ？</p>
<p>可以归纳证明，只要初始序列中有 $1$ ，最终答案就一定不可能是 $2$ 。</p>
<p>在序列有 $0/2$ 的情况下，显然后面都只有 $0/2$ ，因此在模 $4$ 意义下 $|x-y|=x+y$ ，所以类似上面组合数直接算答案就行了。</p>
<p>当然也可以把所有数字除 $2$ 然后在 $\mod 2$ 的意义下计算，没区别。</p>
<p>时间复杂度：$O(n)$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span> + <span class="number">5</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_char_array</span><span class="params">(<span class="type">char</span> *ss)</span></span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">char</span> s[N];</span><br><span class="line">    cin &gt;&gt; s;</span><br><span class="line">    <span class="built_in">memcpy</span>(ss + <span class="number">1</span>, s, <span class="built_in">sizeof</span>(<span class="type">char</span>) * (<span class="built_in">strlen</span>(s) + <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">char</span> st[N];</span><br><span class="line"><span class="type">int</span> n, a[N];</span><br><span class="line"><span class="type">int</span> cnt[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span>&#123;<span class="keyword">return</span> cnt[r] - cnt[l - <span class="number">1</span>];&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">calc</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>&#123;<span class="keyword">return</span> (<span class="built_in">query</span>(<span class="number">1</span>, x) - <span class="built_in">query</span>(<span class="number">1</span>, y) - <span class="built_in">query</span>(<span class="number">1</span>, x - y)) ? <span class="number">0</span> : <span class="number">1</span>;&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="built_in">get_char_array</span>(st);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        cnt[i] = cnt[i - <span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> tmp = i;</span><br><span class="line">        <span class="keyword">while</span>(tmp % <span class="number">2</span> == <span class="number">0</span>) tmp /= <span class="number">2</span>, cnt[i]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> cnt1 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        a[i] = st[i] - <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">        ans = (a[i] * <span class="built_in">calc</span>(n - <span class="number">1</span>, i - <span class="number">1</span>) + ans) % <span class="number">2</span>;</span><br><span class="line">        cnt1 += (a[i] == <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(ans == <span class="number">1</span>) cout &lt;&lt; <span class="number">1</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(cnt1) cout &lt;&lt; <span class="number">0</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            a[i] = a[i] / <span class="number">2</span>;</span><br><span class="line">            ans = (a[i] * <span class="built_in">calc</span>(n - <span class="number">1</span>, i - <span class="number">1</span>) + ans) % <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(ans == <span class="number">1</span>) cout &lt;&lt; <span class="number">2</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; <span class="number">0</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>和官方题解一样，我麻烦的地方在于判断组合数的奇偶性：</p>
<p>$\binom{n}{m}\equiv [n \&amp; m = m]\mod2$</p>
<p>但比赛时不知道就没办法了，不可能花时间去想这个东西的，直接数 $2$ 的个数花不了什么时间，在比赛中肯定是选择时间更短的方案。</p>
<p>至于这是为什么，我记得组合数取模有一个专门的定理，到时候会专门出一篇博客讲解，这里不再赘述。</p>
</div></details>
<h1 id="C-Giant-Graph"><a href="#C-Giant-Graph" class="headerlink" title="C. Giant Graph"></a>C. Giant Graph</h1><p>单独开了一篇题解。</p>
<h1 id="D-Merge-Triplets"><a href="#D-Merge-Triplets" class="headerlink" title="D. Merge Triplets"></a>D. Merge Triplets</h1><p>题目链接：<a href="https://atcoder.jp/contests/agc043/tasks/agc043_d">https://atcoder.jp/contests/agc043/tasks/agc043_d</a></p>
<p>题目大意：问有多少个 $3N$ 的合法排列，合法排列的定义是：</p>
<p>给 $N$ 个长度为 $3$ 的序列，序列中的数互不相同且都在 $[1,3N]$ 。</p>
<p> $P$ 初始为空，然后每次选择所有序列开头最小的数字，删掉，加入 $P$ 中，最后得到的 $P$ 称为合法排列。</p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>合法的 $P$ 有什么要求呢？</p>
<p>如果出现 $P_{i} &gt; P_{i+1}$ ，说明肯定是某个序列中连续弹出了两个数字，这启示我们可以把排列分成若干段：$[l_1,r_1],[l_2,r_2],…,[l_m,r_m]$ 。</p>
<p>满足：</p>
<ol>
<li>$\forall l_i\le j\le r_i:P_{j}\le P_{l_i}$</li>
<li>$P_{l_i} &lt; P_{l_{i+1}}$</li>
</ol>
<p>可以注意到对于每个排列 $P$ ，分法是唯一的。</p>
<p>那么可以注意到 $P$ 合法当且仅当每段长度 $\le 3$ ，而且长度 $\ge 2$ 的段数 $\le n$ 。</p>
<p>然后直接 dp 就行了。</p>
<p>时间复杂度：$O(n^2)$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e3</span> + <span class="number">5</span>;</span><br><span class="line">LL mod, f[N * <span class="number">3</span>][N];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; mod;</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1ll</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n * <span class="number">3</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= n; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i + <span class="number">1</span> &lt;= n * <span class="number">3</span>) f[i + <span class="number">1</span>][j] = (f[i + <span class="number">1</span>][j] + f[i][j]) % mod;</span><br><span class="line">            <span class="keyword">if</span>(i + <span class="number">2</span> &lt;= n * <span class="number">3</span> &amp;&amp; j + <span class="number">1</span> &lt;= n) f[i + <span class="number">2</span>][j + <span class="number">1</span>] = (f[i + <span class="number">2</span>][j + <span class="number">1</span>] + f[i][j] * (i + <span class="number">1</span>)) % mod;</span><br><span class="line">            <span class="keyword">if</span>(i + <span class="number">3</span> &lt;= n * <span class="number">3</span> &amp;&amp; j + <span class="number">1</span> &lt;= n) f[i + <span class="number">3</span>][j + <span class="number">1</span>] = (f[i + <span class="number">3</span>][j + <span class="number">1</span>] + f[i][j] * (i + <span class="number">1</span>) % mod * (i + <span class="number">2</span>)) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    LL ans = <span class="number">0ll</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i++) ans = (ans + f[n * <span class="number">3</span>][i]) % mod;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>和官方题解基本一致。</p>
<p>学到一个新词汇，上面的划分方法可以用一个更加专业的说法说：按照前缀 $max$ 分段。</p>
</div></details>]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>SG</tag>
      </tags>
  </entry>
  <entry>
    <title>AGC044 C. Strange Dance</title>
    <url>/2024/04/22/AGC044-C-Strange-Dance/</url>
    <content><![CDATA[<p>题目链接：<a href="https://atcoder.jp/contests/agc044/tasks/agc044_c">https://atcoder.jp/contests/agc044/tasks/agc044_c</a></p>
<p>题目大意：给一个大小为 $3^{n}$ 的数组，下标为 $0,1,2,…,3^n -1$ ，一开始 $a_{i}=i$，然后有两个操作：</p>
<ol>
<li>令 $a’_{j}=a_{i}$ ，其中 $j$ 是 $i$ 三进制中如果是 $2$ 变成 $1$ ，是 $1$ 变成 $2$ 后的结果。</li>
<li>令 $a$ 数组循环右移一格。</li>
</ol>
<p>问给定操作序列后的数组的逆是啥。</p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>不妨分层考虑：</p>
<p>对于一个 $3^{k}$ 的元件，假如我们已经知道其在操作后进来了多少个数字，出去了什么数字，以及剩下的数字的排布，显然能够类似归并一样的处理出 $3^{k+1}$ 。</p>
<p>然后就做完了。</p>
<p>时间复杂度：$O(n*|S|+3^{n})$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> SN = <span class="number">6e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> L = <span class="number">21</span>;</span><br><span class="line"><span class="type">int</span> n, l, f3[L];</span><br><span class="line"><span class="type">char</span> st[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_char_array</span><span class="params">(<span class="type">char</span> *s)</span></span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">char</span> ss[N];</span><br><span class="line">    cin &gt;&gt; ss;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> len;</span><br><span class="line">    len = <span class="built_in">strlen</span>(ss);</span><br><span class="line">    <span class="built_in">memcpy</span>(s + <span class="number">1</span>, ss, <span class="built_in">sizeof</span>(<span class="type">char</span>) * len);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> nex[][<span class="number">3</span>] = &#123;&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">2</span>, <span class="number">-1</span>, <span class="number">1</span>&#125;&#125;;</span><br><span class="line"><span class="type">int</span> ord[][<span class="number">3</span>]= &#123;&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>&#125;, &#123;<span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>&#125;&#125;;</span><br><span class="line"><span class="type">int</span> be[SN];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; l;</span><br><span class="line">    <span class="built_in">get_char_array</span>(st);</span><br><span class="line">    n = <span class="built_in">strlen</span>(st + <span class="number">1</span>);</span><br><span class="line">    f3[<span class="number">0</span>] = <span class="number">1</span>;<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= l; i++) f3[i] = f3[i - <span class="number">1</span>] * <span class="number">3</span>;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; in, out, res;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; mov;</span><br><span class="line">    <span class="type">int</span> final_type;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> type = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(st[i] == <span class="string">&#x27;S&#x27;</span>) type ^= <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                out.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">                tmp++;</span><br><span class="line">                mov.<span class="built_in">push_back</span>(type);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">        final_type = type;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= l; i++)&#123;<span class="comment">//merge</span></span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; tmp_out = out, tmp_res = res;</span><br><span class="line">        out.<span class="built_in">clear</span>();</span><br><span class="line">        res.<span class="built_in">clear</span>();</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; now[<span class="number">3</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; mov.<span class="built_in">size</span>(); j++)&#123;</span><br><span class="line">            <span class="type">int</span> type = mov[j];</span><br><span class="line">            <span class="type">int</span> o = tmp_out[j];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> t = <span class="number">0</span>; t &lt;= <span class="number">2</span>; t++)&#123;</span><br><span class="line">                <span class="type">int</span> ne = nex[type][t], x;</span><br><span class="line">                <span class="keyword">if</span>(o &lt; f3[i - <span class="number">1</span>]) x = t * f3[i - <span class="number">1</span>] + o;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(!t) x = o - f3[i - <span class="number">1</span>] + f3[i];</span><br><span class="line">                <span class="keyword">else</span> x = now[t][o - f3[i - <span class="number">1</span>]];</span><br><span class="line">                <span class="keyword">if</span>(ne == <span class="number">-1</span>) out.<span class="built_in">push_back</span>(x);</span><br><span class="line">                <span class="keyword">else</span> now[ne].<span class="built_in">push_back</span>(x);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> t = <span class="number">0</span>; t &lt;= <span class="number">2</span>; t++)&#123;</span><br><span class="line">            <span class="type">int</span> tt = ord[final_type][t];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> x : tmp_res)&#123;</span><br><span class="line">                <span class="keyword">if</span>(x &lt; f3[i - <span class="number">1</span>]) res.<span class="built_in">push_back</span>(tt * f3[i - <span class="number">1</span>] + x);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(!tt) res.<span class="built_in">push_back</span>(x - f3[i - <span class="number">1</span>] + f3[i]);</span><br><span class="line">                <span class="keyword">else</span> res.<span class="built_in">push_back</span>(now[tt][x - f3[i - <span class="number">1</span>]]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;x : res)&#123;</span><br><span class="line">            <span class="keyword">while</span>(x &gt;= f3[l]) x = out[x - f3[l]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; f3[l]; i++) be[res[i]] = i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; f3[l]; i++) cout &lt;&lt; be[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></details>
<details class="toggle" ><summary class="toggle-button" style="">Trie 做法</summary><div class="toggle-content"><p>这都能字典树，厉害。</p>
<p>考虑将原来的数组用字典树表示。</p>
<p>首先注意到一个事情，第一个操作是全局下标变换，这在外边打个标记就行了。</p>
<p>而第二个操作全局下标 $+1$ 在传统字典树上很难实现，但是如果字典树是从低到高建的呢？那就非常简单了，处理进位的那棵子树就行了，时间复杂度：$O(n)$ 。</p>
<p>综上，时间复杂度为：$O(n*|S|+3^n)$ 。</p>
</div></details>]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>Trie</tag>
      </tags>
  </entry>
  <entry>
    <title>AGC061 B. Summation By Construction</title>
    <url>/2023/09/06/AGC061-B-Summation-By-Construction/</url>
    <content><![CDATA[<p>题目链接：<a href="https://atcoder.jp/contests/agc061/tasks/agc061_b">https://atcoder.jp/contests/agc061/tasks/agc061_b</a></p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>Mad，纯纯折磨题。</p>
<p>首先，$n=2$ 的时候是无解的，因为连出 $i=2$ 的路径后剩下的两条边无法连到一起。</p>
<p>做法的核心思想是，将两条路径拼到一起，考虑找出一个更长的路径，然后再拆开。</p>
<p>例如奇数的情况，是把路径拼成 $\frac{n+1}{2}$ 条长度为 $2n$ 的路径，然后拆出结果。</p>
<p>做法就是，下面分别从 $1,3,5..$ 开时重复连 M 型。（下面默认二分图上面部分有 $n$ 个点，下面部分有 $n+1$ 个点）</p>
<p>$n=5$ 的情况如下：</p>
<p><img src="1.png" alt=""></p>
<p>然后当时因为 $2$ 无解，而且偶数的情况我想不出来，感觉应该是无解，然后还证明了，然后就写了交上去，WA飞了，百思不得其解，下了数据才发现除了 $2$ 都有解，但是由于已经忘了怎么证了，也就不知道证明哪里假了。</p>
<p>所以，在做这种题目的时候，不能因为没想出来就主观认为无解（不然你猜猜这道题目的评级为什么 3000+ ），还是应该写个暴力或者手动再验证几组数据再下结论。</p>
<p>那么偶数怎么做呢？</p>
<p>同样的思路，我们发现 $i=n$ 一定会在下面产生两个奇数点，需要一条路径消掉，所以不妨考虑处理 $\frac{n}{2}+2$ 条路经，其中 $\frac{n}{2}-1$ 条处理上面为起终点的长度为 $2(n-1)$ 的路径，然后剩下三条路径一条以上面剩下两个奇数点为起终点，两条在下面。</p>
<p>首先是 $\frac{n}{2}-1$ 的路径，在上面分别以 $3,5,7…$ 为起点，以下面的 $n-1$ 个点为中转点抛出类似 M 的路径，被去掉的 $2$ 个点也是有规律的，按照 $(n-2,n-1),(n-4,n-3)…$ 这样下去。</p>
<p>剩下的边可以凑数长度为 $4,2n,2(n-3)$ 的路径，至于怎么凑，看代码吧。</p>
<p>时间复杂度：$O(Tn^2)$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 110</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NN 210</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> v[N][N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> T;<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">2</span>)&#123;<span class="built_in">printf</span>(<span class="string">&quot;No\n&quot;</span>);<span class="keyword">continue</span>;&#125;</span><br><span class="line">        <span class="keyword">if</span>(n&amp;<span class="number">1</span>)&#123;</span><br><span class="line">           <span class="type">int</span> x=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i+i&lt;=n;i++)&#123;</span><br><span class="line">                <span class="type">int</span> cnt=<span class="number">0</span>;<span class="type">int</span> y=x;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">                    cnt++;</span><br><span class="line">                    <span class="keyword">if</span>(cnt&lt;=i+i)v[j][y]=i;</span><br><span class="line">                    <span class="keyword">else</span> v[j][y]=n-i;</span><br><span class="line">                    cnt++;y++;<span class="keyword">if</span>(y==n+<span class="number">2</span>)y=<span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">if</span>(cnt&lt;=i+i)v[j][y]=i;</span><br><span class="line">                    <span class="keyword">else</span> v[j][y]=n-i;</span><br><span class="line">                &#125;</span><br><span class="line">                x+=<span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="type">int</span> pre=<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n/<span class="number">2</span>;i++)&#123;</span><br><span class="line">                <span class="type">int</span> x=i*<span class="number">2</span>+<span class="number">1</span>,t=n-i*<span class="number">2</span>,y=<span class="number">1</span>,cnt=pre+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span>(cnt==<span class="number">2</span> || cnt==n<span class="number">-3</span>)cnt++;</span><br><span class="line">                pre=cnt;</span><br><span class="line">                <span class="type">int</span> type=cnt;</span><br><span class="line">                <span class="comment">// printf(&quot;%d %d %d\n&quot;,x,y,t);</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;n;j++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(j&gt;cnt)type=n<span class="number">-1</span>-cnt;</span><br><span class="line">                    v[x][y]=type;</span><br><span class="line">                    x++;<span class="keyword">if</span>(x==n+<span class="number">1</span>)x=<span class="number">1</span>;</span><br><span class="line">                    <span class="comment">// printf(&quot;%d %d %d\n&quot;,x,y,t);</span></span><br><span class="line">                    v[x][y]=type;</span><br><span class="line">                    y++;<span class="keyword">if</span>(y==n+<span class="number">2</span>)y=<span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">while</span>(y==t || y==t+<span class="number">1</span>)&#123;y++;<span class="keyword">if</span>(y==n+<span class="number">2</span>)y=<span class="number">1</span>;&#125;</span><br><span class="line">                    <span class="comment">// printf(&quot;%d %d %d\n&quot;,x,y,t);</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            v[<span class="number">1</span>][<span class="number">1</span>]=v[<span class="number">1</span>][<span class="number">2</span>]=v[n][<span class="number">2</span>]=v[n][n+<span class="number">1</span>]=n;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n<span class="number">-2</span>;i++)v[n-i][n+<span class="number">2</span>-i]=v[n-i][n+<span class="number">1</span>-i]=n;</span><br><span class="line">            v[<span class="number">2</span>][<span class="number">1</span>]=v[<span class="number">2</span>][<span class="number">2</span>]=v[<span class="number">3</span>][<span class="number">2</span>]=v[<span class="number">3</span>][<span class="number">3</span>]=<span class="number">2</span>;</span><br><span class="line">            v[<span class="number">1</span>][<span class="number">3</span>]=v[<span class="number">4</span>][<span class="number">3</span>]=n<span class="number">-3</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">4</span>;i&lt;n;i++)v[i][i]=v[i+<span class="number">1</span>][i]=n<span class="number">-3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Yes\n&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n+<span class="number">1</span>;j++)<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,v[i][j]);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>回顾：</p>
<p>这道题目其实还是挺有难度的，回顾一下做题过程纪念纪念自己花了这么久时间做出来的一道题目。</p>
<p>而且这道题目的做题过程其实也可以推广到很多存在性构造题上。</p>
<p>首先看到一个构造题，尤其是比较难的构造题，如果直接从其的题目条件出发很多时候不一定能做，因为情况太多，太过复杂和没有规律，这个时候就需要把问题缩小到一个有规律的题目上面，只不过这种缩小有时候可能会无解。</p>
<p>例如奇数的情况我就认为一定存在一种方案使得路径能够连接成 $\frac{n+1}{2}$ 条长度为 $2n$ 的路径，从而把题目变成了一个有规律更好想的题目，但是这种缩小有时候不一定正确，思考缩小的过程也是凭直觉，比较感性，灵感往往来源于自己手动模拟多次后作出的猜想。</p>
<p>再例如，我认为偶数也可以拼成 $\frac{n}{2}$ 条长度为 $2(n-1)$ 的路径，但是却发现剩下的边构成了一个环（事实上想想也知道肯定不是路径，因为此时图中不存在奇数度的点），那么就把一条路径放回去，尝试人为的构造出三条路径。</p>
<p>而且这一步从度数的角度考虑也非常的正确，因为 $i=n$ 的路径一定会在下面创造一对奇数度点，所以我们必须把上面一条由两条路径拼成的路径拆回两条，一条占住他们本来的奇数度点，一条下来消掉 $i=n$ 创造的奇数度点。</p>
<p>然后通过这个操作，问题规模就缩小很多了，接下来就可以自己不断手模求一个通用解了，这样偶数的情况也就搞定了。</p>
<p>所以构造题，往往就是你自己再给题目加上一些约束条件，看看能否找到一个解，找不到就不断调整约束条件，直到找到为止。</p>
</div></details>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>构造</tag>
        <tag>二分图</tag>
      </tags>
  </entry>
  <entry>
    <title>AGC061 C. First Come First Serve</title>
    <url>/2023/08/25/AGC061-C-First-Come-First-Serve/</url>
    <content><![CDATA[<p>题目链接：<a href="https://atcoder.jp/contests/agc061/tasks/agc061_c">https://atcoder.jp/contests/agc061/tasks/agc061_c</a></p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>显然的方向：我们可以让一些选择非法，使得每个答案对应一个合法的选择。</p>
<p>准确来说，我们定义 $ff[i]$ 表示最大的 $j$ 使得 $i&lt;k\le j$ 满足 $l_k&lt;r_i$ 。</p>
<p>我们考虑每个顾客，填 $1$ 表示选择离开时候记录，$0$ 表示选择进入时记录。</p>
<p>那么一个位置填 $0$ 的条件为 $(i,ff[i]]$ 中有一个位置填 $0$ 或者存在一个位置 $k$ 填 $1$ 且 $i\in (k,ff[k]]$ 。</p>
<p>然后用 DP 维护合法方案即可。</p>
<p>一个显然的傻瓜式 DP 是：</p>
<p>$f_1[i]$ 表示 $i$ 填 $1$ 的目前合法序列个数。</p>
<p>$f_2[i]$ 表示 $i$ 填 $0$ 的可能合法序列个数。</p>
<p>$f_3[i]$ 表示 $i$ 填 $0$ ，$i-1$ 填 $1$ 的合法序列个数。</p>
<p>转移即可。</p>
<p>但是这里要讲一个优化，把 $f_3$ 优化掉，就是有一个转移是：</p>
<p>$f_2-&gt;f_3$ ，内容为往后放若干 $1$ 后放一个 $0$ ,那我们不妨先转移到 $f_1$ ，再减去没有放 $0$ 的序列（即减去不合法的序列）</p>
<p>于是：</p>
<p>$f_1[j]+=f2<a href="j\in (i,ff[i]">i</a>),f_1[j]-=(j\in (i+1,ff[i]])$</p>
<p>但是这时又产生了一个疑惑，在化简了式子后可以缩减为：</p>
<p>$f_1[i+1]+=f_2[i],f_1[ff[i]]-=f_2[i]$ 。</p>
<p>其实不难发现，所有的不合法方案在 DP 过程中都一定会经过 $f_1[ff[i]]$ 且贡献为 $1$ ，减掉即可。</p>
<p>时间复杂度：$O(n)$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 510000</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> LL mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> l,r;</span><br><span class="line">&#125;a[N];<span class="type">int</span> ff[N],n;</span><br><span class="line">LL f1[N],f2[N],f3[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a[i].l,&amp;a[i].r);</span><br><span class="line">    <span class="type">int</span> now=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(now&lt;n &amp;&amp; a[now+<span class="number">1</span>].l&lt;=a[i].r)now++;</span><br><span class="line">        ff[i]=now;</span><br><span class="line">    &#125;</span><br><span class="line">    LL fnow=<span class="number">0</span>;f1[<span class="number">1</span>]=f2[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        (f1[i]+=fnow)%=mod;(f2[ff[i]+<span class="number">1</span>]+=f1[i])%=mod;</span><br><span class="line">        <span class="keyword">if</span>(ff[i]&gt;i)(f2[i+<span class="number">1</span>]+=f2[i])%=mod,(f1[i+<span class="number">1</span>]+=f2[i])%=mod,(f1[ff[i]]+=mod-f2[i])%=mod;</span><br><span class="line">        (fnow+=f1[i])%=mod;(f3[ff[i]+<span class="number">1</span>]+=f1[i])%=mod;</span><br><span class="line">        (fnow+=mod-f3[i])%=mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// for(int i=1;i&lt;=n;i++)printf(&quot;%d:%d %lld %lld\n&quot;,i,ff[i],f1[i],f2[i]);</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,fnow);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></details>]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>AGC062 B. Split and Insert</title>
    <url>/2023/09/01/AGC062-B-Split-and-Insert/</url>
    <content><![CDATA[<p>题目链接：<a href="https://atcoder.jp/contests/agc062/tasks/agc062_b">https://atcoder.jp/contests/agc062/tasks/agc062_b</a></p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>非常有意思的一道题目。</p>
<p>我们考虑一个序列被切割以后进入一种如放的状态，简单来说就是我手里现在有两个序列可以拼起来。</p>
<p>当操作一次后会发现手里的两个序列变成了四个序列，而代价实际上就是原来两个序列裂成两个序列的代价之和（因为代价的计算公式是一次式）。</p>
<p>因此，显然，我们要把原串切成一堆上升序列，而代价都是可以自己独立统计后再加起来的，直接上区间 DP ，时间复杂度：$O(Kn^3)$ 。</p>
<p>无解的充分必要条件：最少的上升序列个数 $&gt;2^K$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 110</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line">LL dp[N][N][N],C[N];</span><br><span class="line"><span class="type">int</span> n,K,a[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;K);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=K;i++)<span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;C[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="type">int</span> x;<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">        a[x]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// for(int i=1;i&lt;=n;i++)printf(&quot;%d &quot;,a[i]);</span></span><br><span class="line">    <span class="comment">// printf(&quot;\n&quot;);</span></span><br><span class="line">    <span class="built_in">memset</span>(dp,<span class="number">20</span>,<span class="built_in">sizeof</span>(dp));</span><br><span class="line">    <span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i]&gt;a[i+<span class="number">1</span>])cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=K;i++)cnt&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(cnt)&#123;<span class="built_in">printf</span>(<span class="string">&quot;-1\n&quot;</span>);<span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        dp[K+<span class="number">1</span>][i][i]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[j]&lt;a[j<span class="number">-1</span>])<span class="keyword">break</span>;</span><br><span class="line">            dp[K+<span class="number">1</span>][i][j]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> t=K;t&gt;=<span class="number">1</span>;t--)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i;j&lt;=n;j++)&#123;</span><br><span class="line">                dp[t][i][j]=dp[t+<span class="number">1</span>][i][j];</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k=i;k&lt;j;k++)dp[t][i][j]=<span class="built_in">min</span>(dp[t+<span class="number">1</span>][i][k]+dp[t+<span class="number">1</span>][k+<span class="number">1</span>][j]+(j-k)*C[t],dp[t][i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// for(int i=1;i&lt;=K+1;i++)&#123;</span></span><br><span class="line">    <span class="comment">//     for(int j=1;j&lt;=n;j++)&#123;</span></span><br><span class="line">    <span class="comment">//         for(int k=j;k&lt;=n;k++)printf(&quot;%d %d %d:%lld\n&quot;,i,j,k,dp[i][j][k]);</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,dp[<span class="number">1</span>][<span class="number">1</span>][n]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></details>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
  </entry>
  <entry>
    <title>AGC063 A. Mex Game</title>
    <url>/2023/08/25/AGC063-A-Mex-Game/</url>
    <content><![CDATA[<p>题目链接：<a href="https://atcoder.jp/contests/agc063/tasks/agc063_a">https://atcoder.jp/contests/agc063/tasks/agc063_a</a></p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>显然，如果我是 $A$ ，我一定会把数字放在最小的没被堵上的 $B$ 。</p>
<p> $B$ 同理，最终结果为最小的没有被堵上的位置上面的字符。</p>
<p>时间复杂度：$O(n)$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 210000</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">char</span> st[N];<span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> now1,now2,now3;</span><br><span class="line"><span class="type">bool</span> v[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,st);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i&amp;<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span>(now1&lt;n &amp;&amp; st[now1]!=<span class="string">&#x27;B&#x27;</span>)now1++;</span><br><span class="line">            <span class="keyword">if</span>(now1&lt;=n)v[now1++]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(now2&lt;n &amp;&amp; st[now2]!=<span class="string">&#x27;A&#x27;</span>)now2++;</span><br><span class="line">            <span class="keyword">if</span>(now2&lt;=n)v[now2++]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(now3&lt;=n &amp;&amp; v[now3])now3++;</span><br><span class="line">        <span class="keyword">if</span>(!v[now3])&#123;</span><br><span class="line">            <span class="keyword">if</span>(st[now3]==<span class="string">&#x27;A&#x27;</span>)<span class="built_in">printf</span>(<span class="string">&quot;Alice\n&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;Bob\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></details>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>博弈</tag>
      </tags>
  </entry>
  <entry>
    <title>AGC063 B. Insert 1, 2, 3, ...</title>
    <url>/2023/08/25/AGC063-B-Insert-1-2-3/</url>
    <content><![CDATA[<p>题目链接：<a href="https://atcoder.jp/contests/agc063/tasks/agc063_b">https://atcoder.jp/contests/agc063/tasks/agc063_b</a></p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>对于一个序列的检验，我们可以认为是每次选择一个递增序列，删掉，看最后能不能删完，能删完就是合法序列。</p>
<p>证明两个定理：</p>
<ol>
<li>假如我在后面某步删除了某个序列，且这个序列在现在就存在且能删除，那么现在直接删除不会影响最终判断。<br>例如：1231234，我先删了 123 再删除 1234，但是其实一开始就能删除 1234，那么我一开始就删除 1234 不会影响最终判断。</li>
<li>加入我在某一步删除了一个序列，那么如果我在之前的某一步的瞬间突然删除掉了这个序列某一个后缀，不会导致将原本合法的序列判断为不合法。<br>例如：1231212456 ，显然删除顺序是：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure></div></details>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
  </entry>
  <entry>
    <title>AGC063 C. Add Mod Operations</title>
    <url>/2023/09/01/AGC063-C-Add-Mod-Operations/</url>
    <content><![CDATA[<p>题目链接：<a href="https://atcoder.jp/contests/agc063/tasks/agc063_c">https://atcoder.jp/contests/agc063/tasks/agc063_c</a></p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>无解的充分必要条件：</p>
<p>存在 $i,j(i≠j)$ ，使得 $a_i=a_j,b_i≠b_j$ 。</p>
<p>有解时的构造方法：</p>
<p>设 $c_i$ 表示 $a_i$ 在 $a$ 序列里面从大到小排序的位置。</p>
<p>考虑构造一个这样的序列：$b_i+c_i*K$ ，$K$ 表示一个大于所有 $a$ 的数字。</p>
<p>然后最后全部模 $K$ 就行了。</p>
<p>怎么构造这个序列呢？考虑不算次数的情况，那么先把所有数字加个 INF ，然后每次让当前最大的数字变成 $0$，并且再变成 $0$ 之前加上这个数字与前一个变成 $0$ 的数字之间的间隔，然后就做完了。</p>
<p>然后只要精细化的处理一下这个过程，就可以办到恰好 $n$ 次做完这个过程。</p>
<p>时间复杂度：$O(n\log{n})$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 1100</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;LL,LL&gt; PLL;</span><br><span class="line"><span class="type">const</span> LL inf=<span class="number">1e16</span>;</span><br><span class="line">LL a[N],b[N];<span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> top,sta[N];LL now,d[N];</span><br><span class="line">PLL c[N];LL maxcost=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;<span class="keyword">return</span> a[x]&gt;a[y];&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;a[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;<span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;b[i]);maxcost=<span class="built_in">max</span>(maxcost,b[i]+<span class="number">1</span>);&#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="type">bool</span> bk=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>((a[j]==a[i]) &amp;&amp; (b[j]!=b[i]))&#123;<span class="built_in">printf</span>(<span class="string">&quot;No\n&quot;</span>);<span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line">            <span class="keyword">if</span>(j&lt;i &amp;&amp; a[j]==a[i])bk=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!bk)sta[++top]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(sta+<span class="number">1</span>,sta+top+<span class="number">1</span>,cmp);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;top;i++)d[i]=(top-i<span class="number">-1</span>)*maxcost+b[sta[i]];</span><br><span class="line">    now=inf;LL nowx=now%maxcost;now+=(b[sta[top]]-nowx+maxcost)%maxcost;now-=a[sta[top]];</span><br><span class="line">    c[top].second=maxcost;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Yes\n%d\n&quot;</span>,top);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=top;i&gt;=<span class="number">1</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i!=top)c[i].second=now+a[sta[i]];</span><br><span class="line">        <span class="keyword">if</span>(i!=<span class="number">1</span>)c[i].first=d[i<span class="number">-1</span>]-d[i],now-=c[i].first;</span><br><span class="line">    &#125;</span><br><span class="line">    c[<span class="number">1</span>].first=now;</span><br><span class="line">    <span class="keyword">if</span>(top==<span class="number">1</span>)c[<span class="number">1</span>].first%=c[<span class="number">1</span>].second;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=top;i++)<span class="built_in">printf</span>(<span class="string">&quot;%lld %lld\n&quot;</span>,c[i].first,c[i].second);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></details>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>构造</tag>
      </tags>
  </entry>
  <entry>
    <title>AGC064 D. Red and Blue Chips</title>
    <url>/2023/09/07/AGC064-D-Red-and-Blue-Chips/</url>
    <content><![CDATA[<p>题目链接：<a href="https://atcoder.jp/contests/agc064/tasks/agc064_d">https://atcoder.jp/contests/agc064/tasks/agc064_d</a></p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>Mad，做这道题目的时候把某个定理想错了，想的既错误又复杂，笑死，根本不会做，后面发现想错了，就简单很多了，不久就知道怎么做了。</p>
<p>定理1：假如给每个 B 标号，那么最终的芯片排列中 B 的不同排列有 $(n-1)!$ 种，因为最底下的 B 是固定的，而且每个排列对应一种操作方式（指的是 B 的操作方式）。（这个定理解决了 B 的位置）</p>
<p>定理2：我们定义最终排列中 B 下面的 R 的数量为其的权值，那么前 $i$ 个 B 的权值不超过第 $i$ 个 B 前面的 R 的数量，且只要满足这个要求，就一定能够构造出来。（这个定理解决了 R 的位置）</p>
<p>定理2的构造方法是在放第 $i$ 个 B 之前提前把芯片放到他即将覆盖的 B 的上面就行了，不难发现，在第 $i$ 个 B 放之前一定能放，不管即将被覆盖的 B 怎么移动，同时覆盖了之后一定不能再放。</p>
<p>那么接下来就是怎么做的问题了，显然求出每个 $B$ 的权值然后排列就行了，不难发现，我们可以人为的规定权值非严格单调递增。</p>
<p>接下来我的 DP 是：$dp[i][j][k]$ 表示前 $i$ 个 B 被考虑过了，前面还有 $j$ 个 R ，同时第 $i$ 个芯片的权值为 $k$ 。</p>
<p>不难发现 $k-&gt;k+1$ 的更新最多跑 $\frac{n}{k+1}$ 步，然后就会触发无法放置然后终止后续的更新。</p>
<p>所以这里有个调和级数，时间复杂度： $O(n^3\log{n})$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 310</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> LL mod=<span class="number">998244353</span>;</span><br><span class="line">LL nfc[N],fc[N];</span><br><span class="line">LL dp[N][N][N];</span><br><span class="line"><span class="type">int</span> n,m,a[N];</span><br><span class="line"><span class="type">char</span> st[N];</span><br><span class="line"><span class="function">LL <span class="title">C</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;<span class="keyword">return</span> fc[x]*nfc[y]%mod*nfc[x-y]%mod;&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%s&quot;</span>,&amp;n,st+<span class="number">1</span>);</span><br><span class="line">    fc[<span class="number">0</span>]=fc[<span class="number">1</span>]=nfc[<span class="number">0</span>]=nfc[<span class="number">1</span>]=<span class="number">1</span>;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)nfc[i]=nfc[mod%i]*(mod-mod/i)%mod;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)nfc[i]=nfc[i<span class="number">-1</span>]*nfc[i]%mod,fc[i]=fc[i<span class="number">-1</span>]*i%mod;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(st[i]==<span class="string">&#x27;B&#x27;</span>)m++;</span><br><span class="line">        <span class="keyword">else</span> a[m+<span class="number">1</span>]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)a[i]+=a[i<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">        dp[i][a[i]][<span class="number">0</span>]=<span class="built_in">C</span>(m<span class="number">-1</span>,i);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=a[i];j++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=a[m<span class="number">-1</span>];k++)dp[i][j][k]=(dp[i][j][k]+dp[i][j][k<span class="number">-1</span>])%mod;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=a[i];j++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=a[m<span class="number">-1</span>];k&gt;=<span class="number">1</span>;k--)&#123;</span><br><span class="line">                <span class="type">int</span> t=k<span class="number">-1</span>,now=j;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> q=i+<span class="number">1</span>;q&lt;m;q++)&#123;</span><br><span class="line">                    now+=a[q]-a[q<span class="number">-1</span>]-k;<span class="keyword">if</span>(now&lt;<span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">                    dp[q][now][k]=(dp[q][now][k]+dp[i][j][t]*<span class="built_in">C</span>(m<span class="number">-1</span>-i,q-i))%mod;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    LL ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=a[m<span class="number">-1</span>];i++)ans=(ans+dp[m<span class="number">-1</span>][i][a[m<span class="number">-1</span>]])%mod;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然而一翻题解，发现题解的复杂度没有 $\log$ ，于是我又去优化。</p>
<p>然后就改了一个地方，就是对于 $i$ ，实际上能够更新到答案的有效的 $i$ 只会到 $n-\frac{n}{k}$ 左右。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 310</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> LL mod=<span class="number">998244353</span>;</span><br><span class="line">LL nfc[N],fc[N];</span><br><span class="line">LL dp[N][N][N];</span><br><span class="line"><span class="type">int</span> n,m,a[N];</span><br><span class="line"><span class="type">char</span> st[N];</span><br><span class="line"><span class="function">LL <span class="title">C</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;<span class="keyword">return</span> fc[x]*nfc[y]%mod*nfc[x-y]%mod;&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%s&quot;</span>,&amp;n,st+<span class="number">1</span>);</span><br><span class="line">    fc[<span class="number">0</span>]=fc[<span class="number">1</span>]=nfc[<span class="number">0</span>]=nfc[<span class="number">1</span>]=<span class="number">1</span>;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)nfc[i]=nfc[mod%i]*(mod-mod/i)%mod;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)nfc[i]=nfc[i<span class="number">-1</span>]*nfc[i]%mod,fc[i]=fc[i<span class="number">-1</span>]*i%mod;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(st[i]==<span class="string">&#x27;B&#x27;</span>)m++;</span><br><span class="line">        <span class="keyword">else</span> a[m+<span class="number">1</span>]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)a[i]+=a[i<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">        dp[i][a[i]][<span class="number">0</span>]=<span class="built_in">C</span>(m<span class="number">-1</span>,i);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=a[i];j++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=a[m<span class="number">-1</span>];k++)dp[i][j][k]=(dp[i][j][k]+dp[i][j][k<span class="number">-1</span>])%mod;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i!=m<span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=a[i];j++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k=(a[m<span class="number">-1</span>]-a[i]+j)/(m<span class="number">-1</span>-i);k&gt;=<span class="number">1</span>;k--)&#123;</span><br><span class="line">                    <span class="type">int</span> t=k<span class="number">-1</span>,now=j;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> q=i+<span class="number">1</span>;q&lt;m;q++)&#123;</span><br><span class="line">                        now+=a[q]-a[q<span class="number">-1</span>]-k;<span class="keyword">if</span>(now&lt;<span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">                        dp[q][now][k]=(dp[q][now][k]+dp[i][j][t]*<span class="built_in">C</span>(m<span class="number">-1</span>-i,q-i))%mod;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    LL ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=a[m<span class="number">-1</span>];i++)ans=(ans+dp[m<span class="number">-1</span>][i][a[m<span class="number">-1</span>]])%mod;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么这个复杂度是多少呢？答案是 $O(n^3)$ 。</p>
<p>因为我们不妨考虑枚举 $k$ ，那么有效的 $i$ 有 $O(\frac{n}{k})$ 个，向后转移就平方 $O(n*(\sum\limits_{k=1}^n\frac{n^2}{k^2}))=O(n^3\sum\limits_{i=1}^n\frac{1}{i^2})=O(n^3)$ 。</p>
<p>奇妙吧，这就是时间复杂度分析的美妙之处，一个看似只改变常数的优化竟然能优化掉复杂度中的一个 $\log$ ，实在是奇妙无比。</p>
</div></details>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>计数</tag>
        <tag>DP</tag>
        <tag>经典trick</tag>
      </tags>
  </entry>
  <entry>
    <title>AGC065 D. Not Intersect</title>
    <url>/2024/02/11/AGC065-D-Not-Intersect/</url>
    <content><![CDATA[<p>题目链接：<a href="https://atcoder.jp/contests/agc065/tasks/agc065_d">https://atcoder.jp/contests/agc065/tasks/agc065_d</a></p>
<p>题目大意：圆上有 $n$ 个点，问有多少种连法，使得有 $m$ 条边且边不交叉（可以在端点处相交）</p>
<p>$n,m\le 10^7$ </p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>神仙组合意义，投降。</p>
<p>当 $m=0$ 或者 $m&gt;2n-3$ 时可以直接输出答案，下面默认 $n\ge 2,0&lt;m\le 2n-3$</p>
<p>设 $f_i$ 表示 $n$ 个点 $i$ 条边的答案，$g_i$ 表示 $n$ 个点 $i$ 条边且允许重边的答案。</p>
<p>显然有：$f_n=\sum\limits_{i=1}^n\binom{n-1}{i-1}g_i$</p>
<p>则由二项式反演有：$g_n=\sum\limits_{i=1}^{n}(-1)^{n-i}\binom{n-1}{i-1}f_i$ 。</p>
<p>现在考虑怎么计算 $g_i$ ，考虑边不能交叉这个条件，如果你足够智慧，你就会发现有一个结构很符合这个要求：栈。</p>
<p>现在我们用这么一个过程去描述连边的过程：</p>
<p>从 $1$ 到 $n$ ，到达 $i$ 的时候，先弹出栈内的若干元素，再往栈内加入若干个 $i$ ，到最后栈为空，如果 $i$ 在 $j$ 的时候弹出就代表了一条 $(i,j)$ 的边。</p>
<p>显然，这个过程一一对应，现在就是计数了。</p>
<p>可以发现，$1$ 只能入栈，$n$ 只能出栈，所以我们不妨改为 $n-1$ 次入栈和出栈。（接下来假设要求 $g_k$ 的值）</p>
<p>现在就是 $a_i$ 表示入栈的次数，$b_i$ 表示出栈的次数，满足：</p>
<script type="math/tex; mode=display">1\le i\le n-1,a_i\ge b_i,0\le a_i,b_i \le k,a_i\le a_{i+1},b_i\le b_{i+1},a_{n-1}=b_{n-1}=k</script><p>显然，一个合法的 $a$ 序列代表了一条从 $(0,0)$ 到 $(n-2,k)$ 只能向右或者向上的的路径，$b$ 同理。</p>
<p>则一个合法的 $a,b$ 序列对应了两条合法的路径，且满足一条路径始终在另外一条路径下端。</p>
<p>可以发现，我们设 $0$ 为向右，$1$ 为向上，假设我们能计算有 $a$ 个 $0$ ，$b$ 个 $1$ 时有多少对路径满足第二条路径在第一条路径下方，称作函数 $calc(a,b)$ ，那么我们所求的就是 $calc(n-2,k)$ 。</p>
<p>研究第 $i$ 步，可以发现就四种情况：$(0,0),(0,1),(1,0),(1,1)$ ，可以发现，就是要让每个时刻 $(1,0)$ 的数量不少于 $(0,1)$ 的数量，如果用折线法描述就是上面是：$0,-1,0,1$ ，然后不要让折线低过 $x$ 轴，显然，$-1,1$ 的数量是一样的，枚举 $1$ 的数量就可以知道四种情况的数量了：</p>
<script type="math/tex; mode=display">
\begin{align*} 
calc(a,b)&=\sum\limits_{i=0}^{min(a,b)}\frac{(2i)!}{i!(i+1)!}*\binom{a+b-2i}{a-i}*\binom{(a+b-2i)+(2i+1)-1}{(2i+1)-1}\\
&=\sum\limits_{i=0}^{min(a,b)}\frac{(2i)!}{i!(i+1)!}*\binom{a+b-2i}{a-i}*\binom{a+b}{2i}\\ 
&=\sum\limits_{i=0}^{min(a,b)}\frac{(2i)!}{i!(i+1)!}*\frac{(a+b-2i)!}{(a-i)!(b-i)!}*\frac{(a+b)!}{(2i)!(a+b-2i)!}\\ 
&=\sum\limits_{i=0}^{min(a,b)}\frac{(a+b)!}{i!(i+1)!(a-i)!(b-i)!}\\
&=\frac{(a+b)!}{a!(b+1)!}\sum\limits_{i=0}^{min(a,b)}\frac{a!}{i!(a-i)!}\frac{(b+1)!}{(i+1)!(b-i)!}\\
&=\frac{(a+b)!}{a!(b+1)!}\sum\binom{a}{i}\binom{b+1}{b-i}\\
&=\frac{(a+b)!}{a!(b+1)!}\binom{a+b+1}{b}\\
&=\frac{(a+b)!(a+b+1)!}{a!b!(a+1)!(b+1)!}
\end{align*}</script><p>然后直接算就行了。</p>
<p>时间复杂度：$O(n)$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> LL mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">3e7</span>+<span class="number">105</span>;</span><br><span class="line">LL fc[N],nfc[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> L=<span class="number">3e7</span>+<span class="number">3</span>;</span><br><span class="line">    fc[<span class="number">0</span>]=fc[<span class="number">1</span>]=nfc[<span class="number">0</span>]=nfc[<span class="number">1</span>]=<span class="number">1</span>;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=L;i++)nfc[i]=(mod-mod/i)*nfc[mod%i]%mod;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=L;i++)nfc[i]=nfc[i<span class="number">-1</span>]*nfc[i]%mod,fc[i]=fc[i<span class="number">-1</span>]*i%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n;LL m;</span><br><span class="line">LL g[N];</span><br><span class="line"><span class="function">LL <span class="title">calc</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fc[a+b+<span class="number">1</span>]*fc[a+b]%mod*nfc[a]%mod*nfc[b]%mod*nfc[a+<span class="number">1</span>]%mod*nfc[b+<span class="number">1</span>]%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">C</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fc[x]*nfc[y]%mod*nfc[x-y]%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%lld&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">if</span>(!m)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;1\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(m&gt;n+n<span class="number">-3</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;0\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//n&gt;=2</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)g[i]=<span class="built_in">calc</span>(n<span class="number">-2</span>,i);</span><br><span class="line">    LL ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>((m-i)&amp;<span class="number">1</span>)ans=(ans-g[i]*<span class="built_in">C</span>(m<span class="number">-1</span>,i<span class="number">-1</span>)%mod+mod)%mod;</span><br><span class="line">        <span class="keyword">else</span> ans=(ans+g[i]*<span class="built_in">C</span>(m<span class="number">-1</span>,i<span class="number">-1</span>))%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></details>
<h6 id="坑"><a href="#坑" class="headerlink" title="坑"></a>坑</h6><p>没有生成函数做法。</p>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>计数</tag>
      </tags>
  </entry>
  <entry>
    <title>AGC066 D. A Independent Set</title>
    <url>/2024/05/13/AGC066-D-A-Independent-Set/</url>
    <content><![CDATA[<p>题目链接：<a href="https://atcoder.jp/contests/agc066/tasks/agc066_d">https://atcoder.jp/contests/agc066/tasks/agc066_d</a></p>
<p>题目大意：给你一个 $AB$ 串，保证 $A\le \frac{n + 1}{2}$ ，每次可以交换 $i$ 和 $i + 1$ 的字符，代价为 $w_{i + 1}$ ，要求最小的代价满足：任意两个 $A$ 不相邻。</p>
<details class="toggle" ><summary class="toggle-button" style="">我的做法</summary><div class="toggle-content"><p>观察到一个事情：考任意一种可能成为最优方案的方案，一定可以表示成某几个位置的展开。</p>
<p>展开的意思是是说：选择一个 $A$ ，然后从左到右依次将 $A$ 推开，直到某个小区间内没有 $A$ 相邻。</p>
<p>举个例子：$BBBAAABBB$ ，选择中间的 $A$ ，那么中间的 $A$ 就会想着把周围的 $A$ 推开，推成：$BBABABABB$ 。</p>
<p>证明的话，考虑每个 $A$ 是往左移还是往右移的，显然，每一段往左移和每一段往右移中间存在一个数字是不动，否则一定可以更加优秀，所以，每一个不动和左边的往左移动，和右边的往右移动构成了上面所描述的一个小区间。</p>
<p>那么处理出所有的这些区间就行了，处理方法就是把 $A$ 看成 $1$ ，把 $B$ 看成 $-1$ ，然后在折线法左右第一次出现等高的位置，就是区间的左右端点。</p>
<p>然后转移就行了，时间复杂度 ： $O(n)$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span> + <span class="number">5</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_char_array</span><span class="params">(<span class="type">char</span> *s)</span></span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">char</span> st[N];</span><br><span class="line">    cin &gt;&gt; st;</span><br><span class="line">    <span class="built_in">memcpy</span>(s + <span class="number">1</span>, st, <span class="built_in">sizeof</span>(<span class="type">char</span>) * <span class="built_in">strlen</span>(st));</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> y, next;</span><br><span class="line">    LL c;</span><br><span class="line">&#125;a[N]; <span class="type">int</span> len, las[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ins</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, LL c)</span></span>&#123;a[++len] = &#123;y, las[x], c&#125;; las[x] = len;&#125;</span><br><span class="line"><span class="type">char</span> st[N];</span><br><span class="line"><span class="type">int</span> pre[N * <span class="number">2</span>], val[N];</span><br><span class="line"><span class="type">int</span> ll[N], rr[N];</span><br><span class="line">LL cost[N], f1[N], f2[N];</span><br><span class="line">LL dp[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        cin &gt;&gt; n;</span><br><span class="line">        <span class="built_in">get_char_array</span>(st + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        n += <span class="number">2</span>;</span><br><span class="line">        st[<span class="number">1</span>] = st[n] = <span class="string">&#x27;B&#x27;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(st[i] == <span class="string">&#x27;A&#x27;</span>) val[i] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> val[i] = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        LL ans = <span class="number">0ll</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">3</span>; i &lt; n; i++)&#123;</span><br><span class="line">            cin &gt;&gt; cost[i];</span><br><span class="line">            cost[i] += cost[i - <span class="number">1</span>];</span><br><span class="line">            f1[i] = f1[i - <span class="number">2</span>] + cost[i];</span><br><span class="line">            f2[i] = f2[i - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(val[i] == <span class="number">1</span>) f2[i] = f2[i] + cost[i];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> sum = n;</span><br><span class="line">        <span class="built_in">fill</span>(pre + <span class="number">1</span>, pre + n + n + <span class="number">1</span>, <span class="number">-10ll</span>);</span><br><span class="line">        pre[n] = <span class="number">0ll</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            sum += val[i];</span><br><span class="line">            ll[i] = pre[sum] + <span class="number">1</span>;</span><br><span class="line">            pre[sum] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        sum = n;</span><br><span class="line">        <span class="built_in">fill</span>(pre + <span class="number">1</span>, pre + n + n + <span class="number">1</span>, <span class="number">-10ll</span>);</span><br><span class="line">        pre[n] = (n + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = n; i &gt;= <span class="number">1</span>; i--)&#123;</span><br><span class="line">            sum += val[i];</span><br><span class="line">            rr[i] = pre[sum] - <span class="number">1</span>;</span><br><span class="line">            pre[sum] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(st[i] == <span class="string">&#x27;A&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(ll[i] &gt;= <span class="number">0</span> &amp;&amp; rr[i] &gt;= <span class="number">-1</span>)&#123;</span><br><span class="line">                    LL val = ((f2[i] - f2[ll[i] - <span class="number">1</span>]) - (f1[i] - f1[ll[i] - <span class="number">1</span>])) +</span><br><span class="line">                             ((f1[rr[i] - <span class="number">1</span>] - f1[i - <span class="number">2</span>]) - (f2[rr[i] - <span class="number">1</span>] - f2[i - <span class="number">1</span>]));</span><br><span class="line">                    <span class="built_in">ins</span>(ll[i], rr[i], val);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">ins</span>(i - <span class="number">1</span>, i, <span class="number">0ll</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0ll</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) dp[i] = <span class="number">1e18</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k = las[i]; k; k = a[k].next)&#123;</span><br><span class="line">                <span class="type">int</span> y = a[k].y;</span><br><span class="line">                dp[y] = <span class="built_in">min</span>(dp[y], dp[i] + a[k].c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; dp[n] &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i++) las[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不懂啊，感觉完全不如 $BCE$ 难，奇怪的难度评价。</p>
</div></details>
<details class="toggle" ><summary class="toggle-button" style="">官方题解</summary><div class="toggle-content"><p>好吧，官方题解确实难想。</p>
<p>其先基于这么一个转化：如果在原字符串后面添上 $B$ ，那么原题可以转化为：花最小的代价使得原串可以被分割成 $AB,B$ 。</p>
<p>那么一个观察就是 $AB$ 中的 $A$ 一定不会跨过 $B$ ，否则 $A$ 与这个 $B$ 组合一定更优。</p>
<p>证明要详细写出来可能会比较麻烦，大致就是讨论一下，因为最优方案一定可以写成每个 $A$ 按顺序往某个方案移动，而且 $A/B$ 与 $A/B$ 之间不会交换，根据这个原理讨论一下就行了。</p>
<p>由这个观察，我们可以证明，满足这个观察的最优答案一定可以分成若干段，其中 $[l_i,r_i]$ 满足两个字符串在这个区间上的 $A,B$ 数量一样，且最终字符串要么是 $B$ ，要么是 $ABABAB…AB$ ，那么就能得到下面的 $dp$ 。</p>
<p>设 $dp[i]$ 表示前 $i$ 个字母变成可以分割成 $AB,B$ 的字符串最小代价。</p>
<p>如果 $i$ 后面是 $B$ ，则可以 $dp[i]\to dp[i+1]$ 。</p>
<p>或者可以在后面放 $AB$ ，根据上面的条件可以得到 $dp[i]\to dp[j]+cost(i+1,j)$ ，满足 $[i+1,j]$ 中的 $A,B$ 数量一样，可以注意到，等价于 $A$ 看成 $1$ ，$B$ 看成 $-1$ 后 $s_{i}=s_{j}$ ，而且又显然，$s_{i}$ 只需要更新到后面第一个满足要求的 $j$ 就行了，因为若 $j,k$ 都满足要求的话：$cost(i+1,k)=cost(i+1,j)+cost(j+1,k)$ ，所以只需要 $i\to j\to k$ 就行了。</p>
<p>至于算 $cost$ 的话，注意到，每一段的 $j$ 都是往一个方向移动的，所以可以很方便的算出 $cost$ 。（原因：根据上面的 $dp$ 过程不难得到，这一段的前缀和都是同号的，要么 $&gt;0$ ，要么 $&lt;0$ ，除了整段是 $=0$ 的）</p>
<p>综上，时间复杂度：$O(n)$ 。</p>
<p>这个做法比我的做法难想，但是比我的做法好写。</p>
<p>而且其中很多思考的细节是值得认真想想的，很有意义的一个做法，感觉能想明白这个做法对提升 $dp$ 能力很有帮助。</p>
</div></details>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
  </entry>
  <entry>
    <title>AGC066 E. Sliding Puzzle On Tree</title>
    <url>/2024/05/16/AGC066-E-Sliding-Puzzle-On-Tree/</url>
    <content><![CDATA[<p>题目链接：<a href="https://atcoder.jp/contests/agc066/tasks/agc066_e">https://atcoder.jp/contests/agc066/tasks/agc066_e</a></p>
<p>题目大意：</p>
<p>给一棵树，然后依次在编号为 $1,2,…,n$ 上面放不同的石子，每次放完石子后，问经过下面操作任意次后能得到多少种不同的局面：</p>
<p>将一个石子移到相邻没有石头的位置。</p>
<details class="toggle" ><summary class="toggle-button" style="">我的做法</summary><div class="toggle-content"><p>首先做这道题目一个直观的感受是，答案的结构会不会是可以把石头分成一个个集合，集合内的石头可交换吧？</p>
<p>但是首先就有一个问题，树上没有偏序结构，什么叫可交换？没有次序怎么定义可交换？</p>
<p>注意到一个事情，假设把石头看成没区别的，那么石头可以摆成任意一个局面，我们不妨固定一个局面 $A$ ，然后对于每种其他局面 $B$，我们也固定一种从 $A$ 到 $B$ 的交换方法，而这个交换方法可以用 $\{(x,y)\}$ 来表示，逆过来同理，具体表示为将 $A$ 中的 $x$ 位置的石子放到了 $B$ 的 $y$ 位置。</p>
<p>因此对于 $A$ 的同一局面的不同标号，一定可以对应 $B$ 的不同标号，同理 $B$ 的也可以变成 $A$ 的。</p>
<p>所以最终答案一定可以表示成 $\binom{n}{k}*cnt$ ，$cnt$ 表示同一局面有多少种不同的标号。</p>
<p>因此交换就可以定义了，固定一个局面下两个点的标号是否可交换。</p>
<p>那么怎么判断可交换呢？我在思考这个问题的时候是在 $fix$ 一条直径的情况下做的，然后再推广到不 $fix$ 的情况，这里直接给出我的最终做法，对我的思考过程感兴趣的读者可以去看反思部分。</p>
<p>考虑以某个叶子为根，然后根据某种神奇的 $dfs$ 序开始放下每一个石子（多叉树的后序遍历）。（下面的讨论和证明都默认是基于这个局面，基本上换个局面下面的观察就大概率是错的了）</p>
<p>先特判 $k\ge n-1$ 的情况。</p>
<p>剩下的情况，然后我们考虑两个石子什么时候可以交换，至于不能用交换形容的情况，我们等会再说。</p>
<p>显然只要两个石子是同父亲的，就可以交换，考虑石子什么时候和自己的儿子可交换，一个充分条件是，设 $f_{x}$ 表示 $x$ 到第一个二叉父亲（不包括自己）的所需要的边数，则 $k\le n-(f_{x}+2)$。</p>
<p>这也是为什么要选个叶子当根，否则还要讨论跨过根去到根的另一个子树的情况。</p>
<p><details class="toggle" ><summary class="toggle-button" style="">充分性证明</summary><div class="toggle-content"><p>根据我们放石子的顺序，我们一定可以摆出下面的局面：</p></p>
<p><img src="1.png" alt=""></p>
<p>手模一下就行了，证毕。</p>
</div></details>
<p>但是，这就够了吗？</p>
<p>事实上是够了。</p>
<details class="toggle" ><summary class="toggle-button" style="">必要性及只用考虑交换的证明</summary><div class="toggle-content"><p>可以发现，由于我们的放法，$x$ 这个位置的石子在放下时，其子树就满了，因此空位都在 $x$ 子树外。</p>
<p>设 $gfa_x$ 表示 $x$ 的第一个有两个以上儿子的祖先。</p>
<p>大致情况就和下面的图一样，将 $x$ 移动到 $gfa_x$ 部分，这样石子就分成了两个部分，显然这两个部分之间无法产生交换。</p>
<p><img src="2.png" alt=""></p>
<p>因此，这个节点就像是一个分界点，将子树和外面的点分开，两部分之间不会产生交换。</p>
<p>要严谨写证明过程的话，归纳证明就行了。</p>
<p>证毕。</p>
</div></details>
<p>那么上面的情况就够了吗？</p>
<p>够了，在讨论了上面的情况后，两个石子不能交换的充要条件就是中间有个第二种情况的拦路虎，而显然发生这种情况时，两个石子一定不能交换，因此这不仅是只考虑上面情况的充要，而是原问题的充要条件。</p>
<p>但是问题是，我们现在考虑完交换，那这是否就覆盖了所有的情况呢？</p>
<p>我们这么想，假设 $x,y$ 不可交换，但是存在一个变换，能使 $x$ 到达 $y$ 所在的位置，那么根据上面 $x,y$ 不可交换的条件，中间一定存在一个类似分界一样的东西，会限制 $x$ 不能到达 $y$ 能到达的一些地方，而前面说法矛盾，故不存在这种情况。因此，只考虑交换便能覆盖所有的局面。</p>
<p>做完了。</p>
<p>实现方面，注意到对于 $\forall x,y$ ，上面只给了在 $x\to y$ 这条路径上都已经按照顺序放了石头之后 $x,y$ 可交换的条件，但是如果还没放满呢？</p>
<p>显然除了 $lca$ 外，如果一个位置放了石子，且其的一个儿子也在这条路径上，则显然必须满足这个位置能和儿子交换，而且这显然是充要的，但我们注意到一个事情，如果 $x$ 在 $t$ 的时间假如，则其能与儿子交换的条件要么一直不满足，要么在 $\le t-1$ 时一定能满足。</p>
<p>因此 $x,y$ 可交换的条件在放不放满石头的时候都是一样的（除了 $lca$ 外，如果一个位置和其的一个儿子都在这条路径上，则必须满足这个位置能和儿子交换），直接实现就行了。</p>
<p>时间复杂度：$O(n\alpha(n))$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="type">const</span> LL mod = <span class="number">998244353</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line">LL fc[N], nfc[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> L = <span class="number">2e5</span>;</span><br><span class="line">    nfc[<span class="number">0</span>] = nfc[<span class="number">1</span>] = fc[<span class="number">0</span>] = fc[<span class="number">1</span>] = <span class="number">1ll</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= L; i++) nfc[i] = (mod - mod / i) * nfc[mod % i] % mod;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= L; i++) nfc[i] = nfc[i - <span class="number">1</span>] * nfc[i] % mod, fc[i] = fc[i - <span class="number">1</span>] * i % mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">C</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>&#123;<span class="keyword">return</span> fc[x] * nfc[y] % mod * nfc[x - y] % mod;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> y, next;</span><br><span class="line">&#125;a[N * <span class="number">2</span>]; <span class="type">int</span> len, las[N], du[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ins</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>&#123;a[++len] = &#123;y, las[x]&#125;; las[x] = len;&#125;</span><br><span class="line"><span class="type">int</span> n, rt;</span><br><span class="line"><span class="type">int</span> siz[N];</span><br><span class="line"><span class="type">int</span> dfn[N], be[N], ti;</span><br><span class="line">vector&lt;PII&gt; event[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> fa, <span class="type">int</span> c)</span></span>&#123;</span><br><span class="line">    siz[x] = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> son = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k = las[x]; k; k = a[k].next)&#123;</span><br><span class="line">        <span class="type">int</span> y = a[k].y;</span><br><span class="line">        <span class="keyword">if</span>(y == fa) <span class="keyword">continue</span>;</span><br><span class="line">        son = y;</span><br><span class="line">        <span class="keyword">if</span>(du[x] &gt;= <span class="number">3</span>) <span class="built_in">dfs</span>(y, x, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">dfs</span>(y, x, !c ? <span class="number">0</span> : c + <span class="number">1</span>);</span><br><span class="line">        siz[x] += siz[y];</span><br><span class="line">    &#125;</span><br><span class="line">    be[ dfn[x] = ++ti ] = x;</span><br><span class="line">    <span class="keyword">if</span>(son &amp;&amp; c) event[n - c - <span class="number">2</span>].<span class="built_in">push_back</span>(&#123;x, son&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LL contribution = <span class="number">1ll</span>;</span><br><span class="line"><span class="type">int</span> fa[N], cnt[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">findfa</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="keyword">return</span> fa[x] == x ? x : fa[x] = <span class="built_in">findfa</span>(fa[x]);&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mer</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    x = <span class="built_in">findfa</span>(x);</span><br><span class="line">    y = <span class="built_in">findfa</span>(y);</span><br><span class="line">    <span class="keyword">if</span>(x == y) <span class="keyword">return</span> ;</span><br><span class="line">    contribution = contribution * nfc[cnt[x]] % mod * nfc[cnt[y]] % mod;</span><br><span class="line">    fa[x] = y;</span><br><span class="line">    cnt[y] += cnt[x];</span><br><span class="line">    contribution = contribution * fc[cnt[y]] % mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">del</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    x = <span class="built_in">findfa</span>(x);</span><br><span class="line">    contribution = contribution * nfc[cnt[x]] % mod;</span><br><span class="line">    cnt[x]--;</span><br><span class="line">    contribution = contribution * fc[cnt[x]] % mod;</span><br><span class="line">&#125;</span><br><span class="line">LL ans[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        cin &gt;&gt; n;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="type">int</span> x, y;</span><br><span class="line">            cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">            <span class="built_in">ins</span>(x, y);</span><br><span class="line">            <span class="built_in">ins</span>(y, x);</span><br><span class="line">            du[x]++;</span><br><span class="line">            du[y]++;</span><br><span class="line">        &#125;</span><br><span class="line">        rt = <span class="number">1</span>;<span class="comment">//n = 1;</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(du[i] == <span class="number">1</span>)&#123;</span><br><span class="line">                rt = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">dfs</span>(rt, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="type">int</span> pre = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k = las[i]; k; k = a[k].next)&#123;</span><br><span class="line">                <span class="type">int</span> y = a[k].y;</span><br><span class="line">                <span class="keyword">if</span>(dfn[y] &gt; dfn[i]) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(pre) event[n - <span class="number">2</span>].<span class="built_in">push_back</span>(&#123;pre, y&#125;);</span><br><span class="line">                pre = y;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            fa[i] = i;</span><br><span class="line">            cnt[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ans[n] = <span class="number">1ll</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">1</span>; i--)&#123;</span><br><span class="line">            <span class="built_in">del</span>(be[i + <span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> [x, y] : event[i]) <span class="built_in">mer</span>(x, y);</span><br><span class="line">            ans[i] = <span class="built_in">C</span>(n, i) * contribution % mod;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) cout &lt;&lt; ans[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        contribution = <span class="number">1ll</span>;</span><br><span class="line">        len = ti = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(las + <span class="number">1</span>, <span class="number">0</span>, <span class="built_in">sizeof</span>(<span class="type">int</span>) * n);</span><br><span class="line">        <span class="built_in">memset</span>(du + <span class="number">1</span>, <span class="number">0</span>, <span class="built_in">sizeof</span>(<span class="type">int</span>) * n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span> ; i &lt;= n; i++) event[i].<span class="built_in">clear</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>真是场酣畅淋漓的做题啊。</p></div></details>
<details class="toggle" ><summary class="toggle-button" style=""></summary><div class="toggle-content"><p>破案了，我说为什么难度比 $D$ 低，原来是原题加强，但是原题做法能过。 </p>
</div></details>
<details class="toggle" ><summary class="toggle-button" style="">反思</summary><div class="toggle-content"><p>想想我的想题过程：</p>
<ol>
<li><p>觉得肯定要思考哪些石头是能交换的。（卡了至少 30 分钟）</p>
<p>否决理由：“交换”的定义非常奇怪，对于两种不同的摆石子方式，怎么判断两个石头已经被交换了？（但实际在后面发现，只要解决了这个问题，就已经成功很大一步了，可惜我当时的第一想法是放弃而不是解决）</p>
</li>
<li><p>觉得可能是通过一个石子能够到达哪些位置进行解答，显然处于等价关系的点应该能到达的位置是一样的，本质是尝试在定义上面的交换关系。（卡了至少 30 分钟）</p>
<p>否决理由：能到达的点这个东西并不好量化，而且求出来也十分困难，讨论起来也很麻烦，还不一定能讨论出来，直觉上正解肯定不是这么搞的，直接放弃了。</p>
</li>
<li>发现答案一定是：同种石子的答案 * 一种摆石子方式的不同局面（同一种方式的不同局面通过同一种映射一定到达另一种方式的不同局面，是个双射），所以可以直接固定一个摆石子的方式，研究有多少种不同的局面，这个时候猜测一定是一个集合里面的点可互相交换。（其实也就是严格定义了第一点）</li>
<li><p>断定三个石头共线，则左右两个石头能交换当且仅当和中间的石头能交换。（卡了至少 30 分钟）</p>
<p>否决理由：</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 2</span><br><span class="line">2 3</span><br><span class="line">2 4</span><br><span class="line">2 5</span><br></pre></td></tr></table></figure>
<p> 其中石头在 $1,2,3$ ，$1,3$ 可交换，但 $2$ 不可交换。</p>
</li>
<li><p>接下来卡了很久，因为总觉得这个交换非常的难思考，直到我拿着 $4$ 的例子思考了一下，打算先假设只用接下来这一种方法来判断交换（即找到了一种比较好的判断交换的充分条件进行思考）：</p>
<p><img src="2.png" alt=""></p>
<p>上面黑点表示有石子，白点表示没有石子，那么上面的所有石子都是可交换的，但是如果上下再多一个石子，多出来的石子不可交换，也就是在这种三叉路口上，没有石头的路的长度决定了可交换的有石头的路的长度。</p>
</li>
<li>那么这种结构想到了啥？直径！可以发现，如果我们放石头的时候，有限把树的直径以外的部分填满，那么石头都是可交换的，用上面的结构，但是如果必须要填在直径上呢？</li>
<li><p>继续开始思考，我们发现，我们可以不断的移动直径上没有填石头的部分到某些三叉路口，来使得某些石头是可交换的，但这个时候发现了一种情况：</p>
<p><img src="3.png" alt=""></p>
<p>可以发现，无论没有石子的部分怎么移动，这个石头都不能通过 $5$ 的结构与任何石子交换，但是上面这个例子显然能够证明这个石子无法与其余石子交换，因为其在一条直道上，无法走向左右任意一个交叉口的某个子树里（即使能走到交叉口，不能走到子树里也是白搭），那么能否这样类似的证明其余无法用 $5$ 构造交换的情况其实也是不可交换的呢？（其实这个时候就和下面说的一样，本质上是找到了一个判断不能交换的必要条件，证明这个必要条件是充分的，毕竟想想，证明无法交换就必定满足这个必要条件，反过来就是不满足这个必要条件的就是可交换的，因此这个过程其实就是判断这个必要条件是充要的过程）</p>
</li>
<li><p>刚刚那个问题的答案是可以的，可以移动整段没有石子的路段（这里其实假定了整段不分裂的移动更优，但事实是在后面在这种假设下证明了必要条件是充要的后，这个假设自然也就成立了，也就是下面说的第三点），到一个个石子路口，且只假设会不断向叶子前进，不会做多余的操作，可以用上面的方法证明不能用这种方法交换的一定都是不能交换的。</p>
<p><img src="4.png" alt=""></p>
<p>注：不会多余就是一端在交叉路口，而另一端一定是指向直径方向的。</p>
<p>同时，用上面这个方法也能同时证明，只需要考虑交换就够了，不会出现 $x,y,z$ 可以三轮换但是不能交换的情况。</p>
</li>
<li><p>这个时候这道题目就已经做出来了，但是感觉这个做法有点难写（在直径上操作），而且也并不广泛。</p>
<p> 用到的直径性质也不多（只有在直径上没有石头的时候用到了直径性质），也就是说在直径上做这件事并不本质，直觉告诉我题解肯定不是这么做的。</p>
</li>
<li>这个时候尝试推广这个做法，并最终得到了我自己的最终做法。</li>
</ol>
<p>显然这个思考过程是非常长的，因此需要优化！</p>
<p>在没有看题解之前，我判断这个过程中有什么东西是可以优化的呢？</p>
<ol>
<li><p>就是我发现我在思考一些结论时，总是想着怎么证明，但正确做法应该是先想能不能构造反例，因为构造反例的难度往往比证明要低，而且构造不出来的过程可以指导证明</p>
<p>也就是我之前喜欢先从证明入手，然后因为证明不出来从而发现反例，这是很低效的，因为面对一个棘手的问题往往没有从正面切入的点。</p>
<p>但是如果从反面切入，如果发现是错的，结束了，不是错的，研究为什么对，这样又能对这个问题更加深入一步，而不至于摸不着头绪。</p>
</li>
<li><p>像这种题目，要先多去思考必要条件，也就是两个点不能交换的必要条件，在找到足够多后，再尝试证明或找到充要条件，这样会快很多。</p>
<p>显然，根据我上面的过程，我其实一种都在想两个点能交换的充要条件，但如果我先想两个点不能交换（尤其是两个相邻点）的必要条件，我想会更快想出正解。</p>
<p>虽然最后我想出来正解其实也是找了两个点能交换的充分条件进行思考得到的，因为一般情况下充要条件很难想出来，这个时候就需要找一些比较强的充分或者必要条件进行思考，而且很多情况下，其实这些就是充要条件，只是还没有证明的思路罢了。</p>
</li>
<li><p>假设法，在无法证明某些结论前先假设其是对的，然后进行进一步思考，如果找到反例再来推翻这个假设。</p>
<p>例如如果我一开始就假定两个石头能交换，则中间绝对不能隔着超过一个不能交换的石头，那么这种更加优秀的结构能够更好的引导接下来的思考（至少比原来抓瞎好），我想在这种假设下，也能更快的想出正解，而且事实是，一般想到正解后，这种假设的正确性也就迎刃而解了，尤其是在各种贪心和计数题上。</p>
</li>
</ol>
<p>在看了题解之后，我又有了什么新的感悟？</p>
<p>update：没什么感悟。</p>
</div></details>
<details class="toggle" ><summary class="toggle-button" style="">官方题解</summary><div class="toggle-content"><p>幽默了。原来我想题过程中，从“一个点能到达的集合”作为出发点是真的可行的啊。</p>
<p>接下来认为 $a,b,c$ 是石子，$x,y,z$ 是位置，石子和位置并不绑定，石子是石子，位置是位置，需要的时候可以把石子摆成任意想要的局面。（这里的局面指忽略标号的局面）</p>
<p>同时规定 $dis(x,y)$ 或者 $dis(a,x)$ 表示两点或者石子所在位置到 $x$ 的距离。</p>
<p>设 $S(a)$ 表示石子 $a$ 能到达的位置的集合。（注意，这里的 $S(a)$ 定义是基于石子的）</p>
<p>对于位置 $x$ ，我们称 $a$ 能够利用 $x$ 当且仅当 $x$ 有两个相邻节点属于 $S(a)$ 。</p>
<p>那么以下这三句话等价：</p>
<ol>
<li>$S(a)=S(b)$</li>
<li>$a,b$ 能够利用同一个度数 $\ge 3$ 的节点。</li>
<li>$a,b$ 能够在不影响其他位置的情况下交换他们身上的石子。（这其实给了交换的另外一种定义，但是我认为在没有想到去标号后任何局面可达这件事时，这种定义思考和证明起来是极其麻烦的，反正我不会）</li>
</ol>
<p>$3\to 1,3\to 2, 1\to 2$ 都是显然的。</p>
<p>现在简单的证明一下 $1\to 2$ 。</p>
<p><details class="toggle" ><summary class="toggle-button" style="">证明</summary><div class="toggle-content"><p>首先你需要注意到这么一个形式：$x\in S(a)$ ，如果 $x$ 有一个相邻节点 $y\notin S$ 是什么情况？</p></p>
<p>手动模拟可以发现一定是长这样：</p>
<p><img src="3.png" alt=""></p>
<p>总之就是 $x$ 和 $y$ 之间有一个分界线，两边的集合除了中间外无法互相到达。</p>
<p>从而知道 $x$ 只有一个相邻节点在 $S(a)$ 中。</p>
<p>因此我们可以知道 $S(a)$ 中的节点要么所有相邻节点都在里面，要么只有一个，我们又知道 $S(a)$ 是一个子连通块，因此这等价于这个子连通块中所有非叶子节点的所有相邻节点都在这个 $S(a)$ 中，这样有一个好处，任何一条从集合内走到集合外的简单路径都满足会经过子连通块的叶子（注：这个性质和定义其实是等价的，两者能互推）。</p>
<p>通过上面的描述，我们可以知道 $a$ 能利用 $x$ 等价于 $x\in S(a)$  且 $x$ 不是叶子。</p>
<p>同时通过上面那个例子，我们知道，对于 $S(a)$ 的叶子 $x$ ，如果 $x\in S(b)$ ，那么：</p>
<p><img src="4.png" alt=""></p>
<p>（准确来说这个图画的有点错，$a$ 不一定能到达左边的所有点）</p>
<p>要么 $b\in S(a)$ ，从而 $x$ 也是 $S(b)$ 的叶子，要么 $b\in V’$ ，则 $a,b$ 不可能利用同一个节点。</p>
<p>因此我们知道，如果 $S(a),S(b)$ 有交，且利用的节点有交集，可以通过上面的性质证明，$S(a)=S(b)$ ，同时因为他们利用同一个节点，所以一定有交，所以 $S(a)=S(b)$ ，证毕。</p>
</div></details>
<p>但是 $2\to 3,1\to 3$ 就十分麻烦了，因为在树上讨论交换是一个十分麻烦的事情，树的结构千变万化，很难用少量的讨论去说清楚这个事情。</p>
<p>因此一般情况下，给树赋予某种结构后再进行讨论会比较好，而 DFS 序就是树上一种比较一般且比较好的结构，所以很多树的证明都会涉及到 DFS 序，包括我的做法在最终证明和实现道题目的时候，也是用 DFS 序的。（虽然也可以用直径就是了）</p>
<p>在知道我的做法的正确性后，可以说明 $2\to 3,1\to 3$ 的正确性。首先可以用交换表述所有的情况，其次在 DFS 序上，两石子不能交换当且仅当路径中存在分界线那种结构，这个时候两个石子一定不能利用同一个节点。</p>
<p>因此两石子能利用一个节点则代表他们可以交换，证毕。</p>
<p>但是如果不基于我那个做法，单独给一个证明，我不会，我也没看懂题解那个证明。</p>
<p><img src="5.png" alt=""></p>
<p>我很想知道题解中这一步是怎么构造方案的，反正我感觉不基于某种结构是几乎不可能构造出来的，反正我的智商不支持我这么干，投降。</p>
<p>在假设上面都是对的后有意思的事情就来了。</p>
<p>现在可以建立一张图，其中以石子和度数 $\ge 3$ 的点为节点，其中如果石子可以利用一个位置，我们就给两点间连一条无向边，可以发现，这个图的每个连通块中的石子就是交换的。</p>
<p>以下都讨论都默认节点度数为 $3$ 。</p>
<p>但是这个图的量级是 $O(n^2)$ 的，不够得劲。注意到一个事情，如果 $a$ 能够同时利用 $x,y$ ，那么任何一个石子一定要么能同时利用 $x,y$ ，要么都不能，所以我们可以认为此时 $x,y$ 等价，可以发现这个等价也具有传递性。</p>
<p>同时又因为 $S(a)$ 也是联通块，我们可以得到，如果存在这样一条简单路径：$x\to y\to z$ ，那么 $a$ 能利用 $y$ / $x,y,z$ 等价。</p>
<p>这启示我们这么建图：$a$ 只向其各个方向上最近的 $x$ 连边，$x$ 只向其各个方向上最近的等价的 $y$ 连边，不难证明，这个图与上面那个图的连通性一样，而这个图的边数是 $O(n)$ 的。</p>
<p>开始讨论每条边在什么时候存在。</p>
<ol>
<li>$x,y$ 等价，可以发现在 $[1,n-dis(x,y)-2]$ 都存在，证明很好证明，不存在显然，存在只需要证明存在一个石头既能到 $x$ 又能到 $y$ ，这是显然的，直接先把所有石子移动到两边然后随便拿一个外面的石子就行了。</li>
<li>$a,x$ ，且 $a$ 初始时就在 $x$ 上，要么有至少两个子树（以 $x$ 为根）有空位，要么 $x$ 能等价于另外一个其他节点。</li>
<li><p>$a,x$ ，且 $a$ 初始不在 $x$ 上，条件为去掉 $a$ 所在的子树（以 $x$ 为根）和 $x$ 后的空位数量大于等于 $a$ 到 $x$ 路径上的石子数量 （包括 $a,x$）</p>
<p>首先满足肯定 $a$ 能利用 $x$ ，不满足，但 $a$ 能利用 $x$ ，那肯定是 $a$ 的儿子子树发力了，考虑 $a$ 的子树中最靠近 $a$ 的 $\ge 3$ 度点 $y$ （包括 $a$ 脚下的节点），能发生这种情况则 $a,y$ 一定能满足上面那个条件。（手模一下就知道了）</p>
<p>所以此时 $a$ 能利用 $y$ ，$x,y$ 等价，那么就算没有 $a,x$ 的边，$a$ 也能通过 $a-y-x$ 走到 $x$ ，所以不连也无所谓。</p>
</li>
</ol>
<p>然后就讨论完每条边的条件了。</p>
<p>其中第二种可以线性处理，而第三种边的条件等价于去掉 $x$ 为根时 $a$ 的子树，剩下的空位要 $\ge$ $dis(a,x)+1$ 需要用线段树合并处理出第 $k$ 个空位消失的时间。</p>
<p>这样我们就能知道每条边出现时间的右边界，而左边界显然是石子的出现时间，这个时候就已经可以用 $O(n\log^2 n)$ 的时间做完整道题目了。</p>
<p>但问题来了，一个石头真的需要放下了我们才能将其加入图中吗？</p>
<p>发现一个事情，第一种边也就是节点等价的边是不依赖于石子的，而且这个图的建立是绝对正确的，没有偷工减料，也就是只有第一种边的时候， $x,y$ 之间连通等价于他们等价。（注：有了第二、三种边也不影响这条性质成立）</p>
<p>同时可以证明：$\forall x≠y$ ，且此时满足了 $a$ 和 $x,y$ 连边的条件，那么无论此时 $a$ 放没放上去，$x,y$ 都等价。（发现第二三种边的条件不依赖于 $a$ 放没放上去，因此如果此时 $a$ 还没放上去，就先放上去，此时 $x,y$ 等价，然后再把 $a$ 拿走，空位增多，则此时 $x,y$ 还等价，证毕）</p>
<p>因此，先认为 $k$ 从大到小，则无论任何时候，与 $a$ 相关的边都只会导致一部分节点连通，而显然就算没有这些边，只靠第一种边，他们此时也是连通的，因此在 $k$ 小的时候没必要删掉 $a$ 和 $a$ 相关的那些边，只要记得不要把 $a$ 统计进答案里面就行了。</p>
<p>所以所有边的左边界都可以设为 $1$ ，因此可以用并查集维护，此时正道题目时间复杂度为 $O(n\log{n})$ 。</p>
<p>题外话：因为只有第一种边时就已经满足 $x,y$ 之间连通等价于他们等价，所以理论上 $a$ 只需要和其中一个其能利用的节点连边就行了，第三种边的部分边可以不建立就是这个原理。</p>
<p>但是能不能在 $O(n\alpha(n))$ 的时间完成这道题目呢？</p>
<p>答案是可以，和我的做法同样的手法，按照 DFS 序放石子就行了，这样每个子树都是一个区间，上面所有的查询都变得十分简单，能够在 $O(1)$ 的时间得到，这样就不用线段树合并了，时间复杂度瓶颈变为并查集，总时间复杂度变为 $O(n\alpha(n))$。</p>
<p>写一下我对这个做法的评价：</p>
<p>首先我突然觉得我的做法比他的做法好想，我搞这个做法我会直接卡在那一步 $1,2\to 3$ ，直接放弃接下来的思考（虽然接下来的部分也不简单就是了）。</p>
<p>但就这个做法而言，我给予高度的评价，首先他这个做法并不像我的做法一样特化，我的做法是必须在 DFS 序这个结构上的，并不一般。而他这个做法在任意的石子局面下都能做到 $O(n\log{n})$ ，就已经比我的做法强了不知道多少了（我当时其实有试过把我的做法推向一般局面，但是失败了），而在 DFS 序下也能做到 $O(n\alpha(n))$ ，不输我的做法。</p>
<p>同时他的做法还引进了一个新的概念 $S(a)$ ，并且深挖出了很多和 $S(a)$ 有关的性质，我当时试图从这个角度上想，但是失败了，因此单就这个新的概念本身以及很多相关的性质，就又赢了我的做法很多。</p>
<p>反正我认为这个做法的意义是多方面的，在这当中我学到了很多新的东西。<del>虽然花了很多时间</del></p>
<p>此时再看看我的做法，也就胜在好想了。<del>但是这是比赛，好想胜过一切，我的做法，赢！</del></p></div></details>]]></content>
      <categories>
        <category>信息学</category>
      </categories>
  </entry>
  <entry>
    <title>AGC066 赛后总结</title>
    <url>/2024/04/02/AGC066-%E8%B5%9B%E5%90%8E%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>比赛链接：<a href="https://atcoder.jp/contests/agc066/tasks">https://atcoder.jp/contests/agc066/tasks</a></p>
<p>别TM出你那构造了，我TM真的要做吐了。</p>
<h1 id="A-Adjacent-Difference"><a href="#A-Adjacent-Difference" class="headerlink" title="A Adjacent Difference"></a>A Adjacent Difference</h1><p>题目链接：<a href="https://atcoder.jp/contests/agc066/tasks/agc066_a">https://atcoder.jp/contests/agc066/tasks/agc066_a</a></p>
<p>题目大意：给一个 $n*n$ 的方阵，给一个数字增减 $x$ 的代价是 $|x|$ ，然后给出一种方案使得相邻数字差距 $\ge d$ ，同时代价 $\le \frac{dn^2}{2}$ 。</p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>一个经典的思考模型：由一般到特殊。</p>
<ol>
<li><p>如果 $d=1$ 怎么做？</p>
<p>我当时的想法是：奇数格子跑奇数或这偶数，偶数格子跑另外一类。</p>
</li>
<li><p>如果所有数字在 $[0,d]$ 内，怎么做？</p>
<p>我当时的想法是：奇数格子跑 $0$ 或者 $d$ ，偶数格子跑另外一类。</p>
</li>
</ol>
<p>这都指向了一个想法：奇数格跑向最近的 $0/d \mod{2d}$ ，然后偶数格子跑向另外一个。</p>
<p>至于证明，同样从一般到特殊，考虑上面两个问题，都是两种情况的和为 $dn^2$ ，则必定有一个 $\le \frac{dn^2}{2}$ 。</p>
<p>这个想法的证明也类似，不难发现，问题等价于：给偶数格子的值 $-d$ ，然后问所有格子最近的到 $0/d \mod{2d}$ ，是否有一种可能使得代价 $\le \frac{dn^2}{2}$ 。</p>
<p>不难发现，一个数字到达最近的 $0/d \mod{2d}$ ，两种情况的距离和是 $d$ 的，因此两种情况的代价是 $dn^2$ ，因此必定有一个情况 $\le \frac{dn^2}{2}$ ，证毕。</p>
<p>一个比较形象的图：</p>
<p><img src="1.png" alt=""></p>
<p>时间复杂度：$O(n^2)$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">5e2</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n, d;</span><br><span class="line"><span class="type">int</span> a[N][N], b[N][N];</span><br><span class="line"><span class="type">int</span> base;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> cost = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)&#123;</span><br><span class="line">            <span class="type">int</span> goal;</span><br><span class="line">            <span class="keyword">if</span>((i + j) &amp; <span class="number">1</span>) goal = base;</span><br><span class="line">            <span class="keyword">else</span> goal = base + d;</span><br><span class="line">            <span class="keyword">if</span>(goal &lt; a[i][j])&#123;</span><br><span class="line">                <span class="type">int</span> x = a[i][j] - goal;</span><br><span class="line">                x = x / (d + d) * (d + d) + goal;</span><br><span class="line">                <span class="keyword">if</span>( <span class="built_in">abs</span>(x - a[i][j]) &gt; <span class="built_in">abs</span>(x + d + d - a[i][j])) x += d + d;</span><br><span class="line">                goal = x;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="type">int</span> x = goal - a[i][j];</span><br><span class="line">                x = goal - x / (d + d) * (d + d);</span><br><span class="line">                <span class="keyword">if</span>( <span class="built_in">abs</span>(x - a[i][j]) &gt; <span class="built_in">abs</span>(x - d - d - a[i][j])) x -= d + d;</span><br><span class="line">                goal = x;</span><br><span class="line">            &#125;</span><br><span class="line">            b[i][j] = goal;</span><br><span class="line">            cost += <span class="built_in">abs</span>(a[i][j] - b[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cost;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; d;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)&#123;</span><br><span class="line">            cin &gt;&gt; a[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    base = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">2</span> * <span class="built_in">solve</span>() &gt; d * n *n)&#123;</span><br><span class="line">        base = d;</span><br><span class="line">        <span class="built_in">assert</span>(<span class="number">2</span> * <span class="built_in">solve</span>() &lt;= d * n * n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)&#123;</span><br><span class="line">            cout &lt;&lt; b[i][j] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实感觉想的还是慢了点，感觉还能再快一点的。</p>
</div></details>
<h1 id="B-Decreasing-Digit-Sums"><a href="#B-Decreasing-Digit-Sums" class="headerlink" title="B Decreasing Digit Sums"></a>B Decreasing Digit Sums</h1><p>题目链接：<a href="https://atcoder.jp/contests/agc066/tasks/agc066_b">https://atcoder.jp/contests/agc066/tasks/agc066_b</a></p>
<p>题目大意：给一个长度不超过 $9999$ 的数字，满足乘 $50$ 次 $2$ 时每次乘之后数位和都严格下降。</p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>非常有意思的题目，有时候来这么几道确实能开阔视野，但是考场时恶心我也确实有一手。</p>
<p>首先注意到一个事情：$5$ 乘 $2$ 后会变成 $10$ ，不影响数位和，也就是对于 $5<em>x$ ，在乘 $2$ 后变成 $10</em>x$ ，等价于 $x$ ，也就是乘 $2$ 后数字反而减小了，那么直接搞一个 $5^50$ ，最后直接减小到 $1$ 。</p>
<p>但是数字在减小不代表数字的数位和在减少，事实也确实如此，那么怎么搞呢？</p>
<p>考虑 $n*5^{50}$ ，如果 $5x\le y$ ，虽然 $x$ 的数位和可能大于等于 $y$ ，但是 $nx$ 与 $ny$ 在 $n$ 不断变化时的平均值应该是满足：$nx\le ny$ 的。</p>
<p>因此，直接将不同的 $n$ 得到的 $n*5^{50}$ 拼在一起即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e4</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> SN = <span class="number">1e2</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> a[SN], len;</span><br><span class="line">    <span class="built_in">node</span>()&#123;len = <span class="number">1</span>;<span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="built_in">sizeof</span>(a));&#125;</span><br><span class="line">&#125;a;</span><br><span class="line">node <span class="keyword">operator</span>*(node x, <span class="type">int</span> y)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= x.len; i++) x.a[i] *= y;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= x.len; i++)&#123;</span><br><span class="line">        x.a[i + <span class="number">1</span>] += x.a[i] / <span class="number">10</span>;</span><br><span class="line">        x.a[i] %= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(x.a[x.len + <span class="number">1</span>])&#123;</span><br><span class="line">        x.len++;</span><br><span class="line">        x.a[x.len + <span class="number">1</span>] += x.a[x.len] / <span class="number">10</span>;</span><br><span class="line">        x.a[x.len] %= <span class="number">10</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">char</span> st[N];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> T;</span><br><span class="line">        cin &gt;&gt; T;</span><br><span class="line">    &#125;</span><br><span class="line">    a.a[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    LL now = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">50</span>; i++) a = a * <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">400</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i % <span class="number">2</span> == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">        node b = a * i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= b.len; j++) st[++n] = b.a[j] + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i + i &lt;= n; i++) <span class="built_in">swap</span>(st[i], st[n - i + <span class="number">1</span>]);</span><br><span class="line">    <span class="comment">// cout &lt;&lt; n &lt;&lt; &#x27;\n&#x27; ;</span></span><br><span class="line">    cout &lt;&lt; st + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></details>
<details class="toggle" ><summary class="toggle-button" style="">反思</summary><div class="toggle-content"><p>特有的没做题，看题解后开始马后炮反思。</p>
<ol>
<li><p>思考是否是一些显性的数字组合，例如 ：5555，这种。</p>
<p>否决理由：可以控制很小的 $n$ ，但是 $n$ 比较大时根本控制不住。</p>
<p>特别发现： $9999…999$ ，只要 $n$ 的数量级小于位数的数量级，则位数和不变。</p>
</li>
<li><p>思考是否是分段加循环节，忽略一些小量的变化。</p>
<p>否决理由：循环起来可以发现平均变化量为 $0$ ，那么最终影响减小的还是总变化量。</p>
</li>
<li><p>开始思考可能是一些会损耗的构造，突然发现 $5*2=10$ ，逐步接近正解。</p>
<p>但以为是 $5^k$ 里面存在一段 $[l,r]$ 纯递增。</p>
<p>否决理由：试了，不存在这样的 $[l,r]$ 。</p>
</li>
<li><p>难道是 $n*5^k$ ？最接近正解的一集，可惜思维困在了找 $[l,r]$ 。</p>
<p>否决理由：试了，找不到。</p>
</li>
<li><p>难道不是 $5^k$ ，而是其他幂次，比如 $2^k$ ？。</p>
<p>否决理由：没找到，发现这么想其实已经和乱试没什么区别了，纯纯没有道理。</p>
</li>
<li><p>思考是否是搞几个串，不同的 $n$ 增量不同，然后列个方程，找个可行解。</p>
<p>否决理由：怎么判断方程是否有解，又怎么找到有解的方程。</p>
</li>
<li><p>回到第 $2$ 点，难道是列一堆状态，然后不同状态之间相互联动，然后用算法找一下可行解？</p>
<p>否决理由：根本没想出来个所以然，其实这个时候也知道这样想希望不大，没有正解的感觉，但也没有新的点子了。</p>
</li>
<li>投降，看题解，膜拜。</li>
</ol>
<p>回顾整个过程，其实可以发现做法就是 $3,4,6$ 的组合，但唯独就是没有想到小的数字虽然数位和不一定小，但是在乘 $n$ 后的平均值感觉上是小的。</p>
<p>回顾一下过程：</p>
<p>$1,2$ 步我认为是我目前必须经历的过程，尝试解法是很正常的，但重要的是要在更加短的时间否定这些想法，当能够大致的给出一个想法不对的点的时候，就应该去尝试想想其他想法了。</p>
<p>$3,4,6$ 步我认为没有问题，有一些新的想法是好事。</p>
<p>$5$ 纯粹的乱试，不过赛场也确实没有花太多时间在这一点上。</p>
<p>$7$ 的时候已经黔驴技穷了，也不知道自己在干嘛了，但又必须经历，感觉变强的过程就是在一步步经历 $7$ 的过程中，突然想到可以这么干的过程。但其实也不能硬撑，如果经历 $7$ 一段时间后还没想到新的点子（大概是半个小时到两个小时左右），大概率就是超能力范围了，这个时候硬想基本上是浪费时间，不如直接看题解，我认为在自己最困惑的时候，学习一下别人是怎么解决自己的困惑，是进步最快的方法。</p>
<p>当然，如果赛时进入 $7$ 阶段一小段时间的话，直接跳题才是收益最大化的选择，毕竟这场的 $E$ 我觉得不是不能做的，多一种选择就多一种可能。</p>
<p>怎么更快的想出这道题呢？关键的两点：</p>
<ol>
<li>$2*5=10$ 。（就算再难的构造也要有些比较关键的小性质，而注意到 $5$ 因子能够让数字“从小变大”变成“由大变小”是这道题目一个关键的突破。）</li>
<li>感觉上如果 $x&lt;y$ ，那么 $nx$ 和 $ny$ 的数位和的平均值应该会满足 $nx &lt; ny$ ，在有足够多且随机的 $n$ 时。（这个性质能够很好的利用 $5$ 由大变小的性质，并通过此题）</li>
</ol>
<p>提升“感觉”思维是我下次能够且更快做出这一类题目的关键。</p>
</div></details>
<h1 id="C"><a href="#C" class="headerlink" title="C"></a>C</h1><p>题目大意：给一个只有 $A,B$ 的字符串，每次只能删除 $AAB$ 或者 $BAA$ ，问最多删除多少次。</p>
<details class="toggle" ><summary class="toggle-button" style="">我的做法</summary><div class="toggle-content"><p>首先注意到一个事情，题目不能删除 $ABA$ 的字符串，这意味着单个的 $A$ 有可能被浪费，所以这道题目的核心就是如何减少 $A$ 的浪费。</p>
<p>在足够的思考后，观察到这么一个性质：如果把 $A$ 看成 $1$ ，$B$ 看成 $-2$ ，如果一个子串的和 $&gt;0$ ，那么这个子串一定可以变成一串 $A$ 。</p>
<p>原因是如果不是一串 $A$，最终一定是 $AB…BAB…BA…$ ，那么一定是 $\le 0$ 的。</p>
<p>因此这样合并条件就有了。</p>
<p>因此我们能够将原问题用该问题表示：用一些不相交的段覆盖所有的 $+1$ ，要求段的和 $&gt;0$，然后浪费的 $A$ 为和为奇数的段，最小化浪费。</p>
<p>这个时候其实已经可以 $dp$ 了。</p>
<p>使用某种数据结构维护一下转移过程就能 $O(n\log{n})$ 。</p>
<p>同时注意到，如果 $x\to x+2k$ ，那么一定有 $x\to x+2 \to x+2k$ ，因此转移能只从 $x-1,x-2$ 转移过来，时间复杂度：$O(n)$ 。</p>
<p>不过当时我没意识到到这就已经做完了，发现一个很自然的事情：如果和为奇数，代表可能有浪费，和为偶数，代表没有浪费，因此我们总是希望和为奇数，这个时候就很自然会想，奇数能不能分成两段 $&gt;0$ ？</p>
<p>答案是可以，对于一段我们先将正数合并，负数合并，两端是正数，然后从左边一段正数开始，然后另外一段是去掉下一段负数的右边，然后如果右边 $&lt;0$ ，那么左边的和大于中间负数段的绝对值，那么可以将左边往右推一格，由于最后会推到右边只有正数，所以一定存在一个时刻，左右两端都是正数，证毕。</p>
<p>因此，一段长度 $\ge 2$ 的 $&gt;0$ 一定能分成两段 $&gt;0$ ，综上，和为奇数的一定能分成一段奇数，一段偶数，所以奇数的长度可以至多为 $1$ 。</p>
<p>这样就得到了我的最终做法。</p>
<p>时间复杂度：$O(n)$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">1e9</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_char_array</span><span class="params">(<span class="type">char</span> *s, <span class="type">int</span> &amp;n)</span></span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">char</span> ss[N];</span><br><span class="line">    cin &gt;&gt; ss;</span><br><span class="line">    n = <span class="built_in">strlen</span>(ss);</span><br><span class="line">    <span class="built_in">memcpy</span>(s + <span class="number">1</span>, ss, <span class="built_in">sizeof</span>(<span class="type">char</span>) * n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">char</span> st[N];</span><br><span class="line"><span class="type">int</span> sum[N], a[N], dp[N];</span><br><span class="line"><span class="type">int</span> f[N * <span class="number">3</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="built_in">get_char_array</span>(st, n);</span><br><span class="line">        <span class="built_in">fill</span>(f, f + <span class="number">3</span> * n + <span class="number">2</span> + <span class="number">1</span>, inf);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(st[i] == <span class="string">&#x27;A&#x27;</span>) a[i] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> a[i] = <span class="number">-2</span>;</span><br><span class="line">            sum[i] = sum[i - <span class="number">1</span>] + a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        f[n + n + <span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i] &lt; <span class="number">0</span>) dp[i] = dp[i - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">else</span> dp[i] = <span class="built_in">min</span>(dp[i - <span class="number">1</span>] + <span class="number">1</span>, f[sum[i] + (n + n + <span class="number">2</span>) - <span class="number">2</span>]);</span><br><span class="line">            f[sum[i] + (n + n + <span class="number">2</span>)] = <span class="built_in">min</span>(f[sum[i] + (n + n + <span class="number">2</span>)], dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> A = (sum[n] + n + n) / <span class="number">3</span>, B = n - A;</span><br><span class="line">        A -= dp[n];</span><br><span class="line">        <span class="built_in">assert</span>(A % <span class="number">2</span> == <span class="number">0</span>);</span><br><span class="line">        cout &lt;&lt; <span class="built_in">min</span>(A / <span class="number">2</span>, B) &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>$O(n\log{n})$ 版的代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_char_array</span><span class="params">(<span class="type">char</span> *s, <span class="type">int</span> &amp;n)</span></span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">char</span> ss[N];</span><br><span class="line">    cin &gt;&gt; ss;</span><br><span class="line">    n = <span class="built_in">strlen</span>(ss);</span><br><span class="line">    <span class="built_in">memcpy</span>(s + <span class="number">1</span>, ss, <span class="built_in">sizeof</span>(<span class="type">char</span>) * n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">char</span> st[N];</span><br><span class="line">set&lt;PII&gt; f[<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> sum[N], a[N], dp[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="built_in">get_char_array</span>(st, n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(st[i] == <span class="string">&#x27;A&#x27;</span>) a[i] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> a[i] = <span class="number">-2</span>;</span><br><span class="line">            sum[i] = sum[i - <span class="number">1</span>] + a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        f[<span class="number">0</span>].<span class="built_in">insert</span>(&#123;<span class="number">0</span>, <span class="number">0</span>&#125;);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i] &lt; <span class="number">0</span>) dp[i] = dp[i - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                dp[i] = dp[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                <span class="type">int</span> type = sum[i] &amp; <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">auto</span> tmp = f[type].<span class="built_in">lower_bound</span>(&#123;sum[i], <span class="number">0</span>&#125;);</span><br><span class="line">                <span class="keyword">if</span>(tmp != f[type].<span class="built_in">begin</span>())&#123;</span><br><span class="line">                    tmp--;</span><br><span class="line">                    dp[i] = <span class="built_in">min</span>((*tmp).second, dp[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> type = sum[i] &amp; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">auto</span> tmp = f[type].<span class="built_in">lower_bound</span>(&#123;sum[i], dp[i]&#125;);</span><br><span class="line">                <span class="keyword">if</span>(tmp == f[type].<span class="built_in">end</span>()) <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">if</span>((*tmp).second &gt;= dp[i]) f[type].<span class="built_in">erase</span>(tmp);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">auto</span> tmp = f[type].<span class="built_in">upper_bound</span>(&#123;sum[i], dp[i]&#125;);</span><br><span class="line">            <span class="keyword">if</span>(tmp != f[type].<span class="built_in">begin</span>() &amp;&amp; (*(--tmp)).second &lt;= dp[i]);</span><br><span class="line">            <span class="keyword">else</span> f[type].<span class="built_in">insert</span>(&#123;sum[i], dp[i]&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> A = (sum[n] + n + n) / <span class="number">3</span>, B = n - A;</span><br><span class="line">        A -= dp[n];</span><br><span class="line">        <span class="built_in">assert</span>(A % <span class="number">2</span> == <span class="number">0</span>);</span><br><span class="line">        cout &lt;&lt; <span class="built_in">min</span>(A / <span class="number">2</span>, B) &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        f[<span class="number">0</span>].<span class="built_in">clear</span>();</span><br><span class="line">        f[<span class="number">1</span>].<span class="built_in">clear</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></details>
<details class="toggle" ><summary class="toggle-button" style="">反思</summary><div class="toggle-content"><p>想题过程：</p>
<ol>
<li>发现奇数个 $A$ 与浪费。</li>
<li><p>开始思考合并 $A$ 的条件，觉得可能和和有关。</p>
<p>否决理由：发现 $sum=0$ 时可以 $ABA$ 是反例。</p>
</li>
<li>开始思考能不能调整合并顺序。</li>
<li>发现非奇数的段可以直接与两端的最短的负数段合并，问题变成考虑奇数-负数-奇数-负数 … 。</li>
<li>手玩突然发现 $&gt;0$ 是充要条件。</li>
<li>证明分割的那个定理。</li>
<li>得到做法。</li>
<li>看题解发现可以线性，回来将自己的做法优化到线性。</li>
</ol>
<p>感觉这次想题的问题不大，第二步虽然很早的想到与和有关，这可以说是直觉，但是否决掉就说明实力还是有待提高，我并不觉得这个时候否决是多大的问题。</p>
<p>因为此时我的主要想法是通过调整合并顺序来实现更容易的合并，而 $&gt;0$ 这个条件如果是奇数，最后还会剩一个，如果是偶数，找 $B$ 一定能变成 $=0$ ，所以我当时就局限在我当时的思维卡了一下，以为条件如果有，一定是和为 $0$ 然后加上一些条件，但一直没找到就放弃这个想法了。</p>
<p>一直到后面手玩才发现 $ABB..BA…$ 这种东西和 $\le 0$ ，所以 $&gt;0$ 就是充要条件，你要说问题大吗？我觉得不大，因为当时的思维方向而否决掉一些对的想法这件事，我认为是正常的。</p>
<p>而最后第 $6$ 步也反映了这个想法，我当时觉得和为奇数一定会浪费一个，这种情况是不优且奇怪的，所以在明明已经能做的情况下，第一想法是找个方法把奇数段切割，直到奇数的长度为 $1$ 。</p>
<p>我认为这次的最大问题是思维局限住了，合并奇数的方法不止考虑调整合并顺序这么一种，假如不是运气好手玩发现了 $&gt;0$ 的这个充要条件，我估计要局限在这个思路很久。</p>
<p>当然在某种方向上想一段时间没有问题，保证深度，但是最大的问题是在这种方向上久久没有新的成果的时候，就要考虑换个方向想了，毕竟想题除了深度，还要考虑广度问题，而能有多广，就是实力问题了。</p>
<p>比如这题，我一开始的想法是调整，没有问题，否决掉正确想法，也没有问题，但是后面没有转换思维，去找其余可能的解决方法，就是我最大的问题，虽然最后运气好发现了，那也只能说 $&gt;0$ 这个条件还是比较浅，可以在不深挖的情况下就发现，一旦做法是需要深挖的话（指的是需要在另外一个方向深挖），这个时候不转换思维就只有死路一条。</p>
<p>因此在思路卡住的时候，最有效的解决方法就是跳出原有思路，扩宽想题广度。</p>
<p>（我其实觉得我现在和高中最大的区别就是广度变小了很多，导致我没法做很多我高中会做的题目，现在要注重培养想题的广度了）</p>
</div></details>
<details class="toggle" ><summary class="toggle-button" style="">官方做法</summary><div class="toggle-content"><p>坏了，非要说的话我一开始的想法还真没问题，真就和为 $0$ 且加一些条件就能判断这一段能不能被消除（虽然我当时的想法主要是减少奇数，减少浪费，因此也不太可能往这个方向想）。</p>
<p>菜就多练了只能说。</p>
<p>官方做法基于一个定理：</p>
<p>一个段能够完整的消除的充要条件：</p>
<p>能够分成多段使得每一段和为 $0$ 且两端中有一端为 $B$ 。</p>
<p>充分性：将 $B$ 去掉，这一段就 $&gt;0$ 了，可以只用 $A$ 表示，然后用 $B$ 消掉即可。</p>
<p>必要性：归纳。</p>
<p>然后直接 $dp$ 就行了，时间复杂度：$O(n)$ 。</p>
</div></details>
<h1 id="D"><a href="#D" class="headerlink" title="D"></a>D</h1><p>独立成一篇题解。</p>
<h1 id="E"><a href="#E" class="headerlink" title="E"></a>E</h1><p>独立成一篇题解。</p>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>构造</tag>
        <tag>感觉</tag>
      </tags>
  </entry>
  <entry>
    <title>ARC172 D. Distance Ranking</title>
    <url>/2024/03/18/ARC172-D-Distance-Ranking/</url>
    <content><![CDATA[<p>题目链接：<a href="https://atcoder.jp/contests/arc172/tasks/arc172_d">https://atcoder.jp/contests/arc172/tasks/arc172_d</a></p>
<p>题目大意：请你构造 $n$ 个 $n$ 维空间的整点，满足两点间距离的大小排序符合题目给的顺序。</p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>真TM人类智慧，根本想不到。</p>
<p>准确来说有想过先构造使得每条边都一样长，然后再微调，但是压根没想到微调的具体方法。</p>
<p>简单来说，设第 $i$ 个点的坐标是 $(a_{i,1},a_{i,2},…,a_{i,n})$ 。</p>
<p>先令 $a_{i,j}=[i=j]*K$ ，其中 $K$ 是一个很大的数字，显然，这样能使任意两点间的距离都等于 $\sqrt{2}K$ 。</p>
<p>现在的问题是怎么微调？我们假设给 $a_{i,1},a_{i,2},…,a_{i,n}$ 都加个相对于 $K$ 的小量，那么 $i$ 与别的点的距离会怎样变化呢?</p>
<p>将式子列出来可以发现，对于 $i,j$ 的距离的平方可以大致写成 $2K^2+c*K+O(1)$ ，其中 $c$ 与 $a_{i,i},a_{i,j}$ 有关，可以发现，这个式子的三个部分分别对应不同的量级。</p>
<p>对应任意两点的距离，都有 $2K^2$ 这一项，因此如果 $c*K$ 不一样，就可以用这一项控制相对大小了，显然此时 $O(1)$ 不影响相对大小。</p>
<p>接下来就很简单了，随便口胡一下就行了。</p>
<p>时间复杂度：$O(n^2)$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">30</span>;</span><br><span class="line"><span class="type">int</span> a[N][N];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)a[i][i]=<span class="number">1e6</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n*(n<span class="number">-1</span>)/<span class="number">2</span>;i++)&#123;</span><br><span class="line">        <span class="type">int</span> x,y;<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;x,&amp;y);</span><br><span class="line">        a[x][y]+=n*(n<span class="number">-1</span>)/<span class="number">2</span>-i+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,a[i][j]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>哎，菜就得多练了，根本想不到。</p>
<p>但多练真的有用吗？</p>
</div></details>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>构造</tag>
      </tags>
  </entry>
  <entry>
    <title>ARC170 E. BDFS</title>
    <url>/2024/02/20/ARC170-E-BDFS/</url>
    <content><![CDATA[<p>题目链接：<a href="https://atcoder.jp/contests/arc170/tasks/arc170_e">https://atcoder.jp/contests/arc170/tasks/arc170_e</a></p>
<p>题目大意：现在有一个 $n$ 个点的环，然后每个点的权值 $a_i$ ，一开始都是 $-1$ ，然后有个队列，初始只有一个 $(1,0)$，</p>
<p>然后每次弹出队首 $(d,v)$，若 $a_d=-1$ ，则：</p>
<ol>
<li>$a_d=v$ 。</li>
<li>从小到大考虑 $d$ 相邻的权值为 $-1$ 的邻居 $x$ ，然后有 $p$ 的概率把 $(x,v+1)$ 加入队首，否则加入队尾。</li>
</ol>
<p>问最后所有点的权值和的期望。</p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>唐，太唐了，转换完题意不会做，一个经典的二阶期望不会，唐，太烫了。</p>
<p>首先，这道题目显然可以转换成这个题意：</p>
<p>现在有一个长度为二的数组：$a[0]=-1,a[1]=0$ ，然后 $type=0$ ，现在进行 $n-1$ 轮：</p>
<ol>
<li><code>a[type]++</code> 。</li>
<li>有 $p$ 的概率不发生变化，有 $1-p$ 的概率 <code>type^=1</code> 。</li>
</ol>
<p>问最后 $\frac{a<a href="a[0]+1">0</a>}{2}+\frac{a<a href="a[1]+1">1</a>}{2}$ 的期望值。</p>
<p>首先，多少阶的期望都是能做的，开对应阶数个状态就行了，像自然数幂求和那样推一下式子就行了。</p>
<p>这里是二阶期望，开两个状态即可。</p>
<p>但这里由于数组有两个位置，所以还要再多开一个状态，总共三个状态，分别为：</p>
<p>$f_{ans}[n]$ 表示 $n$ 轮后的期望答案，$f_0[n]$ 表示 $a[type]$ 的期望值，$f_1[n]$ 表示 $a[1-type]$ 的期望值。</p>
<p>则式子为：</p>
<script type="math/tex; mode=display">
\begin{align*}
    f_{ans}[n+1]&=f_{ans}[n]+f_{0}[n]+1\\
    f_{0}[n+1]&=p(f_{0}[n]+1)+(1-p)f_{1}[n]\\
    f_{1}[n+1]&=(1-p)(f_{0}[n]+1)+pf_{1}[n]\\
\end{align*}</script><p>然后直接矩阵快速幂就行了。</p>
<p>时间复杂度：$O(T\log{n})$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> LL mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Matrix</span>&#123;</span><br><span class="line">    LL a[<span class="number">4</span>][<span class="number">4</span>];</span><br><span class="line">    <span class="built_in">Matrix</span>()&#123;</span><br><span class="line">        <span class="built_in">memset</span>(a,<span class="number">0</span>,<span class="built_in">sizeof</span>(a));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;O,tr;</span><br><span class="line">Matrix <span class="keyword">operator</span>*(Matrix x,Matrix y)&#123;</span><br><span class="line">    Matrix z;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">3</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=<span class="number">3</span>;j++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;=<span class="number">3</span>;k++)&#123;</span><br><span class="line">                z.a[i][j]=(z.a[i][j]+x.a[i][k]*y.a[k][j])%mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> z;</span><br><span class="line">&#125;</span><br><span class="line">Matrix <span class="keyword">operator</span>+(Matrix x,Matrix y)&#123;</span><br><span class="line">    Matrix z;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">3</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=<span class="number">3</span>;j++)z.a[i][j]=(x.a[i][j]+y.a[i][j])%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> z;</span><br><span class="line">&#125;</span><br><span class="line">Matrix <span class="keyword">operator</span>%(Matrix x,LL y)&#123;<span class="keyword">return</span> x;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">ksm</span><span class="params">(T x,LL y,T o)</span></span>&#123;</span><br><span class="line">    T ans=o;</span><br><span class="line">    <span class="keyword">while</span>(y)&#123;</span><br><span class="line">        <span class="keyword">if</span>(y&amp;<span class="number">1</span>)ans=ans*x%mod;</span><br><span class="line">        x=x*x%mod;y&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">3</span>;i++)&#123;</span><br><span class="line">        O.a[i][i]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> T;<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        LL n,p;<span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>,&amp;n,&amp;p);</span><br><span class="line">        p=p*<span class="built_in">ksm</span>(<span class="number">100ll</span>,mod<span class="number">-2</span>,<span class="number">1ll</span>)%mod;</span><br><span class="line">        LL pn=(<span class="number">1</span>-p+mod)%mod;</span><br><span class="line">        </span><br><span class="line">        tr.a[<span class="number">0</span>][<span class="number">0</span>]=tr.a[<span class="number">1</span>][<span class="number">0</span>]=tr.a[<span class="number">3</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        tr.a[<span class="number">1</span>][<span class="number">1</span>]=tr.a[<span class="number">3</span>][<span class="number">1</span>]=p;tr.a[<span class="number">2</span>][<span class="number">1</span>]=pn;</span><br><span class="line">        tr.a[<span class="number">1</span>][<span class="number">2</span>]=tr.a[<span class="number">3</span>][<span class="number">2</span>]=pn;tr.a[<span class="number">2</span>][<span class="number">2</span>]=p;</span><br><span class="line">        tr.a[<span class="number">3</span>][<span class="number">3</span>]=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        Matrix ans=<span class="built_in">ksm</span>(tr,n,O);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,(ans.a[<span class="number">3</span>][<span class="number">0</span>]-ans.a[<span class="number">1</span>][<span class="number">0</span>]+mod)%mod);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我当时其实写出了一个正确的式子，但我不知道怎么推了，在文章的最后放一下吧，悲。</p>
<script type="math/tex; mode=display">\frac{(n-1)n}{2}-\sum\limits_{x=1}^{n-1}(x-1)(n-x)\sum\limits_{i=1}^x\binom{x-1}{i}\binom{n-1-x}{i-1}p^{n-1-2i}(1-p)^{2i}+\binom{x-1}{i-1}\binom{n-1-x}{i-1}p^{n-2i}(1-p)^{2i-1}</script><p>唐，怎么每次碰到dp+矩阵快速幂的题都不会做啊，悲。</p>
</div></details>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>概率与期望</tag>
        <tag>矩阵</tag>
      </tags>
  </entry>
  <entry>
    <title>Border学习笔记</title>
    <url>/2024/02/11/Border%E7%90%86%E8%AE%BA/</url>
    <content><![CDATA[<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://www.luogu.com.cn/blog/command-block/border-li-lun-xiao-ji">https://www.luogu.com.cn/blog/command-block/border-li-lun-xiao-ji</a></p>
<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><h2 id="Border"><a href="#Border" class="headerlink" title="Border"></a>Border</h2><p>$Border$ ：字符串的某个前缀（非原串），能与后缀完全匹配。</p>
<p>例：$S[1,m]=S[n-m+1,n]$ ，那么称 $S[1,m]$ 为 $S$ 的一个 $Border$ 。</p>
<p>接下来简称 $Border$ 为 $Bd$ 。</p>
<p>我们称 $mxBd(S)$ 为 $S$ 最长的 $Bd$ ，$Bd(S)$ 为 $S$ 的 $Bd$ 集合。</p>
<h2 id="周期"><a href="#周期" class="headerlink" title="周期"></a>周期</h2><p>若对于 $p$ ，有 $S[i]=S[i+p]$ ，称 $p$ 是 $S$ 的周期。</p>
<p>若 $p| |S|$ ，则称 $p$ 为整周期。</p>
<p>显然，$S[1,p]$ 是 $Bd$ $\Leftrightarrow$ $|S|-p$ 是周期。</p>
<h1 id="与-kmp-的关系"><a href="#与-kmp-的关系" class="headerlink" title="与 kmp 的关系"></a>与 kmp 的关系</h1><h2 id="求每个前缀的最长-Border"><a href="#求每个前缀的最长-Border" class="headerlink" title="求每个前缀的最长 Border"></a>求每个前缀的最长 Border</h2><p>显然，$fail[i]$ 表示的就是 $mxBd(S[1,i])$ 的长度。</p>
<h2 id="求一个串的-Bd-集合。"><a href="#求一个串的-Bd-集合。" class="headerlink" title="求一个串的 $Bd$ 集合。"></a>求一个串的 $Bd$ 集合。</h2><p>无脑 Hash 可以，但是有个更加有理有据的做法：</p>
<p>$Bd(S)=\{mxBd(S)\}+Bd(mxBd(S))$</p>
<p>然后直接用 kmp 的 fail 指针不断跳就行了，即 $Bd(S)$ 对应了 $fail$ 树上的一条链。</p>
<h1 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h1><h2 id="弱周期引理-Weak-Periodicity-Lemma，简称：WPL"><a href="#弱周期引理-Weak-Periodicity-Lemma，简称：WPL" class="headerlink" title="弱周期引理(Weak Periodicity Lemma，简称：WPL)"></a>弱周期引理(Weak Periodicity Lemma，简称：WPL)</h2><p>$p,q$ 都是 $S$ 的周期 ，且 $p+q\le |S|$ ，则 $gcd(p,q)$ 也是 $S$ 的周期。</p>
<p>证明：不妨假设 $p&lt;q$ 。</p>
<p>$S[i]=S[i+q]=S[i+q-p],i\le n-q$</p>
<p>$S[i]=S[i-p]=S[i+q-p],p\le n-q&lt;i\le n+q-p$</p>
<p>所以 $q-p$ 也是一个周期，辗转相减即可证明该结论。</p>
<p>PS：强周期定理：把条件改成 $p+q-gcd(p,q)\le n$ ，不会证明，大部分情况下用弱周期就行了，强周期了解即可。</p>
<p>推论：如果一个串有 $&lt;|S|$ 的整周期，则最小周期也是整周期。</p>
<h2 id="等差数列"><a href="#等差数列" class="headerlink" title="等差数列"></a>等差数列</h2><p><strong>性质 1</strong> ：$S,T,2|S|\ge |T|$ ，则 $S$ 在 $T$ 中的出现位置构成等差数列。</p>
<details class="toggle" ><summary class="toggle-button" style="">证明</summary><div class="toggle-content"><p>如果出现次数小于 $3$ 次，显然成立。</p>
<p>考虑第一次出现位置 $S1$ 、第二次出现位置 $S2$ 和任意一次（除了前两次）出现位置 $S3$ ，假设 $S2-S1=l1,S3-S2=l2$ 。</p>
<p><img src="1.png" alt=""></p>
<p>现在证明 $l1 | l2$ ，考虑 $S1\cup S2$ 这个字符串，显然 $l1,l2$ 都是一个周期，且 $l2\le |S|$ ，则 $l1+l2\le l1+|S|=|S1\cup S2|$ ，所以 $gcd(l1,l2)$ 也是一个周期，如果 $gcd(l1,l2)&lt;l1$ ，则在 $S1$ 和 $S2$ 中间显然还出现了至少一次，与假设矛盾，证毕。</p>
<p>所以 $l1 | l2$ ，则结论显然成立 ，$l1$ 就是公差。</p>
</div></details>
<p><strong>性质 2</strong> ：一个字符串 $S$ 的长度 $\ge \frac{|S|}{2}$ 的 Border 构成等差数列。</p>
<details class="toggle" ><summary class="toggle-button" style="">证明</summary><div class="toggle-content"><p>第一个证明方法是用周期和 Border 的等价性，然后用 WPL 很容易就能证明。</p>
<p>还有一个证明方法是用上面的性质 $1$ ，设 $s$ 为 $\ge \frac{|S|}{2}$ 的长度最短的 Border 。</p>
<p>考虑 $s$ 的所有出现位置，显然，一个 $\ge \frac{|S|}{2}$ 的 Border 对应一个 $s$ 的出现位置，只需要证明一个 $s$ 的出现位置（除了最后一个位置）也对应一个 Border 即可。</p>
<p>（对应方式为：除了最后一个出现位置外的出现位置，考虑这个出现位置的右端点，右端点对应的前缀就是一个 Border ，实际上，如果把原串也视作一个 border 的话，那么最后一个出现位置也有对应了）</p>
<p><img src="2.png" alt=""></p>
<p>证明方法为：观察性质 $1$ 的证明可以发现，$s$ 出现位置的公差就是 $S$ 的周期，所以显然除了最后一个位置外的每一个出现位置都对应了一个 Border 。</p>
<p>但是上面两个方法我还是推荐用周期进行考虑。</p>
</div></details>
<p><strong>性质 3</strong> ：一个字符串的 Border 从小到大排序可以划分成 $O(\log{|S|})$ 个等差数列。</p>
<details class="toggle" ><summary class="toggle-button" style="">证明</summary><div class="toggle-content"><p>考虑 $\ge \frac{|S|}{2}$ 的 Border 构成等差数列，然后考虑 $&lt;\frac{|S|}{2}$ 的最大的 Border ，显然，剩下的 Border 也是这个 Border 的 Border ，然后接着考虑就行了，所以至多 $O(\log{|S|})$ 个。</p>
</div></details>
<p>事实上，通过上面的描述，不难发现：</p>
<p>长度在 $(\frac{|S|}{2},|S|],(\frac{|S|}{4},\frac{|S|}{2}],(\frac{|S|}{8},\frac{|S|}{4}],(\frac{|S|}{16},\frac{|S|}{8}]…$ 即 $(\frac{|S|}{2^{k+1}},\frac{|S|}{2^k}]$ 的 Border 构成等差数列。</p>
<p>或者长度在 $[1,2),[2,4),…,[2^i,2^{i+1}),[2^{i+1},|S|]$ 的 Border 也构成等差数列。（ $|S|&lt;2^{i+2}$ ）</p>
<p>显然，长度在 $<a href="2a\ge b">a,b</a>$ 的 Border 都构成等差数列。</p>
<h2 id="失配树"><a href="#失配树" class="headerlink" title="失配树"></a>失配树</h2><p>对于一个串，考虑对于每个前缀建立一个节点，其父亲是其的 $mxBd$ ，这样构成的一棵根为空串的树叫做失配树，显然，Kmp 的 fail 数组就代表了这棵树。</p>
<p>这棵树有很多性质。</p>
<p><strong>性质 1</strong> ：根据 $Bd(S)=\{mxBd(S)\}+Bd(mxBd(S))$ 可以得出，一个前缀的所有 Bd 就是到父亲的这条链。</p>
<p>这个性质可以用于解决这个题目：</p>
<p><a href="https://www.luogu.com.cn/problem/P5829">https://www.luogu.com.cn/problem/P5829</a></p>
<p>题目大意：给一个串，$q$ 次询问，每次询问询问两个前缀的最长公共 border 长度。</p>
<p>显然就是失配树上找 LCA 就行了。</p>
<p><strong>性质 2</strong> ：每个点到根节点的路径可以划分成 $O(\log)$ 段，每段父子间长度差恒定。（也就是上面 $O(\log)$ 段等差数列的失配树版本）</p>
<p>这个性质可以产生上面那道题目的另外一个做法：</p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>首先，先介绍一种常数更加小的划分 Border 的方式：</p>
<p>如果 $2fail[x]\ge x$ ，令 $p=x-fail[x]$ ，那么 $x$ 到 $x\mod {p}+p$ 构成等差数列，否则 $x$ 自己就是个等差数列。</p>
<p>然后令 $x$ 跳到最大的没有被划分进等差数列的位置就行了，实操中当 $2fail[x]\ge x$ 时，往往直接跳到 $x\mod {p}+p$ ，即认为等差数列间可以有交叉，这样处理方便一些，而且显然，不难证明这么跳 $x’&lt;\frac{2x}{3}$ ，所以仍然是 $O(\log)$ 段。</p>
<p>（这个划分方式还有个小性质，如果 $2fail[x]\ge x$ ，则等差数列至少有两项，否则只有一项）</p>
<p>在划分完 Border 后，显然可以用扩展欧几里得去处理，但是这样是两个 $\log$ 的，而且写起来还没 LCA 好写。</p>
<p>考虑利用性质进行优化，现在考虑找 $x,y$ 前缀的最长公共 Bd ，不妨认为原串也算 Bd，且 $x&gt;y$ ，考虑上述划分中 $x$ 的第一个等差数列。</p>
<p>如果 $2fail[x]&lt;x$，那么显然 $x=fail[x]$ 即可。</p>
<p>如果 $2fail[x]\ge x$ ，那么显然如果 $x\equiv y\mod p$ ，则 $y$ 就是最长公共 Bd ，否则考虑 $y$ 的长度：</p>
<ol>
<li>如果 $y&lt;2p$ ，那么显然这个等差数列，也就是分配树上的这条链除了链头没有别的串可能是公共 Bd 。</li>
<li>如果 $y\ge 2p$ ，显然 $y$ 的最小周期也是 $p$ ，则根据 WPL 可以得出链上 $\ge 2p$ 的点都不可能是公共 Bd（考虑 $x,y$ $\ge 2p$ 的所有 Bd ，显然互不相同），也即只有链头还有可能成为答案，所以 $x=x\mod p+p$。</li>
</ol>
<p>不难发现，这个做法的复杂度与 $x,y$ 按照上述方法划分的等差数列个数同阶（因为上面的过程其实就是从一个等差数列的列尾，跳到下一个等差数列的列尾），也就是 $O(n+q\log{n})$ ，而且显然好写很多，空间也只用 $O(n)$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e6</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">char</span> st[N];</span><br><span class="line"><span class="type">int</span> fail[N],n,q;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,st+<span class="number">1</span>);n=<span class="built_in">strlen</span>(st+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    fail[<span class="number">0</span>]=<span class="number">-1</span>;<span class="type">int</span> now=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(now!=<span class="number">-1</span> &amp;&amp; st[now+<span class="number">1</span>]!=st[i])now=fail[now];</span><br><span class="line">        fail[i]=++now;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;q);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=q;i++)&#123;</span><br><span class="line">        <span class="type">int</span> x,y;<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;x,&amp;y);</span><br><span class="line">        x=fail[x];y=fail[y];</span><br><span class="line">        <span class="keyword">while</span>(x!=y)&#123;</span><br><span class="line">            <span class="keyword">if</span>(x&lt;y)<span class="built_in">swap</span>(x,y);</span><br><span class="line">            <span class="keyword">if</span>(fail[x]*<span class="number">2</span>&lt;x)x=fail[x];</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="built_in">assert</span>(x);</span><br><span class="line">                <span class="type">int</span> d=x-fail[x];</span><br><span class="line">                <span class="keyword">if</span>(x%d==y%d)x=y;</span><br><span class="line">                <span class="keyword">else</span> x=x%d+d;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></details>
<h2 id="一些其他性质"><a href="#一些其他性质" class="headerlink" title="一些其他性质"></a>一些其他性质</h2><ol>
<li><p>如果一个串 $S$ 有 $\ge \frac{|S|}{2}$ 的 Border，则最小的 $\ge \frac{|S|}{2}$ 的 Border 长度 $&lt;\frac{3|S|}{4}$ 。</p>
<details class="toggle" ><summary class="toggle-button" style="">证明</summary><div class="toggle-content"><p>假如最小周期 $p\le \frac{|S|}{4}$ ，则显然 Border $\ge \frac{3|S|}{4}$ 时，还能再去掉一个周期，直到 $&lt;\frac{3|S|}{4}$ 。</p>
<p>假如 $&gt;$ ，显然所有的 Border 都 $&lt;\frac{3|S|}{4}$ ，所以也显然成立。</p>
<p>证毕。</p>
</div></details>
</li>
<li><p>如果一个串 $s$ 有一个 $t$ 作为 mxBd ，且 $2|t|\ge|s|$ ，那么 $t$ 在 $s$ 中只出现了两次。</p>
<details class="toggle" ><summary class="toggle-button" style="">证明</summary><div class="toggle-content"><p>由性质 $1$ 知道出现位置是等差数列，如果出现 $3$ 次及以上可以构造出更长的 Bd ，矛盾。</p>
<p>这个证法和性质 2 的证明 2 挺像的，都是利用了某个 Bd 的出现位置和一些 Bd 的对应关系。</p>
</div></details>
<p>这个性质可以应用在某些 Bd 优化题中，以确定 mxBd 上次出现的位置。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>Border</tag>
      </tags>
  </entry>
  <entry>
    <title>Bridge Elimination</title>
    <url>/2024/02/02/Bridge-Elimination/</url>
    <content><![CDATA[<p>题目链接：<a href="https://qoj.ac/contest/1499/problem/8180">https://qoj.ac/contest/1499/problem/8180</a></p>
<p>题目大意：给定 $n$ 个点的点权，求 $n$ 个点的所有图的权值和，一个图的权值定义为：如果不连通，则为 $0$ ，联通则为所有边双的点权和的乘积。</p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>知道 Cayley 公式乱做。（但是我赛时不知道这个公式 QAQ ）</p>
<p>时间复杂度：$O(n^3)$ 。</p>
<p>解释一下代码：</p>
<p>$cn[i]$ 是 $i$ 个点的联通图的数量。</p>
<p>$dp[i][j]$ 表示有 $j$ 个点，恰好有 $i$ 个连通块的图的权值和（一个图的权值定义为每个连通块大小的乘积）</p>
<p>$bn[i]$ 表示 $i$ 个点的边双联通块数量。</p>
<p>$ff[i]$ 表示 $n$ 个点中，指定的 $i$ 个点各在一个边双，且联通，且恰有 $i$ 个边双的图的数量。</p>
<p>$ge[i]$ 表示从 $n$ 个点中选 $i$ 个点的点权乘积的和。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> LL mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">4e2</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n;LL a[N];</span><br><span class="line">LL fc[N],nfc[N];</span><br><span class="line"><span class="function">LL <span class="title">ksm</span><span class="params">(LL x,LL y)</span></span>&#123;</span><br><span class="line">    LL ans=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(y)&#123;</span><br><span class="line">        <span class="keyword">if</span>(y&amp;<span class="number">1</span>)ans=ans*x%mod;</span><br><span class="line">        x=x*x%mod;y&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    fc[<span class="number">0</span>]=fc[<span class="number">1</span>]=nfc[<span class="number">0</span>]=nfc[<span class="number">1</span>]=<span class="number">1</span>;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)nfc[i]=(mod-mod/i)*nfc[mod%i]%mod;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)nfc[i]=nfc[i<span class="number">-1</span>]*nfc[i]%mod,fc[i]=fc[i<span class="number">-1</span>]*i%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">C</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;<span class="keyword">return</span> fc[x]*nfc[y]%mod*nfc[x-y]%mod;&#125;</span><br><span class="line"><span class="keyword">namespace</span> Graph&#123;</span><br><span class="line">    LL cn[N],dp[N][N],bn[N];</span><br><span class="line">    LL f[N][N],ff[N];</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cn[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            cn[i]=<span class="built_in">ksm</span>(<span class="number">2</span>,i*(i<span class="number">-1</span>)/<span class="number">2</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;i;j++)cn[i]=(cn[i]-cn[j]*<span class="built_in">ksm</span>(<span class="number">2</span>,(i-j)*(i-j<span class="number">-1</span>)/<span class="number">2</span>)%mod*<span class="built_in">C</span>(i<span class="number">-1</span>,j<span class="number">-1</span>)%mod+mod)%mod;</span><br><span class="line">        &#125;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i;j&lt;=n;j++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;j;k++)&#123;<span class="comment">//pre size</span></span><br><span class="line">                    <span class="type">int</span> cnt=j-k;</span><br><span class="line">                    dp[i][j]=(dp[i][j]+dp[i<span class="number">-1</span>][k]*cn[cnt]%mod*<span class="built_in">C</span>(j<span class="number">-1</span>,cnt<span class="number">-1</span>)%mod*cnt)%mod;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            bn[i]=cn[i];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;i;j++)&#123;<span class="comment">//1&#x27;s size</span></span><br><span class="line">                LL now=<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=i-j;k++)&#123;</span><br><span class="line">                    now=now*j%mod;</span><br><span class="line">                    bn[i]=(bn[i]-bn[j]*<span class="built_in">C</span>(i<span class="number">-1</span>,j<span class="number">-1</span>)%mod*dp[k][i-j]%mod*now%mod+mod)%mod;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        f[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i;j&lt;=n;j++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;j;k++)&#123;</span><br><span class="line">                    <span class="type">int</span> cnt=j-k;</span><br><span class="line">                    f[i][j]=(f[i][j]+f[i<span class="number">-1</span>][k]*<span class="built_in">C</span>(j-i,cnt<span class="number">-1</span>)%mod*bn[cnt]%mod*cnt)%mod;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ff[<span class="number">1</span>]=bn[n];<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)ff[i]=f[i][n]*<span class="built_in">ksm</span>(n,i<span class="number">-2</span>)%mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">LL ge[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    Graph::<span class="built_in">init</span>();</span><br><span class="line">    ge[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;a[i]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i;j&gt;=<span class="number">1</span>;j--)ge[j]=(ge[j<span class="number">-1</span>]*a[i]+ge[j])%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    LL ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        ans=(ans+ge[i]*Graph::ff[i])%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></details>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>计数</tag>
        <tag>Prüfer序列</tag>
      </tags>
  </entry>
  <entry>
    <title>CCPC Final 2023 赛后总结</title>
    <url>/2024/04/10/CCPC-Final-2023-%E8%B5%9B%E5%90%8E%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>这就最纯粹的坐牢的乐趣啊。</p>
<h1 id="B"><a href="#B" class="headerlink" title="B"></a>B</h1><p>题目大意：</p>
<p>一个合法的字符串数组（不是字符数组），满足：</p>
<ol>
<li>$1\le |S_i| \le n$</li>
<li>$S_{i}$ 是 $S_{i+1}$ 的周期。</li>
<li>$S_i$ 互不相同</li>
</ol>
<p>这里 $S$ 是 $T$ 的周期的定义是：</p>
<p>如果 $|S|&gt;|T|$ ，则 $T$ 是 $S$ 的前缀，否则和一般的周期定义一致。</p>
<p>问对于 $n$ 从 $1$ 到 $n$ ，每个 $n$ 能构造的最大的合法字符串数组有多大。</p>
<details class="toggle" ><summary class="toggle-button" style="">观察</summary><div class="toggle-content"><p>这是个计数题，但我们首先要知道我们在记什么。</p>
<p>一个基本的观察是：</p>
<p>我们构造 $S_1$ 为 $n$ 个不同的字符组成。</p>
<p>那么一个显然的上界是：能由 $S_1$ 的所有前缀拼接出来的不同字符串数量。</p>
<p>现在证明这个上界是对的：</p>
<p>我们可以将上面的字符串集建成一棵字典树，我们令这棵字典树左儿子为这个位置在 $S_1$ 中的下一个字符（这个位置指的是在前缀中的位置），右儿子为第一个字符。</p>
<p>然后考虑做中序遍历，得到的就是一个合法的构造。</p>
<p>证毕。</p>
<p>但是字符集是小写字母咋办，其实可以发现，把 $S_1$ 换成 $ab….$ 仍然成立，只要满足任意一个字符串的 $S_1$ 的前缀表示不存在或者唯一即可。</p>
<p>而这样的字符串构造也非常的简单，只要字符串中除了第一个位置以外的其余位置都和第一个位置不一样就行了，这是充要条件。</p>
<p>那么现在问题可以等价的转换为：</p>
<p>问多少个数列满足：</p>
<p>$1 \le \sum a_i \le n, a_{i}\le a_1$</p>
</div></details>
<details class="toggle" ><summary class="toggle-button" style="">大佬做法</summary><div class="toggle-content"><p>来自于机房的大佬。</p>
<p>首先根据上面的说法，我们不难设计一个计数方法：</p>
<p>$dp[i][j]$ 表示第一个数字为 $i$ ，同时当前的 $\sum a_i = j$ 的方案数。</p>
<p>初始时 $dp[i][i] = dp[i][i + 1] = 1$ 。</p>
<p>当 $j &gt; i + 1$ 时，满足 $dp[i][j] = dp[i][j - 1] * 2 - dp[i][j - i -1]$ 。</p>
<p>原因是你可以在 $dp[i][j - 1]$ 的基础上选择使最后一个 $a_m+1$ 或者新增一个 $a_m=1$ ，当需要容斥掉 $a_m&gt;i$ 的情况。</p>
<p>另外一方面，从背包的角度看：</p>
<p>$dp[i][j] = \sum\limits_{k=1}^{i}dp[i][j-k]$ 。</p>
<p>然后用 $dp[i][j]$ 的式子减去 $dp[i][j - 1]$ 的式子即可得到上面的转移式。</p>
<p>我们设 $f[n]$ 为 $\sum a_i = n, a_{i}\le a_1$ 的方案数，显然这就是答案的差分，又显然 $f[n] = \sum dp[i][n]$</p>
<p>那么如何维护 $dp[i][n]$ 呢？</p>
<p>可以发现，对于 $dp[i][n]$ ，显然我们只要知道 $dp[i][n],dp[i][n-i],dp[i][n-2i]…$ 就足以完成转移。</p>
<p>即：$b[j]=dp[i][n-(j-1)i]$ 。</p>
<p>显然，下一次：$b[i]=b[i]*2-b[i+1]$ 。</p>
<p>观察到多个 $dp$ 数组的 $b$ 数组转移类似，可以直接累加，而 $b_{1}$ 即为所求。</p>
<p>但是这样还是 $O(n^2)$ ，怎么优化？</p>
<p>注意到当 $i&gt;\sqrt{n}$ 时，$b$ 数组只会开到 $\sqrt{n}$ ，所以直接暴力处理 $i\le \sqrt{n}$ 的 $dp$ 数组，大的用 $b$ 数组转移即可做到 $O(n\sqrt{n})$ 的复杂度。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> B1 = <span class="number">450</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> B2 = <span class="number">450</span>;</span><br><span class="line">LL mod;</span><br><span class="line">LL ans[N];</span><br><span class="line">LL a[N];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, LL val)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i * i &lt;= x; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(x % i == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="type">int</span> j = x / i;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; B1)&#123;</span><br><span class="line">                a[j] = (a[j] + val) % mod;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(j != i &amp;&amp; j &gt; B1)&#123;</span><br><span class="line">                a[i] = (a[i] + val) % mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; mod;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= B1; i++)&#123;</span><br><span class="line">        <span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="built_in">sizeof</span>(a));</span><br><span class="line">        a[i] = <span class="number">1</span>;</span><br><span class="line">        a[i + <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = i + <span class="number">2</span>; j &lt;= n; j++) a[j] = (a[j - <span class="number">1</span>] * <span class="number">2</span> - a[j - i - <span class="number">1</span>] + mod) % mod;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) ans[j] = (ans[j] + a[j]) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="built_in">sizeof</span>(a));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= B2; j++)&#123;</span><br><span class="line">            a[j] = (a[j] * <span class="number">2</span> - a[j + <span class="number">1</span>] + mod) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">add</span>(i, <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">add</span>(i - <span class="number">1</span>, mod - <span class="number">1</span>);</span><br><span class="line">        ans[i] = (ans[i] + a[<span class="number">1</span>]) % mod;</span><br><span class="line">        ans[i] = (ans[i] + ans[i - <span class="number">1</span>]) % mod;</span><br><span class="line">        cout &lt;&lt; ans[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我观察到了一般，可惜一没观察到 $b$ 是可以合并的，二没观察到可以根号分治（不过一没观察到自然也就观察不到二了）。</p>
<p>对于这个做法一个更加形象的解释是：</p>
<p><img src="1.png" alt=""></p>
<p>如果把 $b[i]$ 看成维护一条条直线的话，那么 $b[i]$ 的斜率就是 $i-1$ ，因此在 $i&gt;\sqrt{n}$ 后，直线就只会处在 $i&lt;\sqrt{n}$ 的位置了，直接根号分治，这样就只用维护 $\sqrt{n}$ 条直线了。</p>
</div></details>
<details class="toggle" ><summary class="toggle-button" style="">官方做法</summary><div class="toggle-content"><p>我最学不懂的东西，生成函数启动！</p>
<p>考虑做法 $1$ 中背包的角度开始算生成函数：</p>
<p>先枚举第一个数字是啥，再枚举有多少个 $a$ ，则对于 $n$ 的答案就是：</p>
<script type="math/tex; mode=display">\begin{align*}

 & [x^{n}]\frac{1}{1-x}\sum\limits_{k=1}^n x^{k} \sum\limits_{i=0}^{\infty} (x\frac{1-x^{k}}{1-x})^i \\
 = & [x^{n}]\frac{1}{1-x}\sum\limits_{k=1}^n \frac{x^{k}}{1-x\frac{1-x^k}{1-x}} \\
 = & [x^{n}]\sum\limits_{k=1}^n \frac{x^{k}}{(1-x)-x+x^k} \\
 = & [x^{n}]\sum\limits_{k=1}^n \frac{x^{k}}{1-2x+x^k}
\end{align*}</script><p>然后这个咋处理呢？</p>
<p>不会。</p>
</div></details>
<h1 id="L"><a href="#L" class="headerlink" title="L"></a>L</h1><p>另外开了篇题解详细讲述。</p>
<h1 id="K"><a href="#K" class="headerlink" title="K"></a>K</h1><p>题目大意：</p>
<p>给一个 $n*n$ 的网格，要求在网格上放一些顶着上边界的竖棒或者贴着左边界的横棒，要求棒之间不能相交，且要求一些位置不能被棒覆盖，一些位置必须被棒覆盖，问有多少种合法的放棒方案，两种方案不同当且仅当被覆盖的位置集合不同。</p>
<p>形式化的：</p>
<p>合法的 $a,b$ 数组（长度都为 $n$ ，$a$ 表示横着的棒长，$b$ 表示竖着的棒长）需要满足：</p>
<p>$0\le a_{i},b_{i} \le n$</p>
<p>$[a_{i}\ge j] \ne [b_{j}\ge i]$ </p>
<p>且有一些额外的要求：</p>
<p>$[a_{c_{k}}\ge d_{k}]+[b_{d_{k}}\ge c_{k}]=1$</p>
<p>$[a_{c’_{k}}\ge d_{k}]+[b_{d_{k}}\ge c’_{k}]=0$</p>
<p>但是不是问有多少种不同的合法数组，具体见原题意。</p>
<details class="toggle" ><summary class="toggle-button" style="">我的做法</summary><div class="toggle-content"><p>我们要计数的话，更好计数的是合法的 $a,b$ 数组个数，而不大可能去以覆盖的位置集合为状态去计数（后效性太强）。</p>
<p>但是问题是：不同的 $a,b$ 数组可能是同一个放棒方案。</p>
<p>因此我们需要给合法的 $a,b$ 数组加上一些限制，使其与放棒方案构成双射。</p>
<p>我加上的条件是：</p>
<p>$\forall 1 \le i\le n : a_{b_{i} + 1} \ne i$</p>
<p>证明：</p>
<p>单射：</p>
<p>假设有两组 $a,b$ 、$a’,b’$ 不同但对应的是同一个放棒方案。</p>
<p>不妨设 $b_{i} &gt; b’_{i}$ ，那么 $a’_{b’_{i} + 1} \ge i$ 。</p>
<p>那么显然：$\forall i\le j \le a’_{b’_{i} + 1}:b_{j}\ge b’_{i} + 1,b’_{j} = b’_{i}$ 。</p>
<p>因此 $a’_{1+b’_{a’_{b’_{i} + 1}}} = a’_{b’_{i} + 1}$ ，所以 $a’,b’$ 不是合法的，矛盾。</p>
<p><img src="2.png" alt=""></p>
<p>满射：</p>
<p>对于任意一个没加限制的合法的 $a,b$ 数组，如果违反了限制，那么显然可以让 $b_{i}+1$ ，$a_{b_{i}+1}-1$ ，这样就得到了一个覆盖位置集合不变的新的 $a,b$ 数组，由于 $\sum b$ 在不断增加，因此这个过程一定可以停下来，所以是个满射。</p>
<p>证毕。</p>
<p>接下来就是计数了，还挺麻烦的。</p>
<p>设 $dp[i][j]$ 表示前 $i-1$ 个 $b$ 的值都 $&lt;j$ 且 $b_{i}=j$ ，且已经填了 $a_{1}\sim a_{j}$ 的方案数。</p>
<p>$dp[i][j]\to dp[i’][j’]$ 需要考虑的贡献有 $i\to i’$ 的贡献（填 $b$ 的方案）和 $j\to j’$ 的贡献（填 $b$ 的方案）。</p>
<p>然后优化这个 $dp$ 过程就行了。</p>
<p>时间复杂度 ： $O(n^2)$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> LL mod = <span class="number">998244353</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">3e3</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line">LL nf[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    nf[<span class="number">0</span>] = nf[<span class="number">1</span>] = <span class="number">1ll</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= <span class="built_in">max</span>(n, m); i++) nf[i] = (mod - mod / i) * nf[mod % i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Key</span>&#123;</span><br><span class="line">    LL val;</span><br><span class="line">    <span class="type">int</span> cnt;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> row[N][N], col[N][N];</span><br><span class="line"><span class="type">bool</span> br[N][N], bc[N][N];</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> st[N][N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getst</span><span class="params">(<span class="type">char</span> *s)</span></span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">char</span> ss[N];</span><br><span class="line">    cin &gt;&gt; ss;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) s[i + <span class="number">1</span>] = ss[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//g is consider next row</span></span><br><span class="line">LL f[N], g[N], tmp[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    m = n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="built_in">getst</span>(st[i]);</span><br><span class="line">        st[i][m + <span class="number">1</span>] = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    m++;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        br[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> cnt = row[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="type">bool</span> lock = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(st[i][j] == <span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(lock) cnt = <span class="number">0ll</span>;</span><br><span class="line">                <span class="keyword">else</span> cnt = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(st[i][j] == <span class="string">&#x27;0&#x27;</span>) lock = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(!lock) cnt++;</span><br><span class="line">            <span class="keyword">if</span>(!lock) br[i][j] = <span class="number">1</span>;</span><br><span class="line">            row[i][j] = cnt;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++)&#123;</span><br><span class="line">        bc[<span class="number">0</span>][j] = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> cnt = col[<span class="number">0</span>][j] = <span class="number">1</span>;</span><br><span class="line">        <span class="type">bool</span> lock = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(st[i][j] == <span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(lock) cnt = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">else</span> cnt = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(st[i][j] == <span class="string">&#x27;0&#x27;</span>) lock = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(!lock) cnt++;</span><br><span class="line">            <span class="keyword">if</span>(!lock) bc[i][j] = <span class="number">1</span>;</span><br><span class="line">            col[i][j] = cnt;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    f[<span class="number">0</span>] = <span class="number">1ll</span>;</span><br><span class="line">    g[<span class="number">0</span>] = <span class="number">1ll</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i++) tmp[i] = g[i];</span><br><span class="line">        LL now = <span class="number">0ll</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            now = now * row[i][j - <span class="number">1</span>] % mod;</span><br><span class="line">            <span class="keyword">if</span>(i)&#123;</span><br><span class="line">                now = (now + tmp[i - <span class="number">1</span>]) % mod;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!bc[i][j]) now = <span class="number">0ll</span>;</span><br><span class="line">            <span class="keyword">if</span>(i != n)&#123;</span><br><span class="line">                <span class="keyword">if</span>(st[i + <span class="number">1</span>][j] != <span class="string">&#x27;1&#x27;</span>) g[i] = g[i] * col[i][j] % mod;</span><br><span class="line">                <span class="keyword">else</span> g[i] = <span class="number">0ll</span>;</span><br><span class="line">                <span class="keyword">if</span>(i &amp;&amp; br[i + <span class="number">1</span>][j] &amp;&amp; st[i][j] != <span class="string">&#x27;1&#x27;</span>) g[i] = (g[i] + f[i] * col[i - <span class="number">1</span>][j]) % mod;</span><br><span class="line">                <span class="keyword">if</span>(st[i + <span class="number">1</span>][j] != <span class="string">&#x27;1&#x27;</span>) g[i] = (g[i] + now * row[i + <span class="number">1</span>][j - <span class="number">1</span>]) % mod;</span><br><span class="line">            &#125;</span><br><span class="line">            f[i] = (f[i] * col[i][j] + now) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; f[n] &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>大概的优化就是注意到 $a$ 的贡献可以用类似前缀和的方式搞搞，也就是代码中的 $now$ 。</p>
<p>而 $b$ 的贡献也是类似前缀和，在每一列的转移结束后，用 $O(n)$ 的时间维护一下 $b$ 的贡献，就可以得到对下一列的贡献了。</p>
<p>大概解释一下 $f,g$ ，就是注意到 $a$ 的贡献中，恰好处于 $j + 1$ 位置的行的贡献，由于限制的存在，这一行的限制要比其余行的限制要多，因此 $g$ 就是存储考虑 $j+1$ 行的列的贡献，而 $f$ 就是不考虑 $j+1$ 行的列的贡献，作用是去维护出新的 $g$ 。</p>
<p>我感觉正解肯定不是这么做的，感觉这个做法有一种力大砖飞的感觉，太不优美了。</p>
</div></details>
<details class="toggle" ><summary class="toggle-button" style="">官方做法</summary><div class="toggle-content"><p>如何判断一个 $01$ 矩阵是合法的？（下面以 $f$ 为 $01$ 矩阵）</p>
<p>只需要找到一条从左上到右下的路径（只能向下或者向右），满足左边的都是横条，上面的都是竖条。</p>
<p>但问题是，一个矩阵可能对应多条路径，怎么办？</p>
<p>我们设 $a$ 数组满足：$a_{i}$ 是最小的满足：$f_{i,a_{i}}=0,f_{i,a_{i}+1}=1$ ，如果这一行没有这种东西则认为 $a_{i}=0$ 。</p>
<p>可以用 $a$ 可以表示出一条路径 $p_{l}$ ，同理，可以用 $b$ 表示列，然后同样表示出一条路径 $p_r$ 。</p>
<p>如果这个矩阵是合法的，则一条路径是合法的充要条件是在 $p_l,p_r$ 之间。</p>
<p>显然，$f$ 合法当且仅当 $p_l,p_r$ 合法，因此只需要将 $f$ 放在 $p_l$ 或者 $p_r$ 计数就行了。</p>
<p>简单来说，用 $dp$ 计算每个 $p$ 作为 $p_l$ 时有多少合法的 $f$ 与其对应就行了。</p>
<p>时间复杂度：$O(n^2)$ 。</p>
<p>可以发现，与 $p_r$ 对应的合法的 $f$ 的充要条件就是我的做法所加的那个新限制。</p>
<p>非常的 $interesting$ ，相当于是从不同的角度得到了同一个做法了。</p>
</div></details>
<details class="toggle" ><summary class="toggle-button" style="">更好的实现：</summary><div class="toggle-content"></div></details>
<h1 id="M"><a href="#M" class="headerlink" title="M"></a>M</h1><p>题目大意：在一个数轴上有 $n+1$ 个洞 $n$ 个球，间隔分布，然后假设球的滚动方向确定，你可以自由确定球的滚动顺序使最大化不会落入相邻洞的球的数量，然后现在给你一些球的滚动方向，要求你确定一些球的滚动方向使最大化数量。</p>
<details class="toggle" ><summary class="toggle-button" style="">我的做法</summary><div class="toggle-content"><p>这道题目最难的就是：假设确定了滚动方向，如何找出最大数量。</p>
<p>这个问题可以等价的转化为：将 $&gt;$ 变成 $($ ，将 $&lt;$ 变成 $)$ ，删除若干个括号，使得最终是个合法括号序列，那么这个删法的贡献为：删除的括号数量加上，原来的 $()$ 且最后没有删除其中任何一个括号的数量。</p>
<p>这里可以解释以下后面那个的数量代表什么：和 $&gt;&lt;$ 一定会至少浪费一个球的原因一致。</p>
<p>首先，上面的一种删法可以对应一种顺序。</p>
<p>证明：</p>
<p>首先，对于一个区间的球，其能覆盖的洞的情况分三种：左闭右开，左开右闭，左闭右闭中间开。</p>
<p>但无论是哪种，对于 $()$ ，只要中间其实是有球且已经滚完了，都一定存在一种方式使得这两个球都不会被浪费，滚完以后认为 $()$ 已经被删了就行，所以，初始条件就是对于所有的 $()$ ，要么中间已经有球，要么一开始就是 $()$ ，因此综上，至多浪费上面那个数量，证毕。</p>
<p>其次，最优顺序一定对应上面的一种删法。</p>
<p>证明：</p>
<p>考虑最优顺序一定可以调整成下面的情况：先让所有被浪费的球滚进去，然后每次让一个球跨过一个区间。</p>
<p>现在归纳的证明：对于任意一个左闭右开的区间，一定存在一个上面的一个删法使得在浪费的数量相等的情况下，剩下的括号序列要么是合法的，要么多一个 $)$ ，左开右闭则是 $($ 。</p>
<p>比如一开始有个 $)$ ，那么形成的就是一个左闭右开的洞，所以下次如果有洞跨过它一定是左边有一个 $($ 跨过来，那么合法多个 $($ ，$)$ 和 $($ 匹配，同时左闭右开变成左开右闭。</p>
<p>区间合并同理。</p>
<p>证毕。</p>
<p>然后直接拿着这东西 DP 一下就行了，时间复杂度：$O(n^2)$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">5e3</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf=<span class="number">1e9</span>;</span><br><span class="line"><span class="type">int</span> dp[N][N][<span class="number">2</span>];<span class="comment">//need destroy?</span></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">char</span> st[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        cin &gt;&gt; (st + <span class="number">1</span>);</span><br><span class="line">        n = <span class="built_in">strlen</span>(st + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(st[i] == <span class="string">&#x27;&gt;&#x27;</span>) st[i] = <span class="string">&#x27;(&#x27;</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(st[i] == <span class="string">&#x27;&lt;&#x27;</span>) st[i] = <span class="string">&#x27;)&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= n; j++) dp[i][j][<span class="number">0</span>]=dp[i][j][<span class="number">1</span>]=inf;</span><br><span class="line">        &#125;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; j++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> t = <span class="number">0</span>; t &lt;= <span class="number">1</span>; t++)&#123;</span><br><span class="line">                    <span class="comment">//add &#x27;(&#x27;</span></span><br><span class="line">                    <span class="keyword">if</span>(st[i] != <span class="string">&#x27;)&#x27;</span>)&#123;</span><br><span class="line">                        dp[i][j + <span class="number">1</span>][<span class="number">0</span>] = <span class="built_in">min</span>(dp[i][j + <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][j][t]);</span><br><span class="line">                        dp[i][j + <span class="number">1</span>][<span class="number">1</span>] = <span class="built_in">min</span>(dp[i][j + <span class="number">1</span>][<span class="number">1</span>], dp[i<span class="number">-1</span>][j][t] + <span class="number">1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(st[i] != <span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(j &amp;&amp; t) dp[i][j - <span class="number">1</span>][<span class="number">1</span>] = <span class="built_in">min</span>(dp[i][j - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][j][t]);</span><br><span class="line">                        <span class="keyword">if</span>(j) dp[i][j - <span class="number">1</span>][<span class="number">1</span>] = <span class="built_in">min</span>(dp[i][j - <span class="number">1</span>][<span class="number">1</span>], dp[i<span class="number">-1</span>][j][t] + <span class="number">1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    dp[i][j][<span class="number">1</span>] = <span class="built_in">min</span>(dp[i][j][<span class="number">1</span>], dp[i<span class="number">-1</span>][j][t] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; n-<span class="built_in">min</span>(dp[n][<span class="number">0</span>][<span class="number">0</span>], dp[n][<span class="number">0</span>][<span class="number">1</span>]) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></details>
<details class="toggle" ><summary class="toggle-button" style="">反思</summary><div class="toggle-content"><p>感觉这一类题目就是没想出来脑子里面就是一坨，想出来了就豁然开朗。</p>
<p>赛时花了很多时间还没有做出来，我的问题。</p>
<p>感觉确实难，但做这么久确实蠢。</p>
<p>基本上这道题目知道如何根据滚动方向判断出最大数量就做完了。</p>
<p>但这一步我就卡了很久，下面是最小化浪费的球数。</p>
<ol>
<li><p>首先以为是当成括号匹配，然后是 $&gt;&lt;$ 的数量加上失配的数量。<br>否决理由：</p>
<p>$&gt;&lt;&lt;$，注意到 $&gt;&lt;$ 可以把洞填成左开右闭和左闭右开。</p>
</li>
<li><p>然后以为是相邻两个失配的 $&lt;$ 中间如果有匹配的括号对，那么右边的 $&lt;$ 不会浪费。<br>否决理由：</p>
<p>$&gt;&lt;&gt;&lt;&lt;&lt;$，注意到只有 $&gt;&lt;$ 会浪费中间的洞。</p>
</li>
<li>发现只要有一个 $&gt;&lt;$ 就可以改变一次洞的分布，得到最终做法。</li>
</ol>
<p>别看上面这个过程非常短，实际过了很长的时间。</p>
<p>虽然我认为这里犯了和之前一样的错误：没有先想着证伪（找例子），而是先想着证明（这个往往是困难的），但是我认为以我当时觉得很对的脑子，我觉得我也找不到例子。（虽然这个时候更好的解决方法是找队友，询问他们对这个正确性的看法，因为队友没经过错误的思考回路，当局者迷，旁观者清，反而更容易找到错误）</p>
<p>可以发现，上面最终发现错误的原因都是：找到了个反例，从而加深了对这道题目的认知，最终更加靠近了正解。</p>
<p>然而我找到上面反例的过程都是写了代码，发现没过样例，发现样例里面就有反例。</p>
<p>因此改进措施为（仅针对比较难的题目）：</p>
<ol>
<li>比赛时先手玩一遍数据（非比赛时不手玩是因为我觉得这样其实比较应试，找数据也是实力的一部分）</li>
<li>难题多想一想比较极端或者有代表性的数据，很多时候，在大多数情况足够最优就是在全体情况足够最优，某些数据的最优解法是能够指引最终做法的，我认为这不是一种应试，因为找到数据并说明这个数据的最优做法我认为也是实力的一部分。（简单来说，就是用更多手玩数据的过程去代替更多想证明的过程）</li>
</ol>
<p>第二条其实已经比较接近队长的思考方式了，就是先想一些极端数据，然后找到一个在这些极端数据下仍然对的做法，根据对的理由思考出最终做法，然后再基于大量数据的思考下，给出最终做法的正确性，这其实是一个很好的思考方式，至少比抓瞎要好得多。</p>
<p>希望下一次能够更快的想出这些题目。</p>
</div></details>
<p>官方题解没看懂，感觉非常的奇妙。</p>
<p>还有一些奇奇怪怪的做法，比如花费 $1$ 的代价删除具有某种形式的子串等等，感觉这个题目的做法很多，在此就不一一赘述了。<del>其实是因为我都没看懂</del></p>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
  </entry>
  <entry>
    <title>CCPC final 2023 L. Exchanging Kubic(最大子段和的深入分析)</title>
    <url>/2024/04/28/CCPC-final-2023-L-Exchanging-Kubic-%E6%9C%80%E5%A4%A7%E5%AD%90%E6%AE%B5%E5%92%8C%E7%9A%84%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>题目大意：</p>
<p>交互题，你可以询问一个区间的最大子段和，要求在 $2n$ 的询问次数内给出一个和原数组的最大子段和处处相等的数组。</p>
<details class="toggle" ><summary class="toggle-button" style="">我的做法</summary><div class="toggle-content"><p>首先第一步是花 $n$ 步的次数，问出所有点的正负，这样我们能知道所有的正值，和所有的非负值的位置。</p>
<p>现在要在 $n$ 的次数问出所有非负值的位置。</p>
<p>先把所有连通的正值放在一起，而连通的负值可以等价的认为只有一个，所以原问题可以转化为：+-+-…+，问所有负值的数值。</p>
<p>考虑这么一个询问：+-+ ，假如最终得到的结果等于左右两个 $+$ 值的其中一个，说明 $-$ 起码小于等于两个 $+$ 中最小值的负值。</p>
<p>又可以发现：如果 -+- 且 -+ 和 +- 的和都是 $\le 0$ 的，那么最大子段和一定要么同时包含 -+- ，要么不包含，因此可以将 -+- 合并起来。</p>
<p>因此做法就出来了：每次找到最小的 + ，然后询问其和临近 + 的最大子段和，如果有更大的最大子段和，将这个 + 和临近的 + 合并（此时能够确定中间的 - 值），否则和临近的 - 合并，这样至多两次少一个 + 。</p>
<p>当只剩下一个 + 时，得到的数组就是一个合法的答案，显然，询问次数不超过 $2n-1$ 次。</p>
<p>时间复杂度：$O(n^2)$ 。</p>
<p>可以优化到 $O(n\log{n})$ ，同时这也是这个做法的下界，因为这个做法要找最小值，可以构造：$a_1,-inf,a_2,…,a_m$ ，这样该做法等价于排序 $a_1,…,a_m$ ，因此这个做法的时间复杂度下界就是 $O(n\log{n})$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> LL inf = <span class="number">1e15</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e3</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="function">LL <span class="title">query</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    cnt++;</span><br><span class="line">    <span class="built_in">assert</span>(cnt &lt;= n + n);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;? &quot;</span> &lt;&lt; l &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; r &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="built_in">fflush</span>(stdout);</span><br><span class="line">    <span class="type">static</span> LL c;</span><br><span class="line">    cin &gt;&gt; c;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line">LL ans[N];</span><br><span class="line"><span class="type">bool</span> v[N];</span><br><span class="line"><span class="function">LL <span class="title">querysum</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    LL now = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = l; i &lt;= r; i++) now += ans[i];</span><br><span class="line">    <span class="keyword">return</span> now;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">findpos</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = l; i &lt;= r; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!v[i]) <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">assert</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, LL c, <span class="type">int</span> type)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    LL x = <span class="built_in">querysum</span>(l, r);</span><br><span class="line">    x = c - x;</span><br><span class="line">    <span class="keyword">if</span>(!type) x = <span class="built_in">min</span>(<span class="number">0ll</span>, x);</span><br><span class="line">    <span class="type">int</span> pos = <span class="built_in">findpos</span>(l, r);</span><br><span class="line">    ans[pos] += x;</span><br><span class="line">    <span class="keyword">if</span>(type)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = l; i &lt;= r; i++) v[i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    LL c;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        cin &gt;&gt; n;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) v[i] = <span class="number">0</span>, ans[i] = <span class="number">0ll</span>;</span><br><span class="line">        vector&lt;node&gt; a;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) a.<span class="built_in">push_back</span>(&#123;i, i - <span class="number">1</span>, <span class="number">0ll</span>&#125;);</span><br><span class="line">        a.<span class="built_in">push_back</span>(&#123;n + <span class="number">1</span>, n, <span class="number">0ll</span>&#125;);</span><br><span class="line">        <span class="keyword">while</span>(a.<span class="built_in">size</span>() &gt; <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="type">int</span> minpos = <span class="number">0</span>;</span><br><span class="line">            LL c = a[<span class="number">0</span>].c;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; a.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(a[i].c &lt; c)&#123;</span><br><span class="line">                    c = a[i].c;</span><br><span class="line">                    minpos = i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">auto</span> [l, r, tmp] = a[minpos];</span><br><span class="line">            <span class="keyword">if</span>(minpos)&#123;</span><br><span class="line">                <span class="keyword">auto</span>&amp; [ll, rr, cc] = a[minpos - <span class="number">1</span>];</span><br><span class="line">                LL val = <span class="built_in">query</span>(ll, r);</span><br><span class="line">                <span class="keyword">if</span>(val &lt;= cc) <span class="built_in">add</span>(rr + <span class="number">1</span>, l - <span class="number">1</span>, -c, <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    rr = r;</span><br><span class="line">                    <span class="built_in">add</span>(ll, rr, val, <span class="number">1</span>);</span><br><span class="line">                    cc = val;</span><br><span class="line">                    a.<span class="built_in">erase</span>(a.<span class="built_in">begin</span>() + minpos);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(minpos + <span class="number">1</span> &lt; a.<span class="built_in">size</span>())&#123;</span><br><span class="line">                <span class="keyword">auto</span>&amp; [ll, rr, cc] = a[minpos + <span class="number">1</span>];</span><br><span class="line">                LL val = <span class="built_in">query</span>(l, rr);</span><br><span class="line">                <span class="keyword">if</span>(val &lt;= cc) <span class="built_in">add</span>(r + <span class="number">1</span>, ll - <span class="number">1</span>, -c, <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    ll = l;</span><br><span class="line">                    <span class="built_in">add</span>(ll, rr, val, <span class="number">1</span>);</span><br><span class="line">                    cc = val;</span><br><span class="line">                    a.<span class="built_in">erase</span>(a.<span class="built_in">begin</span>() + minpos);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            a.<span class="built_in">erase</span>(a.<span class="built_in">begin</span>() + minpos);</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;!&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) cout &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; ans[i] ;</span><br><span class="line">        cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个做法的灵感是这样子的：</p>
<p>对于任意一个最大子段和，可以发现，一定存在一个前缀和一个后缀仍然是最大子段和。</p>
<p>也就是说，我们可以这么想象这么一个过程，就好像是一开始所有的 + 值都想要合并出最大的子段和，然后不断吞并中间的 - 值和周围的 + 值合并的过程，而上面就是一个比较良好的合并过程。</p>
<p>正确性分析：</p>
<p>可以发现，上面的过程都是选择相邻的三个数字，合并，或者是一开始相邻两个正数合并或者非负数合并。</p>
<p>因此只需要证明，一个合法的合并后的数组，在合并前也是合法的。</p>
<p>这个证明也不难，只需要小小讨论一下就行了，在此不再赘述。</p>
</div></details>
<details class="toggle" ><summary class="toggle-button" style="">更加正确的分析</summary><div class="toggle-content"><p>在看了题解后感受颇深，感觉自己之前的证明可能伪了，但后面看了下，确实可以这么证明，就没有删除原来的证明。</p>
<p>最后决定将这更加详细的证明新开一个板块，保留以前写的东西，同时这个板块我认为是更加重要的，新开一个板块来讲我认为很合适。</p>
<p>定义一个子段为可能最大子段和，当且仅当其大于其任何真子段和（不是自己的子段）。</p>
<p>充要条件：这个子段的任何前缀和后缀都 $&gt;0$ 。</p>
<p>性质 1 ：这个子段的任意一个前缀的最大子段和是其的前缀，这个子段的任意一个后缀的最大子段和是其后缀。</p>
<p>性质 2 ：对于可能最大子段和 $[l_1,r_1],[l_2,r_2]$ ，如果 $l_1\le l_2,r_1\le r_2,l_2\ge r_1$ ，那么 $[l_2,r_1]$ 也是可能最大子段和。</p>
<p>性质 3 ：如果知道了所有的最大子段和，显然能知道哪些段是可能的最大子段和。</p>
<p>性质 4 ：如果 $[l1,r1],[l2,r2]$ 是可能最大子段和，且满足：$l1\le l2 - 1\le r1\le r2$ ，那么 $[l1,r2]$ 也是可能最大子段和。</p>
<p>现在，回顾一下我之前的灵感中的最大子段和合并的过程，可以发现，里面提到的最大子段和就是可能最大子段和，当时提到了一个词：合并，但是这个合并到达是什么意思呢？</p>
<p>总不能就是感觉上的抽象的合并吧？就两个可能最大子段和合并成一个的过程吧？</p>
<p>接下来我将详细的、具体的描述这个过程：</p>
<p>假设我们知道了 $[l,r]$ 的和，且也有一了一个 $[l,r]$ 的数组满足 $[l,r]$ 内部要求的 $mss$ ，那么我们能不能将 $[l,r]$ 看成一个数字去研究接下来的问题呢？</p>
<p>可以发现，我的做法中，一开始合并两个正数，以及后面的 $+-+$ 的合并都属于这个类型。</p>
<p>这个问题可以这么说：假设我将 $[l,r]$ 看成一个数字，忽略与 $[l,r]$ 有交集但不包含的 $mss$ ，得到了一个合法的数组后，能够在将 $[l,r]$ 展开后，仍然满足所有的 $mss$ 。</p>
<p>又可以这么说：将 $[l,r]$ 看成一个数字，在忽略掉与 $[l,r]$ 有交集但不包含的 $mss$ ，能否唯一决定与 $[l,r]$ 有交集但不包含的 $mss$ 。</p>
<p>而事实上，如果 $[l,r]$ 的数组的得到过程只依赖于 $[l,r]$ 内部的 $mss$ 数组，那么这个问题又可以这么说：能否利用与 $[l,r]$ 有交集但不包含的 $mss$ 以外的 $mss$ 唯一决定这一部分的 $mss$ 。</p>
<p>现在给一个定理：如果 $[l,r]$ 是一个可能的最大子段和，那么上述问题成立。</p>
<p>证明：</p>
<p>考虑计算 $[l’,r’]$ 的 $mss$ ，不妨认为：$l’&lt;l,l\le l’\le r$ ，那么 $mss(l’,r’)=max(mss(l’,l-1),mss(l,r’),K)$ 。</p>
<p>其中 $K$ 表示什么，设最小的 $i$ 满足：$l’\le i &lt; l:[i,r]$ 是可能最大子段和。（没有则 $K=-\infty$）</p>
<p>则 $K=mss(i,r)-mss(l,r)+mss(l,r’)$ ，这一段成立的原因是，如果 $<a href="l\le y \le r">x,y</a>$ 是可能最大子段和，则 $[x,r]$ 也是。</p>
<p>然后显然最大贡献需要挑其中最大的，就是 $[i,r]$ ，然后考虑其的贡献一定是 $sum(i,l-1)$ 加上最大的前缀在 $[l,r’]$ ，显然这个就为 $mss(l,r’)$ 。</p>
<p>因此是可以计算的，证毕。</p>
<p>因此，$[l,r]$ 实际上可以看成一个数字，内部和外部分隔开来，忽略到多余的 $mss$ 不会影响整个 $mss$ 的合法性，我认为这就是上面说的那个合并过程的具体表述。</p>
<p>不过事实上从最终做法也可以看出，决定所有 $mss$ 所需要的 $mss$ 只需要 $O(n)$ 就行了。</p>
<p>区间包含单调性：$mss(l_1,r_1)\ge mss(l_2,r_2),l_1\le l_2,r_1\ge r_2$ 。</p>
<p>四边形不等式：$mss(l_1,r_1)+mss(l_2,r_2)\le mss(l_1,r_2)+mss(l_2,r_1)$ ，$l1\le l_2\le r_2\le r_1$ 。</p>
<p><details class="toggle" ><summary class="toggle-button" style="">证明</summary><div class="toggle-content"><p>只需要证明 $mss(l-1,r+1)-mss(l-1,r)\le mss(l,r+1)-mss(l,r)$ 。</p></p>
<p>考虑 $p(l,r)$ 表示 $\max\limits_{l\le i\le r} sum(i,r)$ ，显然如果 $mss(l,r+1)&gt;mss(l,r)$ ，那么 $mss(l,r+1)=a_{i}+p(l,r)$ ，因此只需要证明：$mss(l-1,r)-p(l-1,r)\ge mss(l,r)-p(l,r)$ 。</p>
<p>设 $[l_1,r_1]$ 为 $mss(l-1,r)$ 的区间， $[l_2,r]$ 为 $p(l-1,r)$ 的区间，$[l_3,r_3]$ 为 $mss(l,r)$ 的区间，$[l_4,r]$ 为 $p(l,r)$ 的区间。</p>
<p>那么显然可以有 $l_1\le l_2, l_3 \le l_4$ ，若有 $l_2\ge l-1$ ，则 $l_2=l_4$ ，则显然成立，所以不妨认为：$l_1 = l_2 = l - 1$ ，此时显然可以有 $r_1&lt;l_3$。</p>
<p>故 $mss(l_1,r)-p(l-1,r)-mss(l,r)+p(l,r)=-sum(r_1+1,l_4-1)\ge 0$ 。</p>
<p>证毕。</p>
</div></details>
<p>最大子段和还有很多其他性质，等待补充。</p>
<p>遇到一道疑似有关这个概念的题目，但是苦于没有提交链接，故先放在这里吃灰：</p>
<p>meta camp 2022 T5 最大子段和，出现链接：<a href="https://www.zhihu.com/question/546431239">https://www.zhihu.com/question/546431239</a> 。</p></div></details>
<details class="toggle" ><summary class="toggle-button" style="">官方题解</summary><div class="toggle-content"><p>看懂了做法，迷迷糊糊的明白了为什么是对的，但是感觉我不太能很好的说明其为什么是对的。（题解看的也不太懂）</p>
<p>我从我的角度去阐述这个做法：</p>
<p>还是跟之前做法一样，先全问一遍，然后合并，变成 $+-+-+-…$ 的形式。</p>
<p>考虑用增量法，即考虑维护一个正确的前缀。</p>
<p>注意到在假如在新添加字符后，我们肯定想知道哪个后缀成为了可能最大子段和。</p>
<p>假设前面的数字是 $a_1,…,a_{t-1}$ ，一个简单粗暴的想法是找到 $l$ ，满足：$mss(l,t) &gt; max(mss(l,t-1), mss(l+1,t))$ ，这样就可以将 $[t,l]$ 合并为一个数字，但是这样子要问 $O(n^2)$ 次，考虑优化。</p>
<p>注意到如果 $[l,t]$ 如果是可能最大子段和的话，那么 $mss(k,t) &gt; mss(k,t-1)(l\le k\le t-1)$ ，因此如果这一条不满足的话，就可以直接退出，但是这样子并没有优化最坏时间复杂度，悲。</p>
<p>接着思考，考虑如果 $mss(k,t)&gt;mss(k,t-1)$ 且 $mss(k,t)=mss(k+1,t)$ ，那究竟意味着什么？如果 $a_{k}\le 0$ 那么显然满足，但是如果 $a_{k}&gt;0$ 时呢？考虑一种简单情况，也就是：$+-+$ ，这个时候也就说明中间 $-$ 的绝对值大于左边的 $+$ 。</p>
<p>注意到，我们有可能永远不可能知道中间 $-$ 的值，因为我们要知道这个 $-$ 的充要条件是有一个可能最大子段和包含它且其余值我们都知道，但是前缀已经写成了 $+-+-+-$ 的形式，且 $-$ 值都不知道，因此这个充要条件感觉上不太可能成立。</p>
<p>这启示我们能不能贪心的给这个位置赋值，也就是给中间的 $-$ 赋值上左边正值的负数（能赋的值中的最大值，显然右边的 $+$ 大于左边的 $+$ 值）。</p>
<p>这样就能利用上每一次询问，根据这个想法，就可以得到题解的做法。</p>
<p>时间复杂度：$O(n)$ 。</p>
<p>具体过程感兴趣的话看代码吧，感觉不太能讲明白。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e3</span> + <span class="number">5</span>;</span><br><span class="line"><span class="function">std::mt19937 <span class="title">rnd</span><span class="params">(time(<span class="number">0</span>))</span></span>;</span><br><span class="line"><span class="type">int</span> n, cnt;</span><br><span class="line"><span class="function">LL <span class="title">mss</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;? &quot;</span> &lt;&lt; l &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; r &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="built_in">fflush</span>(stdout);</span><br><span class="line">    LL res;</span><br><span class="line">    cin &gt;&gt; res;</span><br><span class="line">    cnt++;</span><br><span class="line">    <span class="built_in">assert</span>(cnt &lt;= n + n &amp;&amp; l &gt;= <span class="number">1</span> &amp;&amp; r &lt;= n);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> l, r, p;</span><br><span class="line">    LL preval;</span><br><span class="line">&#125;sta[N]; <span class="type">int</span> top;</span><br><span class="line">LL a[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Seg</span>&#123;</span><br><span class="line">    <span class="type">int</span> l, mid, r;</span><br><span class="line">    LL sum = <span class="number">0ll</span>;</span><br><span class="line">&#125;s[N]; <span class="type">int</span> m;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">    <span class="comment">// while(1)&#123;</span></span><br><span class="line">        top = cnt = <span class="number">0</span>;</span><br><span class="line">        cin &gt;&gt; n;</span><br><span class="line">        <span class="comment">// generater();</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) a[i] = <span class="built_in">mss</span>(i, i);</span><br><span class="line">        <span class="comment">// for(int i = 1; i &lt;= n; i++) a[i] = mss(i, i, b);</span></span><br><span class="line">        m = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> l = <span class="number">1</span>; l &lt;= n; l++)&#123;</span><br><span class="line">            <span class="type">int</span> mid = l - <span class="number">1</span>;</span><br><span class="line">            LL sum = <span class="number">0ll</span>;</span><br><span class="line">            <span class="keyword">while</span>(mid &lt; n &amp;&amp; a[mid + <span class="number">1</span>] &gt; <span class="number">0</span>) mid++, sum += a[mid];</span><br><span class="line">            <span class="type">int</span> r = mid;</span><br><span class="line">            <span class="keyword">while</span>(r &lt; n &amp;&amp; a[r + <span class="number">1</span>] == <span class="number">0</span>) r++;</span><br><span class="line">            s[++m] = &#123;l, mid, r, sum&#125;;</span><br><span class="line">            l = r;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i].mid == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            LL val = s[i].sum;</span><br><span class="line">            <span class="type">int</span> p = s[i].l;</span><br><span class="line">            LL preval = s[i].sum;</span><br><span class="line">            <span class="keyword">while</span>(top)&#123;</span><br><span class="line">                val = <span class="built_in">mss</span>(sta[top].p, s[i].mid);</span><br><span class="line">                <span class="comment">// val = mss(sta[top].p, s[i].mid, b);</span></span><br><span class="line">                <span class="keyword">if</span>(val &gt; sta[top].preval)&#123;</span><br><span class="line">                    a[sta[top].r] = val - sta[top].preval - preval;</span><br><span class="line">                    <span class="keyword">if</span>(val &gt; preval) p = sta[top].p, preval = val;</span><br><span class="line">                    top--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> l = sta[top].l + <span class="number">1</span>;</span><br><span class="line">            sta[++top] = &#123;l, s[i].r, p, preval&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= top; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!a[sta[i].r]) a[sta[i].r] = <span class="number">-1e15</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;!&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) cout &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; a[i];</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>正确性可以感受一下，在每个 $-$ 值处放上能放的最大值，就可以在出现可能最大子段和的时候，使得放下的最后那个决定性的 $-$ 值是合法的，反之，如果在之前的 $-$ 值放下 $-inf$，那么在出现最大子段和时甚至可能在 $-$ 的位置放下正数，这显然是不合法的，这类似一种贪心思想。</p>
<p>再放一个东西：</p>
<p>对于一个 $+-+-+-…+$ 的序列 $a_1,..,a_n$ ，满足 $mss(1,n)=sum(1,n),mss(l,r)=\max\limits_{l\le i\le r}(0,a_{i})([l,r]\ne[1,n])$ ，则一定有以下结论：</p>
<p>$a_1,a_n$ 是 $a$ 序列中的最大值和次大值。</p>
<p>$mss(1,n)\le a_1+a_n-\max\limits_{2\le i \le n - 1}a_i$ 。</p>
<p><details class="toggle" ><summary class="toggle-button" style="">证明</summary><div class="toggle-content"><p>反证法：$\exists i: 2\le i \le n - 1:a_{i}&gt;a_1$（存在多个就找最小的 $i$ ），则 $mss(1,n)+mss(i,i)\le mss(1,i)+mss(i,n)$ ，推出：$mss(1,n)=mss(i,n)$ ，与定义矛盾，第一条证毕。</p></p>
<p>$mss(1,n)+mss(i,i)\le mss(1,i)+mss(i,n)=a_{1}+a_{n}$ ，整理一下可以得到第二条，证毕。</p>
</div></details>
<p>这个性质可以用于证明最后放下的那个负数的合法性。</p>
<p>但我感觉题解肯定不是这个意思，至少正确性应该不是这么丑陋的证明，肯定有更加高深的东西我没看懂，至于是啥，读者只能自行体会或者去看题解了，博主水平有限了。</p></div></details>]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>构造</tag>
        <tag>交互</tag>
      </tags>
  </entry>
  <entry>
    <title>CF1526 E. Oolimry and Suffix Array(从后缀数组反推字符串)</title>
    <url>/2024/02/16/CF1526-E-Oolimry-and-Suffix-Array-%E4%BB%8E%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84%E5%8F%8D%E6%8E%A8%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<p>题目链接：<a href="https://codeforces.com/contest/1526/problem/E">https://codeforces.com/contest/1526/problem/E</a></p>
<p>题目大意：字符集大小为 $n$ ，询问有多少个字符串的后缀数组就是给定的后缀数组。</p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>其实我也不太清楚我是怎么想到这个做法的，反正就是想什么时候两个位置的字符能够相同，然后就知道怎么做了。</p>
<p>看到一个题解说的很有道理：<a href="https://www.luogu.com.cn/blog/namelessgugugu/solution-cf1526e">https://www.luogu.com.cn/blog/namelessgugugu/solution-cf1526e</a></p>
<p>这么说的：知道 $s[i,n]&lt;s[j,n]$ ，就知道 $s[i]\le s[j]$ ，问题是什么时候能够相等，显然是 $s[i+1,n]&lt;s[j+1,n]$ 的时候能够相等。</p>
<p>所以做法就出来了：显然后缀数组上每个位置的字符是非严格递增的，问题是相邻的位置字符能否相等，显然条件就是上面那个，假设我们已经知道了至少需要有 $now$ 个不同的字符，则答案为：</p>
<script type="math/tex; mode=display">\sum\limits_{i=0}^{\min(n,K)-now}\binom{K}{i+now}\binom{n-now}{i}</script><p>显然，这已经足以通过此题，但是还能再简化：</p>
<script type="math/tex; mode=display">
\begin{align*}
&\sum\limits_{i=0}^{\min(n,K)-now}\binom{K}{i+now}\binom{n-now}{i}\\
=& \sum\limits_{i=0}^{\min(n,K)-now}\binom{K}{i+now}\binom{n-now}{n-now-i}\\
=& \sum\limits_{i=0}^{n}\binom{K}{i}\binom{n-now}{n-i}\\
\end{align*}</script><p>最后一步是因为超出来的范围都因为组合数不合法所以值为 $0$ ，不会对结果产生影响。</p>
<p>所以显然，最终化简结果为：$\binom{K+n-now}{n}$ 。</p>
<p>时间复杂度：$O(n+K)$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> LL mod=<span class="number">998244353</span>;</span><br><span class="line">LL fc[N],nfc[N];</span><br><span class="line"><span class="type">int</span> n,K,sa[N],rk[N];</span><br><span class="line"><span class="function">LL <span class="title">C</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;<span class="keyword">return</span> fc[x]*nfc[y]%mod*nfc[x-y]%mod;&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;K);</span><br><span class="line">    fc[<span class="number">0</span>]=fc[<span class="number">1</span>]=nfc[<span class="number">0</span>]=nfc[<span class="number">1</span>]=<span class="number">1</span>;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=<span class="built_in">max</span>(n,K);i++)nfc[i]=(mod-mod/i)*nfc[mod%i]%mod;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=<span class="built_in">max</span>(n,K);i++)fc[i]=fc[i<span class="number">-1</span>]*i%mod,nfc[i]=nfc[i<span class="number">-1</span>]*nfc[i]%mod;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;sa[i]);</span><br><span class="line">        rk[sa[i]]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// rk[n+1]=0;</span></span><br><span class="line">    <span class="type">int</span> now=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(rk[sa[i<span class="number">-1</span>]+<span class="number">1</span>]&gt;rk[sa[i]+<span class="number">1</span>])&#123;</span><br><span class="line">            now++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    LL ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i+now&lt;=n &amp;&amp; i+now&lt;=K;i++)&#123;</span><br><span class="line">        ans=(ans+<span class="built_in">C</span>(K,i+now)*<span class="built_in">C</span>(n-now,i))%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></details>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>计数</tag>
        <tag>字符串</tag>
        <tag>后缀数组</tag>
      </tags>
  </entry>
  <entry>
    <title>Cola</title>
    <url>/2024/01/29/Cola/</url>
    <content><![CDATA[<p>题目链接：<a href="https://contest.ucup.ac/contest/1499/problem/8171">https://contest.ucup.ac/contest/1499/problem/8171</a></p>
<p>题目大意： $A$ 手里有个排列，$B$ 能问 $A$ 一个排列，如果排列完全匹配上，那就 $B$ 胜利，否则 $A$ 回答前 $x$ 个位置都是正确的，$x+1$ 的位置是错误的，如果 $m$ 次询问 $B$ 没有胜利就 $A$ 胜利。问 $B$ 在最优决策下， $A$ 随机拿到一个排列时 $B$ 的获胜概率。</p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>显然要对所有排列计数，而 $B$ 的最优策略就是变 $x+1$ 的位置，然后后面的位置从小到大排序（反正是随机拿一个排列，后面的部分随便一个都行，不会影响答案，从小到大好计数）。</p>
<p>所以问题等价于，有多少个 $n-1$ 的序列 $a$ ，满足：</p>
<p>$0\le a_i\le i,\sum\limits_{i=1}^{n-1}a_i\le m-1$ 。</p>
<p>那么等价于求：$[x^{m-1}]\frac{\prod\limits_{i=1}^{n-1}(1-x^i)}{(1-x)^{n+1}}$ ，但是注意到 $m\le n$ .</p>
<p>所以又等价于求： $[x^{m-1}]\frac{\prod\limits_{i=1}^{\infty}(1-x^i)}{(1-x)^{n+1}}$</p>
<p>分母是经典的高维前缀和，可以用组合意义快速计算 $x^i$ 的系数，分子是五边形数定理，直接算就行了。</p>
<p>时空复杂度：$O(n)$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> LL mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e7</span>+<span class="number">5</span>;</span><br><span class="line">LL fc[N],nfc[N];</span><br><span class="line"><span class="function">LL <span class="title">C</span><span class="params">(LL x,LL y)</span></span>&#123;<span class="keyword">return</span> fc[x]*nfc[y]%mod*nfc[x-y]%mod;&#125;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);n--;m--;</span><br><span class="line">    <span class="keyword">if</span>(!n)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;1\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    nfc[<span class="number">0</span>]=nfc[<span class="number">1</span>]=fc[<span class="number">0</span>]=fc[<span class="number">1</span>]=<span class="number">1</span>;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n+n+<span class="number">1</span>;i++)nfc[i]=(mod-mod/i)*nfc[mod%i]%mod;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n+n+<span class="number">1</span>;i++)nfc[i]=nfc[i<span class="number">-1</span>]*nfc[i]%mod,fc[i]=fc[i<span class="number">-1</span>]*i%mod;</span><br><span class="line">    LL ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="type">int</span> x=i*(<span class="number">3</span>*i<span class="number">-1</span>)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(x&gt;m)<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span>(i&amp;<span class="number">1</span>)ans=(ans+(mod<span class="number">-1</span>)*<span class="built_in">C</span>(n+<span class="number">1</span>+m-x,n+<span class="number">1</span>))%mod;</span><br><span class="line">        <span class="keyword">else</span> ans=(ans+<span class="built_in">C</span>(n+<span class="number">1</span>+m-x,n+<span class="number">1</span>))%mod;</span><br><span class="line">        x=i*(<span class="number">3</span>*i+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(x&gt;m || !i)<span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(i&amp;<span class="number">1</span>)ans=(ans+(mod<span class="number">-1</span>)*<span class="built_in">C</span>(n+<span class="number">1</span>+m-x,n+<span class="number">1</span>))%mod;</span><br><span class="line">        <span class="keyword">else</span> ans=(ans+<span class="built_in">C</span>(n+<span class="number">1</span>+m-x,n+<span class="number">1</span>))%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans*nfc[n+<span class="number">1</span>]%mod);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></details>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>组合意义</tag>
        <tag>五边形数定理</tag>
      </tags>
  </entry>
  <entry>
    <title>CF Round 921 Div.1 赛后总结</title>
    <url>/2024/02/01/CF-Round-921-Div-1-%E8%B5%9B%E5%90%8E%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>比赛链接：<a href="https://codeforces.com/contest/1924/problem/D">https://codeforces.com/contest/1924/problem/D</a></p>
<h1 id="A"><a href="#A" class="headerlink" title="A"></a>A</h1><p>弱智题，每次选最远就行了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e3</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M=<span class="number">26</span>;</span><br><span class="line"><span class="type">int</span> nex[N][M],las[M];</span><br><span class="line"><span class="type">char</span> st[N],ans[N];</span><br><span class="line"><span class="type">int</span> n,k,m;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">work</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;k,&amp;m);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,st+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;k;i++)las[i]=m+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=m;i&gt;=<span class="number">1</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;k;j++)nex[i][j]=las[j];</span><br><span class="line">        las[st[i]-<span class="string">&#x27;a&#x27;</span>]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;k;j++)nex[<span class="number">0</span>][j]=las[j];</span><br><span class="line">    <span class="type">int</span> now=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="type">int</span> maxpos=<span class="number">0</span>,num=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;k;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nex[now][j]&gt;maxpos)maxpos=nex[now][j],num=j;</span><br><span class="line">        &#125;</span><br><span class="line">        ans[i]=num+<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        now=maxpos;</span><br><span class="line">        <span class="keyword">if</span>(now&gt;m)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;=n;j++)ans[j]=<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            ans[n+<span class="number">1</span>]=<span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line">    <span class="comment">// T=1;</span></span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">work</span>())&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Yes\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;No\n%s\n&quot;</span>,ans+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="B"><a href="#B" class="headerlink" title="B"></a>B</h1><p>典中典线段树题，我还以为有高论，想多了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">3e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> NN=<span class="number">6e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Segment</span>&#123;</span><br><span class="line">    <span class="type">int</span> lc,rc;</span><br><span class="line">    LL lazy,c1,c2,d1,d2;</span><br><span class="line">&#125;tr[NN];<span class="type">int</span> len;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">updata</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    tr[x].c1=tr[tr[x].lc].c1+tr[tr[x].rc].c1;</span><br><span class="line">    tr[x].c2=tr[tr[x].lc].c2+tr[tr[x].rc].c2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushlazy</span><span class="params">(<span class="type">int</span> x,LL c)</span></span>&#123;</span><br><span class="line">    tr[x].c1+=c*tr[x].d1;</span><br><span class="line">    tr[x].c2+=c*tr[x].d2;</span><br><span class="line">    tr[x].lazy+=c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tr[x].lazy)&#123;</span><br><span class="line">        <span class="built_in">pushlazy</span>(tr[x].lc,tr[x].lazy);</span><br><span class="line">        <span class="built_in">pushlazy</span>(tr[x].rc,tr[x].lazy);</span><br><span class="line">        tr[x].lazy=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bt</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> x=++len;</span><br><span class="line">    tr[x].d1=r-l+<span class="number">1</span>;tr[x].d2=<span class="number">1ll</span>*(r+l)*(r-l+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(l&lt;r)&#123;</span><br><span class="line">        <span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        tr[x].lc=<span class="built_in">bt</span>(l,mid);</span><br><span class="line">        tr[x].rc=<span class="built_in">bt</span>(mid+<span class="number">1</span>,r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">change</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> ll,<span class="type">int</span> rr,LL c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ll&gt;rr || r&lt;ll || l&gt;rr)<span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">if</span>(l&gt;=ll &amp;&amp; r&lt;=rr)&#123;</span><br><span class="line">        <span class="built_in">pushlazy</span>(x,c);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pushdown</span>(x);</span><br><span class="line">    <span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">change</span>(tr[x].lc,l,mid,ll,rr,c);</span><br><span class="line">    <span class="built_in">change</span>(tr[x].rc,mid+<span class="number">1</span>,r,ll,rr,c);</span><br><span class="line">    <span class="built_in">updata</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">findans</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> id)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&gt;id)<span class="keyword">return</span> <span class="number">0ll</span>;</span><br><span class="line">    <span class="keyword">if</span>(r&lt;=id)<span class="keyword">return</span> (id+<span class="number">1</span>)*tr[x].c1-tr[x].c2;</span><br><span class="line">    <span class="built_in">pushdown</span>(x);</span><br><span class="line">    <span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">findans</span>(tr[x].lc,l,mid,id)+<span class="built_in">findans</span>(tr[x].rc,mid+<span class="number">1</span>,r,id);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,m,q;</span><br><span class="line">set&lt;<span class="type">int</span>&gt; pos;</span><br><span class="line">LL V[N];<span class="type">bool</span> v[N];<span class="type">int</span> p[N];</span><br><span class="line"><span class="type">int</span> ll[N];<span class="comment">//(ll[i],i)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modif</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,LL c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&gt;r)<span class="keyword">return</span> ;</span><br><span class="line">    <span class="built_in">change</span>(<span class="number">1</span>,<span class="number">1</span>,n,l,r,c);</span><br><span class="line">    <span class="built_in">change</span>(<span class="number">1</span>,<span class="number">1</span>,n,r+<span class="number">1</span>,r+<span class="number">1</span>,-c*(r-l+<span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld &quot;</span>,<span class="built_in">findans</span>(<span class="number">1</span>,<span class="number">1</span>,n,i)-<span class="built_in">findans</span>(<span class="number">1</span>,<span class="number">1</span>,n,i<span class="number">-1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;q);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="type">int</span> x;<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);x=n-x+<span class="number">1</span>;</span><br><span class="line">        v[x]=<span class="number">1</span>;</span><br><span class="line">        p[i]=x;</span><br><span class="line">        pos.<span class="built_in">insert</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        LL x;<span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;x);</span><br><span class="line">        V[p[i]]=x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">bt</span>(<span class="number">1</span>,n);</span><br><span class="line">    <span class="type">int</span> pre=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!v[i])<span class="keyword">continue</span>;</span><br><span class="line">        ll[i]=pre;pre=i;</span><br><span class="line">        <span class="built_in">modif</span>(ll[i]+<span class="number">1</span>,i<span class="number">-1</span>,V[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// print();</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=q;i++)&#123;</span><br><span class="line">        <span class="type">int</span> t;<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;t);</span><br><span class="line">        <span class="keyword">if</span>(t==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="type">int</span> x,val;<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;x,&amp;val);x=n-x+<span class="number">1</span>;</span><br><span class="line">            v[x]=<span class="number">1</span>;V[x]=val;pos.<span class="built_in">insert</span>(x);</span><br><span class="line">            <span class="type">int</span> nex=*pos.<span class="built_in">upper_bound</span>(x);</span><br><span class="line">            <span class="built_in">modif</span>(ll[nex]+<span class="number">1</span>,nex<span class="number">-1</span>,-V[nex]);</span><br><span class="line">            ll[x]=ll[nex];</span><br><span class="line">            <span class="built_in">modif</span>(ll[x]+<span class="number">1</span>,x<span class="number">-1</span>,V[x]);</span><br><span class="line">            ll[nex]=x;</span><br><span class="line">            <span class="built_in">modif</span>(ll[nex]+<span class="number">1</span>,nex<span class="number">-1</span>,V[nex]);</span><br><span class="line">            <span class="comment">// print();</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="type">int</span> l,r;<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;l,&amp;r);l=n-l+<span class="number">1</span>;r=n-r+<span class="number">1</span>;</span><br><span class="line">            <span class="built_in">swap</span>(l,r);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,<span class="built_in">findans</span>(<span class="number">1</span>,<span class="number">1</span>,n,r)-<span class="built_in">findans</span>(<span class="number">1</span>,<span class="number">1</span>,n,l<span class="number">-1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="C"><a href="#C" class="headerlink" title="C"></a>C</h1><p>一个显然的事情，你考虑在折过一次的的纸上，去考虑接下来折纸产生的折痕，在这一次折纸展开后会变成什么样，可以发现：</p>
<script type="math/tex; mode=display">(M,V)=(\frac{M'+V'}{\sqrt{2}},\frac{M'+V'+4}{\sqrt{2}})</script><p>赛时唐了，以为要写矩阵，但实际上不用，直接推式子就行了。</p>
<p>最终 $\frac{M}{V}=1-\frac{2}{\sqrt{2}^{n+1}+\sqrt{2}^{n}-\sqrt{2}}$ ，直接算就行了。</p>
<p>题解说奇怪的模数是为了保证分母不为 $0$ ，说是不能让 $2$ 能够开根，我推测用上面的式子精细的讨论一下 $n$ 的奇偶，可能也能分析出来，但我懒得想了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> LL mod=<span class="number">999999893</span>,ni2=(mod+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    LL x,y;<span class="comment">//x+y*sqrt(2)</span></span><br><span class="line">&#125;;</span><br><span class="line">node <span class="keyword">operator</span>*(node x,node y)&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;(x.x*y.x+x.y*y.y*<span class="number">2</span>)%mod,(x.x*y.y+x.y*y.x)%mod&#125;;</span><br><span class="line">&#125;</span><br><span class="line">node <span class="keyword">operator</span>*(node x,LL y)&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;(x.x*y)%mod,(x.y*y)%mod&#125;;</span><br><span class="line">&#125;</span><br><span class="line">node <span class="keyword">operator</span>+(node x,node y)&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;(x.x+y.x)%mod,(x.y+y.y)%mod&#125;;</span><br><span class="line">&#125;</span><br><span class="line">node <span class="keyword">operator</span>-(node x,node y)&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;(x.x-y.x+mod)%mod,(x.y-y.y+mod)%mod&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">node <span class="title">ksm</span><span class="params">(node x,LL y)</span></span>&#123;</span><br><span class="line">    node ans=&#123;<span class="number">1ll</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">while</span>(y)&#123;</span><br><span class="line">        <span class="keyword">if</span>(y&amp;<span class="number">1</span>)ans=ans*x;</span><br><span class="line">        x=x*x;y&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">ksm</span><span class="params">(LL x,LL y)</span></span>&#123;</span><br><span class="line">    LL ans=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(y)&#123;</span><br><span class="line">        <span class="keyword">if</span>(y&amp;<span class="number">1</span>)ans=ans*x%mod;</span><br><span class="line">        x=x*x%mod;y&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> T;<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="type">int</span> n;<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">        node x=&#123;<span class="number">0ll</span>,<span class="number">1</span>&#125;;</span><br><span class="line">        node y=<span class="built_in">ksm</span>(x,n+<span class="number">1</span>)-node&#123;<span class="number">0ll</span>,<span class="number">1</span>&#125;+<span class="built_in">ksm</span>(x,n);</span><br><span class="line">        node z=node&#123;y.x,mod-y.y&#125;*<span class="built_in">ksm</span>( (y.x*y.x-y.y*y.y*<span class="number">2</span>%mod+mod)%mod ,mod<span class="number">-2</span>);</span><br><span class="line">        node ans=node&#123;<span class="number">1ll</span>,<span class="number">0ll</span>&#125;-z*<span class="number">2</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans.y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="D"><a href="#D" class="headerlink" title="D"></a>D</h1><p>唐了。</p>
<p>这道题目我一开始的思路是，一个显然的事情，最终序列一定是一堆合法括号序列，然后用 $)))((($ 插入到两个合法括号序列中间，然后就有了我最开始的做法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> LL mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e4</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> L=<span class="number">10000</span>;</span><br><span class="line">LL fc[N],nfc[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    fc[<span class="number">0</span>]=fc[<span class="number">1</span>]=nfc[<span class="number">0</span>]=nfc[<span class="number">1</span>]=<span class="number">1</span>;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=L;i++)nfc[i]=(mod-mod/i)*nfc[mod%i]%mod;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=L;i++)nfc[i]=nfc[i<span class="number">-1</span>]*nfc[i]%mod,fc[i]=fc[i<span class="number">-1</span>]*i%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">C</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;y || y&lt;<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0ll</span>;</span><br><span class="line">    <span class="keyword">return</span> fc[x]*nfc[y]%mod*nfc[x-y]%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">goal_fu</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> len)</span></span>&#123;</span><br><span class="line">    x--;len--;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;<span class="number">0</span>)x=-x;</span><br><span class="line">    <span class="keyword">if</span>(x&gt;len)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">assert</span>((len&amp;<span class="number">1</span>)==(x&amp;<span class="number">1</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">C</span>(len,(len-x)&gt;&gt;<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">goal</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">goal_fu</span>(x,len)-<span class="built_in">goal_fu</span>(-x,len)+mod)%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="type">int</span> T;<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="type">int</span> n,m,k;<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;k);</span><br><span class="line">        <span class="keyword">if</span>(n&lt;k || m&lt;k)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;0\n&quot;</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        n-=k;m-=k;</span><br><span class="line">        LL ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=k;i++)&#123;</span><br><span class="line">            LL now=<span class="built_in">goal</span>(i,k+k-i);</span><br><span class="line">            ans=(ans+now*<span class="built_in">C</span>(n+m+i,i))%mod;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但实际上可以直接用折线法得到最终答案。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> LL mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e4</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> L=<span class="number">10000</span>;</span><br><span class="line">LL fc[N],nfc[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    fc[<span class="number">0</span>]=fc[<span class="number">1</span>]=nfc[<span class="number">0</span>]=nfc[<span class="number">1</span>]=<span class="number">1</span>;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=L;i++)nfc[i]=(mod-mod/i)*nfc[mod%i]%mod;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=L;i++)nfc[i]=nfc[i<span class="number">-1</span>]*nfc[i]%mod,fc[i]=fc[i<span class="number">-1</span>]*i%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">C</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;<span class="keyword">return</span> fc[x]*nfc[y]%mod*nfc[x-y]%mod;&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="type">int</span> T;<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="type">int</span> n,m,k;<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;k);</span><br><span class="line">        <span class="keyword">if</span>(n&lt;k || m&lt;k)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;0\n&quot;</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,(<span class="built_in">C</span>(n+m,k)-<span class="built_in">C</span>(n+m,k<span class="number">-1</span>)+mod)%mod);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>显然两种做法后面一种更加优秀，而且也不算难。</p>
<p>但是赛时就是没想出来，警钟敲烂。</p>
<p>已将上面两种做法的最关键部分全部写入组合计数练习，引以为戒，警钟敲烂。</p>
<h1 id="E"><a href="#E" class="headerlink" title="E"></a>E</h1><p>做法已加入《组合计数练习》。</p>
<p>简单来说就是用排列考虑就行了。</p>
<p>时间复杂度：$O(n+m)$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> LL mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e6</span>+<span class="number">5</span>;</span><br><span class="line">LL nfc[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> L=<span class="number">2e6</span>+<span class="number">1</span>;</span><br><span class="line">    nfc[<span class="number">0</span>]=nfc[<span class="number">1</span>]=<span class="number">1</span>;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=L;i++)nfc[i]=(mod-mod/i)*nfc[mod%i]%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="type">int</span> T;<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        LL n,m,k;<span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld%lld&quot;</span>,&amp;n,&amp;m,&amp;k);k--;</span><br><span class="line">        <span class="keyword">if</span>(n*m&lt;=k)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;0\n&quot;</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        LL ans=<span class="number">1</span>;</span><br><span class="line">        &#123;</span><br><span class="line">            LL l=k/n+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=l;i&lt;m;i++)ans=(ans+nfc[n<span class="number">-1</span>+i])%mod;</span><br><span class="line">        &#125;</span><br><span class="line">        &#123;</span><br><span class="line">            LL l=k/m+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=l;i&lt;n;i++)ans=(ans+nfc[i+m<span class="number">-1</span>])%mod;</span><br><span class="line">        &#125;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">                LL l=k/i+<span class="number">1</span>,r=m<span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">if</span>(l&lt;=r)ans=(ans+<span class="number">2</span>*(nfc[i+l<span class="number">-1</span>]-nfc[i+r]+mod))%mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h2><p>在想这道题目的时候发现了一个具有意思的组合意义，可惜没法扩展。</p>
<p>考虑一个弱化版的问题：</p>
<p>令 $m=1$ ，问出现 $k*1$ 的纸张的概率。</p>
<p>这么考虑这个问题：</p>
<p>现在从 $n-1$ 开始考虑，考虑到 $x$ 时，有 $\frac{1}{x}$ 的概率选中他，不难发现这与原过程等价。</p>
<p>这样，问题转化为选中 $k$ 的概率，显然就是 $\frac{1}{k}$ 了。</p>
<h1 id="F"><a href="#F" class="headerlink" title="F"></a>F</h1><p>咕咕咕。</p>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title>ECNU 2023.8 B. Bare Minimum Difference</title>
    <url>/2023/09/02/ECNU-2023-8-B-Bare-Minimum-Difference/</url>
    <content><![CDATA[<p>题目链接：<a href="https://acm.ecnu.edu.cn/contest/695/problem/B/">https://acm.ecnu.edu.cn/contest/695/problem/B/</a></p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>题弱智但我也弱智，看错题了，以为要求方案数，乐，而且还以为会有负数。</p>
<p>我的做法是枚举 $n^2$ 个下界，然后 DP 维护最小上界，时间复杂度：$O(n^4)$。</p>
<p>然而看了题解后发现如果二分上界的话实际上可以配合滑动窗口之类的东西做到 $O(n)$ check 。</p>
<p>所以最优秀的时间复杂度是：$o(n^3\log{n})$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 110</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf=<span class="number">999999999</span>;</span><br><span class="line"><span class="type">int</span> a[N],n,dp[N],b[N],m;</span><br><span class="line"><span class="type">int</span> ans=inf;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> type=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> limit)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)b[i]+=b[i<span class="number">-1</span>];</span><br><span class="line">    <span class="built_in">memset</span>(dp,<span class="number">20</span>,<span class="built_in">sizeof</span>(dp));</span><br><span class="line">    dp[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">            <span class="comment">// if(type)printf(&quot;OK %d\n&quot;,limit);</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;i;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(b[i]-b[j]&lt;limit)<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span>(dp[i]&gt;<span class="built_in">max</span>(dp[j],b[i]-b[j]))dp[i]=<span class="built_in">max</span>(b[i]-b[j],dp[j]);</span><br><span class="line">            <span class="comment">// if(type==1 &amp;&amp; i==3 &amp;&amp; j==0)printf(&quot;%d\n&quot;,dp[i]);</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// if(type==1)printf(&quot;%d\n&quot;,dp[m]);</span></span><br><span class="line">    <span class="keyword">return</span> dp[m];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i;j&lt;=n;j++)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// type=0;</span></span><br><span class="line"></span><br><span class="line">            sum+=a[j];<span class="keyword">if</span>(i==<span class="number">1</span> &amp;&amp; j==n)<span class="keyword">continue</span>;</span><br><span class="line">            m=i<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;i;k++)b[k]=a[k];</span><br><span class="line">            <span class="type">int</span> now=<span class="built_in">solve</span>(sum);</span><br><span class="line">            m=n-j;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=j+<span class="number">1</span>;k&lt;=n;k++)b[k-j]=a[k];</span><br><span class="line"></span><br><span class="line">            <span class="comment">// if(i==1 &amp;&amp; j==3)type=1;</span></span><br><span class="line">            <span class="comment">// else type=0;</span></span><br><span class="line"></span><br><span class="line">            now=<span class="built_in">max</span>(<span class="built_in">solve</span>(sum),now);</span><br><span class="line">            <span class="comment">// if(i==1 &amp;&amp; j==3)printf(&quot;%d\n&quot;,now);</span></span><br><span class="line">            ans=<span class="built_in">min</span>(now-sum,ans);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></details>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title>ECNU 2023.8 C. Kaleidoscope</title>
    <url>/2023/09/02/ECNU-2023-8-C-Kaleidoscope/</url>
    <content><![CDATA[<p>题目链接：<a href="https://acm.ecnu.edu.cn/contest/695/problem/C/">https://acm.ecnu.edu.cn/contest/695/problem/C/</a></p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>我是状压 DP 做的，不难发现，我们可以把这一行被上一行占用的位置保存下来，然后转移。</p>
<p>显然如果 $x$ 转移到 $y$ ，那么 $x\And y=0$ ，而这是一个经典的 trick ，这样子转移的复杂度是 $O(3^m)$ 的，所以最终时间复杂度就是：$O(n3^m)$ 。</p>
<p>不过看题解说其实有效转移 $&lt;6000$ ？</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 310</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> M 160</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">26</span>],len,fa;</span><br><span class="line">&#125;tr[N];<span class="type">int</span> tot,last;</span><br><span class="line"><span class="type">char</span> st[M];<span class="type">int</span> n;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> c)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> p=last;<span class="type">int</span> np=last=++tot;</span><br><span class="line">    tr[np].len=tr[p].len+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(;p &amp;&amp; !tr[p].a[c];p=tr[p].fa)tr[p].a[c]=np;</span><br><span class="line">    <span class="keyword">if</span>(!p)tr[np].fa=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="type">int</span> q=tr[p].a[c];</span><br><span class="line">        <span class="keyword">if</span>(tr[q].len==tr[p].len+<span class="number">1</span>)tr[np].fa=q;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="type">int</span> nq=++tot;</span><br><span class="line">            tr[nq].fa=tr[q].fa;tr[q].fa=nq;</span><br><span class="line">            tr[nq].len=tr[p].len+<span class="number">1</span>;<span class="built_in">memcpy</span>(tr[nq].a,tr[q].a,<span class="built_in">sizeof</span>(tr[q].a));</span><br><span class="line">            tr[np].fa=nq;</span><br><span class="line">            <span class="keyword">for</span>(;p &amp;&amp; tr[p].a[c]==q;p=tr[p].fa)tr[p].a[c]=nq;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool</span> dp[N][M][M];</span><br><span class="line"><span class="type">int</span> m,X;<span class="type">char</span> ans[M];<span class="type">int</span> fuck;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getval</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> fucklen)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> cnt=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=fucklen;i&gt;=<span class="number">1</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(tr[x].a[ans[i]-<span class="string">&#x27;a&#x27;</span>])x=tr[x].a[ans[i]-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        <span class="keyword">else</span> x=tr[<span class="number">1</span>].a[ans[i]-<span class="string">&#x27;a&#x27;</span>],cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool</span> v[<span class="number">40</span>];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">work</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(fuck!=m)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=tot;i++)&#123;</span><br><span class="line">            <span class="type">int</span> x=<span class="built_in">getval</span>(i,fuck);</span><br><span class="line">            <span class="keyword">if</span>(x&lt;=X &amp;&amp; dp[i][m-fuck][X-x+<span class="number">1</span>])<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">getval</span>(tr[<span class="number">1</span>].a[ans[m]-<span class="string">&#x27;a&#x27;</span>],m<span class="number">-1</span>)==X;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> T;<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;X);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,st+<span class="number">1</span>);</span><br><span class="line">        tot=last=<span class="number">1</span>;<span class="built_in">memset</span>(tr,<span class="number">0</span>,<span class="built_in">sizeof</span>(tr));<span class="built_in">memset</span>(v,<span class="number">0</span>,<span class="built_in">sizeof</span>(v));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i+i&lt;=n;i++)<span class="built_in">swap</span>(st[i],st[n-i+<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="built_in">add</span>(st[i]-<span class="string">&#x27;a&#x27;</span>),v[st[i]-<span class="string">&#x27;a&#x27;</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="comment">// for(int i=1;i&lt;=tot;i++)&#123;</span></span><br><span class="line">        <span class="comment">//     printf(&quot;%d %d\n&quot;,tr[i].fa,tr[i].len);</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">25</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(tr[<span class="number">1</span>].a[i])dp[tr[<span class="number">1</span>].a[i]][<span class="number">1</span>][<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;m;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">2</span>;j&lt;=tot;j++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> t=<span class="number">1</span>;t&lt;=i &amp;&amp; t&lt;=X;t++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(!dp[j][i][t])<span class="keyword">continue</span>;</span><br><span class="line">                    <span class="comment">// if(i==1 &amp;&amp; j==5 &amp;&amp; t==1)printf(&quot;OK\n&quot;);</span></span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;=<span class="number">25</span>;k++)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(tr[j].a[k])dp[tr[j].a[k]][i+<span class="number">1</span>][t]=<span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span>(tr[<span class="number">1</span>].a[k] &amp;&amp; t&lt;X)dp[tr[<span class="number">1</span>].a[k]][i+<span class="number">1</span>][t+<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// for(int i=1;i&lt;=tot;i++)printf(&quot;%d:%d %d\n&quot;,i,tr[i].len,tr[i].fa);</span></span><br><span class="line">        <span class="comment">// printf(&quot;%d %d %d\n&quot;,dp[4][2][1],tr[5].a[0],dp[5][1][1]);</span></span><br><span class="line">        <span class="type">bool</span> bk=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=tot;i++)bk|=dp[i][m][X];</span><br><span class="line">        <span class="keyword">if</span>(!bk)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=tot;i++)<span class="built_in">memset</span>(dp[i],<span class="number">0</span>,<span class="built_in">sizeof</span>(dp[i]));</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;-1\n&quot;</span>);<span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ans[1]=ans[2]=&#x27;a&#x27;;printf(&quot;%d\n&quot;,getval(5,2));</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">            fuck=i;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=<span class="number">25</span>;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!v[j])<span class="keyword">continue</span>;</span><br><span class="line">                ans[i]=j+<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">work</span>()==<span class="number">1</span>)<span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans[m+<span class="number">1</span>]=<span class="string">&#x27;\0&#x27;</span>;<span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,ans+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=tot;i++)<span class="built_in">memset</span>(dp[i],<span class="number">0</span>,<span class="built_in">sizeof</span>(dp[i]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>官方做法：</p>
<p>可以发现 $(i,j)$ 至多从 $(i-1,j-1)$ 转移过来，所以可以直接轮廓线 DP ，保存所有需要位置的状态就行了。</p>
<p>时间复杂度：$O(nm2^m)$ 。</p>
</div></details>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>经典trick</tag>
        <tag>状压</tag>
        <tag>轮廓线</tag>
      </tags>
  </entry>
  <entry>
    <title>ECNU 2023.8 D. Mutton string</title>
    <url>/2023/09/02/ECNU-2023-8-D-Mutton-string/</url>
    <content><![CDATA[<p>题目链接：<a href="https://acm.ecnu.edu.cn/contest/695/problem/D/">https://acm.ecnu.edu.cn/contest/695/problem/D/</a></p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>引理 $1$ ：优先加入符合要求的最长子串。（把后一个子串的前缀拿过来显然不劣）</p>
<p>到这里其实就差不多了，子串显然能够想到那个算法：SAM 。</p>
<p>如果给你一个字符串，怎么求出其的最小操作数呢？显然是拉上 SAM 上跑一遍，现在要我们确定一个最小操作数为 $x$ 的字符串，显然也是在 SAM 上 DP 一下就行了。</p>
<p>如果没有字典序的约束，这道题目就是：$dp[i][j]<a href="bool">k</a>$ 表示是否存在一个方案满足终止位置 SAM 上的第 $i$ 个节点，目前长度为 $j$ ，已经有了 $k$ 段，然后直接转移就行了。</p>
<p>但是因为我赛时分析错了复杂度，以为是四次方的，就没有往下接着想了，但实际上是三次方的。</p>
<p>显然时间复杂度是：$O(26nmx)$ ，而且如果实现的足够精妙能够到达 $O(nmx)$ ，因为考虑固定 $j,k$ ，这样对于 $i$ 的转移分两种，跑存在的边（ SAM 边的数量级是 $O(n)$ 的），跑不存在的边（可以状压，也可以调整搜索顺序，优先跑 $26$ ，然后去找可行且不能到达的状态（因此需要提前把可行的状态记录一下））。</p>
<p>但是如果要求字典序最小的字符串呢？</p>
<p>显然，我们必须要查询对于一个前缀，是否存在满足要求的答案，为此，我们不妨考虑整个字符串是倒着加子串的，然后把 $A$ 翻转，反着跑一遍 $DP$ ，然后枚举刚好跑到前缀时位于哪个点，然后继续扔到后缀数组上跑，看看能否凑出一个 $X$ 段出来。</p>
<p>时间复杂度：$O(26nmx)$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 310</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> M 160</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">26</span>],len,fa;</span><br><span class="line">&#125;tr[N];<span class="type">int</span> tot,last;</span><br><span class="line"><span class="type">char</span> st[M];<span class="type">int</span> n;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> c)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> p=last;<span class="type">int</span> np=last=++tot;</span><br><span class="line">    tr[np].len=tr[p].len+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(;p &amp;&amp; !tr[p].a[c];p=tr[p].fa)tr[p].a[c]=np;</span><br><span class="line">    <span class="keyword">if</span>(!p)tr[np].fa=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="type">int</span> q=tr[p].a[c];</span><br><span class="line">        <span class="keyword">if</span>(tr[q].len==tr[p].len+<span class="number">1</span>)tr[np].fa=q;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="type">int</span> nq=++tot;</span><br><span class="line">            tr[nq].fa=tr[q].fa;tr[q].fa=nq;</span><br><span class="line">            tr[nq].len=tr[p].len+<span class="number">1</span>;<span class="built_in">memcpy</span>(tr[nq].a,tr[q].a,<span class="built_in">sizeof</span>(tr[q].a));</span><br><span class="line">            tr[np].fa=nq;</span><br><span class="line">            <span class="keyword">for</span>(;p &amp;&amp; tr[p].a[c]==q;p=tr[p].fa)tr[p].a[c]=nq;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool</span> dp[N][M][M];</span><br><span class="line"><span class="type">int</span> m,X;<span class="type">char</span> ans[M];<span class="type">int</span> fuck;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getval</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> fucklen)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> cnt=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=fucklen;i&gt;=<span class="number">1</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(tr[x].a[ans[i]-<span class="string">&#x27;a&#x27;</span>])x=tr[x].a[ans[i]-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        <span class="keyword">else</span> x=tr[<span class="number">1</span>].a[ans[i]-<span class="string">&#x27;a&#x27;</span>],cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool</span> v[<span class="number">40</span>];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">work</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(fuck!=m)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=tot;i++)&#123;</span><br><span class="line">            <span class="type">int</span> x=<span class="built_in">getval</span>(i,fuck);</span><br><span class="line">            <span class="keyword">if</span>(x&lt;=X &amp;&amp; dp[i][m-fuck][X-x+<span class="number">1</span>])<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">getval</span>(tr[<span class="number">1</span>].a[ans[m]-<span class="string">&#x27;a&#x27;</span>],m<span class="number">-1</span>)==X;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> T;<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;X);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,st+<span class="number">1</span>);</span><br><span class="line">        tot=last=<span class="number">1</span>;<span class="built_in">memset</span>(tr,<span class="number">0</span>,<span class="built_in">sizeof</span>(tr));<span class="built_in">memset</span>(v,<span class="number">0</span>,<span class="built_in">sizeof</span>(v));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i+i&lt;=n;i++)<span class="built_in">swap</span>(st[i],st[n-i+<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="built_in">add</span>(st[i]-<span class="string">&#x27;a&#x27;</span>),v[st[i]-<span class="string">&#x27;a&#x27;</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="comment">// for(int i=1;i&lt;=tot;i++)&#123;</span></span><br><span class="line">        <span class="comment">//     printf(&quot;%d %d\n&quot;,tr[i].fa,tr[i].len);</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">25</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(tr[<span class="number">1</span>].a[i])dp[tr[<span class="number">1</span>].a[i]][<span class="number">1</span>][<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;m;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">2</span>;j&lt;=tot;j++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> t=<span class="number">1</span>;t&lt;=i &amp;&amp; t&lt;=X;t++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(!dp[j][i][t])<span class="keyword">continue</span>;</span><br><span class="line">                    <span class="comment">// if(i==1 &amp;&amp; j==5 &amp;&amp; t==1)printf(&quot;OK\n&quot;);</span></span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;=<span class="number">25</span>;k++)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(tr[j].a[k])dp[tr[j].a[k]][i+<span class="number">1</span>][t]=<span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span>(tr[<span class="number">1</span>].a[k] &amp;&amp; t&lt;X)dp[tr[<span class="number">1</span>].a[k]][i+<span class="number">1</span>][t+<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// for(int i=1;i&lt;=tot;i++)printf(&quot;%d:%d %d\n&quot;,i,tr[i].len,tr[i].fa);</span></span><br><span class="line">        <span class="comment">// printf(&quot;%d %d %d\n&quot;,dp[4][2][1],tr[5].a[0],dp[5][1][1]);</span></span><br><span class="line">        <span class="type">bool</span> bk=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=tot;i++)bk|=dp[i][m][X];</span><br><span class="line">        <span class="keyword">if</span>(!bk)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=tot;i++)<span class="built_in">memset</span>(dp[i],<span class="number">0</span>,<span class="built_in">sizeof</span>(dp[i]));</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;-1\n&quot;</span>);<span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ans[1]=ans[2]=&#x27;a&#x27;;printf(&quot;%d\n&quot;,getval(5,2));</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">            fuck=i;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=<span class="number">25</span>;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!v[j])<span class="keyword">continue</span>;</span><br><span class="line">                ans[i]=j+<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">work</span>()==<span class="number">1</span>)<span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans[m+<span class="number">1</span>]=<span class="string">&#x27;\0&#x27;</span>;<span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,ans+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=tot;i++)<span class="built_in">memset</span>(dp[i],<span class="number">0</span>,<span class="built_in">sizeof</span>(dp[i]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>官方做法：</p>
<p>不得不说这应该是经典 trick 但是我忘了，在遇到 DP + 字符串 + 字典序最小就应该马上意识过来才对。</p>
<p>简单来说，用 BFS 更新 DP 状态，这样只要更新出了最终状态那么这条更新路径就是答案，而且不止最终状态，准确来说对于每个状态其的更新路径都是字典序最小的路径。（那这样是不是 DFS 也可以啊，只要加个记忆化就行了，本质应该是一样的）</p>
<p>原因：队列中对于两个长度相等的状态，一定满足更新路径字典序小的在前面，大的在后面，同时只要前面符合这种情况，后面也一定符合这种情况，想想就知道了，挺有意思的，</p>
<hr>
<p>队友的做法：</p>
<p>赛后讨论了一下，他的做法是正着做，反过来标记每个状态如果要到达最终状态的最优决策是什么（实际上只要处理出能否到达最终状态就行了），然后在正着处理出答案。</p>
<p><del>然而，我突然发现，实际上倒着跑就可以只跑两遍了，先倒着跑一遍 DP ，处理出每个位置的最优，然后正着跑出结果就行了。</del> (错误原因：一个点可能有多个点走同一个字符的边转移过来，因此无法在常数的时间判断出来哪个是最优决策)</p>
<hr>
<p>同机房同学的做法：</p>
<p>非常的有意思，我只能说不愧是他，A不了，但是可以看一下。</p>
<p>观察发现实际上会出问题当且仅当某个子串的下一个位置和下一个子串的首位置相等，所以一个操作次数 $≥2$ 的子串的某个前缀一定是由一个子串+某个字符构成的（且这个前缀不是一个子串），不妨考虑处理出所有这样的字符串（最多 $26n^2$ 个），然后排序，可以发现，这样的字符串具有一个性质，不存在一个字符串是另外一个字符串的前缀，这个性质后面有用。</p>
<p>然后设 $f[i][j][k]$ 表示长度为 $j$ ，首字母为 $i$ ，最小操作次数为 $k$ 的最小字典序的字符串（其实也不需要保留字符串，保留转移就行了）。</p>
<p>这样，转移的时候只需要从小到达遍历前面那个字符串，能转移就转移，不难发现这就是最优的决策。</p>
<p>但是仔细计算一下复杂度是 $O(26^2nmx)$ ，非常遗憾不能通过此题，但是我个人感觉这个思想非常的有意思，所以就把它给记录下来了，而且也很有启示意义，就是很多时候可以尝试一下脱离算法思考，可以发现这个方法并不依赖任何字符串算法，却得到了一个非常有意思的方法（这个老哥就是这个想法的忠实拥护者，不怎么学算法，坚信大部分题目都是可以用思维解决，所以他的思维就非常的厉害）。</p>
<hr>
<p>听说同机房还有基于字典树和 bitset 优化的四方做法过了，厉害厉害。</p>
</div></details>]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>经典trick</tag>
        <tag>字符串</tag>
        <tag>字典序</tag>
        <tag>SAM</tag>
      </tags>
  </entry>
  <entry>
    <title>Game of Connect(Shannon&#39;s Switching Game)</title>
    <url>/2024/01/31/Game-of-Connect-Shannon-s-Switching-Game/</url>
    <content><![CDATA[<p>题目链接：<a href="https://onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=3792">https://onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=3792</a></p>
<p>题目大意：给一张图，先手先选定两个不同的点 $A,B$ ，然后开始游戏，每轮先手指定一个未固定的边删掉，后手指定一个没被固定的边固定，如果 $A,B$ 最后联通，则后手获胜，否则先手获胜，问后手是否必胜。</p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>这道题目非常经典，又叫：Shannon’s Switching Game。</p>
<p>又有个变体问题：没有指定 $A,B$ 了，后手的目的是最后要是个联通图。</p>
<p>这两个问题的后手必胜的充要条件是：图中有两个交集为 $0$ 的生成树。</p>
<p>对于变体问题的充分性是比较好证明的，采用归纳+缩边的方法就行，详情请看：<a href="https://zhuanlan.zhihu.com/p/33862629">https://zhuanlan.zhihu.com/p/33862629</a> 。</p>
<p>也可以用拟阵中的基进行证明，这里不再赘述。</p>
<p>但是必要性我不会证明，所以这道题目在此留一个坑，就此作罢。</p>
<h6 id="坑"><a href="#坑" class="headerlink" title="坑"></a>坑</h6><p>学会 Shannon’s Switching Game 。</p>
<p>知道这个判定条件后后面就好搞了，怎么判定呢？</p>
<p>要有个生成树，且在这个生成树外还有一个生成树，前者是图拟阵，后者是图拟阵的对偶拟阵，所以就是图拟阵与图拟阵的对偶拟阵的拟阵交。</p>
<p>时间复杂度：$O(Tm^3)$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">没有，不会证明，懒得写代码了。</span><br></pre></td></tr></table></figure>
</div></details>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>拟阵</tag>
      </tags>
  </entry>
  <entry>
    <title>Graffiti</title>
    <url>/2024/02/05/Graffiti/</url>
    <content><![CDATA[<p>题目链接：<a href="https://contest.ucup.ac/contest/1511/problem/8213">https://contest.ucup.ac/contest/1511/problem/8213</a></p>
<p>题目大意：</p>
<p>给一个树，给一个长度不超过 $3$ 的串，然后问：每个点填一个字母，最大化满足经过的点构成的字符串等于给定串的有向路径数量，输出数量。</p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>显然只有长度为 $3$ 的串需要思考，当只有两个不同的字母的时候，会发现如果使用 $dp[x][0/1]$ 的 dp 方式，会无法处理从 $x$ 的儿子的儿子，到 $x$ 的路径，所以我们需要再多添加一维，表示父亲填的字母，相当于提前知道了父亲填的字母，然后父亲在转移的时候直接调用就行了。</p>
<p>但是会发现我们仍然无法处理三个字母都不同的情况，因为儿子有三种选择。</p>
<p>但是注意到第一个字母和第三个字母并没有本质区别，将一个子树的第一个字母和第三个字母全部颠倒不会影响这个子树的贡献，所以也就只需要知道儿子应该选一/三字母或者第二个字母就行，排个序枚举一下就行了。</p>
<p>时间复杂度：$O(n\log{n})$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="keyword">typedef</span> vector&lt;<span class="type">int</span>&gt; VI;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">3e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> NN=<span class="number">6e5</span>+<span class="number">5</span>;</span><br><span class="line">LL dp[N][<span class="number">4</span>][<span class="number">4</span>];</span><br><span class="line"><span class="type">int</span> ss[<span class="number">4</span>],n,m,C;<span class="type">char</span> st[<span class="number">10</span>];</span><br><span class="line"><span class="type">int</span> vis[<span class="number">300</span>];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> y,next;</span><br><span class="line">&#125;a[NN];<span class="type">int</span> len,las[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ins</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;a[++len]=&#123;y,las[x]&#125;;las[x]=len;&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">pd</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(m==<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> (x==ss[<span class="number">1</span>] &amp;&amp; y==ss[<span class="number">2</span>]) || (x==ss[<span class="number">2</span>] &amp;&amp; y==ss[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">pd</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> z)</span></span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(m==<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">return</span> (x==ss[<span class="number">1</span>] &amp;&amp; y==ss[<span class="number">2</span>] &amp;&amp; z==ss[<span class="number">3</span>]) || (x==ss[<span class="number">3</span>] &amp;&amp; y==ss[<span class="number">2</span>] &amp;&amp; z==ss[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">count</span><span class="params">(LL c1,LL c2,<span class="type">int</span> fc)</span></span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(C&gt;<span class="number">1</span>);</span><br><span class="line">    LL tmp=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(C==<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">pd</span>(<span class="number">1</span>,ss[<span class="number">2</span>],<span class="number">1</span>)==<span class="number">1</span>)tmp+=c1*(c1<span class="number">-1</span>)/<span class="number">2</span>;</span><br><span class="line">        <span class="comment">// if(pd(2,ss[2],2)==1)tmp+=c2*(c2-1)/2; impossible</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">pd</span>(<span class="number">1</span>,ss[<span class="number">2</span>],<span class="number">2</span>)==<span class="number">1</span>)tmp+=c1*c2;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">pd</span>(<span class="number">1</span>,ss[<span class="number">2</span>],fc)==<span class="number">1</span>)tmp+=c1;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">pd</span>(<span class="number">2</span>,ss[<span class="number">2</span>],fc))tmp+=c2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(fc==<span class="number">1</span> || fc==<span class="number">3</span>)&#123;</span><br><span class="line">            LL c3=(c1+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">            tmp+=c3*(c1-c3)+c3;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            LL c3=c1/<span class="number">2</span>;</span><br><span class="line">            tmp+=c3*(c1-c3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line">LL sta[N];<span class="type">int</span> top;</span><br><span class="line">VI son[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> fa)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=las[x];k;k=a[k].next)&#123;</span><br><span class="line">        <span class="type">int</span> y=a[k].y;<span class="keyword">if</span>(y==fa)<span class="keyword">continue</span>;</span><br><span class="line">        son[x].<span class="built_in">push_back</span>(y);</span><br><span class="line">        <span class="built_in">dfs</span>(y,x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(m==<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=C;i++)&#123;</span><br><span class="line">            LL now=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> y:son[x])&#123;</span><br><span class="line">                LL tmp=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=C;j++)&#123;</span><br><span class="line">                    tmp=<span class="built_in">max</span>(dp[y][i][j],tmp);</span><br><span class="line">                &#125;</span><br><span class="line">                now+=tmp;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> fc=<span class="number">1</span>;fc&lt;=C;fc++)&#123;<span class="comment">//father color</span></span><br><span class="line">                <span class="keyword">if</span>(x!=<span class="number">1</span> &amp;&amp; <span class="built_in">pd</span>(i,fc))dp[x][fc][i]=now+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> dp[x][fc][i]=now;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;<span class="comment">//m=3</span></span><br><span class="line">        <span class="built_in">assert</span>(m==<span class="number">3</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=C;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i!=ss[<span class="number">2</span>])&#123;<span class="comment">//only up</span></span><br><span class="line">                LL now=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">auto</span> y:son[x])&#123;</span><br><span class="line">                    LL tmp=<span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=C;j++)&#123;</span><br><span class="line">                        tmp=<span class="built_in">max</span>(tmp,dp[y][i][j]);</span><br><span class="line">                    &#125;</span><br><span class="line">                    now+=tmp;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> fc=<span class="number">1</span>;fc&lt;=C;fc++)&#123;<span class="comment">//father color</span></span><br><span class="line">                    dp[x][fc][i]=now;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(C==<span class="number">1</span>)&#123;</span><br><span class="line">                LL siz=son[x].<span class="built_in">size</span>();</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">auto</span> y:son[x]) dp[x][<span class="number">1</span>][<span class="number">1</span>]+=dp[y][<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">                dp[x][<span class="number">1</span>][<span class="number">1</span>]+=siz*(siz<span class="number">-1</span>)/<span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span>(x!=<span class="number">1</span>)dp[x][<span class="number">1</span>][<span class="number">1</span>]+=siz;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                top=<span class="number">0</span>;</span><br><span class="line">                LL ini=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">auto</span> y:son[x])&#123;</span><br><span class="line">                    sta[++top]=dp[y][i][<span class="number">2</span>]-dp[y][i][<span class="number">1</span>];</span><br><span class="line">                    <span class="built_in">assert</span>(C!=<span class="number">3</span> || dp[y][i][<span class="number">1</span>]==dp[y][i][<span class="number">3</span>]);</span><br><span class="line">                    ini+=dp[y][i][<span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">sort</span>(sta+<span class="number">1</span>,sta+top+<span class="number">1</span>,[](LL x,LL y)&#123;<span class="keyword">return</span> x&gt;y;&#125;);</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> fc=<span class="number">1</span>;fc&lt;=C;fc++)&#123;</span><br><span class="line">                    LL now=<span class="number">0</span>,tmp=ini;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=top;j++)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(x!=<span class="number">1</span>)now=<span class="built_in">max</span>( now , tmp+<span class="built_in">count</span>(top-j,j,fc) );</span><br><span class="line">                        <span class="keyword">else</span> now=<span class="built_in">max</span>( now , tmp+<span class="built_in">count</span>(top-j,j,<span class="number">0</span>) );</span><br><span class="line">                        <span class="keyword">if</span>(j!=top) tmp+=sta[j+<span class="number">1</span>];</span><br><span class="line">                    &#125;</span><br><span class="line">                    dp[x][fc][i]=now;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">work</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,st+<span class="number">1</span>);m=<span class="built_in">strlen</span>(st+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="type">int</span> x,y;<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;x,&amp;y);</span><br><span class="line">        <span class="built_in">ins</span>(x,y);<span class="built_in">ins</span>(y,x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!vis[st[i]])vis[st[i]]=++C;</span><br><span class="line">        ss[i]=vis[st[i]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(m==<span class="number">1</span>)<span class="keyword">return</span> n;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    LL ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=C;i++)ans=<span class="built_in">max</span>(ans,dp[<span class="number">1</span>][<span class="number">1</span>][i]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ss[<span class="number">1</span>]==ss[m])ans*=<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,<span class="built_in">work</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>题外话：<br>其实这个 dp 设计非常有意思。</p>
<ol>
<li><p>从树的角度考虑，我们其实有另外一种设计思路是，多添加几维表示这个节点的每个颜色的儿子选了多少个，但是可以发现这种设计是显然会超时的。</p>
<p>这是因为一个节点的儿子数量可以很多，而父亲至多一个，因此，我们更希望通过父亲解决问题，而不是通过儿子。</p>
<p>一个类似的例子是：一个数据结构题目，每次能够给一个点周围的所有点的点权加上 $c$ ，做法为：父亲的点权直接加上，儿子的点权加在自己身上，等查询一个点点权的时候让他自己来问父亲。</p>
<p>当然，上面那个例子还有个单 log 做法，就是利用 BFS 序+线段树，因为 BFS 序上儿子的编号是连续的。</p>
</li>
<li><p>从预知未来的角度考虑：</p>
<p>每个点先预知未来的一些信息，在这道题目上的作用是，让我们能够处理了一些本来无法处理的信息。</p>
<p>当然也可以有其他作用，举个减少时间复杂度的例子（某一年提高组初赛的题目，忘记是哪一年了）：</p>
<h6 id="坑"><a href="#坑" class="headerlink" title="坑"></a>坑</h6><p>这道题目到底是哪一年的。</p>
<p>求长度恰好为 $k$ 且相邻数字的异或的和最大的子序列，输出最大的和，值域 $2^{8}-1$。</p>
<p>做法为 $dp[i][x][y]$ ，$i$ 是已经有几个数字，$x$ 表示子序列目前最后一个数字的上 $4$ 位，$y$ 表示我们期望下一个数字的下 $4$ 位是多少。</p>
<p>这样就能在 $O(n^2*2^4)$ 的复杂度处理这个问题，相较于 $dp[i][x]$ 少了 $2^4$ 。</p>
</li>
</ol>
</div></details>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>树形DP</tag>
      </tags>
  </entry>
  <entry>
    <title>MEXimum Spanning Tree</title>
    <url>/2024/01/30/MEXimum-Spanning-Tree/</url>
    <content><![CDATA[<p>题目链接：<a href="https://qoj.ac/contest/1221/problem/6402">https://qoj.ac/contest/1221/problem/6402</a></p>
<p>题目大意：求 $mex$ 最大的生成树。</p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>一个显然的事情，这道题目是拟阵交，第一个拟阵无环，第二个拟阵要求每条数字的边至多一条。</p>
<p>这个时候可以二分+拟阵交，也可以从小到达考虑 $\le c$ 的边的拟阵交，因为拟阵交的算法保证了，只要给一个交集中的元素（一般默认空集），就一定可以增广出最大的元素。</p>
<p>接下来默认用从小到大考虑的方法，因为少个 $log$ 。</p>
<p>以下时间复杂度默认点数与边数同阶。</p>
<p>暴力建图的话是 $O(n^3)$ ，虽然能过，但是能不能更加优秀？</p>
<p>这个时候有几个优化方向：</p>
<ol>
<li>bitset ，在翻代码的时候看到的，虽然没看具体怎么优化的，反正是有人这么干的。</li>
<li>等到遍历到在加入边，显然，我们没必要一开始就把图建出来，而是跑到一个点再把这个点的所有出边找到，发现由于是 BFS，所以每个点至多走一次，所以这个优化只快不慢，同时注意到图拟阵那边的出边是难的，可以采用并查集优化的方式，在 $O(n^2\alpha(n))$ 的时间解决这个特殊的拟阵交问题。</li>
<li>题解说可以 $O(n^2\sqrt{n})$ ，没懂具体咋搞的，但肯定不是一开始就把图建出来。后面经过询问，似乎是说最短路的总长度有个 bound ，又说和 Hopcroft Karp 的分析类似，但 Hopcroft Karp 我没有学过，这个方法先咕了，等以后再说吧。</li>
</ol>
<p>但我写的是最暴力的三方做法，还要乘并查集的 $\alpha(n)$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e3</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M=<span class="number">2e6</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span>&#123;</span><br><span class="line">    <span class="type">int</span> x,y,c;</span><br><span class="line">&#125;e[N];<span class="type">int</span> pf[N];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(Edge x,Edge y)</span></span>&#123;<span class="keyword">return</span> x.c&lt;y.c;&#125;</span><br><span class="line"><span class="type">bool</span> in[N],col[N];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> fa[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">findfa</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="keyword">return</span> fa[x]==x?x:fa[x]=<span class="built_in">findfa</span>(fa[x]);&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mer</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    x=<span class="built_in">findfa</span>(x);y=<span class="built_in">findfa</span>(y);</span><br><span class="line">    <span class="keyword">if</span>(x!=y)fa[x]=y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">pd</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;<span class="keyword">return</span> <span class="built_in">findfa</span>(x)==<span class="built_in">findfa</span>(y);&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">uinit</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)fa[i]=i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> y,next;</span><br><span class="line">&#125;a[M];<span class="type">int</span> len,las[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ins</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;a[++len]=&#123;y,las[x]&#125;;las[x]=len;&#125;</span><br><span class="line"><span class="type">int</span> typ[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> lim)</span></span>&#123;</span><br><span class="line">    len=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(las+<span class="number">1</span>,<span class="number">0</span>,<span class="built_in">sizeof</span>(<span class="type">int</span>)*lim);</span><br><span class="line">    <span class="built_in">memset</span>(typ+<span class="number">1</span>,<span class="number">0</span>,<span class="built_in">sizeof</span>(<span class="type">int</span>)*lim);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=lim;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!in[i])<span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">uinit</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=lim;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i!=j &amp;&amp; in[j])<span class="built_in">mer</span>(e[j].x,e[j].y);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=lim;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(in[j])<span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(!<span class="built_in">pd</span>(e[j].x,e[j].y))<span class="built_in">ins</span>(i,j);</span><br><span class="line">            <span class="keyword">if</span>(e[i].c==e[j].c || !col[e[j].c])<span class="built_in">ins</span>(j,i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">uinit</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=lim;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(in[i])<span class="built_in">mer</span>(e[i].x,e[i].y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=lim;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(in[i])<span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">pd</span>(e[i].x,e[i].y))typ[i]|=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(!col[e[i].c])typ[i]|=<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"><span class="type">int</span> pre[N];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> lim)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=lim;i++)pre[i]=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=lim;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(typ[i]&amp;<span class="number">1</span>)&#123;</span><br><span class="line">            pre[i]=<span class="number">0</span>;</span><br><span class="line">            q.<span class="built_in">push</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="type">int</span> x=q.<span class="built_in">front</span>();q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(typ[x]&amp;<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">while</span>(x)&#123;</span><br><span class="line">                col[e[x].c]^=<span class="number">1</span>;</span><br><span class="line">                in[x]^=<span class="number">1</span>;</span><br><span class="line">                x=pre[x];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k=las[x];k;k=a[k].next)&#123;</span><br><span class="line">            <span class="type">int</span> y=a[k].y;</span><br><span class="line">            <span class="keyword">if</span>(pre[y]==<span class="number">-1</span>)&#123;</span><br><span class="line">                pre[y]=x;</span><br><span class="line">                q.<span class="built_in">push</span>(y);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;e[i].x,&amp;e[i].y,&amp;e[i].c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(e+<span class="number">1</span>,e+m+<span class="number">1</span>,[](Edge x,Edge y)&#123;</span><br><span class="line">        <span class="keyword">return</span> x.c&lt;y.c;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)pf[e[i].c]=i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)pf[i]=<span class="built_in">max</span>(pf[i],pf[i<span class="number">-1</span>]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">build</span>(pf[i]);</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">solve</span>(pf[i]))&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,i);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="坑"><a href="#坑" class="headerlink" title="坑"></a>坑</h6><p>根号做法是啥。</p>
</div></details>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>拟阵</tag>
      </tags>
  </entry>
  <entry>
    <title>Milk Candy</title>
    <url>/2024/01/31/Milk-Candy/</url>
    <content><![CDATA[<p>题目链接：<a href="https://qoj.ac/contest/1386/problem/7580">https://qoj.ac/contest/1386/problem/7580</a></p>
<p>题目大意：</p>
<p>有 $n$ 个未知数字，有 $m$ 个商人，每个商人有 $c_i$ 个的线索，每个线索有个价格，同时线索内容为 $[l,r]$ 的数字的和，你可以向每个商人买线索，但是每个商人必须恰好买 $k_i$ 个线索，问最少需要多少钱才能知道所有未知数字。</p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>虽然赛时队长神力秒了，但是我来编一个比较自然的思考路线：前缀和。</p>
<p>设 $s$ 为前缀和数组，所以实际上就是要知道所有 $s_i-s_0$ 。</p>
<p>考虑每个线索实际上提供了 $s_r-s_{l-1}$ ，又 $(s_a-s_b)+(s_b-s_c)=(s_a-s_c)$ ，所以实际上就是 $r$ 与 $l-1$ 连边，最后问所有点是不是与 $0$ 联通，也就是 $n+1$ 个点的生成树。</p>
<p>问题等价于 $n+1$ 个点，然后有一些边，问符合要求的最小权连通图。</p>
<ol>
<li>第一个拟阵 ，图拟阵的对偶拟阵。</li>
<li>第二个拟阵 ，每个商人去掉的线索数量不超过 $c_i-k_i$ 。</li>
</ol>
<p>带权拟阵交。</p>
<p>时间复杂度：$O((n\sum c_i)^2)$ 。</p>
<p>记得特判图一开始是不是联通的，因为如果一开始就不联通，那么 $\emptyset\notin \mathcal{I}$ ，这与拟阵交一开始默认 $\emptyset \in \mathcal{I}$ 冲突。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf=<span class="number">1e9</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e2</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M=<span class="number">2e4</span>+<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m,K,ans,ned;</span><br><span class="line"><span class="type">int</span> bel[N],cnt[N],lim[N];</span><br><span class="line">PII e[N];<span class="type">int</span> pri[N];</span><br><span class="line"><span class="type">bool</span> in[N];</span><br><span class="line"><span class="keyword">namespace</span> Union&#123;</span><br><span class="line">    <span class="type">int</span> fa[N];</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findfa</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="keyword">return</span> fa[x]==x?x:fa[x]=<span class="built_in">findfa</span>(fa[x]);&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mer</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">        x=<span class="built_in">findfa</span>(x);y=<span class="built_in">findfa</span>(y);</span><br><span class="line">        <span class="keyword">if</span>(x!=y)fa[x]=y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">pd</span><span class="params">(<span class="type">int</span> mov,<span class="type">int</span> add)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;i++)fa[i]=i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=K;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i==mov)<span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(i!=add &amp;&amp; in[i])<span class="keyword">continue</span>;</span><br><span class="line">            <span class="built_in">mer</span>(e[i].first,e[i].second);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">findfa</span>(i)!=<span class="built_in">findfa</span>(<span class="number">0</span>))<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> Union::pd;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> y,next;</span><br><span class="line">&#125;a[M];<span class="type">int</span> len,las[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ins</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;a[++len]=&#123;y,las[x]&#125;;las[x]=len;&#125;</span><br><span class="line"><span class="type">int</span> val[N],typ[N];PII d[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    len=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(las+<span class="number">1</span>,<span class="number">0</span>,<span class="built_in">sizeof</span>(<span class="type">int</span>)*K);</span><br><span class="line">    <span class="built_in">memset</span>(typ+<span class="number">1</span>,<span class="number">0</span>,<span class="built_in">sizeof</span>(<span class="type">int</span>)*K);</span><br><span class="line">&#125;</span><br><span class="line">queue&lt;<span class="type">int</span>&gt; q;<span class="type">bool</span> v[N];</span><br><span class="line"><span class="type">int</span> pre[N];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=K;i++)d[i]=&#123;-inf,-inf&#125;;</span><br><span class="line">    <span class="built_in">assert</span>(q.<span class="built_in">empty</span>());</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=K;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(typ[i]&amp;<span class="number">1</span>)&#123;</span><br><span class="line">            d[i]=&#123;val[i],<span class="number">0</span>&#125;;</span><br><span class="line">            v[i]=<span class="number">1</span>;</span><br><span class="line">            pre[i]=<span class="number">0</span>;</span><br><span class="line">            q.<span class="built_in">push</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="type">int</span> x=q.<span class="built_in">front</span>();q.<span class="built_in">pop</span>();</span><br><span class="line">        v[x]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k=las[x];k;k=a[k].next)&#123;</span><br><span class="line">            <span class="type">int</span> y=a[k].y;</span><br><span class="line">            <span class="keyword">if</span>(PII&#123;d[x].first+val[y],d[x].second<span class="number">-1</span>&#125;&gt;d[y])&#123;</span><br><span class="line">                d[y]=PII&#123;d[x].first+val[y],d[x].second<span class="number">-1</span>&#125;;</span><br><span class="line">                pre[y]=x;</span><br><span class="line">                <span class="keyword">if</span>(!v[y])&#123;</span><br><span class="line">                    v[y]=<span class="number">1</span>;</span><br><span class="line">                    q.<span class="built_in">push</span>(y);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    PII maxval=&#123;-inf,-inf&#125;;</span><br><span class="line">    <span class="type">int</span> endpoint=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=K;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>((typ[i]&amp;<span class="number">2</span>) &amp;&amp; d[i]&gt;maxval)&#123;</span><br><span class="line">            maxval=d[i];</span><br><span class="line">            endpoint=i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!endpoint)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    ans-=maxval.first;ned--;</span><br><span class="line">    <span class="type">int</span> now=endpoint;</span><br><span class="line">    <span class="keyword">while</span>(now)&#123;</span><br><span class="line">        <span class="keyword">if</span>(in[now])cnt[bel[now]]--;</span><br><span class="line">        <span class="keyword">else</span> cnt[bel[now]]++;</span><br><span class="line">        in[now]^=<span class="number">1</span>;</span><br><span class="line">        now=pre[now];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=K;i++)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!in[i])val[i]=pri[i];</span><br><span class="line">        <span class="keyword">else</span> val[i]=-pri[i];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(in[i])&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=K;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(in[j])<span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">pd</span>(j,i))<span class="built_in">ins</span>(i,j);</span><br><span class="line">                <span class="keyword">if</span>(cnt[bel[j]]&lt;lim[bel[j]] || bel[i]==bel[j])<span class="built_in">ins</span>(j,i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">pd</span>(i,<span class="number">-1</span>))typ[i]|=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(cnt[bel[i]]&lt;lim[bel[i]])typ[i]|=<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> T;<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        ans=ned=K=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(cnt,<span class="number">0</span>,<span class="built_in">sizeof</span>(cnt));</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">            <span class="type">int</span> x;<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;x,&amp;lim[i]);</span><br><span class="line">            lim[i]=x-lim[i];</span><br><span class="line">            ned+=lim[i];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=x;j++)&#123;</span><br><span class="line">                ++K;bel[K]=i;in[K]=<span class="number">0</span>;</span><br><span class="line">                <span class="type">int</span> l,r;<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;l,&amp;r,&amp;pri[K]);</span><br><span class="line">                l--;</span><br><span class="line">                e[K]=&#123;l,r&#125;;</span><br><span class="line">                ans+=pri[K];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">pd</span>(<span class="number">-1</span>,<span class="number">-1</span>))&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;-1\n&quot;</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            <span class="built_in">build</span>();</span><br><span class="line">        &#125;<span class="keyword">while</span>(<span class="built_in">solve</span>());</span><br><span class="line">        <span class="keyword">if</span>(ned)ans=<span class="number">-1</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></details>]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>拟阵</tag>
      </tags>
  </entry>
  <entry>
    <title>Pick Your Own Nim</title>
    <url>/2024/01/31/Pick-Your-Own-Nim/</url>
    <content><![CDATA[<p>题目链接：<a href="https://codeforces.com/gym/102156/problem/D">https://codeforces.com/gym/102156/problem/D</a></p>
<p>题目大意：</p>
<p>给你 $n$ 个数字，再给你 $m$ 组数字，你要在每一组里面选一个数字，使得选出来的数字和那 $n$ 个数字，关于异或运算线性无关，如果可以，给一组方案。</p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>有限大小的线性空间本身就是拟阵，这样就很显然了。</p>
<ol>
<li>拟阵 $1$ 是线性无关。（算上那 $n$ 个数字）</li>
<li>拟阵 $2$ 是每组数字至多一个。</li>
</ol>
<p>时间复杂度：$O(60^2\sum\limits k_i)$ 。</p>
<p>记得特判一开始的 $n$ 个数字是否线性无关，否则还是老生常谈的问题：$\emptyset\notin \mathcal{I}$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N1=<span class="number">65</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N2=<span class="number">5e3</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M=<span class="number">6e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n,m,K;</span><br><span class="line">LL va[N2];<span class="type">int</span> bel[N2];</span><br><span class="line"><span class="type">bool</span> col[N1],in[N2];</span><br><span class="line"></span><br><span class="line">LL sta[N1];</span><br><span class="line"><span class="type">int</span> pos[N1],top;</span><br><span class="line">LL lin[N1],fac[N1];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">add</span><span class="params">(LL x,<span class="type">int</span> id)</span></span>&#123;</span><br><span class="line">    LL now=(<span class="number">1ll</span>&lt;&lt;(id<span class="number">-1</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">59</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">if</span>((x&gt;&gt;i)&amp;<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!lin[i])&#123;</span><br><span class="line">                lin[i]=x;</span><br><span class="line">                fac[i]=now;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> x^=lin[i],now^=fac[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">build_liner</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(lin,<span class="number">0</span>,<span class="built_in">sizeof</span>(lin));</span><br><span class="line">    <span class="built_in">memset</span>(fac,<span class="number">0</span>,<span class="built_in">sizeof</span>(fac));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=top;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">add</span>(sta[i],i))<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">findfac</span><span class="params">(LL x)</span></span>&#123;</span><br><span class="line">    LL now=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">59</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">if</span>((x&gt;&gt;i)&amp;<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!lin[i])<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">else</span> x^=lin[i],now^=fac[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> now;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> y,next;</span><br><span class="line">&#125;a[M];<span class="type">int</span> len,las[N2];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ins</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;a[++len]=&#123;y,las[x]&#125;;las[x]=len;&#125;</span><br><span class="line"><span class="type">int</span> typ[N2];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getliner</span><span class="params">()</span></span>&#123;</span><br><span class="line">    top=n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=K;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(in[i])sta[++top]=va[i],pos[top]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">assert</span>(<span class="built_in">build_liner</span>());</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">()</span></span>&#123;</span><br><span class="line">    len=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(las+<span class="number">1</span>,<span class="number">0</span>,<span class="built_in">sizeof</span>(<span class="type">int</span>)*K);</span><br><span class="line">    <span class="built_in">memset</span>(typ+<span class="number">1</span>,<span class="number">0</span>,<span class="built_in">sizeof</span>(<span class="type">int</span>)*K);</span><br><span class="line">    <span class="built_in">getliner</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> now=n+<span class="number">1</span>,i=pos[now];now&lt;=top;now++,i=pos[now])&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=K;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(in[j])<span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(bel[i]==bel[j] || !col[bel[j]])<span class="built_in">ins</span>(j,i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=K;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(in[i])<span class="keyword">continue</span>;</span><br><span class="line">        LL x=<span class="built_in">findfac</span>(va[i]);</span><br><span class="line">        <span class="keyword">if</span>(x==<span class="number">-1</span>)&#123;</span><br><span class="line">            typ[i]|=<span class="number">1</span>;</span><br><span class="line">            x=(<span class="number">1ll</span>&lt;&lt;top)<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> now=n+<span class="number">1</span>;now&lt;=top;now++)&#123;</span><br><span class="line">            <span class="keyword">if</span>((x&gt;&gt;(now<span class="number">-1</span>))&amp;<span class="number">1</span>)<span class="built_in">ins</span>(pos[now],i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!col[bel[i]])typ[i]|=<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"><span class="type">int</span> pre[N2];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=K;i++)pre[i]=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=K;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(typ[i]&amp;<span class="number">1</span>)&#123;</span><br><span class="line">            pre[i]=<span class="number">0</span>;</span><br><span class="line">            q.<span class="built_in">push</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="type">int</span> x=q.<span class="built_in">front</span>();q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(typ[x]&amp;<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">while</span>(x)&#123;</span><br><span class="line">                col[bel[x]]^=<span class="number">1</span>;</span><br><span class="line">                in[x]^=<span class="number">1</span>;</span><br><span class="line">                x=pre[x];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k=las[x];k;k=a[k].next)&#123;</span><br><span class="line">            <span class="type">int</span> y=a[k].y;</span><br><span class="line">            <span class="keyword">if</span>(pre[y]==<span class="number">-1</span>)&#123;</span><br><span class="line">                pre[y]=x;</span><br><span class="line">                q.<span class="built_in">push</span>(y);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);top=n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;sta[i]);</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">build_liner</span>())&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;-1\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="type">int</span> cnt;<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;cnt);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=cnt;j++)&#123;</span><br><span class="line">            ++K;bel[K]=i;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;va[K]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="built_in">build</span>();</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">solve</span>())&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;-1\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=K;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(in[i])<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,va[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></details>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
  </entry>
  <entry>
    <title>Prüfer序列学习笔记</title>
    <url>/2024/02/02/Prufer%E5%BA%8F%E5%88%97%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p> Prüfer 序列是真好用啊。</p>
<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>对于一棵 $n(n\ge 2)$ 个点的树，每次我们选择一个编号最小的叶子节点删掉，然后将其相邻节点的编号加入到序列中，直到剩下两个点为止，这样构成的序列，就叫这棵树的 Prüfer 序列。</p>
<h1 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h1><p>Prüfer 序列构建了一个有标号无根树到序列的双射，后面会讲如何通过另方求另一方。</p>
<p>而且任意一个值域为 $n$ 长度为 $n-2$ 的序列都对应了一棵生成树，这让 Prüfer 序列在解决无根树相关的计数问题非常好用。</p>
<p>从度数的角度看 Prüfer 序列，可以发现，Prüfer 序列中的点实际上表现的是度数 $-1$ 的过程。</p>
<p>例如 ：Prüfer 序列是 $1,2,3$ ，那么表示在删除第一个叶子时，$1$ 号点度数减 $1$ ，接下来同理。</p>
<p>最后，所有度数为 $1$ 的点被删除，只剩下了 $n$ 和另外一个度数为 $1$ 的点。</p>
<p>综上，我们可以得到下面这个结论。</p>
<p><strong>结论 1</strong> ：每个点在 Prüfer 序列中的出现次数为度数$-1$ 。</p>
<h1 id="转化"><a href="#转化" class="headerlink" title="转化"></a>转化</h1><h2 id="无根树转-Prufer-序列"><a href="#无根树转-Prufer-序列" class="headerlink" title="无根树转 Prüfer 序列"></a>无根树转 Prüfer 序列</h2><p>从小到大搜索每一个点，直到 Prüfer 序列中已经有 $n-2$ 个数字，设搜索到 $p$ 号点：</p>
<ol>
<li>假如 $p$ 号点不是叶子，继续搜。</li>
<li>假如 $p$ 号点是叶子，删除，如果新增了一个叶子节点且编号小于 $p$ ，显然这个叶子节点编号最小，接着删，直到删了 $n-2$ 个点或者编号 $&gt;p$ 。</li>
</ol>
<p>时间复杂度：$O(n)$ 。</p>
<h2 id="Prufer-序列转无根树"><a href="#Prufer-序列转无根树" class="headerlink" title="Prüfer 序列转无根树"></a>Prüfer 序列转无根树</h2><p>首先，根据 Prüfer 序列可以算出每个点的度数，然后按照 Prüfer 序列，每次取出编号最小的叶子节点和 Prüfer 序列当前位置连边，然后给 Prüfer 序列当前位置度数 $-1$ ，不断重复，直到最后，就只会剩两个度数为 $1$ 的节点，连起来即可。</p>
<p>时间复杂度：$O(n\log{n})$ 。</p>
<h1 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h1><ol>
<li>$n$ 个点的有标号无根树有多少个：$n^{n-2}$ 个。</li>
<li>假设每个点的度数已知，设为 $d_i$ ，求满足这个度数限制的有标号无根树的数量：$\binom{n-2}{d_1-1,d_2-1,…,d_n-1}$ 。</li>
<li><p>Cayley 公式：给定 $m(m\ge 2)$ 个连通块，每个连通块的大小是 $s_i$ ，且 $\sum\limits_{i=1}^m=n$ ，那么用 $m-1$ 条边把这 $m$ 个联通块联通起来的方案数为 $(\prod\limits_{i=1}^m s_i)n^{m-2}$ 。</p>
<details class="toggle" ><summary class="toggle-button" style="">证明</summary><div class="toggle-content"><p>证明 1 ：考虑 $m$ 个点的树的 $Prüfer$ 序列，不妨设为 $p$ 序列，由于 $Prüfer$ 序列实际上代表了一种连边方式，所以我们只需要计算 $n-1$ 条边能够有多少种连法就行了，那么对于这个 $Prüfer$ 序列能够代表的方案数，通过计算为：$(\prod_{i=1}^m s_i)<em>(\prod_{i=1}^{m-2} s_{p_i})$ 。又 Prüfer 序列 $m-2$ 个位置都可以填 $1-m$ ，所以显然，总方案数为 $(\prod\limits_{i=1}^m s_i)</em>n^{m-2}$ 。</p>
<p>证明 2 ：代数证明（来自oiwiki）</p>
<p>考虑每个连通块的度数为 $d_i$ ，显然，只要 $d_i&gt;0,\sum\limits_{i=1}^md_i=2m-2$ ，就能算是一个合法的度数序列。</p>
<p>所以这样子的方案数为：$\binom{m-2}{d_1-1,d_2-1,…,d_m-1}\prod{s_i^{d_i}}$ 。</p>
<p>由多元二项式定理：$(x_1+x_2+…+x_p)^k=\sum\limits_{a_1,a_2,…,a_p\ge 0,a_1+a_2+…+a_p=k}\binom{k}{a_1,a_2,…,a_p}\prod\limits_{i=1}^px_i^{a_i}$ 。</p>
<p>那么 $\sum\limits_{d_i&gt;0,d_1+…+d_m=2m-2}\binom{m-2}{d_1-1,d_2-1,…,d_m-1}\prod\limits_{i=1}^m{s_i^{d_i}}$ ，令 $e_i=d_i-1$ 可以得到：$\sum\limits_{e_i\ge 0,e_1+…+e_m=m-2}\binom{m-2}{e_1,e_2,…,e_m}\prod\limits_{i=1}^m{s_i^{e_i+1}}=n^{m-2}\prod\limits_{i=1}^ms_i$</p>
<p>证毕。</p>
</div></details></li>
</ol>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>计数</tag>
        <tag>Prüfer序列</tag>
      </tags>
  </entry>
  <entry>
    <title>Strange Keyboard</title>
    <url>/2024/02/11/Strange-Keyboard/</url>
    <content><![CDATA[<p>题目链接：Strange Keyboard</p>
<p>题目大意：$Q$ 组数据，给 $n$ 个串 $S_i$ 和一个 $K$ ，还有一个空串和目标串 $T$ ，你可以对空串依次做下面两个操作的其中一个，问最少几步变成目标串。</p>
<ol>
<li>如果串长 $\ge K$ ，就删除最后 $K$ 个字符。</li>
<li>在串尾加入 $n$ 个串的其中一个。</li>
</ol>
<p>数据范围：$Q\le 100$ ，所有数据的 $\sum |S_i|\le 10^6$ ，所有数据的 $\sum |K|\le 5000$ ，$K\le 5000$ 。</p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>循序渐进的考虑这道题目怎么做：</p>
<p>考虑一种特殊情况：$T=aaa…$ ，然后只有一个串是 $abc…$ 的结构（首字母为 $a$ ，后面全都不是 $a$ ），然后其余一堆没有 $a$ 的垃圾串，那么这显然引导我们先要解决一个同余最短路的问题，即需要至少多少次数能够消掉一个长度为 $len$ 的后缀？</p>
<p>注意到，在这个问题中，我们并不关心字符串的内容是什么，我们只关心长度，不同的长度只有至多 $O(\sqrt{\sum |S_i|})$ 种。</p>
<p>设 $f_i$ 表示需要最少多少次才能让字符串恰好有 $i$ 个字符，$f_0=0$ ，这个时候发现，跑同余最短路会超时，多个 log ，怎么办呢？</p>
<p>如果你足够聪慧，就会发现，导致出现权值从而让我们不得不跑最短路的原因是我们直接做了取余操作，事实上，我们根本没必要一次性把取余操作做完，详细的说就是：</p>
<script type="math/tex; mode=display">
\begin{align*}
    f_{i-K}&=\min(f_{i-K},f_{i}+1),i\ge K\\
    f_{i+a_j}&=\min(f_{i+a_j},f_{i}+1),i<K\\
\end{align*}</script><p>这样，权值就都是 $1$ 了，直接跑 $BFS$ 即可。</p>
<p>当然，我不够聪慧，我的解决方法是直接开值域个队列，不难证明 $f$ 的最大值不超过 $\max(S_i)+K$ 。</p>
<p>上述两种方法的时空复杂度都一样，单组数据下：</p>
<p>时间复杂度：$O(max(S_i)+K\sqrt{\sum |S_i|})$</p>
<p>空间复杂度：$O(\sum |S_i|+K)$</p>
<p>后面就简单了，考虑一个事情，假如我们现在已经填了 $T$ 的一个前缀，然后现在我们要填一个字符串，并且要删掉字符串的一个后缀，那么代价可以很方便的用 $f$ 计算。</p>
<p>设 $dp[i]$ 表示填下 $T$ 的长度为 $i$ 的前缀的最小操作次数。</p>
<p>那么 $dp[i]\to dp[j]$ 的转移就是所有前缀能对上 $T[i+1\to j]$ 的 $S$ 串的转移代价的最小值，这里有个匹配前缀的要求，显然用 Trie 就行了。</p>
<p>因此这道题目就做完了：先同余最短路算 $f$ ，然后建 $Trie$ ，最后 $dp$ 转移即可。</p>
<p>单组数据下：</p>
<p>时间复杂度：$O(26\sum S_i+K\sqrt{\sum |S_i|}+T^2)$</p>
<p>空间复杂度：$O(26\sum S_i+K+T)$</p>
<p>虽然有 $100$ 组数据，但是算一下发现这个复杂度已经足以通过此题。（注意 $S$ 是所有数据的长度总和不超过 $10^6$ ，不是单组数据的）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> LL inf=<span class="number">1e15</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e6</span>+<span class="number">5e3</span>+<span class="number">105</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M=<span class="number">5e3</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n,K;</span><br><span class="line">string ss[N];<span class="type">char</span> st[N];</span><br><span class="line"><span class="type">bool</span> v[N];<span class="type">int</span> stk[N],top;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!v[x])stk[++top]=x;</span><br><span class="line">    v[x]=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> h[N];</span><br><span class="line"><span class="function">LL <span class="title">calc</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> y=x%K;</span><br><span class="line">    <span class="keyword">if</span>(!y)<span class="keyword">return</span> x/K;</span><br><span class="line">    <span class="keyword">if</span>(!h[K-y])<span class="keyword">return</span> inf;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> h[K-y]+x/K;</span><br><span class="line">&#125;</span><br><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;</span><br><span class="line">    h[<span class="number">0</span>]=<span class="number">1</span>;q.<span class="built_in">push</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="type">int</span> x=q.<span class="built_in">front</span>();q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(x&gt;=K)&#123;</span><br><span class="line">            <span class="type">int</span> y=x-K;</span><br><span class="line">            <span class="keyword">if</span>(!h[y])&#123;</span><br><span class="line">                h[y]=h[x]+<span class="number">1</span>;</span><br><span class="line">                q.<span class="built_in">push</span>(y);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=top;i++)&#123;</span><br><span class="line">                <span class="type">int</span> y=x+stk[i];</span><br><span class="line">                <span class="keyword">if</span>(!h[y])&#123;</span><br><span class="line">                    h[y]=h[x]+<span class="number">1</span>;</span><br><span class="line">                    q.<span class="built_in">push</span>(y);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Trie</span>&#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">26</span>];LL val;</span><br><span class="line">    <span class="type">int</span>&amp; <span class="keyword">operator</span>[](<span class="type">int</span> x)&#123;<span class="keyword">return</span> a[x];&#125;</span><br><span class="line">&#125;tr[N];<span class="type">int</span> tcnt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">cl</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(tr[x].a,<span class="number">0</span>,<span class="built_in">sizeof</span>(tr[x].a));</span><br><span class="line">    tr[x].val=inf;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> mxlen=<span class="number">0</span>;</span><br><span class="line">    top=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        v[ss[i].<span class="built_in">length</span>()]=<span class="number">0</span>;</span><br><span class="line">        mxlen=<span class="built_in">max</span>(mxlen,(<span class="type">int</span>)ss[i].<span class="built_in">length</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    mxlen+=K;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(h,<span class="number">0</span>,<span class="built_in">sizeof</span>(<span class="type">int</span>)*mxlen);</span><br><span class="line"></span><br><span class="line">    tcnt=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">cl</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(string &amp;s)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> len=s.<span class="built_in">length</span>();</span><br><span class="line">    <span class="type">int</span> now=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=len;i++)&#123;</span><br><span class="line">        <span class="type">int</span> x=s[i<span class="number">-1</span>]-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span>(!tr[now][x])&#123;</span><br><span class="line">            tr[now][x]=++tcnt;</span><br><span class="line">            <span class="built_in">cl</span>(tcnt);</span><br><span class="line">        &#125;</span><br><span class="line">        now=tr[now][x];</span><br><span class="line">        tr[now].val=<span class="built_in">min</span>(tr[now].val,<span class="built_in">calc</span>(len-i));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LL dp[M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> T;<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;K);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,st+<span class="number">1</span>);</span><br><span class="line">            ss[i]=st+<span class="number">1</span>;</span><br><span class="line">            <span class="built_in">add</span>(ss[i].<span class="built_in">length</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">bfs</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="built_in">add</span>(ss[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,st+<span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> m=<span class="built_in">strlen</span>(st+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)dp[i]=inf;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">            <span class="type">int</span> now=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">                now=tr[now][st[j]-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">                <span class="keyword">if</span>(!now)<span class="keyword">break</span>;</span><br><span class="line">                dp[j]=<span class="built_in">min</span>(dp[j],dp[i]+tr[now].val+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">assert</span>(dp[m]&lt;=inf);</span><br><span class="line">        <span class="keyword">if</span>(dp[m]==inf)dp[m]=<span class="number">-1</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,dp[m]);</span><br><span class="line">        <span class="built_in">init</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></details>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>Trie</tag>
        <tag>字符串</tag>
        <tag>同余最短路</tag>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title>Rainbow Graph</title>
    <url>/2024/01/31/Rainbow-Graph/</url>
    <content><![CDATA[<p>题目链接：<a href="https://open.kattis.com/problems/rainbowgraph">https://open.kattis.com/problems/rainbowgraph</a></p>
<p>题目大意：</p>
<p>一张无向图，每条边有红绿蓝三种颜色，请选一个最小权值和的边集，使得：不看红色边图是联通的，不看蓝色边图也是联通的。</p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>两个对偶拟阵一交就做完了，需要注意的是，带权拟阵交每次增广出来的集合，都是与他同大小的权值和最大的集合，所以一遍带权拟阵交就能处理出所有的答案。</p>
<p>记得特判图一开始是不是联通的，因为如果一开始就不联通，那么 $\emptyset\notin \mathcal{I}$ ，这与拟阵交一开始默认 $\emptyset \in \mathcal{I}$ 冲突。</p>
<p>时间复杂度：$O(m^4)$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf=<span class="number">1e9</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e2</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M=<span class="number">2e4</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n,m,zans;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span>&#123;</span><br><span class="line">    <span class="type">int</span> x,y,c,typ;</span><br><span class="line">&#125;e[N];</span><br><span class="line"><span class="type">bool</span> in[N];</span><br><span class="line"><span class="keyword">namespace</span> Union&#123;</span><br><span class="line">    <span class="type">int</span> fa[N];</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findfa</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="keyword">return</span> fa[x]==x?x:fa[x]=<span class="built_in">findfa</span>(fa[x]);&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mer</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">        x=<span class="built_in">findfa</span>(x);y=<span class="built_in">findfa</span>(y);</span><br><span class="line">        <span class="keyword">if</span>(x!=y)fa[x]=y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">pd</span><span class="params">(<span class="type">int</span> ban,<span class="type">int</span> mov,<span class="type">int</span> add)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)fa[i]=i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(e[i].typ==ban || i==mov)<span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(i!=add &amp;&amp; in[i])<span class="keyword">continue</span>;</span><br><span class="line">            <span class="built_in">mer</span>(e[i].x,e[i].y);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">findfa</span>(i)!=<span class="built_in">findfa</span>(<span class="number">1</span>))<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> Union::pd;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> y,next;</span><br><span class="line">&#125;a[M];<span class="type">int</span> len,las[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ins</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;a[++len]=&#123;y,las[x]&#125;;las[x]=len;&#125;</span><br><span class="line"><span class="type">int</span> pri[N],typ[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">()</span></span>&#123;</span><br><span class="line">    len=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(las+<span class="number">1</span>,<span class="number">0</span>,<span class="built_in">sizeof</span>(<span class="type">int</span>)*m);</span><br><span class="line">    <span class="built_in">memset</span>(typ+<span class="number">1</span>,<span class="number">0</span>,<span class="built_in">sizeof</span>(<span class="type">int</span>)*m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(in[i])&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(in[j])<span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">pd</span>(<span class="number">0</span>,j,i))<span class="built_in">ins</span>(i,j);</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">pd</span>(<span class="number">2</span>,j,i))<span class="built_in">ins</span>(j,i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">pd</span>(<span class="number">0</span>,i,<span class="number">-1</span>))typ[i]|=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">pd</span>(<span class="number">2</span>,i,<span class="number">-1</span>))typ[i]|=<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!in[i])pri[i]=e[i].c;</span><br><span class="line">        <span class="keyword">else</span> pri[i]=-e[i].c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> pre[N];PII d[N];</span><br><span class="line"><span class="type">bool</span> v[N];</span><br><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(q.<span class="built_in">empty</span>());</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)d[i]=&#123;-inf,-inf&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(typ[i]&amp;<span class="number">1</span>)&#123;</span><br><span class="line">            q.<span class="built_in">push</span>(i);</span><br><span class="line">            v[i]=<span class="number">1</span>;</span><br><span class="line">            d[i]=&#123;pri[i],<span class="number">0</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="type">int</span> x=q.<span class="built_in">front</span>();q.<span class="built_in">pop</span>();</span><br><span class="line">        v[x]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k=las[x];k;k=a[k].next)&#123;</span><br><span class="line">            <span class="type">int</span> y=a[k].y;</span><br><span class="line">            <span class="keyword">if</span>(PII&#123;d[x].first+pri[y],d[x].second<span class="number">-1</span>&#125;&gt;d[y])&#123;</span><br><span class="line">                d[y]=PII&#123;d[x].first+pri[y],d[x].second<span class="number">-1</span>&#125;;</span><br><span class="line">                pre[y]=x;</span><br><span class="line">                <span class="keyword">if</span>(!v[y])&#123;</span><br><span class="line">                    v[y]=<span class="number">1</span>;</span><br><span class="line">                    q.<span class="built_in">push</span>(y);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    PII maxval=&#123;-inf,-inf&#125;;<span class="type">int</span> mp=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>((typ[i]&amp;<span class="number">2</span>) &amp;&amp; d[i]&gt;maxval)&#123;</span><br><span class="line">            maxval=d[i];</span><br><span class="line">            mp=i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!mp)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    zans-=maxval.first;</span><br><span class="line">    <span class="type">int</span> now=mp;</span><br><span class="line">    <span class="keyword">while</span>(now)&#123;</span><br><span class="line">        in[now]^=<span class="number">1</span>;</span><br><span class="line">        now=pre[now];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">char</span> ss[<span class="number">10</span>];</span><br><span class="line"><span class="type">int</span> ans[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="type">int</span> x,y,w,t;<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%s&quot;</span>,&amp;x,&amp;y,&amp;w,ss+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(ss[<span class="number">1</span>]==<span class="string">&#x27;R&#x27;</span>)t=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(ss[<span class="number">1</span>]==<span class="string">&#x27;G&#x27;</span>)t=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> t=<span class="number">2</span>;</span><br><span class="line">        e[i]=&#123;x,y,w,t&#125;;</span><br><span class="line">        zans+=w;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)ans[i]=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">pd</span>(<span class="number">0</span>,<span class="number">-1</span>,<span class="number">-1</span>) &amp;&amp; <span class="built_in">pd</span>(<span class="number">2</span>,<span class="number">-1</span>,<span class="number">-1</span>))&#123;</span><br><span class="line">        ans[m]=zans;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=m<span class="number">-1</span>;i&gt;=<span class="number">1</span>;i--)&#123;</span><br><span class="line">            <span class="built_in">build</span>();</span><br><span class="line">            <span class="keyword">if</span>(!<span class="built_in">solve</span>())<span class="keyword">break</span>;</span><br><span class="line">            ans[i]=zans;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></details>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>拟阵</tag>
      </tags>
  </entry>
  <entry>
    <title>Treelection</title>
    <url>/2024/02/11/Treelection/</url>
    <content><![CDATA[<p>题目链接：<a href="https://qoj.ac/contest/1259/problem/6638">https://qoj.ac/contest/1259/problem/6638</a></p>
<p>题目大意：给一棵以 $1$ 为根的树，举办一场投票，每个人只能向祖先投票，问每个点存不存在一种情况使得这个点的得票数严格大于其他点的得票数。（根不投票）</p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>考虑一个事情，一个子树大小为 $x$ 的点可以当选，那么显然一个子树大小 $y&gt;x$ 的点也一定可以当选，但是 $y=x$ 呢？</p>
<p>显然如果子树大小为 $x$ 的点的形状不是菊花就行，如果是菊花的话就还得另外考虑。</p>
<p>于是我们就发现，答案结构应该是存在一个 $limit$ ，$siz&gt;limit$ 一定可以，$siz=limit$ 得看情况（且必要条件是子树得是个菊花），考虑怎么找这个 limit ，显然得二分，但是怎么判断 $&gt;mid$ 的子树全都可以呢？</p>
<p>观察上述结论的证明过程，发现关键在于对于一个点 $x$ ，子树大小为 $siz$ ，要求每个点的得票数 $&lt;siz-1$ 时，这个子树能内部消化自己的得票数（也就是不是菊花），也就是说，存在一种情况使得整棵树的得票数的最大值 $&lt;siz-1$ ，因此做法就出来了。</p>
<p>如果存在一个情况，使得整棵树的得票数最大值 $\le mid-1$ ，那么 $limit \le mid$ ，显然树形DP即可。</p>
<p>在找到 $limit$ 后，考虑处理 $siz=limit$ 的点，用树形 DP 跑一遍每个点的最大容量只有 $limit-2$ 的情况，显然，只有当根节点得票数为 $limit-1$ 且这个点的 $siz=limit$ 且这个点到根节点这条路径上一直存在 $dp$ 值的有效转移时，这个点才是可以当选的点，否则不符合这种情况。（显然，能符合上述要求的点，子树一定是个菊花，这也符合上面的讨论）</p>
<p>时间复杂度：$O(n\log{n})$ </p>
<p>注：代码的实现思路和上面说的略有不同。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e6</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> p[N],siz[N],n;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="built_in">memset</span>(siz+<span class="number">1</span>,<span class="number">0</span>,<span class="built_in">sizeof</span>(<span class="type">int</span>)*n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;p[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=n;i&gt;=<span class="number">1</span>;i--)&#123;</span><br><span class="line">        siz[i]+=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(i!=<span class="number">1</span>)siz[p[i]]+=siz[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> f[N];<span class="type">bool</span> v[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">check</span><span class="params">(<span class="type">int</span> U)</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(f+<span class="number">1</span>,<span class="number">0</span>,<span class="built_in">sizeof</span>(<span class="type">int</span>)*n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=n;i&gt;=<span class="number">2</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(f[i]&lt;=U)v[i]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> v[i]=<span class="number">1</span>;</span><br><span class="line">        f[p[i]]+=<span class="built_in">max</span>(f[i]-U,<span class="number">0</span>)+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f[<span class="number">1</span>]-U;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">char</span> ac[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;1\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> l=<span class="number">3</span>,r=n+<span class="number">1</span>,mid,ans;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;=r)&#123;</span><br><span class="line">        mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">check</span>(mid<span class="number">-2</span>)&lt;=<span class="number">0</span>)r=mid<span class="number">-1</span>,ans=mid;</span><br><span class="line">        <span class="keyword">else</span> l=mid+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(siz[i]&gt;=ans)ac[i]=<span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">        <span class="keyword">else</span> ac[i]=<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ac[<span class="number">1</span>]=<span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">    <span class="keyword">if</span>(ans!=<span class="number">2</span> &amp;&amp; <span class="built_in">check</span>(ans<span class="number">-3</span>)==<span class="number">1</span>)&#123;</span><br><span class="line">        v[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(v[p[i]] &amp;&amp; v[i])v[i]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> v[i]=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(v[i] &amp;&amp; siz[i]==ans<span class="number">-1</span>)ac[i]=<span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ac[n+<span class="number">1</span>]=<span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,ac+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> T;<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></details>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>二分</tag>
        <tag>树形DP</tag>
      </tags>
  </entry>
  <entry>
    <title>The 2nd Ucup Stage 2: SPb M. Hardcore String Counting</title>
    <url>/2024/05/30/The-2nd-Ucup-Stage-2-SPb-M-Hardcore-String-Counting/</url>
    <content><![CDATA[<p>题目链接：<a href="https://contest.ucup.ac/contest/1356/problem/7187">https://contest.ucup.ac/contest/1356/problem/7187</a></p>
<p>题目大意：给一个长度为 $n$ 的字符串 $S$，问有多少个长度为 $m$ 的字符串满足所有真前缀没有子串等于 $S$ ，但整个串有。</p>
<details class="toggle" ><summary class="toggle-button" style="">做法 + 反思</summary><div class="toggle-content"><p>看复杂度，应该是 $n\log$ 之类的东西，不大可能在 AC 自动机上跑，因此比较有可能的就是列一个线性递推式，然后常系数齐次线性递推。</p>
<p>我当时想到这一步了，可惜并没有列出线性递推式。</p>
<p>我当时的思路是，设 $g(m)$ 表示长度为 $m$ 的字符串且没有子串等于 $S$ ，然后在 $g(m-1)$ 放一个字符，容斥减去 $g(m-n)$ ，但 $g(m-n)$ 不一定满足前 $m-1$ 前缀没有子串等于 $S$ ，所以还得容斥，当时我的思路就是接着找 border ，不断下去，但是发现这个过程好想是无穷的。</p>
<p>例如 $S=aa$ 时，则按照这个思路可以得到：$g(m)=26g(m-1)-\sum\limits_{i=2}^{m}(-1)^ig(m-i)$ 。</p>
<p>下面的代码可以验证：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> LL mod = <span class="number">998244353</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line">LL f1[N][<span class="number">2</span>], f2[N];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    f1[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1ll</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        f1[i][<span class="number">0</span>] = (f1[i - <span class="number">1</span>][<span class="number">0</span>] + f1[i - <span class="number">1</span>][<span class="number">1</span>]) * <span class="number">25ll</span> % mod;</span><br><span class="line">        f1[i][<span class="number">1</span>] = f1[i - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">        cout &lt;&lt; (f1[i][<span class="number">0</span>] + f1[i][<span class="number">1</span>]) % mod &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    f2[<span class="number">0</span>] = <span class="number">1ll</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        f2[i] = f2[i - <span class="number">1</span>] * <span class="number">26</span> % mod;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">2</span>, type = <span class="number">-1ll</span>; j &lt;= i; j++, type = -type) f2[i] = (f2[i] + f2[i - j] * type + mod) % mod; </span><br><span class="line">        cout &lt;&lt; f2[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>然后我就觉得这个思路是错的，虽然上面的 $g(m)$ 可以加上 $g(m-1)$ ，这样就可以变成有限项求和，但是这只是针对 $S=aa$ 的情况，对于更加一般的情况，就不一定能这么干了，而且我也想不太明白一般情况下 $g$ 的递推式。（这个思路我感觉确实比较绕，比较难想）</p>
<p>但是如果换个角度来看：我们设 $f(m)$ 就表示答案，显然：$f(m)=26g(m-1)-g(m)$ ，上面的式子中，我们需要容斥掉不一定满足前 $m-1$ 前缀没有子串等于 $S$ 但是前 $m-n$ 的前缀满足的字符串，显然这就是 $\sum\limits_{Border}f(m-n+Border)$ 。</p>
<p>所以这显然就是 $\sum\limits_{Border}26g(m-n+Border-1)-g(m-n+Border)$ ，那么就得到了有限项的递推式。</p>
<p>然后直接加速一下，就可以在 $O(n\log{n}\log{k})$ 的时间解决这个问题了。</p>
<p>反思一下我为什么没做出来：我没找到有限项递推 ≠ 没有，我找到无限项递推 ≠ 没有有限项。</p>
<p>再回头看我那个思考方向，我不认为能想出来，从结果来看，有限项的递推式中一堆 $26$ ，因此可以知道那个无穷递推式的结果肯定很难看，更别说要看出怎样线性组合可以把那个无穷递推式变成有限项，反正我不认为那个角度可以想出来。</p>
<p>所以当推不出递推式的时候，先别着急的认为不存在递推式，或许换个方式去推就能很快推出来了。虽然做题的时候，做不出来换个方向考虑是正常的，但对于这种不同的推式子方法难度天差地别的方向，多换不同的方法推式子也是必要的。同理，组合题也是。</p>
<h6 id="坑"><a href="#坑" class="headerlink" title="坑"></a>坑</h6><p>代码？博主不会多项式算法，咕了，以后会了再回来补上。</p>
</div></details>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>计数</tag>
        <tag>字符串</tag>
        <tag>常系数齐次线性递推</tag>
      </tags>
  </entry>
  <entry>
    <title>UR1 外星人</title>
    <url>/2023/08/22/UR1-%E5%A4%96%E6%98%9F%E4%BA%BA/</url>
    <content><![CDATA[<p>题目链接：<a href="https://uoj.ac/problem/22">https://uoj.ac/problem/22</a></p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>经典 trick 。</p>
<p>简单来说，对于 $x$ 个有标号的数字，让指定的数字站在开头的概率是多少？</p>
<p>答案：$\frac{1}{x}$ 。</p>
<p>证法：</p>
<ol>
<li>从随机性的角度考虑，第一个位置是某个数字的概率为 $\frac{1}{x}$ 。</li>
<li>从式子的角度分析：$\frac{(x-1)!}{x!}=\frac{1}{x}$ 。</li>
</ol>
<p>现在规定有 $y$ 个数字必须在某些数字前面，且对于第 $i$ 个数字，其必须在前面的数字包括其自己所构成的集合为 $S_i$ 。</p>
<p>如果满足：$S_{i}\subseteq S_{i-1}$ 。</p>
<p>那么概率的计算公式为：$\prod \frac{1}{|S_{i}|}$ 。</p>
<p>证法：</p>
<p>我们顺序考虑，假如第一个数字是 $x$ ，$S_1/x$ 的元素都要在其后面，那么为 $\frac{1}{S_1}$ ，显然剩下元素仍然是随机的，现在把 $S_1/S_2$ 的元素删掉，考虑 $S_2$ 的元素，其仍然是随机的，且不受前面影响，完全是一个子问题，那么直接乘就行了。</p>
<p>证毕。</p>
<p>这是一个很经典的概率 trick ，但是一定要谨记其的使用范围。</p>
<p>比如我稍微改变一下上面的条件，让 $S_i$ 不包含 $x$ 就已经错了。</p>
<p>例如：$1,2$ 都要在 $3$ 前面，那么：$\frac{1}{4}$ ，显然是错的。</p>
<p>为什么？原因是接下来的序列并不是一个完全的子问题，原因是：</p>
<p>例如 $13$ ，这个时候放 $2$ ，$23$ 的情况有两种：$213,123$ ，而 $32$ 的情况只有一种：$132$ ，所以并不满足不受前面影响这句话。</p>
<p>当然，也可以采用式子严谨证明：</p>
<p>显然，结果为：</p>
<p>定义 $|S_0|=n+1$ 。</p>
<p>公式为：$(\prod\limits_{i=1}^{m} C_{|S_{i-1}|-1}^{|S_i|}<em>(|S_{i-1}|-1-|S_{i}|)!)</em>\frac{(S_{m}-1)!}{S_{m}!}$ 。</p>
<p>展开可以发现就是结论中的式子。而上面的反例显然就是不满足这条计算公式，所以也就不能使用结论中的计算式进行计算。</p>
<p>利用这个 trick ，这道题目就随便做了，做法就不详写了，自己想想。</p>
<p>UPD：看了官方题解突然发现，貌似这道题目不用这个 trick 也能做，本质上是把官方题解的式子优化了一下。</p>
</div></details>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>经典trick</tag>
        <tag>概率</tag>
      </tags>
  </entry>
  <entry>
    <title>UR1 缩进优化</title>
    <url>/2023/08/22/UR1-%E7%BC%A9%E8%BF%9B%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<p>题目链接：<a href="https://uoj.ac/contest/3/problem/21">https://uoj.ac/contest/3/problem/21</a></p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
</div></details>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>调和级数</tag>
      </tags>
  </entry>
  <entry>
    <title>UR3-铀仓库</title>
    <url>/2023/08/25/UR3-%E9%93%80%E4%BB%93%E5%BA%93/</url>
    <content><![CDATA[<p>题目链接：<a href="https://uoj.ac/contest/5/problem/49">https://uoj.ac/contest/5/problem/49</a></p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>CNM，血压高了，一直卡在官方题解中的算法 2 ，根本就没有想到是二分答案，悲。</p>
<p>首先，一个十分显然的事情，这题有两种不同的二分方法：</p>
<ol>
<li>如果指定左右两边最远的到达距离，你可以在 $O(n)$ 的时间内对所有位置处理出其对应的区间，但是由于二分最远到达距离只能作用在一个数上，所以时间复杂度是： $O(n\log{n}\log_{X})$ ，也就是算法二。</li>
<li>既然答案要求箱子数，就二分箱子数 $K$ ，同理，可以在 $O(n)$ 的时间处理出对应的区间，然后算一下最小代价就行了，时间复杂度：$O(n\log{X})$ ，这就是题解的做法。</li>
</ol>
<p>为什么啊，纯二分题没有做出来，你真的是越来越菜了QAQ。</p>
<p>处理细节：考虑处理出包含 $x$ 的最长的区间，满足两个要求：</p>
<ol>
<li>区间内的箱子数和 $&lt;K$。</li>
<li>区间为这个位置搬箱子最优方案的一种。</li>
</ol>
<p>什么叫搬箱子的最优方案，显然：优先搬最近的。</p>
<p>所以每次把最近的不在区间中的位置加入区间所得到的任意一个方案都是最优方案。</p>
<p>可以证明，这个区间的左右端点会随着位置右移而非严格递增。</p>
<p>然后直接写就行了。</p>
<p>时间复杂度：$O(n\log{X})$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 510000</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line">LL a[N],fa[N],ff[N],b[N],sum,T;</span><br><span class="line">LL limit;</span><br><span class="line"><span class="type">int</span> n,left,right;</span><br><span class="line"><span class="function">LL <span class="title">dis</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;<span class="keyword">return</span> b[y]-b[x];&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve1</span><span class="params">(<span class="type">int</span> i)</span></span>&#123;<span class="keyword">while</span>(<span class="built_in">dis</span>(left,i)&gt;<span class="built_in">dis</span>(i,right) &amp;&amp; sum&gt;limit)sum-=a[left++];&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">()</span></span>&#123;</span><br><span class="line">    sum=<span class="number">0</span>;left=<span class="number">1</span>;right=<span class="number">0</span>;</span><br><span class="line">    LL mincost=T+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(right&lt;i)right++,sum+=a[right];</span><br><span class="line">        <span class="built_in">solve1</span>(i);</span><br><span class="line">        <span class="keyword">while</span>(right&lt;n &amp;&amp; (left==<span class="number">1</span> || <span class="built_in">dis</span>(left<span class="number">-1</span>,i)&gt;<span class="built_in">dis</span>(i,right+<span class="number">1</span>)) &amp;&amp; sum&lt;=limit)&#123;</span><br><span class="line">            right++,sum+=a[right];</span><br><span class="line">            <span class="built_in">solve1</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(sum&gt;limit)sum-=a[right--];</span><br><span class="line">        LL now=ff[right]-ff[i]-b[i]*(fa[right]-fa[i])+b[i]*(fa[i<span class="number">-1</span>]-fa[left<span class="number">-1</span>])-(ff[i<span class="number">-1</span>]-ff[left<span class="number">-1</span>]);</span><br><span class="line">        LL fnow=T+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(left&gt;<span class="number">1</span>)fnow=<span class="built_in">min</span>(<span class="built_in">dis</span>(left<span class="number">-1</span>,i)*(limit-sum),fnow);</span><br><span class="line">        <span class="keyword">if</span>(right&lt;n)fnow=<span class="built_in">min</span>(<span class="built_in">dis</span>(i,right+<span class="number">1</span>)*(limit-sum),fnow);</span><br><span class="line">        <span class="keyword">if</span>(left==<span class="number">1</span> &amp;&amp; right==n)fnow=<span class="number">0</span>;</span><br><span class="line">        mincost=<span class="built_in">min</span>(mincost,now+fnow);</span><br><span class="line">        <span class="comment">// printf(&quot;%d:%d %d %lld %lld %lld %lld\n&quot;,i,left,right,sum,mincost,now,fnow);</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mincost*<span class="number">2</span>&lt;=T;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// freopen(&quot;std.in&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%lld&quot;</span>,&amp;n,&amp;T);</span><br><span class="line">    LL l=<span class="number">0</span>,r=<span class="number">0</span>,ans;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;b[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;<span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;a[i]);l=<span class="built_in">max</span>(a[i],l);r+=a[i];fa[i]=fa[i<span class="number">-1</span>]+a[i];&#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)ff[i]=ff[i<span class="number">-1</span>]+b[i]*a[i];</span><br><span class="line">    <span class="comment">// printf(&quot;%lld %lld\n&quot;,l,r);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// limit=11;printf(&quot;%d\n&quot;,check());</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(l&lt;=r)&#123;</span><br><span class="line">        limit=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">check</span>())ans=limit,l=limit+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> r=limit<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></details>]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title>UR4-元旦三侠的游戏</title>
    <url>/2023/08/25/UR4-%E5%85%83%E6%97%A6%E4%B8%89%E4%BE%A0%E7%9A%84%E6%B8%B8%E6%88%8F/</url>
    <content><![CDATA[<p>题目链接：<a href="https://uoj.ac/problem/51">https://uoj.ac/problem/51</a></p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>这道题目主要涉及到了一个转化的问题。</p>
<p> SG 函数一般是使用在了没得走的时候为必败态，但是如果题目是走到了某个状态就输了要怎么转化呢？</p>
<p>答案是，我们认为玩家绝顶聪明，那显然不会去走那些输了的状态，也就是状态树中只会去走那些不会立即输的状态。（对应在本题中就是走后一定要 $a^b\le n$） </p>
<p>那么显然，当一个点没的走的时候，其是不是就一定输了，因为其下一步必定要走到判定为输的局面，这样我们就转化为了 $SG$ 的常见模型：没得走的状态为必败态。</p>
<p>这道题目也是同理，经过这种转化后，就是一个非常裸的 SG 函数了。</p>
<p>可以直接按题解写的做：$O(\sqrt{n}\log{n})$ ，但是感觉也存在更加优秀的做法。</p>
<p>就是观察发现状态只有 $0,1,2$ 三种，而且 $2$ 不会相邻，观察不难发现，同一个 $b$ 至多一个 $2$ ，记录一下 $2$ 的位置以及同一个 $b$ 的 SG 函数的一些参数，应该是可以做到 $O(\text{预处理}+m\log{n})$ 的时间做出来这道题目的。</p>
<p>但是感觉上就非常难写，以及有很多细节，有兴趣的读者可以自行尝试，我就不尝试了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 110000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> M 40</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n,m,a[M][N];</span><br><span class="line"><span class="type">int</span> b[M],top;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ksm</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> now=n;</span><br><span class="line">    <span class="keyword">while</span>(y)&#123;</span><br><span class="line">        <span class="keyword">if</span>(y&amp;<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(now&lt;x)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            now/=x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(y!=<span class="number">1</span> &amp;&amp; now/x&lt;x)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        x=x*x;y&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(y==<span class="number">1</span> &amp;&amp; x&gt;b[<span class="number">2</span>])<span class="keyword">return</span> (n-x)&amp;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> a[y][x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">findans</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> now=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(now==x || now==y)now++;</span><br><span class="line">    <span class="keyword">return</span> now;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// printf(&quot;%d\n&quot;,ksm(2,31));</span></span><br><span class="line"></span><br><span class="line">    b[top=<span class="number">1</span>]=n;</span><br><span class="line">    <span class="keyword">while</span>(b[top]&gt;<span class="number">1</span>)&#123;</span><br><span class="line">        b[++top]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">ksm</span>(b[top]+<span class="number">1</span>,top))b[top]++;</span><br><span class="line">    &#125;</span><br><span class="line">    top--;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=top;i&gt;=<span class="number">1</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="built_in">min</span>(b[i],b[<span class="number">2</span>]);j&gt;=<span class="number">2</span>;j--)&#123;</span><br><span class="line">            <span class="type">int</span> x=<span class="number">-1</span>,y=<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">if</span>(!(i==top || j&gt;b[i+<span class="number">1</span>]))x=a[i+<span class="number">1</span>][j];</span><br><span class="line">            <span class="keyword">if</span>(j!=b[i] &amp;&amp; !(i==<span class="number">1</span> &amp;&amp; j&gt;b[<span class="number">2</span>]))y=a[i][j+<span class="number">1</span>];</span><br><span class="line">            a[i][j]=<span class="built_in">findans</span>(x,y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// for(int i=1;i&lt;=top;i++)&#123;</span></span><br><span class="line">    <span class="comment">//     printf(&quot;%d %d: &quot;,i,b[i]);</span></span><br><span class="line">    <span class="comment">//     for(int j=2;j&lt;=b[i];j++)printf(&quot;%d &quot;,a[i][j]);</span></span><br><span class="line">    <span class="comment">//     printf(&quot;\n&quot;);</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="type">int</span> a,b;<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a,&amp;b);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">solve</span>(a,b))<span class="built_in">printf</span>(<span class="string">&quot;Yes\n&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;No\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></details>]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>SG</tag>
        <tag>博弈</tag>
        <tag>经典模型转化</tag>
      </tags>
  </entry>
  <entry>
    <title>UR5 怎样提高智商</title>
    <url>/2023/08/29/UR5-%E6%80%8E%E6%A0%B7%E6%8F%90%E9%AB%98%E6%99%BA%E5%95%86/</url>
    <content><![CDATA[<p><a href="https://uoj.ac/contest/7/problem/60">https://uoj.ac/contest/7/problem/60</a></p>
<span id="more"></span>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>非常有意思的一道题目，结论不难猜，但是非常难证。</p>
<p>首先，答案为 $4*3^{n-1}$ ，达到上界也非常的简单，搞一堆 ‘A 0 0 0 0’ 就行了。</p>
<p>时间复杂度：$O(n)$ 。</p>
<details class="toggle" ><summary class="toggle-button" style="">证明</summary><div class="toggle-content"><p>我们认为如果一道题目的四个答案都是一样的，我们称其为 SB 题。</p>
<p>假设最早出现的 SB 题在第 $i$ 道。</p>
<p>那么显然。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> LL mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    LL ans=<span class="number">4</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)ans=ans*<span class="number">3</span>%mod;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="built_in">printf</span>(<span class="string">&quot;A 0 0 0 0\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></details></div></details>]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>构造</tag>
        <tag>思维</tag>
      </tags>
  </entry>
  <entry>
    <title>UR4 元旦激光炮</title>
    <url>/2023/08/24/UR4-%E5%85%83%E6%97%A6%E6%BF%80%E5%85%89%E7%82%AE/</url>
    <content><![CDATA[<p>题目链接：<a href="https://uoj.ac/problem/52">https://uoj.ac/problem/52</a></p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>题解做法不难想到，每次把 $K$ 均摊到三个数组，查询三次，最小的那个数字显然一定在 $\le K$  的范围内。</p>
<p>操作次数：$n\log_{\frac{n}{n-1}}{K}$ 左右。</p>
<p>但是这个做法存在优化的空间：</p>
<ol>
<li>我们每次查询三个数组位置的和为 $K$ ，这个限制太强了，可以考虑放宽这个限制。</li>
<li>我们只利用到了最小的数字一定在 $\le K$ 的性质，没有利用到 最大的数字一定在 $\ge K$ 的性质。（但是上面那个做法每个数组查询的位置非严格单调递减，所以上面那个算法无法利用该性质进行优化。）</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;kth.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> cnt[<span class="number">3</span>],ff[<span class="number">3</span>],fucknow[<span class="number">3</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getans</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> type)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(type==<span class="number">0</span>)<span class="keyword">return</span> <span class="built_in">get_a</span>(x);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(type==<span class="number">1</span>)<span class="keyword">return</span> <span class="built_in">get_b</span>(x);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">get_c</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> lastans=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">solve1</span><span class="params">(<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(k)&#123;</span><br><span class="line">        <span class="type">int</span> pre=<span class="number">-1</span>,preval=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">2</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cnt[i]&lt;ff[i])&#123;</span><br><span class="line">                <span class="type">int</span> now=<span class="built_in">getans</span>(cnt[i],i);</span><br><span class="line">                <span class="keyword">if</span>(pre==<span class="number">-1</span> || <span class="built_in">now</span>&lt;preval)preval=now,pre=i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cnt[pre]++;k--;</span><br><span class="line">        lastans=preval;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> lastans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> id[<span class="number">10</span>];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;<span class="keyword">return</span> (ff[x]-cnt[x])&gt;(ff[y]-cnt[y]);&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">solve2</span><span class="params">(<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">2</span>;i++)id[i]=i;</span><br><span class="line">    <span class="keyword">while</span>(k&gt;<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="type">int</span> now=k;</span><br><span class="line">        <span class="built_in">sort</span>(id,id+<span class="number">3</span>,cmp);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="type">int</span> x=id[i],s=<span class="built_in">min</span>(ff[x]-cnt[x],now/(i+<span class="number">1</span>));</span><br><span class="line">            now-=s;fucknow[x]=cnt[x]+s;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> pre=<span class="number">-1</span>,preval=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">2</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cnt[i]==ff[i])<span class="keyword">continue</span>;</span><br><span class="line">            <span class="type">int</span> now=<span class="built_in">getans</span>(fucknow[i]<span class="number">-1</span>,i);</span><br><span class="line">            <span class="keyword">if</span>(pre==<span class="number">-1</span> || preval&gt;now)preval=now,pre=i;</span><br><span class="line">        &#125;</span><br><span class="line">        k-=fucknow[pre]-cnt[pre];cnt[pre]=fucknow[pre];</span><br><span class="line">        lastans=preval;</span><br><span class="line">        <span class="comment">// printf(&quot;%d\n&quot;,k);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">solve1</span>(k);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query_kth</span><span class="params">(<span class="type">int</span> n_a, <span class="type">int</span> n_b, <span class="type">int</span> n_c, <span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">    ff[<span class="number">0</span>]=n_a;ff[<span class="number">1</span>]=n_b;ff[<span class="number">2</span>]=n_c;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">solve2</span>(k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>基于二分的做法：</p>
<p>接下来阐释做法时默认数字不同，相同的情况加个浮动可以转化为不同的情况。</p>
<p>每个数组都有个 $[L,R]$ ,考虑查询每个数组的 $mid$ ，$mid$ 总和为 $sum$ ， $sum\ge sum$ ，那么最大的数字一定在 $\ge sum$ 的位置。</p>
<p>$&lt;sum$ ，那么最小的位置一定在 $&lt;sum$ 的位置。</p>
<p>然后二分就行了。</p>
<p>最后把所有 $\ge K$ 的数字拉出来跑个最小值就行了。（不用搜索次数，之前自动记录）</p>
<p>至于为什么是对的？</p>
<p>证明：</p>
<p>首先，最后每个数字都会分为两类 $&lt;K,\ge K$ ，那么显然 $\ge K$ 的数字中最小的那个就是 $=K$ 的数字，证毕。</p>
<p>注：准确来说，$\ge K$ 又分为 $\ge K$ 和 $\ge K+1$ ，同时，根据过程和定义，显然 $&lt;K$ 里面有恰好 $K-1$ 个数字。</p>
<p>操作次数：$n\log_{2}{K}$ 左右，显然，这个做法完全优于上面的做法。</p>
<p>还没有明白怎么做的可以直接看代码，很好看懂的，我讲的确实有点抽象。</p>
<p>代码来自：<a href="https://uoj.ac/submission/243331">https://uoj.ac/submission/243331</a> 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kth.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">   </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i,s,t) for(int i=(s),_t=(t);i&lt;_t;++i)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> per(i,s,t) for(int i=(t)-1,_s=(s);i&gt;=_s;--i)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> bug(x) cerr&lt;&lt;#x&lt;&lt;<span class="string">&quot; = &quot;</span>&lt;&lt;(x)&lt;&lt;<span class="string">&quot; &quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug(x) cerr&lt;&lt;#x&lt;&lt;<span class="string">&quot; = &quot;</span>&lt;&lt;(x)&lt;&lt;<span class="string">&quot;\n&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">double</span> db;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; pii;</span><br><span class="line">   </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;<span class="function"><span class="type">void</span> <span class="title">rd</span><span class="params">(T &amp;x)</span></span>&#123;</span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> f;<span class="type">static</span> <span class="type">char</span> c;</span><br><span class="line">	f=<span class="number">1</span>;x=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(c=<span class="built_in">getchar</span>(),c&lt;<span class="number">48</span>)<span class="keyword">if</span>(c==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">do</span> x=x*<span class="number">10</span>+(c&amp;<span class="number">15</span>);</span><br><span class="line">	<span class="keyword">while</span>(c=<span class="built_in">getchar</span>(),c&gt;<span class="number">47</span>);</span><br><span class="line">	x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;<span class="function"><span class="type">void</span> <span class="title">prin</span><span class="params">(T x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x&lt;<span class="number">0</span>)<span class="built_in">putchar</span>(<span class="string">&#x27;-&#x27;</span>),x=-x;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(!x)&#123;<span class="built_in">putchar</span>(<span class="string">&#x27;0&#x27;</span>);<span class="keyword">return</span> ;&#125;</span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> stk[<span class="number">100</span>],tp;</span><br><span class="line">	<span class="keyword">while</span>(x)stk[tp++]=x%<span class="number">10</span>,x/=<span class="number">10</span>;</span><br><span class="line">	<span class="keyword">while</span>(tp)<span class="built_in">putchar</span>(stk[--tp]^<span class="number">48</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;<span class="function"><span class="type">void</span> <span class="title">ptk</span><span class="params">(T x)</span></span>&#123;<span class="built_in">prin</span>(x);<span class="built_in">putchar</span>(<span class="string">&#x27; &#x27;</span>);&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;<span class="function"><span class="type">void</span> <span class="title">ptn</span><span class="params">(T x)</span></span>&#123;<span class="built_in">prin</span>(x);<span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;<span class="function"><span class="type">void</span> <span class="title">Min</span><span class="params">(T &amp;a,T b)</span></span>&#123;<span class="keyword">if</span>(b&lt;a)a=b;&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;<span class="function"><span class="type">void</span> <span class="title">Max</span><span class="params">(T &amp;a,T b)</span></span>&#123;<span class="keyword">if</span>(a&lt;b)a=b;&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=(<span class="type">int</span>)<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> A[N],B[N],C[N];</span><br><span class="line"><span class="comment">//int get_a(int x);</span></span><br><span class="line"><span class="comment">//int get_b(int x);</span></span><br><span class="line"><span class="comment">//int get_c(int x);</span></span><br><span class="line"><span class="comment">//int get_a(int x)&#123;</span></span><br><span class="line"><span class="comment">//	return 1;</span></span><br><span class="line"><span class="comment">//	</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//int get_b(int x)&#123;</span></span><br><span class="line"><span class="comment">//	return 1;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//int get_c(int x)&#123;</span></span><br><span class="line"><span class="comment">//	return 1;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Find_a</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(A[x])<span class="keyword">return</span> A[x];</span><br><span class="line">	<span class="keyword">return</span> A[x]=<span class="built_in">get_a</span>(x<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Find_b</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(B[x])<span class="keyword">return</span> B[x];</span><br><span class="line">	<span class="keyword">return</span> B[x]=<span class="built_in">get_b</span>(x<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Find_c</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(C[x])<span class="keyword">return</span> C[x];</span><br><span class="line">	<span class="keyword">return</span> C[x]=<span class="built_in">get_c</span>(x<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query_kth</span><span class="params">(<span class="type">int</span> na, <span class="type">int</span> nb, <span class="type">int</span> nc, <span class="type">int</span> K)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> L[<span class="number">3</span>]=&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,R[<span class="number">3</span>]=&#123;na,nb,nc&#125;,mid[<span class="number">3</span>],could[<span class="number">3</span>];</span><br><span class="line">	<span class="type">int</span> ans=(<span class="type">int</span>)<span class="number">1e9</span>;pii arr[<span class="number">3</span>];</span><br><span class="line">	<span class="keyword">while</span>(L[<span class="number">0</span>]&lt;=R[<span class="number">0</span>]||L[<span class="number">1</span>]&lt;=R[<span class="number">1</span>]||L[<span class="number">2</span>]&lt;=R[<span class="number">2</span>])&#123;</span><br><span class="line">		<span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">		<span class="built_in">rep</span>(i,<span class="number">0</span>,<span class="number">3</span>)&#123;</span><br><span class="line">			<span class="keyword">if</span>(L[i]&lt;=R[i])mid[i]=(L[i]+R[i])&gt;&gt;<span class="number">1</span>;</span><br><span class="line">			<span class="keyword">else</span> mid[i]=could[i];</span><br><span class="line">			sum+=mid[i];</span><br><span class="line">		&#125;</span><br><span class="line">		arr[<span class="number">0</span>]=<span class="built_in">pii</span>(<span class="built_in">Find_a</span>(mid[<span class="number">0</span>]),<span class="number">0</span>);</span><br><span class="line">		arr[<span class="number">1</span>]=<span class="built_in">pii</span>(<span class="built_in">Find_b</span>(mid[<span class="number">1</span>]),<span class="number">1</span>);</span><br><span class="line">		arr[<span class="number">2</span>]=<span class="built_in">pii</span>(<span class="built_in">Find_c</span>(mid[<span class="number">2</span>]),<span class="number">2</span>);</span><br><span class="line">		<span class="built_in">sort</span>(arr,arr+<span class="number">3</span>);</span><br><span class="line">		<span class="keyword">if</span>(sum&gt;=K)&#123;<span class="comment">//找最大的 </span></span><br><span class="line">			<span class="built_in">Min</span>(ans,arr[<span class="number">2</span>].fi);</span><br><span class="line">			<span class="built_in">per</span>(i,<span class="number">0</span>,<span class="number">3</span>)&#123;</span><br><span class="line">				<span class="keyword">if</span>(L[arr[i].se]&lt;=R[arr[i].se])&#123;</span><br><span class="line">					R[arr[i].se]=mid[arr[i].se]<span class="number">-1</span>;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;<span class="comment">//找最小的 </span></span><br><span class="line">			<span class="built_in">rep</span>(i,<span class="number">0</span>,<span class="number">3</span>)&#123;</span><br><span class="line">				<span class="keyword">if</span>(L[arr[i].se]&lt;=R[arr[i].se])&#123;</span><br><span class="line">					could[arr[i].se]=mid[arr[i].se];</span><br><span class="line">					L[arr[i].se]=mid[arr[i].se]+<span class="number">1</span>;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></details>]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>交互</tag>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title>Vizing 定理学习笔记</title>
    <url>/2024/05/28/Vizing-%E5%AE%9A%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>题目链接：</p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
</div></details>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
  </entry>
  <entry>
    <title>WC2016 论战捆竹竿</title>
    <url>/2024/03/18/WC2016-%E8%AE%BA%E6%88%98%E6%8D%86%E7%AB%B9%E7%AB%BF/</url>
    <content><![CDATA[<p>题目链接：<a href="https://www.luogu.com.cn/problem/P4156">https://www.luogu.com.cn/problem/P4156</a></p>
<p>题目大意：每一开始你有一个字符串 $s$ ，然后你可以在字符串末尾加入 $s$ 并删除末尾一个 $s$ 的 Border ，问你最终能得到多少个不超过 $w$ 的不同长度。</p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>首先，如何计数？观察到我们只要知道对于 $\forall k\in \{0,1,…,n-1\}$ ，最小的长度 $len_k$ 满足：$len_k\equiv k\mod{n}$ 。</p>
<p>这样就能够在 $O(n)$ 的时间内计算答案了。</p>
<p>这时一个很暴力的想法是求出所有的 Border 然后做同余最短路，时间复杂度 $O(n^2)$ 。</p>
<p>这个时候就要利用 Border 的性质做一些优化了，Border 有一个性质：能够把所有 Border 划分成恰好 $\log$ 段等差数列。</p>
<p>不妨将长度设为 $l,l+d,l+2d,…,l+(s-1)d$ 。</p>
<p>这时候还要观察到一个事情：如果把这个问题想象成背包，这个背包的体积和价值是一样的，这能够产生一个什么性质呢？不妨认为 $len_k\equiv t\mod{l}$ ，我们只要先在$\mod{l}$ 意义下跑出最小的 $len’_t$ ，然后再用 $len’_t$ 去更新 $len_k$ 即可。</p>
<p>前一部分可以用单调队列，后一部分连单调队列都不用。</p>
<p>时间复杂度：$O(Tn\log{n})$ 。</p>
<p>空间复杂度：$O(n)$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">5e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> NN=<span class="number">1e6</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> LL inf=<span class="number">1e18</span>+<span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;<span class="keyword">return</span> !x?y:<span class="built_in">gcd</span>(y%x,x);&#125;</span><br><span class="line"><span class="type">int</span> fail[N],n;LL m,dp[N],tmp[N];</span><br><span class="line"><span class="type">char</span> st[N];</span><br><span class="line">PII lis[NN];</span><br><span class="line"><span class="type">int</span> head,tail;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> s,<span class="type">int</span> d)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;l;i++)tmp[i]=inf+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)tmp[dp[i]%l]=<span class="built_in">min</span>(tmp[dp[i]%l],dp[i]);</span><br><span class="line">    <span class="type">int</span> g=<span class="built_in">gcd</span>(l,d);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;g;i++)&#123;</span><br><span class="line">        head=<span class="number">1</span>;tail=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> now=i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> lim=l/g*<span class="number">2</span>,ti=<span class="number">0</span>;lim;lim--,ti++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(head&lt;=tail &amp;&amp; ti-lis[head].second+<span class="number">1</span>&gt;s)head++;</span><br><span class="line">            <span class="keyword">if</span>(head&lt;=tail)tmp[now]=<span class="built_in">min</span>(tmp[now],tmp[lis[head].first]+<span class="number">1ll</span>*(ti-lis[head].second)*d+l);</span><br><span class="line">            <span class="keyword">while</span>(head&lt;=tail &amp;&amp; tmp[lis[tail].first]+(ti-lis[tail].second)*d&gt;tmp[now])tail--;</span><br><span class="line">            lis[++tail]=&#123;now,ti&#125;;</span><br><span class="line">            now=(now+d)%l;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;l;i++)&#123;</span><br><span class="line">        dp[tmp[i]%n]=<span class="built_in">min</span>(dp[tmp[i]%n],tmp[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    g=<span class="built_in">gcd</span>(l,n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;g;i++)&#123;</span><br><span class="line">        <span class="type">int</span> now=i;LL mi=inf;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> lim=n/g*<span class="number">2</span>;lim;lim--)&#123;</span><br><span class="line">            dp[now]=<span class="built_in">min</span>(dp[now],mi);</span><br><span class="line">            mi=<span class="built_in">min</span>(mi,dp[now])+l;</span><br><span class="line">            now=(now+l)%n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> T;<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%lld&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,st+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(m&lt;n)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;0\n&quot;</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        m-=n;</span><br><span class="line">        fail[<span class="number">0</span>]=<span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> now=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(now!=<span class="number">-1</span> &amp;&amp; st[now+<span class="number">1</span>]!=st[i])now=fail[now];</span><br><span class="line">            fail[i]=++now;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)dp[i]=inf+<span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        now=fail[n];</span><br><span class="line">        <span class="keyword">while</span>(now)&#123;</span><br><span class="line">            <span class="type">int</span> nex=fail[now];</span><br><span class="line">            <span class="keyword">if</span>(nex+nex&lt;now)<span class="built_in">solve</span>(n-now,<span class="number">1</span>,<span class="number">1</span>),now=nex;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="type">int</span> p=now-nex;</span><br><span class="line">                <span class="type">int</span> l=now%p+p;</span><br><span class="line">                <span class="built_in">solve</span>(n-now,(now-l)/p+<span class="number">1</span>,p);</span><br><span class="line">                now=l;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        LL ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dp[i]&lt;=m)ans+=(m-dp[i])/n+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我没做出来，我的评价是：菜就多练。</p>
<p>训，狠狠地训。</p>
</div></details>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>Border</tag>
        <tag>同余最短路</tag>
        <tag>单调队列</tag>
      </tags>
  </entry>
  <entry>
    <title>ZJOI2017 字符串</title>
    <url>/2024/02/18/ZJOI2017-%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<p>题目链接：<a href="https://loj.ac/p/2572">https://loj.ac/p/2572</a></p>
<p>题目大意：</p>
<p>一个长度为 $n$ ，字符集大小为 $10^9$ 的字符串，要求完成 $m$ 次操作。</p>
<p>两种操作：</p>
<ol>
<li>区间 $+d$ ，$d$ 可以为负。</li>
<li>求区间的字典序最小的后缀。</li>
</ol>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>太唐了，都已经知道了 Significant Suffixes 都还不会，感觉自从高三回归课内搞了一年后，我信息学的许多基本功都下降了好多，悲。</p>
<p>首先，一个显然的事情，我们得先处理子串比较的问题，这个显然可以 二分+线段树+Hash 解决，时间复杂度：$O(n\log^2{n})$ 。（修改复杂度：$O(n\log{n})$）</p>
<p>其次，我们可以在线段树上维护每个区间的 Significant Suffixes 的集合，但是问题是怎么求 Significant Suffixes？</p>
<p>其实压根没有必要保证集合里面都是 Significant Suffixes，只需要保证 Significant Suffixes 一定在集合里面就行了，同时保证集合大小在 $O(\log)$ 即可。（当确定一个东西是什么十分困难时，不妨尝试确定一个东西不是什么）</p>
<p>根据 Significant Suffixes 的相关证明以及线段树的性质，不难发现，线段树上合并节点时，左节点只会贡献一个可能是 Significant Suffixes 的后缀。</p>
<p>而找到这个后缀的方法就是：在左节点的集合中找一种奇怪字典序最小的后缀，这种字典序最小是认为空字符大于所有字符，即如果 $A$ 是 $B$ 的真前缀且 $A$，则 $B&lt;A$ 。</p>
<p>但是可以发现，一次修改的时间复杂度高达：$O(\log^4)$ ，但如果你足够聪慧，你可以发现，Hash 修改的时间开销很小，但是查询的时间开销很大，所以我们希望牺牲一下修改复杂度，从而降低查询复杂度，不难想到分块，分块+Hash 修改复杂度 $O(\sqrt{n})$ ，查询复杂度 $O(1)$ ，这样修改的最终复杂度就能优化到：$O(\log^3{n}+\sqrt{n})$ 。</p>
<p>那查询咋整，如果和修改一样合并节点，就没法保证左右节点长度几乎相等的性质，那个做法就不能用了，虽然也能补救，就是从右往左合并，如果左边的长度大于右边的长度+1，那么就把左边那个节点变成这个节点的左儿子和又儿子再进行合并，显然这样的时间复杂度是 $O(\log^3)$ 的，但是比较麻烦，有没有简单点的方法。</p>
<p>变换思路，不合并了，反正就 $O(\log)$ 个节点，则集合的并的大小也就 $O(\log^2)$ 大小，直接比较大小就行了，时间复杂度：$O(\log^3)$ 。</p>
<p>所以，最终复杂度就出来：$O(n\log^2{n}+m(\sqrt{n}+\log^3{n}))$</p>
<p>空间复杂度：$O(n\log{n})$ </p>
<p>什么时候我能自己独立做出来一道这么牛逼的字符串题啊。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;LL,<span class="type">int</span>&gt; PLI;</span><br><span class="line"><span class="type">const</span> LL mod=<span class="number">2000000239</span>;</span><br><span class="line"><span class="type">const</span> LL A=<span class="number">2000000137</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> NN=<span class="number">4e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> B=<span class="number">950</span>;</span><br><span class="line"><span class="type">int</span> n,q;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getz</span><span class="params">(<span class="type">int</span> &amp;x)</span></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">int</span> f=<span class="number">1</span>;<span class="type">char</span> c=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(c&gt;<span class="string">&#x27;9&#x27;</span> || c&lt;<span class="string">&#x27;0&#x27;</span>)c==<span class="string">&#x27;-&#x27;</span>?f=<span class="number">-1</span>:<span class="number">1</span>,c=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(c&lt;=<span class="string">&#x27;9&#x27;</span> &amp;&amp; c&gt;=<span class="string">&#x27;0&#x27;</span>)x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+c-<span class="string">&#x27;0&#x27;</span>,c=<span class="built_in">getchar</span>();</span><br><span class="line">    x=x*f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">mt</span><span class="params">(LL x)</span></span>&#123;<span class="keyword">return</span> x&gt;=mod?x-mod:(x&lt;<span class="number">0</span>?x+mod:x);&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Hash</span>&#123;</span><br><span class="line">    LL fb[N],ff[N];</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">        fb[<span class="number">0</span>]=<span class="number">1</span>;fb[<span class="number">1</span>]=A;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)fb[i]=fb[i<span class="number">-1</span>]*A%mod;</span><br><span class="line">        ff[<span class="number">0</span>]=<span class="number">1</span>;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)ff[i]=<span class="built_in">mt</span>(ff[i<span class="number">-1</span>]+fb[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;has;</span><br><span class="line">PLI <span class="keyword">operator</span>+(PLI x,PLI y)&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;(x.first*has.fb[y.second]+y.first)%mod,x.second+y.second&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> bel[N],lazy[N],ll[N],rr[N],val[N];</span><br><span class="line">PLI fl[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">maintain</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=ll[x];i&lt;=rr[x];i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i==ll[x])fl[i]=PLI&#123;val[i],<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">else</span> fl[i]=fl[i<span class="number">-1</span>]+PLI&#123;val[i],<span class="number">1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">change</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> d)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=ll[x];i&lt;=rr[x];i++)&#123;</span><br><span class="line">        val[i]+=lazy[x];</span><br><span class="line">        <span class="keyword">if</span>(i&gt;=l &amp;&amp; i&lt;=r)val[i]+=d;</span><br><span class="line">    &#125;</span><br><span class="line">    lazy[x]=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">maintain</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">change</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> d)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(bel[l]==bel[r])<span class="built_in">change</span>(bel[l],l,r,d);</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">change</span>(bel[l],l,r,d);</span><br><span class="line">        <span class="built_in">change</span>(bel[r],l,r,d);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=bel[l]+<span class="number">1</span>;i&lt;bel[r];i++)lazy[i]+=d;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">PLI <span class="title">queryhash_nl</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l==ll[bel[l]])<span class="keyword">return</span> fl[r];</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> &#123;<span class="built_in">mt</span>(fl[r].first-fl[l<span class="number">-1</span>].first*has.fb[ r-l+<span class="number">1</span> ]%mod),r-l+<span class="number">1</span>&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">PLI <span class="title">hashplus</span><span class="params">(PLI x,LL d)</span></span>&#123;<span class="keyword">return</span> &#123;<span class="built_in">mt</span>(x.first+has.ff[x.second<span class="number">-1</span>]*d%mod),x.second&#125;;&#125;<span class="comment">/*x+dval*/</span></span><br><span class="line"><span class="function">PLI <span class="title">queryhash_l</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;<span class="keyword">return</span> <span class="built_in">hashplus</span>(<span class="built_in">queryhash_nl</span>(l,r),lazy[bel[l]]);&#125;</span><br><span class="line"><span class="function">PLI <span class="title">queryhas</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    PLI ans=&#123;<span class="number">0ll</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=bel[l];i&lt;=bel[r];i++)&#123;</span><br><span class="line">        ans=ans+<span class="built_in">queryhash_l</span>(<span class="built_in">max</span>(l,ll[i]),<span class="built_in">min</span>(rr[i],r));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> lim,<span class="type">int</span> typ=<span class="number">0</span>)</span></span>&#123;<span class="comment">//return x&lt;y</span></span><br><span class="line">    <span class="type">int</span> l=<span class="number">1</span>,r=lim-<span class="built_in">max</span>(x,y)+<span class="number">1</span>,mid,ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;=r)&#123;</span><br><span class="line">        mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">queryhas</span>(x,x+mid<span class="number">-1</span>)!=<span class="built_in">queryhas</span>(y,y+mid<span class="number">-1</span>))r=mid<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">else</span> l=mid+<span class="number">1</span>,ans=mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(ans==lim-<span class="built_in">max</span>(x,y)+<span class="number">1</span>)<span class="keyword">return</span> typ?x&lt;y:x&gt;y;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> val[x+ans]+lazy[bel[x+ans]]&lt;val[y+ans]+lazy[bel[y+ans]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Segment</span>&#123;</span><br><span class="line">    <span class="type">int</span> lc,rc;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; sign;</span><br><span class="line">&#125;tr[NN];<span class="type">int</span> cnt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">updata</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="comment">// tr[x].sign.clear();</span></span><br><span class="line">    tr[x].sign=tr[tr[x].rc].sign;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> y:tr[tr[x].lc].sign)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!ans || <span class="built_in">cmp</span>(y,ans,r,<span class="number">1</span>))ans=y;</span><br><span class="line">    &#125;</span><br><span class="line">    tr[x].sign.<span class="built_in">push_back</span>(ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bt</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> x=++cnt;</span><br><span class="line">    <span class="keyword">if</span>(l==r)tr[x].sign.<span class="built_in">push_back</span>(l);</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        tr[x].lc=<span class="built_in">bt</span>(l,mid);</span><br><span class="line">        tr[x].rc=<span class="built_in">bt</span>(mid+<span class="number">1</span>,r);</span><br><span class="line">        <span class="built_in">updata</span>(x,r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">change</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> ll,<span class="type">int</span> rr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ll&gt;rr || rr&lt;l || ll&gt;r || (l&gt;=ll &amp;&amp; r&lt;=rr))<span class="keyword">return</span> ;</span><br><span class="line">    <span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">change</span>(tr[x].lc,l,mid,ll,rr);</span><br><span class="line">    <span class="built_in">change</span>(tr[x].rc,mid+<span class="number">1</span>,r,ll,rr);</span><br><span class="line">    <span class="built_in">updata</span>(x,r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> zans;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">query</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> ll,<span class="type">int</span> rr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ll&gt;rr || rr&lt;l || ll&gt;r)<span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">if</span>(l&gt;=ll &amp;&amp; r&lt;=rr)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> y:tr[x].sign)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!zans || <span class="built_in">cmp</span>(y,zans,rr))zans=y;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">query</span>(tr[x].lc,l,mid,ll,rr);</span><br><span class="line">    <span class="built_in">query</span>(tr[x].rc,mid+<span class="number">1</span>,r,ll,rr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">getz</span>(n);<span class="built_in">getz</span>(q);</span><br><span class="line">    has.<span class="built_in">init</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">getz</span>(val[i]);</span><br><span class="line">        val[i]+=<span class="number">1000000001</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        bel[i]=i/B+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(!ll[bel[i]])ll[bel[i]]=i;</span><br><span class="line">        rr[bel[i]]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=bel[n];i++)<span class="built_in">maintain</span>(i);</span><br><span class="line">    <span class="built_in">bt</span>(<span class="number">1</span>,n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=q;i++)&#123;</span><br><span class="line">        <span class="type">int</span> typ;<span class="built_in">getz</span>(typ);</span><br><span class="line">        <span class="keyword">if</span>(typ==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="type">int</span> l,r,d;<span class="built_in">getz</span>(l);<span class="built_in">getz</span>(r);<span class="built_in">getz</span>(d);</span><br><span class="line">            <span class="built_in">change</span>(l,r,d);</span><br><span class="line">            <span class="built_in">change</span>(<span class="number">1</span>,<span class="number">1</span>,n,l,r);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="type">int</span> l,r;<span class="built_in">getz</span>(l);<span class="built_in">getz</span>(r);</span><br><span class="line">            zans=<span class="number">0</span>;</span><br><span class="line">            <span class="built_in">query</span>(<span class="number">1</span>,<span class="number">1</span>,n,l,r);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,zans);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个题目有点卡常，这里说一下我是怎么卡常的：</p>
<ol>
<li>模数等量改成常数，同时将一些取模改成判断和加减的组合。</li>
<li>调调块长，在 $2\sqrt{n}$ 左右会快很多。</li>
<li>加快读。</li>
</ol>
</div></details>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>数据结构</tag>
        <tag>Hash</tag>
        <tag>分块</tag>
        <tag>线段树</tag>
        <tag>Significant Suffixes</tag>
      </tags>
  </entry>
  <entry>
    <title>sgu543 Cafe</title>
    <url>/2024/04/29/sgu543-Cafe/</url>
    <content><![CDATA[<p>题目链接：<a href="https://codeforces.com/problemsets/acmsguru/problem/99999/543">https://codeforces.com/problemsets/acmsguru/problem/99999/543</a></p>
<p>题目大意：有 $n$ 个团体，每张桌子有 $r$ 个位置，问最小多少张桌子能让所有人上桌，要求：一个桌子上不会出现一个团体只有一个人在这张桌子上。</p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>注意到一个事情：任何一个 $&gt;1$ 的正整数可以被拆分成若干 $2,3$ 的和，但问题是，我们不知道每个团体的人要被拆成多少个 $2,3$ （显然，知道有多少个 $2,3$ ，就可以在足够优秀的时间复杂度内得到最少的桌子数量）。</p>
<p>但是又注意到一个事情：一个桌子上有两个 $3$ 和一个团体被拆分成两个 $3$ 这两件事不会同时发生，因为发生这种情况时可以交换，然后把两个 $3$ 拆成 $3$ 个 $2$ 。</p>
<p>因此我们只要分成两种情况讨论就行了：</p>
<ol>
<li>每个团体至多拆出一个 $3$ 。</li>
<li>每个桌子至多放置一个 $3$ 。</li>
</ol>
<p>然后讨论一下就做完了，我采用了二分，所以时间复杂度是：$O(n\log{V})$ 的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e3</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n, R, a[N];</span><br><span class="line"><span class="keyword">namespace</span> Solve1&#123;<span class="comment">//any team only one    </span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">evenpd</span><span class="params">(<span class="type">int</span> res, <span class="type">int</span> cnt, <span class="type">int</span> num2, <span class="type">int</span> num3)</span></span>&#123;</span><br><span class="line">        <span class="built_in">assert</span>(res % <span class="number">2</span> == <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(<span class="number">1ll</span> * res * cnt &lt; num2 * <span class="number">2</span> + num3 * <span class="number">3</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="number">1ll</span> * res / <span class="number">6</span> * <span class="number">2</span> * cnt &gt;= num3) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> tmp = res % <span class="number">6</span>;</span><br><span class="line">        <span class="keyword">if</span>(tmp &lt; <span class="number">3</span>) <span class="keyword">return</span> <span class="number">0ll</span>;</span><br><span class="line">        num3 -= <span class="number">1ll</span> * res / <span class="number">6</span> * <span class="number">2</span> * cnt;</span><br><span class="line">        <span class="keyword">return</span> tmp * cnt &gt;= num3 * <span class="number">4</span> + num2 * <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">pd</span><span class="params">(<span class="type">int</span> cnt, <span class="type">int</span> num2, <span class="type">int</span> num3)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!(R &amp; <span class="number">1</span>)) <span class="keyword">return</span> <span class="built_in">evenpd</span>(R, cnt, num2, num3);</span><br><span class="line">        <span class="keyword">if</span>(num3 &lt;= cnt) <span class="keyword">return</span> <span class="number">1ll</span> * (R - <span class="number">1</span>) * cnt &gt;= (num2 + num3) * <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">evenpd</span>(R - <span class="number">3</span>, cnt, num2, num3 - cnt);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> num2 = <span class="number">0</span>, num3 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i] &amp; <span class="number">1</span>) num3 ++, num2 --;</span><br><span class="line">            num2 += a[i] / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">1</span>, r = <span class="number">2000</span> * n, mid, ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt;= r)&#123;</span><br><span class="line">            mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">pd</span>(mid, num2, num3)) ans = mid, r = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">assert</span>(ans);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> Solve2&#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">pd</span><span class="params">(<span class="type">int</span> cnt, <span class="type">int</span> num2, <span class="type">int</span> num3, <span class="type">int</span> num6)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(num3 &gt; cnt) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> use = num3 + <span class="built_in">min</span>((cnt - num3) / <span class="number">2</span> * <span class="number">2</span>, num6 * <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">return</span> (num3 * <span class="number">3</span> + num2 * <span class="number">2</span> + num6 * <span class="number">6</span> + (cnt - use)) &lt;= <span class="number">1ll</span> * cnt * R;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!(R &amp; <span class="number">1</span>)) <span class="keyword">return</span> <span class="number">1e9</span>;</span><br><span class="line">        <span class="type">int</span> num2 = <span class="number">0</span>, num3 = <span class="number">0</span>, num6 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="type">int</span> tmp = a[i];</span><br><span class="line">            <span class="keyword">if</span>(a[i] &amp; <span class="number">1</span>) num3 ++, tmp -= <span class="number">3</span>;</span><br><span class="line">            num6 += tmp / <span class="number">6</span>;</span><br><span class="line">            tmp %= <span class="number">6</span>;</span><br><span class="line">            num2 += tmp / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">1</span>, r = <span class="number">2000</span> * n, mid, ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt;= r)&#123;</span><br><span class="line">            mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">pd</span>(mid, num2, num3 ,num6)) ans = mid, r = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">assert</span>(ans);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; R;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">min</span>(Solve1::<span class="built_in">solve</span>(), Solve2::<span class="built_in">solve</span>()) &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还有个问题，如果知道了有多少个 $2,3$ ，可以多快知道有多少个桌子数，显然 $O(\log)$ 可以，但是可以线性吗？</p>
<p>我们不妨设 $f(x)$ 表示有 $x$ 张桌子的情况下，将 $3$ 的桌子放进去，最多还能放入多少的 $2$ ，而 $f$ 显然能写成 $O(1)$ 个分段函数相加，且边界可以在 $O(1)$ 的时间处理完，所以一定可以在 $O(1)$ 的时间解决，具体讨论不再赘述。</p>
<p>因此，每个团队至多一个 $3$ 的情况可以在 $O(1)$ 的时间内解决。</p>
<p>同理，每张桌子至多一个 $3$ 的情况，显然此时可以认为 $r$ 为奇数，$r$ 为偶数的情况这种情况肯定不如另一种情况优。</p>
<p>可以先把原来的团队分成：$0/1$ 个 $3$ ，最多的 $6$ 和剩下的 $2$。</p>
<p>设 $f(x)$ 表示有 $x$ 张桌子的话至多能放多少个人，其中 $x\ge 3$ 的个数，因此 $f(x)$ 关于 $x$ 是偶数和奇数分别是分段函数，因此类似上面的，只要肯讨论，也可以在 $O(1)$ 内解决。</p>
<p>综上，该问题可以在 $O(n)$ 时间内解决。</p>
</div></details>]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title>lzqy_ の Strings Round 赛后总结</title>
    <url>/2024/03/21/lzqy-%E3%81%AE-Strings-Round-%E8%B5%9B%E5%90%8E%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="A-好奇心宝宝"><a href="#A-好奇心宝宝" class="headerlink" title="A 好奇心宝宝"></a>A 好奇心宝宝</h1><p><a href="https://www.luogu.com.cn/problem/P10270?contestId=155684">https://www.luogu.com.cn/problem/P10270?contestId=155684</a></p>
<p>题目大意：给一个网格，求两条从左上到右下的路径满足最长公共前缀最短，输出最短公共前缀长度。</p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>显然等价于找 $\{(x,y)|x+y=t\}$ 中最小的 $t$ 满足这个集合中的点的字符集大小 $&gt;1$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e3</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">char</span> st[N][N];</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,st[i]+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n<span class="number">-1</span>+m<span class="number">-1</span>;i++)&#123;</span><br><span class="line">        <span class="type">int</span> pre=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> x=<span class="number">1</span>;x&lt;=i+<span class="number">1</span>;x++)&#123;</span><br><span class="line">            <span class="type">int</span> y=i-(x<span class="number">-1</span>)+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(x&gt;=<span class="number">1</span> &amp;&amp; y&gt;=<span class="number">1</span> &amp;&amp; x&lt;=n &amp;&amp; y&lt;=m)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!pre)pre=st[x][y];</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(pre!=st[x][y])&#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,i);</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,n+m<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></details>
<h1 id="B-漫长悄悄话"><a href="#B-漫长悄悄话" class="headerlink" title="B 漫长悄悄话"></a>B 漫长悄悄话</h1><p><a href="https://www.luogu.com.cn/problem/P10270?contestId=155684">https://www.luogu.com.cn/problem/P10270?contestId=155684</a></p>
<p>题目大意：对于 $i,j$ ，贡献为 $i,j$ 前缀的翻转和后缀的 $LCP$ （四个串的 LCP ），求最大贡献。</p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>等价于找最长的奇数长度回文串满足出现了至少两次。</p>
<p>接下来各显神通了，可以马拉车+Hash，可以回文自动机，也可以Hash+二分。</p>
<p>我用了回文自动机。</p>
<p>Hash+二分的做法详见官方题解：<a href="https://www.luogu.com/article/sfxeve97。（需要用到本质不同的回文串只有至多">https://www.luogu.com/article/sfxeve97。（需要用到本质不同的回文串只有至多</a> $n$ 个的性质）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e3</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">char</span> st[N][N];</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,st[i]+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n<span class="number">-1</span>+m<span class="number">-1</span>;i++)&#123;</span><br><span class="line">        <span class="type">int</span> pre=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> x=<span class="number">1</span>;x&lt;=i+<span class="number">1</span>;x++)&#123;</span><br><span class="line">            <span class="type">int</span> y=i-(x<span class="number">-1</span>)+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(x&gt;=<span class="number">1</span> &amp;&amp; y&gt;=<span class="number">1</span> &amp;&amp; x&lt;=n &amp;&amp; y&lt;=m)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!pre)pre=st[x][y];</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(pre!=st[x][y])&#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,i);</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,n+m<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></details>
<h1 id="C-在四方城外"><a href="#C-在四方城外" class="headerlink" title="C 在四方城外"></a>C 在四方城外</h1><p><a href="https://www.luogu.com.cn/problem/P10272?contestId=155684">https://www.luogu.com.cn/problem/P10272?contestId=155684</a></p>
<p>题目大意：每次操作在 $S$ 后面添加 $S$ 的 mxBd ，求第 $L$ 次操作和第 $R$ 次操作之间所有操作后的字符串长度之和。</p>
<details class="toggle" ><summary class="toggle-button" style="">我的做法</summary><div class="toggle-content"><p>引理 1 ：若 $ST=TS$ ，则 $S,T$ 有相同的整周期。</p>
<p><details class="toggle" ><summary class="toggle-button" style="">情况1：无Bd</summary><div class="toggle-content"><p>若原串的 $mxBd=0$ ，则答案为 $|S|*(r-l+1)$ 。</p>
</div></details></p>
<p><details class="toggle" ><summary class="toggle-button" style="">情况2：有整周期</summary><div class="toggle-content"><p>若原串有最小整周期 $p$ ，那么每次添加的长度必然是：$|S|-p$ ，否则一定会出现下面的情况：</p></p>
<p><img src="1.png" alt=""></p>
<p>那么根据引理，原串存在更小的整周期，矛盾，证毕。</p>
</div></details>
<details class="toggle" ><summary class="toggle-button" style="">情况3：无整周期但有Bd</summary><div class="toggle-content"><p>这里给一些例子：abababababcab 、aaaaaaaba 。</p>
<p>为了方便下面叙述，我们设 $S_m$ 表示第 $m$ 操作后的字符串，$S_0=S$ ，然后设 $T_m=S_m-S,T_m’=(mxBd(S)+T_m)$ ，字符串 $S-T$ 定义为 $S$ 删去 $LCP(S,T)$ 。</p>
<p>显然，$|T_{m+1}|-|T_{m}|=|T’_{m+1}|-|T’_{m}|$ ，$|T_{m+1}|-|T_{m}|\le |T_{m+2}|-|T_{m+1}|$ </p>
<p>接下来先说结论，整个增长过程可以分成两个部分，先是 $|T’_{m+1}|=2|T’_m|$ ，然后 $|T_{m+1}|-|T_m|$ 恒定。</p>
<p>定理 1 ：$|mxBd(T_{m})|\le |T’_{m}|$ 。（显然，归纳一下就行了）</p>
<p>因此，$|T’_{m+1}|\le 2|T’_m|$ 。</p>
<p>定理 2 ： $|T’_{m+1}|&lt;2|T’_m|$ 时，则后面 $|T_{m+1}|-|T_m|$ 恒定。</p>
<p><details class="toggle" ><summary class="toggle-button" style="">证明</summary><div class="toggle-content"><p>设 $U=mxBd(T’_{0})$ 。</p></p>
<p>$T_{m}-T_{m-1},T_{m+1}-T_m$ 是 $S$ 的一个 Bd ，显然 $T_{m}-T_{m-1}$ 是 $T_{m+1}-T_m$ 的一个 Bd 。可以得到 $T’_{0}$ 是 $T_{m+1}-T_m$ 的一个 Bd 。</p>
<p>根据引理 $1$ 可以得到 $U$ 是 $T_{m+1}-T_{m}$ 的最小整周期。</p>
<p>这个时候，可以把 $T’_{m+1},T’_{m}$ 等字符串想象成若干 $U$ 的拼接，显然 $U$ 也是 $T’_{m+1}$ 等字符串的最小整周期，否则最小整周期也是 $U$ 的整周期，与前面矛盾。</p>
<p><img src="3.png" alt=""></p>
<p>则 $|T’_{m+1}|&lt;2|T’_m|$ ，就已经说明了 $S_{m}$ 前面只有 $\frac{|T’_{m+1}|}{|U|}$ 个 $U$ ，没有 $\frac{|T’_{m+1}|}{|U|}+1$ 个 $U$ ，若 $|T_{m+2}|-|T_{m-1}|&gt;|T_{m+2}|-|T_{m-1}|$ ，则与 $U$ 的个数矛盾，证毕。</p>
</div></details>
<p>定理 3 ：若 $|T’_{m+1}|=2|T’_m|$ ，那么 $|T_{m+1}|-|T_{m}|&lt;|S|$。</p>
<details class="toggle" ><summary class="toggle-button" style="">证明</summary><div class="toggle-content"><p>反证法，若 $\ge n$ 。</p>
<p>显然 $T’_{0}$ 是 $T_{m+1}-T_{m}$ 的一个周期，即 $S_{m}$ 一个 $\ge n$ 的 Bd 的周期是 $T’_{0}$ ，注意到 $T’_{0}$ 也出现在 $S$ 的末尾，根据引理 $1$ 知道 $S$ 有整周期，矛盾，证毕。</p>
</div></details>
<p>推论： $m=\left \lfloor \log_2{|S|} \right \rfloor+1$ ，则一定有 $|T’_{m+1}|&lt;2|T’_m|$ 。</p>
<p>于是就有很多种搞法了。</p>
<p>我的方法是直接 Kmp ，注意到长度 $\le 3n$ ，所以时间复杂度为：$O(n\log{n})$ ，空间复杂度为 : $O(n)$ 。</p>
<p>当然，根据上面的证明，有更加快速的搞法：求出 $U$ ，然后从左到右找至多有多少个 $U$ ，这样就可以在 $O(n)$ 的时间解决这个问题了。</p></div></details>
<p>注意：上面的时间复杂度都忽略了快速幂计算答案的时间。</p>
<p>综上，时间复杂度为：$O(n\log{n}+\log{R})$ ，空间复杂度：$O(n)$。</p>
<p>当然，时间复杂度可以优化到：$O(n+\log{R})$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> LL mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e6</span>+<span class="number">5</span>;</span><br><span class="line"><span class="function">LL <span class="title">ksm</span><span class="params">(LL x,LL y)</span></span>&#123;</span><br><span class="line">    LL ans=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(y)&#123;</span><br><span class="line">        <span class="keyword">if</span>(y&amp;<span class="number">1</span>)ans=ans*x%mod;</span><br><span class="line">        x=x*x%mod;y&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">char</span> st[N*<span class="number">3</span>];</span><br><span class="line"><span class="type">int</span> fail[N*<span class="number">3</span>],n;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">gp</span><span class="params">(<span class="type">int</span> len)</span></span>&#123;</span><br><span class="line">    fail[<span class="number">0</span>]=<span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> now=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=len;i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(now!=<span class="number">-1</span> &amp;&amp; st[now+<span class="number">1</span>]!=st[i])now=fail[now];</span><br><span class="line">        fail[i]=++now;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fail[len];</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> len[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,st+<span class="number">1</span>);n=<span class="built_in">strlen</span>(st+<span class="number">1</span>);</span><br><span class="line">    <span class="type">int</span> d=<span class="built_in">gp</span>(n),p=n-d;</span><br><span class="line">    <span class="keyword">if</span>(!d)&#123;</span><br><span class="line">        LL l,r;<span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>,&amp;l,&amp;r);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,(r-l+<span class="number">1</span>)*n%mod);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n%p==<span class="number">0</span>)&#123;</span><br><span class="line">        LL l,r;<span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>,&amp;l,&amp;r);</span><br><span class="line">        LL ans=<span class="built_in">ksm</span>(<span class="number">2</span>,l)*(<span class="built_in">ksm</span>(<span class="number">2</span>,r-l+<span class="number">1</span>)<span class="number">-1</span>+mod)%mod*(n-p)%mod;</span><br><span class="line">        ans=(ans+p*(r-l+<span class="number">1</span>))%mod;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> pred,m=<span class="number">0</span>;</span><br><span class="line">    len[m]=n;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        m++;</span><br><span class="line">        len[m]=len[m<span class="number">-1</span>];</span><br><span class="line">        <span class="built_in">assert</span>(len[m]+d&lt;=n*<span class="number">3</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=d;i++)st[++len[m]]=st[i];</span><br><span class="line">        pred=d;</span><br><span class="line">        d=<span class="built_in">gp</span>(len[m]);</span><br><span class="line">        p=len[m]-d;</span><br><span class="line">    &#125;<span class="keyword">while</span>(d==pred*<span class="number">2</span>);</span><br><span class="line">    <span class="comment">//d is key;</span></span><br><span class="line">    LL l,r;<span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>,&amp;l,&amp;r);</span><br><span class="line">    LL ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=l;i&lt;=m &amp;&amp; i&lt;=r;i++)ans=(ans+len[i])%mod;</span><br><span class="line">    <span class="keyword">if</span>(m&lt;r)&#123;</span><br><span class="line">        l=<span class="built_in">max</span>(l-m,<span class="number">1ll</span>);</span><br><span class="line">        r-=m;</span><br><span class="line">        ans=(ans+len[m]*(r-l+<span class="number">1</span>))%mod;</span><br><span class="line">        ans=(ans+(r+l)*(r-l+<span class="number">1</span>)/<span class="number">2</span>%mod*d)%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>感觉想出这个做法非常花时间啊。</p></div></details>
<details class="toggle" ><summary class="toggle-button" style="">官方题解</summary><div class="toggle-content"><p>官方做法和我的 $O(n)$ 做法没什么区别，区别在于官方题解导出正解的路线非常短。</p>
<p>想想怎么更快的想出正解？</p>
<ol>
<li>首先注意到 $S$ 有整周期（简单的）和没有整周期（不简单的）是两种情况。</li>
<li>其次一个必要条件是足够快的想出引理 $1$ （我的做法有提到）。</li>
<li>然后要有足够的观察力观察到如果设 $U$ 是 $mxBd(S)$ 的最小整周期，那么 $U$ 是这个问题的关键。</li>
<li>需要观察到 $U$ 是每次添加的字符串的整周期（那么显然 $U$ 是最小的整周期），否则可以证明 $mxBd(S)$ 存在更小的整周期。</li>
<li>设 $l$ 是从左到右 $S$ 可以匹配上的 $U$ 的个数，$r$ 是从右到左的，如果 $(l+r-1)*|U|\ge |S|$ ，则可以说明 $S$ 有最小整周期，矛盾。</li>
<li>根据 $4,5$ 就可以得到 $O(n)$ 做法，也可以根据至多 $O(\log)$ 后增速固定，且在这之前字符串长度至多乘 $3$ 倍的性质，想出更加好写的 $O(n\log{n})$ 做法。</li>
</ol>
<p>观察上面过程，在第 $3$ 步之后对我而言比较自然，也就是想要更快的做出这题，更快的想出第 $2,3$ 步是关键。</p>
</div></details>
<h1 id="D-大娱乐至上"><a href="#D-大娱乐至上" class="headerlink" title="D 大娱乐至上"></a>D 大娱乐至上</h1><p>题目链接：<a href="https://www.luogu.com.cn/problem/P10273?contestId=155684">https://www.luogu.com.cn/problem/P10273?contestId=155684</a></p>
<p>题目大意：给你一个字符串，给一堆区间代表子串，问你每个区间能不能在只改变原串一个字母的情况下，使原本给出的小于它的子串现在大于等于它了。</p>
<details class="toggle" ><summary class="toggle-button" style="">我的做法</summary><div class="toggle-content"><p>我考场的第一想法是后缀数组，但非常可惜的是太过答辩，以至于我根本没有时间在考场上品鉴完。</p>
<p>一个简单的思路是：要么改变这个子串，变小一个字母。要么让其余所有原本小于它的给定子串变大，变大一个字母。</p>
<p>基础实现思路：从小到大遍历子串，然后讨论当前这个子串是否可行，如果有多个相同的子串，则同时进行查询即可（即全部询问完后再执行相应的修改操作）。</p>
<p>然后就可以开始讨论了：</p>
<p>不妨设现在考虑的是 $[l_i, r_i]$ ，下面不加说明时，都仅考虑原本小于它的子串 $[l_j, r_j]$ ，设 $lcp(x,y)$ 表示 $x,y$ 后缀的最长公共前缀，同时下面提到的子串都指题目给定的子串。</p>
<p><strong>变小一个字母</strong>（一个基本性质是所有子串只可能变小不可能变大）：</p>
<ol>
<li>显然，如果要让 $[l_i, r_i]$ 小于等于 $[l_j,r_j]$ ，设 $len = min(lcp(l_i, l_j), r_j - l_j + 1, r_i - l_i + 1)$ ，则显然改的字符必须落在 $[l_i, l_i + len - 1]$ 。</li>
<li>同时如果改的字符同时落在 $[l_i, r_i]$ 和 $[l_j, r_j]$ ，那么显然必须有：$l_i &gt; l_j$ ，即如果有 $l_j \ge l_i$ 的话，修改的位置不能在 $[l_i,r_i]\cap [l_j,r_j]$ ，同时根据上一条可以知道，修改的位置不可能在 $l_j$ 之后，即落点只能落在 $[l_i, l_j - 1]$ 。（可以发现，找到右边最近的 $l_j$ 给个约束就行了，可以用单调栈预处理达到 $O(n)$ ）</li>
</ol>
<p>这样就可以得到修改的位置必须落在的区间，而且根据上面的讨论，不难发现只要落在这个区间，直接改到 $&lt;a$ 就可以符合要求了，即这个区间有可改的位置是改小可行的充要条件。</p>
<p>现在问题是，第一点怎么实现？</p>
<p>假设小于等于 $[l_i,r_i]$ 的子串（包括自己）中 $l$ 后缀 rank 最大为 $k$ ，同时所有给定的字符串中 rank 最小的 $l$ 的 rk 为 $smallrk$ 。</p>
<p>那么第一点的限制可以写成 $min(lcp(sa[smallrk],l),r_{j}-l_{j}+1(\forall j : [l_j,r_j]\le [l_i,r_i]))$ ，这样就可以维护了，具体实现中，还可以将 $lcp(sa[smallrk],l)$ 换成 $lcp(sa[k],l)$ ，因为显然 $lcp(sa[smallrk],sa[k])\ge min(r_{j}-l_{j}+1(\forall j : [l_j,r_j]\le [l_i,r_i]))$ 。</p>
<p>可以在询问的过程中一起维护，时间复杂度 $O(n)$ 。</p>
<p><strong>变大一个字母</strong>（一个基本性质是所有子串只可能变大不可能变小）：</p>
<ol>
<li>需要让这个位置落在所有 $[l_j,r_j]$ $([l_j,r_j]&lt;[l_i,r_i])$ 。（很容易 $O(n)$ 处理）</li>
<li>如果要让 $[l_i, r_i]$ 小于等于 $[l_j,r_j]$ ，则显然改的字符必须落在 $[l_j, l_j + lcp(l_i, l_j)]$ 。</li>
<li>如果要让 $[l_i, r_i]$ 小于等于 $[l_j,r_j]$ ，则显然改的字符必须落在 $[l_j, l_j + (r_i - l_i + 1) - 1]$ 。（很容易 $O(n)$ 处理）</li>
<li>若 $\exists j : l_j \le l_i ,[l_j,r_j] &lt;[l_i,r_i]$ ，则显然修改位置不能落在 $[l_i,r_i]$ ，否则 $[l_i,r_i]$ 的增大程度大于 $[l_j,r_j]$ 。（很容易 $O(n)$ 处理）</li>
</ol>
<p>这样就可以得到修改的位置必须落在的区间，而且根据上面的讨论，不难发现只要落在这个区间，直接改到 $&gt;z$ 就可以符合要求了，即这个区间有可改的位置是改大可行的充要条件。</p>
<p>现在问题是，第二点怎么实现？毕竟 $rk[l_i]$ 可以跳上跳下的 ，因此维护 $lcp(l_i,l_j)$ 是个很困难的事情。</p>
<p>假设大于等于 $[l_i,r_i]$ 的子串（包括自己）中 $l$ 后缀 rank 最大为 $k$ 。</p>
<p>那么实际上只需要考虑 $j:[l_j,r_j]&lt;[l_i,r_i],rk(l_j)&lt;k$ ，且 $lcp$ 只需要考虑 $lcp(l_j,sa[k])$ ，原因是这样子改的影响一定可以被其余三点消掉。（一个基本的事实是：若 $rk[l_i]\ge rk[l_j]$，但 $[l_i,r_i]\le[l_j,r_j]$ ，那么 $[l_i,r_i]$ 一定是 $[l_j,r_j]$ 的前缀）</p>
<p>这样子的好处是可以用一个栈轻松实现这个过程。</p>
<p>综上，在对子串排序后，所有的讨论都可以在线性的时间解决。</p>
<p>时间复杂度：$O(n\log{n})$</p>
<p>空间复杂度：$O(n\log{n})$</p>
<p>我的代码实现细节和上述实现不完全相同，但是思路是一致的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> SN = <span class="number">20</span>;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">char</span> ss[N],ch[N];</span><br><span class="line"><span class="type">char</span> ans[N];</span><br><span class="line">set&lt;<span class="type">int</span>&gt; chp;<span class="comment">//change pos</span></span><br><span class="line"><span class="function">PII <span class="title">getcp</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    PII x = &#123;n+<span class="number">1</span>, n+<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">if</span>(l&gt;r)<span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">auto</span> tmp = chp.<span class="built_in">lower_bound</span>(l);</span><br><span class="line">    <span class="keyword">if</span>(tmp != chp.<span class="built_in">end</span>()) x.first = *tmp;</span><br><span class="line">    tmp = chp.<span class="built_in">upper_bound</span>(r);</span><br><span class="line">    <span class="keyword">if</span>(tmp != chp.<span class="built_in">begin</span>())&#123;</span><br><span class="line">        tmp--;</span><br><span class="line">        x.second = *tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(x.first &gt; r) x.first = n + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x.second &lt; l) x.second = n + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> SA&#123;</span><br><span class="line">    <span class="type">int</span> cc[N],sa[N],xx[N],yy[N],top,V;</span><br><span class="line">    <span class="type">int</span> rk[N],height[N],h[N];</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">getsa</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//need clear : height,h</span></span><br><span class="line">        V=<span class="number">26</span>;<span class="built_in">memset</span>(cc+<span class="number">1</span>,<span class="number">0</span>,V&lt;&lt;<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)cc[xx[i]=ss[i]-<span class="string">&#x27;a&#x27;</span>+<span class="number">1</span>]++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=V;i++)cc[i]+=cc[i<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=n;i&gt;=<span class="number">1</span>;i--)sa[cc[xx[i]]--]=i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;n;k&lt;&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">            top=<span class="number">0</span>;<span class="keyword">for</span>(<span class="type">int</span> i=n;i&gt;n-k;i--)yy[++top]=i;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(sa[i]&gt;k)yy[++top]=sa[i]-k;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">memset</span>(cc+<span class="number">1</span>,<span class="number">0</span>,V&lt;&lt;<span class="number">2</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)cc[xx[i]]++;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=V;i++)cc[i]+=cc[i<span class="number">-1</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=n;i&gt;=<span class="number">1</span>;i--)sa[cc[xx[yy[i]]]--]=yy[i];</span><br><span class="line">            <span class="built_in">swap</span>(xx,yy);</span><br><span class="line">            V=xx[sa[<span class="number">1</span>]]=<span class="number">1</span>;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)xx[sa[i]]=V+=!(sa[i]+k&lt;=n &amp;&amp; sa[i<span class="number">-1</span>]+k&lt;=n &amp;&amp; yy[sa[i]]==yy[sa[i<span class="number">-1</span>]] &amp;&amp; yy[sa[i]+k]==yy[sa[i<span class="number">-1</span>]+k]);</span><br><span class="line">            <span class="keyword">if</span>(V==n)<span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)rk[sa[i]]=i;</span><br><span class="line">        <span class="type">int</span> now=<span class="number">0</span>;ss[n+<span class="number">1</span>]=<span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(now)now--;</span><br><span class="line">            <span class="keyword">if</span>(rk[i]==<span class="number">1</span>)<span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">while</span>(ss[i+now]==ss[sa[rk[i]<span class="number">-1</span>]+now])now++;</span><br><span class="line">            h[i]=now;height[rk[i]]=now;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> rmq[SN][N];</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init_rmq</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)rmq[<span class="number">0</span>][i]=height[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">19</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=n-(<span class="number">1</span>&lt;&lt;i)+<span class="number">1</span>;j&gt;=<span class="number">1</span>;j--)rmq[i][j]=<span class="built_in">min</span>(rmq[i<span class="number">-1</span>][j],rmq[i<span class="number">-1</span>][j+(<span class="number">1</span>&lt;&lt;(i<span class="number">-1</span>))]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getrmq</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> z=__lg(y-x+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">min</span>(rmq[z][x],rmq[z][y-(<span class="number">1</span>&lt;&lt;z)+<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getlcp</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x==y)<span class="keyword">return</span> n-x+<span class="number">1</span>;</span><br><span class="line">        x=rk[x];y=rk[y];</span><br><span class="line">        <span class="keyword">if</span>(x&gt;y)<span class="built_in">swap</span>(x,y);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">getrmq</span>(x+<span class="number">1</span>,y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> SA::getsa;</span><br><span class="line"><span class="keyword">using</span> SA::init_rmq;</span><br><span class="line"><span class="keyword">using</span> SA::getlcp;</span><br><span class="line"><span class="keyword">using</span> SA::height;</span><br><span class="line"><span class="keyword">using</span> SA::sa;</span><br><span class="line"><span class="keyword">using</span> SA::rk;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> ql[N],qr[N],qlen[N],id[N];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>&#123;<span class="comment">//x&lt;y;</span></span><br><span class="line">    <span class="type">int</span> k=<span class="built_in">getlcp</span>(ql[x], ql[y]);</span><br><span class="line">    <span class="keyword">if</span>(qlen[x] &lt;= k || qlen[y] &lt;= k) <span class="keyword">return</span> qlen[x] &lt; qlen[y];</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> ss[ql[x] + k] &lt; ss[ql[y] + k];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//small square</span></span><br><span class="line"><span class="type">int</span> smallrk,minlen;</span><br><span class="line">set&lt;<span class="type">int</span>&gt; banp;<span class="comment">//ban pos</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//big square</span></span><br><span class="line"><span class="type">int</span> minl, maxl;</span><br><span class="line">PII stk[N];<span class="type">int</span> top;</span><br><span class="line"><span class="type">int</span> maxrk,rp;</span><br><span class="line">multiset&lt;<span class="type">int</span>&gt; querypos;</span><br><span class="line"><span class="type">bool</span> v[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    cin &gt;&gt; ss+<span class="number">1</span> &gt;&gt; ch+<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">getsa</span>();</span><br><span class="line">    <span class="built_in">init_rmq</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ch[i] == <span class="string">&#x27;1&#x27;</span>) chp.<span class="built_in">insert</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">        cin &gt;&gt; ql[i] &gt;&gt; qr[i];</span><br><span class="line">        qlen[i] = qr[i] - ql[i] + <span class="number">1</span>;</span><br><span class="line">        id[i] = i;</span><br><span class="line">        ans[i] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        querypos.<span class="built_in">insert</span>(rk[ql[i]]);</span><br><span class="line">        v[ql[i]] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(id + <span class="number">1</span>, id + m +<span class="number">1</span>, cmp);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//small init</span></span><br><span class="line">    minlen = smallrk = n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)smallrk = <span class="built_in">min</span>(smallrk, rk[ql[i]]);</span><br><span class="line">    <span class="comment">//max init</span></span><br><span class="line">    maxrk = maxl = <span class="number">1</span>;</span><br><span class="line">    minl = n + <span class="number">1</span>;</span><br><span class="line">    rp = n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> tl = <span class="number">1</span>; tl &lt;= m; tl++)&#123;</span><br><span class="line">        <span class="type">int</span> tr = tl;</span><br><span class="line">        <span class="keyword">while</span>(tr &lt; m &amp;&amp; <span class="built_in">getlcp</span>(ql[id[tl]], ql[id[tr + <span class="number">1</span>]]) &gt;= qlen[id[tl]] &amp;&amp;</span><br><span class="line">            <span class="built_in">getlcp</span>(ql[id[tl]], ql[id[tr + <span class="number">1</span>]]) &gt;= qlen[id[tr + <span class="number">1</span>]] &amp;&amp; qlen[id[tl]] == qlen[id[tr + <span class="number">1</span>]]) tr++;</span><br><span class="line">        <span class="keyword">if</span>(tl == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = tl; i &lt;= tr; i++) ans[id[i]] = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = tl; i &lt;= tr; i++)&#123;</span><br><span class="line">            <span class="comment">//small change</span></span><br><span class="line">            <span class="type">int</span> x = id[i];</span><br><span class="line">            <span class="type">int</span> l = ql[x], r = qr[x];</span><br><span class="line">            <span class="keyword">while</span>(rk[l] &gt; smallrk)&#123;</span><br><span class="line">                smallrk++;</span><br><span class="line">                minlen = <span class="built_in">min</span>(minlen, height[smallrk] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            minlen = <span class="built_in">min</span>(minlen, qlen[x]);</span><br><span class="line">            <span class="comment">//big change</span></span><br><span class="line">            <span class="keyword">while</span>((*querypos.<span class="built_in">begin</span>()) &gt; maxrk)&#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(v[sa[maxrk]])&#123;</span><br><span class="line">                    <span class="type">int</span> pos = sa[maxrk];</span><br><span class="line">                    stk[++top] = &#123;pos, n - pos + <span class="number">1</span>&#125;;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                maxrk++;</span><br><span class="line">                <span class="type">int</span> tmp = height[maxrk] + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(top &amp;&amp; stk[top].second &gt; tmp)&#123;</span><br><span class="line">                    PII y = stk[top];</span><br><span class="line">                    <span class="keyword">while</span>(top &amp;&amp; stk[top].second &gt;= tmp)&#123;</span><br><span class="line">                        y.first = <span class="built_in">min</span>(y.first, stk[top].first);</span><br><span class="line">                        top--;</span><br><span class="line">                    &#125;</span><br><span class="line">                    y.second = tmp;</span><br><span class="line">                    stk[++top] = y;</span><br><span class="line"></span><br><span class="line">                    rp = <span class="built_in">min</span>(rp, y.first + y.second - <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = tl; i &lt;= tr; i++)&#123;</span><br><span class="line">            <span class="type">int</span> x = id[i];</span><br><span class="line">            <span class="type">int</span> l = ql[x], r = qr[x];</span><br><span class="line">            <span class="comment">//small query</span></span><br><span class="line">            <span class="keyword">if</span>(minlen)&#123;</span><br><span class="line">                <span class="type">int</span> rban= n + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">auto</span> tmp=banp.<span class="built_in">lower_bound</span>(l);</span><br><span class="line">                <span class="keyword">if</span>(tmp != banp.<span class="built_in">end</span>()) rban = *tmp;</span><br><span class="line">                <span class="keyword">auto</span> [al, ar] = <span class="built_in">getcp</span>(l, <span class="built_in">min</span>(rban - <span class="number">1</span>, l + minlen - <span class="number">1</span>));</span><br><span class="line">                <span class="keyword">if</span>(al != n + <span class="number">1</span>) ans[x] = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//big query</span></span><br><span class="line">            <span class="keyword">if</span>(maxl &lt;= <span class="built_in">min</span>(rp, minl + qlen[x] - <span class="number">1</span>))&#123;</span><br><span class="line">                <span class="keyword">auto</span> [al, ar] = <span class="built_in">getcp</span>(maxl, <span class="built_in">min</span>(rp, minl + qlen[x] - <span class="number">1</span>));</span><br><span class="line">                <span class="keyword">if</span>(al&lt;l) ans[x] = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">                <span class="keyword">if</span>(minl &gt; l &amp;&amp; ar != n + <span class="number">1</span>) ans[x] = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = tl; i &lt;= tr; i++)&#123;</span><br><span class="line">            <span class="type">int</span> x = id[i];</span><br><span class="line">            <span class="type">int</span> l = ql[x], r = qr[x];</span><br><span class="line">            <span class="comment">//small change</span></span><br><span class="line">            banp.<span class="built_in">insert</span>(l);</span><br><span class="line">            <span class="comment">//big change</span></span><br><span class="line">            querypos.<span class="built_in">erase</span>(querypos.<span class="built_in">find</span>(rk[l]));</span><br><span class="line">            </span><br><span class="line">            minl = <span class="built_in">min</span>(minl, l);</span><br><span class="line">            maxl = <span class="built_in">max</span>(maxl, l);</span><br><span class="line"></span><br><span class="line">            rp = <span class="built_in">min</span>(rp, r);</span><br><span class="line">        &#125;</span><br><span class="line">        tl = tr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; ans + <span class="number">1</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>能不能再快一点？空间能不能再小一点？</p>
<p>答案是可以的，首先后缀数组换成 SA-IS ，但即使换成 $O(n)-O(1)$ RMQ 排序也要 $O(n\log{n})$ ，如何处理呢？</p>
<p>注意到一个事情，排序的时候只关注子串是什么，而不关注子串的位置，因此只要我们能给每一个子串，找到最小的以该子串为前缀的后缀即可，做法也很简单：</p>
<p>将 height 从大到小跑，然后用并查集维护连接起来的一块，然后每次把一个子串送到所在连通块中排名最小的后缀即可。</p>
<p>这样就能在 $O(n\alpha(n))$ 时间排序完毕，再算上 $O(n)$ 的讨论，理论上能做到的最优复杂度：</p>
<p>时间复杂度：$O(n\alpha(n)))$ </p>
<p>空间复杂度：$O(n)$ </p>
</div></details>]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>后缀数组</tag>
        <tag>总结</tag>
        <tag>后缀自动机</tag>
      </tags>
  </entry>
  <entry>
    <title>tag说明</title>
    <url>/2023/09/04/tag%E8%AF%B4%E6%98%8E/</url>
    <content><![CDATA[<p>帮助更好的使用本网站的 tag 找到你想找到的内容。</p>
<details class="toggle" ><summary class="toggle-button" style="">字典序</summary><div class="toggle-content"><p>这里你会看到各种处理题目中最小字典序要求的做法，例如 DP 题要求最小字典序，字符串要求最小字典序等等。</p>
</div></details>
<details class="toggle" ><summary class="toggle-button" style="">感觉</summary><div class="toggle-content"><p>依赖感觉的题目，难以证明。</p>
</div></details>]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>ACM杂类</tag>
      </tags>
  </entry>
  <entry>
    <title>一句话题解.md</title>
    <url>/2023/08/22/%E4%B8%80%E5%8F%A5%E8%AF%9D%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<ol>
<li>UR 2 猪猪侠再战括号序列：<a href="https://uoj.ac/problem/31">https://uoj.ac/problem/31</a> 。</li>
<li>UR 3 核聚变反应强度：<a href="https://uoj.ac/problem/48">https://uoj.ac/problem/48</a> 。做法：把 $a_1$ 所有质因数找出来判一下就行了，时间复杂度：$O(n\log{V}+\sqrt{V})$ 。</li>
<li>ECNU 2023.8 A Extra Large Knapsack：<a href="https://acm.ecnu.edu.cn/contest/695/problem/A/">https://acm.ecnu.edu.cn/contest/695/problem/A/</a> 显然所有数字的异或和必须为 $0$ ，然后随便拉出一个数字出来就行了，记得特判 $n=1$ 的情况。</li>
<li>UR 8 赴京赶考：<a href="https://uoj.ac/problem/118">https://uoj.ac/problem/118</a> ，想想网格图长成啥样就知道怎么做了，时间复杂度：$O(n+m+q)$ 。</li>
</ol>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>杂题</tag>
      </tags>
  </entry>
  <entry>
    <title>博客食用指北</title>
    <url>/2024/01/19/%E5%8D%9A%E5%AE%A2%E9%A3%9F%E7%94%A8%E6%8C%87%E5%8C%97/</url>
    <content><![CDATA[<p>我写博客有以下目的：</p>
<ol>
<li><strong>帮助我重新梳理一遍做法。</strong>（必要）（我自己写过的博客一般是不会自己再看一遍的，所以复习作用很小，更多的作用是帮助梳理）</li>
<li><strong>锻炼自己用简短语言描述做法的能力。</strong>（重要）（打ACM被队友吐槽表达能力不行，而且能简洁说明的事情为啥要长篇大论，还能节省写博客的时间）</li>
<li><strong>用更加标准公式化的方式描述做法，比如把某个题的做法和其他题目联系起来，总结成一类做法。</strong>（重要）（有助于能力提升）</li>
<li><strong>尝试扩展题目以及做法，学习更多的做法。</strong>（适当）（因为有些做法和题目就是没法扩展的，强行扩展可能浪费时间，但收益还行，学习做法这个事情也是两面的，有点显然，缺点是浪费时间，很多时候某些复杂做法其实就是简单做法的同构，但是需要等到看了很久才能发现这一点，这就会浪费很多时间，尤其是数据结构题）</li>
<li><strong>让读者看懂。</strong>（最次）（我的博客首先肯定是基于我自己再看一遍能懂的，所以肯定阅读门槛就是我自己的水平，或者比自己再弱一点的水平，如果你不能看懂请移步别人的博客。因为我写博客的初衷就是为了自己的提升，当作自己的笔记本用的，而不是造福广大OIer的。当然，如果几乎大部分人都看不懂的话我就有必要反思自己的语言表达能力了）</li>
</ol>
<p>至于第5条，对我自己最重要的警告就是，写博客要明白什么东西是要写的，什么东西是不用写的（我一定懂的），深刻明白这一点能够节省我很多时间，最大化博客对我的作用。（毕竟我之前经常放弃写博客的原因就是浪费时间，而且我写博客一贯的作风就是冗杂，对读者对我都不好，这点一定要改）</p>
<p>一个经典的例子是：一个题目有很多证明，不需要什么证明都写，写一两个个人认为最优美的证明就行了。不否认每个证明都有其自己的价值，但实际上有很多证明我自己心里也清楚，我绝对不会再想看他第二次了，感觉不如 ** 证明。（有很多做法的情况也是同理）</p>
<p>至于反思总结的工作，我会自己在本地机子上用excel编写，写在博客上一来我自己不会看，而且多篇博客的形式很不方便重新浏览这些总结，二来这些极具个人色彩的东西放在博客里也十分影响观感，而写在excel上清晰明了，方便反复查看，作用最大化。</p>
<p>比较简单的题目不会写博客，有时候可能会提一嘴。</p>
<p>附录：</p>
<ol>
<li>官方题解的部分不仅会解释官方题解，某些题目还会额外的思考：究竟如何思考这道题目，才能更快的想出做法。（思考如何正确的思考）</li>
<li>一场比赛的题目有时候会在比赛总结里面统一讲解，不会单独开一个博客单独讲解。</li>
</ol>
<h1 id="暂未解决"><a href="#暂未解决" class="headerlink" title="暂未解决"></a>暂未解决</h1><p>按照如下步骤进行：</p>
<ol>
<li>在文章的小标题（不是文章标题）中使用“坑”的标记。（结合第二条方便定位在文章中的位置）</li>
<li>在博客“待解决”中加入需要解决的事宜。（方便定位）</li>
<li>在本地机子的计划中写上期望解决的日期，到达这个日期就就将这个“坑”的解决提上日程。</li>
</ol>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>ACM杂类</tag>
      </tags>
  </entry>
  <entry>
    <title>五边形数定理学习笔记</title>
    <url>/2024/01/29/%E4%BA%94%E8%BE%B9%E5%BD%A2%E6%95%B0%E5%AE%9A%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<script type="math/tex; mode=display">\prod\limits_{i=1}^{\infty}(1-x^i)=\sum\limits_{k=-\infty}^{\infty}(-1)^{k}x^{\frac{k(3k-1)}{2}}=1+\sum\limits_{k=1}^{\infty}(-1)^{k}x^{\frac{k(3k\pm 1)}{2}}</script><details class="toggle" ><summary class="toggle-button" style="">证明</summary><div class="toggle-content"><p>这个证明太厉害了，拍案叫绝。</p>
<p>首先，不难发现，$x^i$ 的系数是：偶数个不同正整数的拆分数的方案-奇数个不同正整数的拆分数的方案。</p>
<p>所以要证明这个定理就得找到一个关于偶数拆分和奇数拆的双射。</p>
<p>现在用一个点阵表示一个拆分，考虑把拆分数从大到小排序，然后第 $i$ 行的点的数量表示数的大小。（这玩意又叫Ferrers图）</p>
<p>下面是拆分：$6,5,3,1$ 的例子。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0 0 0 0 0 0</span><br><span class="line">0 0 0 0 0</span><br><span class="line">0 0 0</span><br><span class="line">0</span><br></pre></td></tr></table></figure>
<p>考虑把最下面一行点的数量，也就是最小的数字设为 $s$ ，最右边 $45$ 度斜线的点的数量设为 $m$ 。</p>
<p>为了方便理解，对上面那个例子做了标记，$1$ 表示 $s$ ，$2$ 表示 $m$。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0 0 0 0 0 2</span><br><span class="line">0 0 0 0 2</span><br><span class="line">0 0 0</span><br><span class="line">1</span><br></pre></td></tr></table></figure>
<p>如果 $s&gt;m$ 就把 $m$ 个元素放到最下面一行，否则把 $s$ 个元素放到 $m$ 个元素右边。</p>
<p>例如上面那个例子就是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0 0 0 0 0 2 1</span><br><span class="line">0 0 0 0 2</span><br><span class="line">0 0 0</span><br></pre></td></tr></table></figure>
<p>可以发现，这大部分情况下是一个双射，但是有一些特殊情况：</p>
<ol>
<li>$s=m+1$ ，同时拆分数的数字个数也就恰好 $m$ 个，这个时候如果拆出来就会有相同的两行：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0 0 0 0</span><br><span class="line">0 0 0</span><br></pre></td></tr></table></figure>
这个时候数字总数为 ：$\frac{m(3m+1)}{2}$ ，系数为 $(-1)^m$ 。</li>
<li>$s=m$ ，同时拆分数的数字个数也就恰好 $m$ 个：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0 0 0</span><br><span class="line">0 0</span><br></pre></td></tr></table></figure>
这个时候数字总数为 ：$\frac{m(3m-1)}{2}$ ，系数为 $(-1)^m$ 。</li>
</ol>
<p>综上，结论得证，证毕。</p>
<p>这个证明真的是太优美了。</p>
</div></details>
<p>参考资料：<a href="https://blog.csdn.net/visit_world/article/details/52734860">https://blog.csdn.net/visit_world/article/details/52734860</a></p>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>五边形数定理</tag>
        <tag>组合数学</tag>
      </tags>
  </entry>
  <entry>
    <title>卡常的辅助方法</title>
    <url>/2024/02/20/%E5%8D%A1%E5%B8%B8%E7%9A%84%E8%BE%85%E5%8A%A9%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<ol>
<li><p>使用能够测量代码时间的代码辅助卡常。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> begin = std::chrono::high_resolution_clock::<span class="built_in">now</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> end = std::chrono::high_resolution_clock::<span class="built_in">now</span>();</span><br><span class="line"><span class="keyword">auto</span> elapsed = std::chrono::<span class="built_in">duration_cast</span>&lt;std::chrono::nanoseconds&gt;(end - begin);</span><br><span class="line">cerr &lt;&lt; B &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; elapsed.<span class="built_in">count</span>() * <span class="number">1e-9</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br></pre></td></tr></table></figure></li>
<li>警告：别开O3，那不真实，万一比赛ban了O3你就完了，老老实实卡常，练习卡常技巧。</li>
</ol>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>卡常</tag>
      </tags>
  </entry>
  <entry>
    <title>可以尝试解决的题目</title>
    <url>/2023/09/04/%E5%8F%AF%E4%BB%A5%E5%B0%9D%E8%AF%95%E8%A7%A3%E5%86%B3%E7%9A%84%E9%A2%98%E7%9B%AE/</url>
    <content><![CDATA[<ol>
<li><a href="https://acm.ecnu.edu.cn/contest/695/problem/E/">https://acm.ecnu.edu.cn/contest/695/problem/E/</a></li>
</ol>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>杂题</tag>
        <tag>待解决</tag>
      </tags>
  </entry>
  <entry>
    <title>实验</title>
    <url>/2023/08/08/%E5%AE%9E%E9%AA%8C/</url>
    <content><![CDATA[<h1 id="喜"><a href="#喜" class="headerlink" title="喜"></a>喜</h1><h2 id="怒"><a href="#怒" class="headerlink" title="怒"></a>怒</h2><h3 id="哀"><a href="#哀" class="headerlink" title="哀"></a>哀</h3><h2 id="乐"><a href="#乐" class="headerlink" title="乐"></a>乐</h2><h1 id="典"><a href="#典" class="headerlink" title="典"></a>典</h1><p>$a_{i}=1$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>$good$<br>good</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hello world.</span><br></pre></td></tr></table></figure>
<p><img src="1.png" alt="1.png"></p>
<p>😀</p>
<div class="tabs" id="test1"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test1-1">test1 1</button></li><li class="tab"><button type="button" data-href="#test1-2">test1 2</button></li><li class="tab"><button type="button" data-href="#test1-3">test1 3</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test1-1"><p><strong>This is Tab 1.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-2"><p><strong>This is Tab 2.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-3"><p><strong>This is Tab 3.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>
<p>现在已经知道 hidetoggle 和代码块嵌套会导致渲染出错。</p>
<p>解决方法为在每层嵌套中间加句号。</p>
<details class="toggle" ><summary class="toggle-button" style="">1</summary><div class="toggle-content"><p>。</p>
<p><details class="toggle" ><summary class="toggle-button" style="">2</summary><div class="toggle-content"><p>。</p></p>
<p><details class="toggle" ><summary class="toggle-button" style="">3</summary><div class="toggle-content"><p>。</p>
</div></details></p>
<p>。</p></div></details>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>。</p></div></details>
<details class="toggle" ><summary class="toggle-button" style="">1</summary><div class="toggle-content"><p><details class="toggle" ><summary class="toggle-button" style="">2</summary><div class="toggle-content"><details class="toggle" ><summary class="toggle-button" style="">3</summary><div class="toggle-content"></div></details>&lt;/div&gt;&lt;/details&gt;<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br></pre></td></tr></table></figure></p>
</div></details>]]></content>
      <categories>
        <category>杂项</category>
      </categories>
  </entry>
  <entry>
    <title>小凯的疑惑</title>
    <url>/2024/05/29/%E5%B0%8F%E5%87%AF%E7%9A%84%E7%96%91%E6%83%91/</url>
    <content><![CDATA[<p>题目链接：<a href="https://www.luogu.com.cn/problem/P3951">https://www.luogu.com.cn/problem/P3951</a></p>
<p>题目大意：给你两个互质的整数 $a,b$ ，求最大的不能由 $ka+tb$ 表示的数字，其中 $k,t$ 非负。</p>
<p>看到一个很好的解法，这里写一下。</p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>需要明白，不定方程和同余方程本质是一样的。</p>
<p>从同余方程的角度考虑，$ka\equiv x\mod{b}$ ，不妨令 $0\le k \le b-1$ ，那么 $x$ 能够表示的充要条件是 $\frac{x-ka}{b}\ge 0$ ，因此直接令 $k=b-1,\frac{x-ka}{b}=-1$ 就可以得到最大的不能被表示的数字：$ab-a-b$ 。</p>
<p>当然也可以从不定方程的角度考虑，对于任意一组解：$ka+tb=x$ ，则 $(k-b)a+(t+a)b=x$ ，所以不妨令 $0\le k\le b-1$ （即找到最小的非负的 $k$），然后能表示当且仅当 $t\ge 0$ ，所以令 $k=b-1,t=-1$ 就行了。</p>
<p>可以看到，这两个做法几乎一样，本质上是相同的。因此在做题目的时候，可以哪个角度好想就从哪个角度想。</p>
</div></details>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
  </entry>
  <entry>
    <title>待解决</title>
    <url>/2024/01/20/%E5%BE%85%E8%A7%A3%E5%86%B3/</url>
    <content><![CDATA[<p>学习书籍 《A course in combinatorial optimization》，在网上突然看到的，感觉这一本书还是很有学习的必要的。</p>
<ol>
<li>“MEXimum Spanning Tree” 中的根号做法是什么。（解决条件：学会 Hopcroft Karp 的复杂度分析）</li>
<li>“拟阵学习笔记”：<ol>
<li>匹配拟阵交换性的证明。（用增广路的证明）</li>
<li>用基的定义能不能再弱一点。</li>
<li>带权拟阵交。</li>
<li>学习剩下的内容。</li>
</ol>
</li>
<li>Game of Connect(Shannon’s Switching Game) 学会 Shannon’s Switching Game 。</li>
<li>Graffiti 那个dp分块到底是哪一年提高组初赛的题目。</li>
<li>Not Intersect 的生成函数做法。</li>
<li>The 2nd Ucup Stage 2: SPb M. Hardcore String Counting 写代码</li>
</ol>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>ACM杂类</tag>
      </tags>
  </entry>
  <entry>
    <title>感悟</title>
    <url>/2023/09/01/%E6%84%9F%E6%82%9F/</url>
    <content><![CDATA[<ol>
<li>锻炼在写 DP 之前先把转移方程写出来的能力，方便自己写代码，也方便队友 Debug ，还有就是变量名一定要和代码中的是一样的。</li>
<li>要多锻炼动笔想题的能力，防止一动笔脑子就宕机。</li>
<li>赛时只要证明了做法是对的就直接写，赛后可以思考一下更加优美的证明，但是不要太久，思考太久的话还不如直接去多做几道题目。</li>
<li>即使 AC 了题目，也要看看题解，因为题解中可能会有值得学习的点，如果一直沉浸在自己的世界，不去接受一些别人的东西，进步起来是非常慢的。</li>
</ol>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>ACM杂类</tag>
      </tags>
  </entry>
  <entry>
    <title>楼房重建</title>
    <url>/2024/03/20/%E6%A5%BC%E6%88%BF%E9%87%8D%E5%BB%BA/</url>
    <content><![CDATA[<p>题目链接：<a href="https://www.luogu.com.cn/problem/P4198">https://www.luogu.com.cn/problem/P4198</a></p>
<p>题目大意：维护有多少个不同的前缀最大值（相同数值但是位置更靠后的认为更大且两数不同，即认为每个数字加上与位置成正比的浮动）</p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>非常经典的题目，众所周知，信息学有一类题目的出题方法就是打破常规。</p>
<p>这道题目就是个经典的打破常规的题目，当然你也可以从别的角度去看他。</p>
<p>正常的线段树 updata 都是 $O(1)$ 的，但是这道题目的 updata 是 $\log$ 的。</p>
<p>更详细的来说，维护这么一个函数 $g(x,k)$ ，能够维护 $x$ 所管理的区间中 $\ge k$ 的不同前缀最大值个数。</p>
<p>这个函数可以 $\log$ ，当左区间的最大值 $&lt;k$ ，那么直接去右区间，左区间贡献为 $0$ 。否则，说明考虑左区间的话，对右区间的不同前缀最大值没有影响，直接去左区间就行了，而右区间的贡献就是 $x$ 的不同前缀最大值个数，减去左儿子的。（满足可减性）</p>
<p>用这个函数可以在 $\log$ 的时间轻松实现 updata ，这样就可以在 $O(\log^2)$ 的时间解决这个问题。</p>
<p>显然，这个做法还能轻松实现区间不同的前缀最大值个数。</p>
<p>时间复杂度： $O(n+q\log^2n)$ 。</p>
<p>空间复杂度： $O(n)$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> NN=<span class="number">2e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> eps=<span class="number">1e-8</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Fac</span>&#123;LL a,b;&#125;;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>&lt;(Fac x,Fac y)&#123;<span class="keyword">return</span> x.a*y.b&lt;x.b*y.a;&#125;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>&lt;=(Fac x,Fac y)&#123;<span class="keyword">return</span> !(y&lt;x);&#125;</span><br><span class="line">Fac a[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> lc,rc,c;</span><br><span class="line">    Fac mx;</span><br><span class="line">&#125;tr[NN];<span class="type">int</span> len;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">findans</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> l,<span class="type">int</span> r,Fac k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l==r)<span class="keyword">return</span> k&lt;=tr[x].mx &amp;&amp; tr[x].mx.a;</span><br><span class="line">    <span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(tr[tr[x].lc].mx&lt;k)<span class="keyword">return</span> <span class="built_in">findans</span>(tr[x].rc,mid+<span class="number">1</span>,r,k);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> tr[x].c-tr[tr[x].lc].c+<span class="built_in">findans</span>(tr[x].lc,l,mid,k);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">updata</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> l,<span class="type">int</span> mid,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(tr[x].lc &amp;&amp; tr[x].rc);</span><br><span class="line">    tr[x].mx=<span class="built_in">max</span>(tr[tr[x].lc].mx,tr[tr[x].rc].mx);</span><br><span class="line">    tr[x].c=tr[tr[x].lc].c+<span class="built_in">findans</span>(tr[x].rc,mid+<span class="number">1</span>,r,tr[tr[x].lc].mx);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bt</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> x=++len;</span><br><span class="line">    <span class="keyword">if</span>(l&lt;r)&#123;</span><br><span class="line">        <span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        tr[x].lc=<span class="built_in">bt</span>(l,mid);</span><br><span class="line">        tr[x].rc=<span class="built_in">bt</span>(mid+<span class="number">1</span>,r);</span><br><span class="line">        <span class="built_in">updata</span>(x,l,mid,r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> tr[x].mx=a[l];</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">change</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> id,Fac k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">        tr[x].mx=k;</span><br><span class="line">        tr[x].c=k.a&gt;<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(id&lt;=mid)<span class="built_in">change</span>(tr[x].lc,l,mid,id,k);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">change</span>(tr[x].rc,mid+<span class="number">1</span>,r,id,k);</span><br><span class="line">    <span class="built_in">updata</span>(x,l,mid,r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,q;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;q);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)a[i]=&#123;<span class="number">0</span>,<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="built_in">bt</span>(<span class="number">1</span>,n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=q;i++)&#123;</span><br><span class="line">        <span class="type">int</span> x,y;<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;x,&amp;y);</span><br><span class="line">        a[x]=&#123;y,x&#125;;</span><br><span class="line">        <span class="built_in">change</span>(<span class="number">1</span>,<span class="number">1</span>,n,x,a[x]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,tr[<span class="number">1</span>].c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然，这个问题还能扩展。</p>
<p>思考一下，假如维护的信息不满足可减性怎么办呢？</p>
<p>答案是每个点不维护区间的答案，而是维护在考虑左区间的情况下右区间的贡献即可。</p>
<p>这个方法又有个别名，叫兔队线段树。</p>
<p>原链接在这：<a href="https://www.cnblogs.com/PinkRabbit/p/Segment-Tree-and-Prefix-Maximums.html">https://www.cnblogs.com/PinkRabbit/p/Segment-Tree-and-Prefix-Maximums.html</a></p>
<p>一道练习题在这：<a href="https://codeforces.com/contest/671/problem/E">https://codeforces.com/contest/671/problem/E</a></p>
<p>具体做法看原链接吧，我感觉粉兔已经说的很明白了。<del>其实是因为我懒</del></p>
</div></details>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>经典问题</tag>
      </tags>
  </entry>
  <entry>
    <title>求图上最大异或和路径的证明</title>
    <url>/2024/02/27/%E6%B1%82%E5%9B%BE%E4%B8%8A%E6%9C%80%E5%A4%A7%E5%BC%82%E6%88%96%E5%92%8C%E8%B7%AF%E5%BE%84%E7%9A%84%E8%AF%81%E6%98%8E/</url>
    <content><![CDATA[<p>还记得 OI 时期有一道典的不能再典的题目：给一张图，求一条从 $s$ 到 $t$ 的最大异或和的路径。</p>
<p>一个很典的结论是：跑一棵生成树，然后把这棵生成树上的环全部拿下来做个线性基，然后用任意一条 $s\to t$ 的路径丢进线性基里求最大值。</p>
<p>之前一直不知道怎么证明。</p>
<p>现在来证明一手：</p>
<p>不妨假设图中只有一个联通图。</p>
<p>可以发现，答案路径和随便一条路径的对称差满足每个点的度数都为  $0$ ，我们不妨把所有满足所有点度数为 $0$ 的边集集中到一个集合 $S$ 。</p>
<p>显然，不仅路径的对称差属于 $S$ ，$S$ 的任意一个元素都显然可以称为路径的对称差，因此，任意一条路径的异或和，和答案的异或值，可以且仅可以是 $S$ 中某个元素的异或值。</p>
<p>然后在这个集合上定义一种类似异或的运算：对应两个集合 $X,Y$ ，这种运算的返回结果为：$(X\cup Y)\setminus(X\cap Y)$ ，下面直接称这种运算为异或。</p>
<p>显然这个运算是封闭的（即结果还在这个集合内），显然这个结构能够像线性基一样定义基（把存在或不存在看成 $0/1$ 就可以直接看成线性基了），如果能够证明基的大小是 $m-(n-1)$ ，那么这个问题就解决了。</p>
<p>考虑生成树用到的边集 $E_1$ ，那么显然 $E\setminus E_1$ 中的每个元素都会生成一个环，这下环构成的集合我们称为 $S’$ ，显然 $S’\subset S$ ，且 $S’$ 线性无关，现在我们证明这个组合能够表示出 $S$ 就行了。</p>
<p>对于任意一个 $S$ 的元素 $L$，对于 $L$ 中非 $E_1$ 的元素，我们将他们拉出来异或，得到元素 $L’$ ，显然 $L,L’$ 在 $E\setminus  E_1$ 的部分是相同的，而在 $E_1$ 的部分，显然也能根据树的结构以及度数都为 $0$ 这一性质证明是相同的，这样，就构造性的证明了 $L’=L$ ，因此 $S’$ 就是 $S$ 的一组基。</p>
<p>证毕。</p>
<p>说起来，现在用异或的角度观察图的结构发现，图的结构其实和向量空间很像，不过只有一个运算。</p>
<p>同时从拟阵的角度来看，图拟阵和有限的向量空间都是拟阵。</p>
<p>太神奇了，可惜碍于我浅薄的知识面，无法看见更加深层次的联系，实在可惜。</p>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
  </entry>
  <entry>
    <title>拟阵初级学习笔记</title>
    <url>/2024/01/26/%E6%8B%9F%E9%98%B5%E5%88%9D%E7%BA%A7%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>建议直接去看原论文，哪篇论文放在参考文献了。</p>
<p>前排提示，本篇中对于集合操作 $+$ 和 $\cup$ 没有区分，都表示<strong>并</strong>的意思，$-$ 和 $\setminus$ 同理。</p>
<h1 id="拟阵的入门"><a href="#拟阵的入门" class="headerlink" title="拟阵的入门"></a>拟阵的入门</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><h3 id="幂集"><a href="#幂集" class="headerlink" title="幂集"></a>幂集</h3><p> $2^S$ 称作 $S$ 的拟阵当且仅当 $2^S$ 是 $S$ 所有子集构成的集合。</p>
<p> 例如：$\{1,2\}$ 的幂集是 $\{\{1,2\},\{1\},\{2\},\emptyset\}$ 。</p>
<h3 id="拟阵"><a href="#拟阵" class="headerlink" title="拟阵"></a>拟阵</h3><p>记 $M=(S,\mathcal{I})$ 表示一个定于在有限集合 $S$ 且独立集的集合为 $\mathcal{I}$ 的当且仅当满足以下三条：</p>
<ol>
<li>$\mathcal{I}\subset 2^S$</li>
<li><strong>遗传性</strong> ：如果 $J\subset I\in \mathcal{I}$，那么 $J\in \mathcal{I}$ 。</li>
<li><strong>交换性/扩张性</strong> ：如果 $I,J\in\mathcal{I},|J|&lt;|I|$，那么 ${\exists}z\in J\setminus I , I\cup z\in \mathcal{I}$ 。</li>
</ol>
<p>为了方便，我们一般认为 $\emptyset \in \mathcal{I}$ ，即认为独立集的集合是非空的。</p>
<p>我们称 $\mathcal{I}$ 的元素为独立集。</p>
<p>例子：</p>
<p><strong>均匀拟阵</strong> ：$U^k_n=(S,\mathcal{I})$，其中 $|S|=n,\mathcal{I}=\{I\subset S : |I| \le k \}$ 。</p>
<p><strong>图拟阵</strong> ：令无向图 $G=(V,E)$，令图拟阵：$M=(E,\mathcal{I})$ ，其中 $\mathcal{I}=\{F\subset E : F 无环\}$ 。</p>
<p>为啥是拟阵这件事不难自证，不再赘述。</p>
<p>图拟阵非常的重要，因为他提供了一个形象想象拟阵的工具，在前期学习拟阵在图拟阵上想想是非常有用的方法。</p>
<p>不过图拟阵在有向图上不一定成立，一样的定义，只不过把无向图换成有向图。</p>
<p><img src="1.png" alt=""></p>
<p><strong>匹配拟阵</strong> ：令无向图 $G=(V,E)$，匹配拟阵：$M=(V,\mathcal{I})$ ，其中一个点集是独立集当且仅当存在一个匹配能够覆盖点集中的所有点（可以覆盖点集外的点）。</p>
<p>遗传性显然，交换性不会。</p>
<p>拟阵同时还可以与高代联动，对于一个有限的向量空间，一个独立集定义为线性无关的向量组，非常有意思的是，此时下面基的定义就是高代中基的定义，环是最小的线性相关的向量组，而引理1.2对应的就是基扩张定理。（从这个角度来看，很多拿到一个子空间的极大独立集，直接扩张成大空间的极大独立集的证明，突然就熟悉多了，这也能与课内联动？）</p>
<p>这么说的话，用线性空间来作为拟阵的例子辅助思考貌似也是一个不错的选择。</p>
<h6 id="坑1"><a href="#坑1" class="headerlink" title="坑1"></a>坑1</h6><p>不会交换性的证明。</p>
<h3 id="基"><a href="#基" class="headerlink" title="基"></a>基</h3><p>独立集 $I$ 是基当且仅当加入 $S/I$ 中的任何一个元素都不是独立集。</p>
<p>这种拟阵中的极大元素，在拟阵的研究中发挥着至关重要的作用。</p>
<h3 id="环"><a href="#环" class="headerlink" title="环"></a>环</h3><p>一个非独立集 $I’$ 是环当且仅当 $I’$ 删除其中任意一个元素都是独立集。</p>
<p>例子：图拟阵中的简单环。</p>
<p>我们用 $C(M)$ 表示拟阵 $M$ 中所有的环。</p>
<h2 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h2><p><strong>引理 1.1</strong> ：基的大小相同。（用交换性显然）</p>
<p><strong>引理 1.2</strong> ：${\forall} J \in \mathcal{I},{\exists} 基I:J\in I$ 。（用交换性显然）</p>
<p>该引理说明任意一个元素都属于一个基，所以对于一个拟阵，只要知道基，加上遗传性就可以知道所有独立集。</p>
<p>但是能不能凭借此定义独立集的集合呢？</p>
<p>还需要一个定理：</p>
<p><strong>定理 1.3(基交换定理)</strong> ：${\forall}基A,B,A\ne B,{\forall} z\in A\setminus B,{\exists} y\in B\setminus A:A-\{z\}+\{y\}\in \mathcal{I}$ 。（用遗传性显然）</p>
<p>满足基交换定律且大小相同的基的集合可以定义一个拟阵。（可以证明交换性成立，并不困难，在此不再赘述，证明过程类似【完美匹配那个证明】）</p>
<p>这种定义相较于原来定义的优势在于检验拟阵的工作量小了，本来对于每一对独立集都要检验，现在只需要检验基，尤其是对于自己随手写的拟阵，例如：$\{\{1,3,4\},\{2,3,4\}\}$ 。</p>
<h6 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h6><p>完美匹配定理的编号。</p>
<h6 id="坑2"><a href="#坑2" class="headerlink" title="坑2"></a>坑2</h6><p>其实我觉得这里的大小相同的限制可以改得再弱一点：基之间没有包含关系，我严重怀疑没有包含关系可以推出大小相同，但是水平有限，目前我证不出来。</p>
<p>基交换定理可以放宽一下条件，仍然成立：</p>
<p>${\forall}A,B\in \mathcal{I},|A|\le|B|,{\forall} z\in A,{\exists} y\in B\setminus (A-\{z\}):A-\{z\}+\{y\}\in \mathcal{I}$ 。</p>
<p><strong>引理 1.4</strong> ：$I$ 不是独立集，则一定有一个子集是环 。（显然）</p>
<p><strong>引理 1.5</strong> ：${\forall}X,Y\in C(M),X\subset Y:X=Y$ 。（显然）</p>
<p><strong>引理 1.6</strong> ：${\forall}X,Y\in C(M),X\ne Y,e\in X\cap Y:{\exists} C\in C(M),C\subset X\cup Y-\{e\}$ 。</p>
<details class="toggle" ><summary class="toggle-button" style="">证明</summary><div class="toggle-content"><p>等价于证明 $X\cup Y-\{e\}$ 不是独立集。</p>
<p>证明一个集合不是独立集，思考一下条件：环、一个已知的集合。因此我们考虑利用这个已知的集合用反证法，通过构造与环产生矛盾。</p>
<p>反证法：已知 $X\cap Y \in \mathcal{I}$ ，然后用 $X\cup Y-\{e\}$ 扩大这个集合到同样的大小，由于环的限制， $X\setminus Y,Y\setminus X$ 都要丢掉一个元素，所以集合大小最大是 $|X|+|Y|-2$ ，然而可以扩展到 $|X|+|Y|-1$ ，矛盾，证毕。</p>
<p>至于更加严谨的写法，这里引用一下2018国集论文（根据引理编号对内容做了一点更改）：</p>
<p>证明：由引理 1.5 可得， $X\setminus Y$ 非空，设 $f \in X\setminus Y$ 。假设 $X\cup Y − \{e\}$ 是独立集。由于 $X$ 是环，<br>所以 $X − \{f\}$ 是独立集，假设 $X\cup Y$ 中最大的包含 $X − \{f\}$ 的独立集是 $Z$ 。由于 $Y$ 不是独立<br>集，所以 $Y \not\subset Z$ 。由此可得 $|Z|\le |X\cup Y − \{f\}| − 1 \le |X \cup Y| − 2 &lt; |X \cup Y − \{e\}|$ 。因为 $Z$ 已经<br>是最大的独立集了，所以 $X\cup Y − \{e\}$ 不可能是独立集（否则由交换性可以扩大 $Z$ ），命题得证。</p>
</div></details>
<p><strong>引理 1.7</strong> ：$I$ 是基，$e\notin I$ ，那么 $I+\{e\}$ 包含一个唯一的环。</p>
<details class="toggle" ><summary class="toggle-button" style="">证明</summary><div class="toggle-content"><p>至少有一个环是显然的，每个环都有 $e$ 是显然的。</p>
<p>引理 1.6 告诉我们只要有两个环，就可以构造出不含 $e$ 的环，所以至多只有一个环。</p>
<p>证毕。</p>
</div></details>
<h1 id="秩函数"><a href="#秩函数" class="headerlink" title="秩函数"></a>秩函数</h1><h2 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h2><p>对于拟阵 $M=(S,\mathcal{I})$ ，基的元素的个数称为拟阵的秩，对于任意一个 $U\subset S$，定义秩函数 $r(U)$ 表示 $U$ 中极大独立集的大小。</p>
<h2 id="性质-1"><a href="#性质-1" class="headerlink" title="性质"></a>性质</h2><p><strong>定理 2.1(有界性)</strong> ：${\forall}U\subset S, 0\le r(U)\le|U|$</p>
<p><strong>定理 2.2 (单调性)</strong> ：${\forall}A\subset B\subset S,r(A)\le r(B)$</p>
<p><strong>定理 2.3 (次模性)</strong> ：${\forall}A,B\subset S,r(A\cup B)+r(A\cap B)\le r(A)+r(B)$</p>
<p>定理1,2都是显然的，下面证明定理3。</p>
<details class="toggle" ><summary class="toggle-button" style="">证明</summary><div class="toggle-content"><p>首先，我们使用构造方法，证明一个集合的秩的下界是更加容易的（构造一个独立集总比说明独立集大小的上界要容易得多），根据这个方向，我们得到这个证明：</p>
<p>先找到 $A\cap B$ 的极大独立集，然后用交换性扩大成 $A\cup B$ 的极大独立集，然后把扩大的部分，按照 $A\setminus B,B\setminus A$ 分成两部分，和 $A\cap B$ 的极大独立集合成 $A,B$ 的独立集，然后就证完了。</p>
<p>更加严谨的写法看国集论文，这里懒得复制粘贴了，思路是一样的。</p>
</div></details>
<p>那么问题来了，我们能否用秩函数定义拟阵？答案是：可以。</p>
<p>如果我们有一个函数 $r$ ；$2^S\to \mathbb{Z}$，定义 $\mathcal{I}={I:r(I)=|I|}$ 。</p>
<details class="toggle" ><summary class="toggle-button" style="">遗传性证明</summary><div class="toggle-content"><p>在遗传性的证明中，我们更希望证明一个集合是独立集，也就是证明 $r(I)=I$ ，显然，我们其实是需要证明 $r(I)\ge I$ ，所以在证明中应该更多的将目标集合放在 $\le$ 的右边。</p>
<p>$A=J,B=I\setminus J$，即可证明。</p>
</div></details>
<details class="toggle" ><summary class="toggle-button" style="">交换性证明</summary><div class="toggle-content"><p>在交换性的证明中，由于找到具体哪个集合是独立集有点困难，采用反证，则考虑限制集合秩的上界，去证明大集合（$I$）并不是独立集，此时把目标集合（$I$）放在 $le$ 左边限制上界。</p>
<p>令 $\{b_1,b_2,…,b_n\}=I\setminus J$</p>
<p>考虑 ：$A=J+\{b_1\},B=J+\{b_2\}$，则可以证明 $r(J+\{b_1,b_2\})=|J|$，然后将其作为新的 $A$，令 $B=J+\{b_3\}$ ，不断往下做，直到合成出 $I\cup J$ 为止，此时 $r(I\cup J)=|J|&lt;|I|=r(I)$ ，矛盾，证毕。</p>
</div></details>
<p>说点抽象的话：</p>
<p>事实上，定理 3 变换一下可以得到另外一个形式：$r(A\cup B)-r(A)\le r(B)-r(A\cap B)$ ，然后变个符号：$r(A\cup C)-r(A)\le r(B\cup C)-r(B),B\subset A$ 。</p>
<p>在面对一个集合时，小集合的增量要不劣于大集合的增量，这说明小集合比起大集合具有更大的增长潜力，在后面闭包算子中会反复提及这一点。</p>
<p>当然，对于这一点，可以这么理解，现在假设有个空集，他可以到达任何的基，但是随着元素一个个被确定，能到达的基越来越少，选择也越来越少，因此增长潜力也在减小，极端的，当为基的时候，没有选择，增长不了，增长潜力达到最低值。</p>
<h1 id="拟阵最优化"><a href="#拟阵最优化" class="headerlink" title="拟阵最优化"></a>拟阵最优化</h1><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>定义函数 $w:S\to \mathbb{R}$ ，定义一个集合的权值为：$w(I)=\sum\limits_{e\in I}w(e)$，找 $\mathcal{I}$ 中最大的 $w(I)$ 。</p>
<p>例子：最小生成树。</p>
<h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p><del>最小生成树plus版</del></p>
<p>以下先默认权值非负，因此显然权值最大的基就是权值最大的独立集。</p>
<ol>
<li>把 $S$ 中的元素按照从大到小的顺序排序，记作 $s_1,s_2,s_3,…,s_n$ 。</li>
<li>维护一个集合 $I$ ，初始为空，按顺序考虑 $s_i$ ，如果 $I$ 加上 $s_i$ 是独立集就加入，否则就不加入。</li>
</ol>
<details class="toggle" ><summary class="toggle-button" style="">证明</summary><div class="toggle-content"><p>没看懂论文第二步的证明，自己瞎掰了一个。</p>
<p>记 $U_i=\{s_1,s_2,…,s_i\}$，$I_i$ 为考虑完 $s_i$ 后的 $I$ 。</p>
<p>$|I_i|=r(U_i)$ ，否则$|I_i|$ 可以扩大，加入的元素为 $s_j(j\le i)$ ，则一定会在考虑到 $s_j$ 的时候加入该元素，矛盾，所以成立。</p>
<p>所以最后 $I$ 是一个基。</p>
<p>考虑把每个独立集用其所含元素的下标从小到大呈现，例如：$\{1,2,4\}$ 表示其含有 $s_1,s_2,s_4$ 。</p>
<p>那么对于 $I$ ，假设其呈现出来是：$a_1,a_2,…,a_t$ , 对于任意一个基而言，是：$a’_1,a’_2,…,a’_t$ ，那么显然有 $a_i\le a’_i$ ，则显然 $I$ 是权值最大的基。</p>
</div></details>
<p>事实上，同样的证明方法，不一定要 $I$ 是基，可以扩展，当 $|I|$ 的大小为 $t$ 时，$I$ 就是所有大小为 $t$ 的独立集中权值最大的。</p>
<p>所以就算权值是非负的，如果指定了目标独立集的大小，仍然可以用此算法。（不过如果已经指定了大小，令总体权值加减一个数字只会让答案改变 $siz*val$，也能把问题转化到非负情形下）</p>
<p>但是如果权值可以是负数呢？</p>
<p>显然当 $s_i\le 0$ 时推出就行了，显然正确，考虑答案只可能出在 $I_i$ 就行了。（显然，$I_i$ 是同集合大小的独立集中权值最大的，只考虑他就行了）</p>
<h1 id="拟阵交"><a href="#拟阵交" class="headerlink" title="拟阵交"></a>拟阵交</h1><h2 id="问题-1"><a href="#问题-1" class="headerlink" title="问题"></a>问题</h2><p>对于 $M_1=(S,\mathcal{I}_1)$，$M_2=(S,\mathcal{I}_2)$ ，定义 $M_1,M_2$ 的交是所有 $I$ 的集合 ，$I$ 满足在两个集合中都是独立集。</p>
<p>首先，拟阵的交是拟阵吗？不是。</p>
<p>反例：$S=\{1,2,3\},\mathcal{I}_1=\{\emptyset,\{1\},\{2\},\{3\},\{1,2\},\{1,3\}\},\mathcal{I}_2=\{\emptyset,\{1\},\{2\},\{3\},\{1,2\},\{2,3\}\}$ 。</p>
<p>交为：$\{\emptyset,\{1\},\{2\},\{3\},\{1,2\}\}$</p>
<p>显然不是拟阵。</p>
<p>不过拟阵交虽然不是拟阵，但是显然是个集合，那问题来了，这个集合中大小最大的独立集有多大？并且求出一个合法解。</p>
<p>这个问题在两个拟阵的交时有多项式求法，但是三个以上是 NP-hard 的。</p>
<p>所以接下来的讨论默认是两个拟阵的交。</p>
<h2 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h2><h3 id="闭包算子"><a href="#闭包算子" class="headerlink" title="闭包算子"></a>闭包算子</h3><p>对于 $A\subset S$ ，我们定义 $A$ 的闭包算子 $cl(A)=\{e\in S : r(A\cup \{e\})=e(A)\}$ 。</p>
<p>也就是加入后不会影响 $A$ 的秩的元素。</p>
<p>一个显然的事情：$A\subset cl(A)$ 。</p>
<h3 id="交换图"><a href="#交换图" class="headerlink" title="交换图"></a>交换图</h3><p>对于 $I\in \mathcal{I}$，定义一个二分图，一边是 $I$ ，一边是 $S\setminus I$ ，存在边 $(x,y)(x\in I,y\in S\setminus I)$ 当且仅当 ：$I-\{x\}+\{y\}\in \mathcal{I}$ 。</p>
<p>称此二分图为 $I$ 的交换图，记作 $D_M(I)$ 。</p>
<h2 id="性质-2"><a href="#性质-2" class="headerlink" title="性质"></a>性质</h2><p><strong>引理 4.1</strong> ：如果 $A\subset B$ ，那么 $cl(A)\subset cl(B)$ 。</p>
<details class="toggle" ><summary class="toggle-button" style="">证明</summary><div class="toggle-content"><p>兄弟，来一个极其富有高代特色的证明。</p>
<p>对于任意一个 $z\in cl(A)$ ，找到 $A$ 的一个极大独立集，然后在 $B+\{z\}$ 中扩大，那么一定会得到一个不含 $z$ 的极大独立集，所以 $z$ 不会扩大 $B$ 的秩。</p>
<p>这个证明用到了一个显然正确的结论：如果加入 $z$ 后，存在一个极大独立集不包含 $z$ ，那么 $z$ 一定在该集合的闭包算子中，否则不在。</p>
<p>论文采用秩函数证明：</p>
<p>$r(A+\{z\})+r(B)\ge r((A+\{z\})\cap B)+r(B+\{z\})\ge r(A)+r(B+\{z\})$ 。（也可以由 $r(A+\{z\})-r(A)\ge r(B+\{z\})-r(B)$ 得到，这个式子在上面的次模性的变形中给出过）</p>
<p>又 $r(A+\{z\})=r(A)$ ，所以 $r(B)\ge r(B+\{z\})$，所以 $r(B)=r(B+\{z\})$ ，证毕。</p>
</div></details>
<p>这个定理同样反映了小集合比大集合更加具有增长潜力，一个元素对小集合没有贡献，那么对大集合同样没有贡献。</p>
<p><strong>引理 4.2</strong> ：$A\subset S,e\in cl(A)$ ，那么 $cl(A)=cl(A\cup \{e\})$ 。</p>
<details class="toggle" ><summary class="toggle-button" style="">证明</summary><div class="toggle-content"><p>${\forall} z \in cl(A\cup \{e\}),r(A)=r(A+\{z\})=r(A+\{e,z\})$，则 $r(A)\le r(A+\{z\})\le r(A+\{e,z\})$ ，所以 $r(A)=r(A+z)$ ，证毕。</p>
<p>人话讲就是，如果加到大集合秩不变，由于大集合秩等于小集合，大集合的秩本来就比小集合大，如果小集合变大了，就比大集合大了，所以加入到小集合中秩也不能变大。</p>
<p>所以如果 $r(A)=r(B),A\subset B$，那么 $cl(A)=cl(B)$ 。（引出下文）</p>
</div></details>
<p><strong>引理 4.3</strong> ：$cl(A)=cl(cl(A)),r(A)=r(cl(A))$ 。（反复用 引理 4.2 就行了）</p>
<p>上面两个引理说明了个什么事呢？（包括证明过程）</p>
<p>显然的事情：</p>
<ol>
<li>$A\subset B,r(A)=r(B)$，那么 $cl(A)=cl(B),B\setminus A \subset B\subset cl(B)=cl(A)$ 。（秩相同则 $cl$ 相同）</li>
<li>${\forall} B\subset cl(A):cl(A\cup B)=cl(A),r(A\cup B)=r(A)$ 。（这一条主要是对引理4.3的扩展）</li>
<li>$A\subset B,cl(A)=cl(B):r(A)=r(B)$ 。（因为 $B\subset cl(B)=cl(A)$，所以 $r(B)=r(A\cup B)=r(A)$ ）（ $cl$ 相同则秩相同）</li>
</ol>
<p>因此，如果子集之间相互包含，那么秩相同和 $cl$ 相同同时成立，也很符合直觉，集合变大，秩不变，那一定是你一直在加一些没有贡献的元素进来。同时，加入没有贡献的元素进来，也并不会改变没贡献的元素的集合，也就是说没贡献的元素之间不会产生联动，突然就产生贡献了，没用就是一直没用，直到秩增大。</p>
<p>这几个引理还可以从另外一个视角看：若 $C\subset cl(B)$ ，$B\subset cl(A)$ ，那么 $C\subset cl(A)$ ，这体现了闭包的传递性。</p>
<p>这也说明了一个事情：在产生秩增量这件事情上， $B$ 没用，$C$ 一定没用，$C$ 有用，$B$ 一定有用，也就是说某种程度上讲 $B$ 覆盖了 $C$ 的功能，这在后面的某些证明中有所体现。</p>
<p>在图拟阵中的一个体现就是：$(x,y)$ 和一个简单路径 $x\to y$ 形成了一个简单环，$(x,y)$ 的作用是有他在的边集合中，最大的独立集 $x,y$ 一定是联通的，而 $x\to y$ 一样能办到这件事。（此时 $(x,y)\in cl(x\to y))$）</p>
<p>注意一个特殊的集合：环，对于环 $I’,{\forall} z\in I’:z\in cl(I’-\{z\})$ ，这在后面的证明中会用到。</p>
<p><strong>定理 4.4(强基交换定理)</strong> ：对于两个不同的基 $A,B$ ，${\forall}x\in A\setminus B,{\exists} y\in B\setminus A : A-\{x\}+\{y\},B-\{y\}+\{x\}$ 都是基 。</p>
<details class="toggle" ><summary class="toggle-button" style="">证明</summary><div class="toggle-content"><p>先写论文的证法：</p>
<p>将 $x$ 加入 $B$ 中得到一个环 $C$ 。</p>
<p>则 $x\in cl(C-\{x\})$ ，则 $x\in cl((A\cup C)-\{x\})$ ，那么 $cl((A\cup C)-\{x\})=cl(A\cup C)$ ，所以 $r((A\cup C)-\{x\})=r(A\cup C)$ ，综上，存在 $y\in C-\{x\}$ ，满足 $A-\{x\}+\{y\}$ 是基，同时因为 $y$ 是环中的一个元素，所以 $B-\{y\}+\{x\}$ 也是环中的一个基。</p>
<p>这里其实就是用 $C-\{x\}$ 去代替 $x$ 的作用，然后找到是哪个元素起到了作用，将他作为 $y$ 。</p>
<p>当然，可以从染色的视角去看这个问题：</p>
<p>如果把这个问题放在图拟阵，也就是 $A$ 的一条边 $(x,y)$ 放到 $B$ 中，然后需要我去证明在 $B$ 的环中存在一条不是刚刚加入进来的边，满足能够填补 $A$ 的空缺。（一般的，我们认为 $A,B$ 都是生成树，就算是生成森林，边所在的联通块是一致的）</p>
<p>那么把 $A$ 中 $(x,y)$ 切断，与 $x$ 联通染蓝色， $y$ 联通染红色，显然，$B$ 中与 $(x,y)$ 形成环的路径上一定存在一条边，一端红色，一端蓝色，他就是我们要找的边。（因为路径两端一端红色，一端蓝色）</p>
<p>但是对点染色貌似和拟阵没什么关系，但是不妨换个角度看，我们要找的是路径上两端异色的边，所以我们不妨对边也染色，两端同色染为白色，异色染为黑色，观察一下这是什么？这就是 $cl(A-\{x\})$ ，也就是说 $cl$ 其实可以看成一种染色，无用染白，有用染黑。</p>
<p>有了这个想法，证明就轻松多了，显然在图拟阵中，一个环不能只有恰好一条黑边，否则从 $x$ 的联通块走黑边到达 $y$ 联通块，就没有另外一条黑边走回来了，与简单环的定义矛盾。所以去掉这条黑边是一个独立集（环的定义），加上这条黑边还是个独立集，与环矛盾，证毕。</p>
<p>用拟阵的话就是：反证法，如果 $C-\{x\}\subset cl(A-\{x\})$ ，那么 $x\notin cl(A-\{x\})$ ，则 $x\notin cl(C-\{x\})$ ，与环的定义矛盾，证毕。</p>
<p>所以 $cl$ 某种角度上可以算是拟阵的染色法。（先从图拟阵的角度思考是有道理的，直观）</p>
</div></details>
<p>当然，由上面的证明过程，可以放宽定理条件：$A,B$ 不一定得是基，只要满足 $|A|\le|B|$ 即可。</p>
<p>即：</p>
<p>${\forall}A,B\in \mathcal{I},|A|\le|B|,{\forall} x\in A,{\exists} y\in B\setminus (A-\{x\}):A-\{x\}+\{y\}，B+\{x\}-\{y\}\in \mathcal{I}$ 。</p>
<details class="toggle" ><summary class="toggle-button" style="">证明</summary><div class="toggle-content"><p>$B+\{x\}$ 不是独立集就类似上面证明就行了，小改即可。</p>
<p>是独立集，则 $|B+\{x\}|=|B|+1&gt;|A|$ ，则有交换性，存在 $y\in B:A+\{y\}\in\mathcal{I}$ 。</p>
<p>则 $A+\{y\}-\{x\}\in \mathcal{I}$ 。</p>
<p>这里还有个非常有意思的想法，用上面的思路证完 $|A|=|B|$ 的情况，然后对于 $|A|&lt;|B|$ 的情况，先用 $B$ 把 $A$ 扩大到相同大小，然后强交换，由于用于扩大的集合是两个集合的交集，所以不会出现在 $x,y$ 中，所以可以直接用遗传性再缩小回去，从而完成 $|A|&lt;|B|$ 的证明。</p>
<p>但是上面的思路可以直接把两种情况都证了，也就不需要多此一举了。</p>
</div></details>
<p><strong>引理 4.5</strong> ：对于独立集 $I,J,I\ne J,|I|=|J|$ ，则 $I\setminus J$ 与 $J \setminus I$ 存在完美匹配。</p>
<details class="toggle" ><summary class="toggle-button" style="">证明</summary><div class="toggle-content"><p>很有意思的构造性解，反正我没有证出来，思路确实新奇，小清新构造。（mad，没有证出来真TM不爽）</p>
<p>对于元素 $y\in J\setminus I$ ，由强交换定理可知存在 $x\in I\setminus J$ ，使得 $I-\{x\}+\{y\},J-\{y\}+\{x\}$ 仍然是独立集。</p>
<p>则认为 $x,y$ 匹配，然后令 $J=J+\{x\}-\{y\}$ ，接着构造，直到 $I=J$ ，构造完毕。</p>
</div></details>
<p><strong>引理 4.6</strong> ：对于独立集 $I$ 和集合 $J,I\ne J,|I|=|J|$ ，且 $I\setminus J$ 与 $J \setminus I$ 存在唯一的完美匹配，则 $J$ 也是独立集。</p>
<details class="toggle" ><summary class="toggle-button" style="">证明</summary><div class="toggle-content"><p>显然，要直接证明 $J$ 是不是独立集这件事情非常的困难，所以我的思路是构造+归纳，通过已有的信息，把 $I$ 构造出 $J$ 。</p>
<p>我们考虑把 $I\setminus J$ 换成 $J\setminus I$ 的一个元素，变成 $I’$ ，使得 $I’$ 与 $J$ 仍然只存在唯一的完美匹配。</p>
<p>考虑对于 $(x,y),x\in I\setminus J,y\in J\setminus I$ ，如果 唯一匹配是 $(x,y)$ ，则认为是 $x\to y$ ，否则认为是 $y\to x$ ，由于无环，所以是拓扑图。（因为是唯一匹配，所以无环，唯一匹配这个信息，显然是要往无环的角度去靠）</p>
<p>所以一定存在一个点 $x\in I\setminus J$ ，$x$ 没有入边，即在由 $I\setminus J$ 与 $J\setminus I$ 的导出子图中，$x$ 只有一条边。</p>
<p>考虑直接把 $x$ 换成与他匹配的 $y$ 。</p>
<p>不难证明（用交换性搞搞就行了），在 $D_M(I’)$ 中 $I’\setminus J$ 与 $J\setminus I’$ 的导出子图中的边一定在 $D_M(I)$ 中出现，同时 原来的匹配边也一定在新的导出子图中，所以仍然是唯一匹配。（匹配边还在，非匹配边减少了）</p>
<p>然后归纳就行了。</p>
<p>不过论文给了种更加简单的证明，不过我觉得本质应该差不多。</p>
<p>首先把匹配写成 $(x_1,y_1),(x_2,y_2),…,(x_t,y_t)$ 的形式，一般的，当 $i&lt;j$ 时， $x_i,y_j$ 没有边。（把 $x$ 按照拓扑序从小到大排就行了） </p>
<p>然后假设 $J$ 不是独立集，那么就存在环，假设为 $C$ ，并且其中下标最小的是 $y_i$ （显然一定有 $J\setminus I$ 的元素）。</p>
<p>考虑 $I-\{x_i\}$ ，那么 $C-y_i\subset cl(I-\{x_i\})$ ，又 $y_i\subset cl(C-y_i)\subset cl(cl(I-\{x_i\}))=cl(I-\{x_i\})$ ，这与 $x_i,y_i$ 匹配矛盾，证毕。</p>
<p>本质上就是 $C-\{y_i\}$ 能够替代 $y_i$ 的功能，但是由唯一匹配可以导出不能替代，从而导致了矛盾。</p>
</div></details>
<p><strong>引理 4.7</strong> ：$I,J\in \mathcal{I},|I|=|J|,{\forall} z\in J\setminus I,I+\{z\}\notin\mathcal{I},x\in S\setminus I,I+\{x\}\in \mathcal{I}$ ，那么 $J+\{x\}\in \mathcal{I}$ 。</p>
<details class="toggle" ><summary class="toggle-button" style="">证明</summary><div class="toggle-content"><p>$J\setminus I\subset cl(I)$ ，如果 $x\in cl(J)$ ，那么 $x\in cl(I)$ ，矛盾，证毕。</p>
</div></details>
<p><strong>定理 4.8(最小最大定理)</strong> ：$\max\limits_{I\in \mathcal{I_1}\cap\mathcal{I_2}} |I|=\min\limits_{U\subset S}(r_1(U)+r_2(S\setminus U))$</p>
<p>这里证明 $\le$ 是显然的，$|I\cap U|\le r_1(U)$ ，另一边同理，加起来就行了。</p>
<p>但是证明相等比较麻烦，后面在算法中用构造性方法证明。</p>
<h2 id="算法-1"><a href="#算法-1" class="headerlink" title="算法"></a>算法</h2><p>现在给出算法流程。</p>
<p>现有集合 $I,X_1=\{x\in S\setminus I:I+\{x\}\in \mathcal{I_1}\},X_2=\{x\in S\setminus I:I+\{x\}\in \mathcal{I_2}\}$ ，初始时 $I=\emptyset$ 。</p>
<p>定义交换图（有向图） $D_{M_1,M_2}(I)$ 为 ：</p>
<ol>
<li>$x\in I,y\in S\setminus I$ ，如果 $(x,y)\in D_{M_1}(I)$ ，那么 $x\to y\in D_{M_1,M_2}(I)$ 。</li>
<li>$x\in I,y\in S\setminus I$ ，如果 $(x,y)\in D_{M_2}(I)$ ，那么 $y\to x\in D_{M_1,M_2}(I)$ 。</li>
</ol>
<p>重复进行算法流程：</p>
<ol>
<li>在 $D_{M_1,M_2}(I)$ 找到一条起点属于 $X_1$ ，终点属于 $X_2$ 的最短路 $P$。（没有就结束算法）</li>
<li>令 $I=I∆P$ 。（ $∆$ 表示集合的对称差操作）</li>
</ol>
<p>最后得到的 $I$ 就是一个最大大小的拟阵交，同时 $U=\{x\in S:x 在D_{M_1,M_2}(I)能够到达 X_2 中的点\}$ 。</p>
<p>这个算法的正确性要证明两件事：</p>
<ol>
<li>$I$ 为什么仍然是拟阵交。</li>
<li>为什么 $|I|=r_1(U)+r_2(S\setminus U)$ 。</li>
</ol>
<details class="toggle" ><summary class="toggle-button" style="">证明1</summary><div class="toggle-content"><p>先证明新的 $I\in \mathcal{I_1}$ 。</p>
<p>令路径 $P=\{y_0,x_1,y_1,…,y_t\}$ ，令 $J=I-\{x_1,x_2,…,x_t\}+\{y_1,y_2,…,y_t\}$ ，由最短路可以导出是唯一匹配（因为 $D_{M_1}(I)$ 的结构类似 DAG 那样，BFS图），所以 $J$ 也是独立集，且同时可以直到 $y_1,y_2,…,y_t\in cl(I)$ ，由引理 4.7可知 $I+\{x\}\in \mathcal{I_1}$ 。</p>
<p>同理可证 $I\in \mathcal{I_2}$ 。</p>
<p>证毕。</p>
</div></details>
<details class="toggle" ><summary class="toggle-button" style="">证明2</summary><div class="toggle-content"><p>假设 $r_1(U)&gt;|I\cap U|$ ，则 ${\exists} z\in U\setminus I,(I\cap U)+\{z\}\in\mathcal{I_1}$ ，如果 $I+\{z\}\in \mathcal{I_1}$ ，则显然存在路径 $P$ ，否则，显然，$|I|&gt;|I\cap U|$ ，所以用 $I$ 把 $I\cap U +\{z\}$ 扩大，则显然存在 $x\in S\setminus U,I-\{x\}+\{z\}\in\mathcal{I_1}$ ，所以存在 $x\to z$ ，这与 $x\notin S$ 矛盾。</p>
<p>另外一边类似，不再赘述。</p>
<p>证毕。</p>
</div></details>
<p>这样，就证明了最小最大定理，同时也给出了一个求一组 $I,U$ 的多项式算法。</p>
<p>分析一下时间复杂度。</p>
<p>不计建 $D_{M_1,M_2}(I)$ 的复杂度，令 $n=|S|,r=\max(r_1(S),r_2(S))$ ，每次增广的代价是 $O(rn)$ ，每轮 $|I|$ 增大 $1$ ，所以至多进行 $r$ 轮，所以时间复杂度为 $O(r^2n)$ 。</p>
<p>非常优秀的时间复杂度。</p>
<h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><h3 id="三个以上的拟阵交为什么是-NP-Hard-的"><a href="#三个以上的拟阵交为什么是-NP-Hard-的" class="headerlink" title="三个以上的拟阵交为什么是 NP-Hard 的"></a>三个以上的拟阵交为什么是 NP-Hard 的</h3><p>可以证明难于哈密顿路径：</p>
<p>对于有向图 $G=(V,E)$ ，求 $s\to t$ 的哈密顿路径。</p>
<p>构造拟阵：</p>
<ol>
<li>令 $M_1$ 为边集满足把有向边看成无向边，则无环。</li>
<li>令 $M_2$ 为 $s$ 的入度为 $0$ ，其余点入度至多为 $1$ 。</li>
<li>令 $M_3$ 为 $t$ 的出度为 $0$ ，其余点出度至多为 $1$ 。</li>
</ol>
<p>求出这三个拟阵的拟阵交显然就能求出哈密顿路径，或者证明无解。</p>
<p>所以求三个及以上的拟阵交是 NP-Hard 的。</p>
<h3 id="带权拟阵交"><a href="#带权拟阵交" class="headerlink" title="带权拟阵交"></a>带权拟阵交</h3><p>定义权值函数：$w:S\to \mathbb{R}$ ，求 $\max\limits_{I\in \mathcal{I_1}\cap\mathcal{I_2}}\sum\limits_{e\in I}w(e)$ 。</p>
<p>扩展版本的最小最大定理我没看懂，这一部分建议自己去看论文。我没看懂这一部分，就不在这里胡说八道了。</p>
<p>算法流程就是把最短路径换成，以点权和最大为第一关键字，最少边数为第二关键字找路径。</p>
<p>其中 $I$ 的点权为 $-w(e)$ ，$S\setminus I$ 为 $w(e)$ 。</p>
<p>论文里写的是点权和最小，但是一个很简单的例子，所有独立集大小最大为 $1$ ，然后让这个拟阵自己和自己做交，那么最大值是什么？显然是权值最大的元素，但是按照论文里写的会找权值最小的元素，这显然是错误的。</p>
<p>更重要的是，在做题的时候，我写最长路过了。</p>
<p>至于为什么不会有正环，为什么算法一定会停止，为什么这个算法对，我一概不知，我只知道写最长路能过，仅此而已，现在当黑盒用了。</p>
<p>时间复杂度：$O(r^2n^2)$ 。</p>
<h6 id="坑3"><a href="#坑3" class="headerlink" title="坑3"></a>坑3</h6><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>兄弟，学了这么久，该做做题了，不然你学拟阵干什么。</p>
<p>拟阵交的题目一般是题目的条件无法直接使用拟阵，但是单看其中的一部分条件是满足拟阵要求的，所以就搞两个拟阵交起来，获得一个满足多个条件的集合，这种题目最难的就是怎么去构造合适的拟阵。</p>
<h3 id="二分图匹配"><a href="#二分图匹配" class="headerlink" title="二分图匹配"></a>二分图匹配</h3><p>虽然二分图匹配的匹配点集本身就是个拟阵，但是检验一个子集是否是独立集，就需要判断是否被一个匹配覆盖，这显然是难的。（我都能找匹配了，为什么还要多此一举再用个拟阵=.=）</p>
<p>所以构造拟阵。</p>
<ol>
<li>第一个拟阵 $M_1=(E,\mathcal{I_1})$ ，满足左部点的每个点的度数至多为 $1$ 。</li>
<li>第二个拟阵 $M_2=(E,\mathcal{I_2})$ ，满足右部点的每个点的度数至多为 $1$ 。</li>
</ol>
<p>拟阵交即可。</p>
<p>其实如果思考一下，会发现拟阵交找的增广路和匈牙利算法找的是一样的。</p>
<h3 id="最小树形图"><a href="#最小树形图" class="headerlink" title="最小树形图"></a>最小树形图</h3><p>给定带权有向图 $G=(V,E)$ ，求以 $root$ 为根的最小权外向树。</p>
<ol>
<li>第一个拟阵 $M_1=(E,\mathcal{I_1})$ ，满足把有向边看成无向边无环。</li>
<li>第二个拟阵 $M_2=(E,\mathcal{I_2})$ ，除 $root$ 之外入度至多为 $1$ ，$root$ 入度为 $0$ 。</li>
</ol>
<p>然后用带权拟阵交。</p>
<h3 id="Colorful-Tree"><a href="#Colorful-Tree" class="headerlink" title="Colorful Tree"></a>Colorful Tree</h3><p>给定带权无向图 $G=(V,E)$ ，每条边有一个 $1$ 到 $n-1$ 的颜色，求一个最大权的生成树，满足每个颜色恰好出现一次。</p>
<ol>
<li>第一个拟阵 $M_1=(E,\mathcal{I_1})$ ，无环。</li>
<li>第二个拟阵 $M_2=(E,\mathcal{I_2})$ ，每个颜色至多出现一次。</li>
</ol>
<p>带权拟阵交。</p>
<h1 id="一些拟阵的操作"><a href="#一些拟阵的操作" class="headerlink" title="一些拟阵的操作"></a>一些拟阵的操作</h1><p>在理解接下来的操作时，推荐用基的定义去理解，优先考虑基的变化，会很有助于理解这个拟阵在这个操作后会发生什么变化。</p>
<h2 id="对偶拟阵"><a href="#对偶拟阵" class="headerlink" title="对偶拟阵"></a>对偶拟阵</h2><p>定义：对于拟阵 $M=(S,\mathcal{I})$ ，定义 $M$ 的对偶拟阵 $M^{<em>}=(S,\mathcal{I^</em>})$ ，其中 $I^*=\{U\subset S:{\exists}基I\in \mathcal{I},I\subset S\setminus U\}$ 。</p>
<p>遗传性显然，现在证明交换性：</p>
<details class="toggle" ><summary class="toggle-button" style="">交换性的证明</summary><div class="toggle-content"><p>假设 $|U_1|&gt;|U_2|$ ，设基 $I_1\subset S\setminus U_1,I_2\subset S\setminus U_2$ 。</p>
<p>设基 $I_3=I_1\setminus U2$ ，然后用 $I_2$ 去扩张 $I_3$ 成基 $I_4$ 。</p>
<p>那么 $|I_4\cap U_1|\le|I_4\setminus I_3|\le |U_2|-|U_1\cap U_2|&lt; |U_1|-|U_1\cap U_2|$ 。</p>
<p>显然 $I_4\subset S\setminus U_2$ ，所以显然 ${\exists} z\in U_1\setminus U_2: U_2+\{z\}\in \mathcal{I_2}$ 。</p>
</div></details>
<p>对偶拟阵的秩函数：</p>
<p>$r^<em>(U)=\max\limits_{I\subset U,I\subset I^</em>}|I|=\max\limits_{B是M中的基}|U\setminus B|=|U|-\min\limits_{B是M中的基}|U\cap B|=|U|-r(S)+\max\limits_{B是M中的基}|B\cap (S\setminus U)|=|U|-r(S)+r(S\setminus U)$</p>
<p>也可以用秩函数证明这是个拟阵，在这里就不展开讲了，不是很麻烦，可以自证。</p>
<p>对偶拟阵的用途很广，他代表了一般拟阵的另外一个方面，举个例子：图拟阵的对偶就是去掉哪些边仍能保证图是联通的。</p>
<p>对偶拟阵实际上就是把所有基的补集作为了基的集合定义的拟阵。</p>
<h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><p>对于拟阵 $M=(S,I)$ ，和 $Z\subset S$ ，定义拟阵 $M$ 删除子集 $Z$ 的拟阵为 $(S\setminus Z,\mathcal{I’}), \mathcal{I’}=\{I:I\subset S\setminus Z, I\in \mathcal{I}\}$ 。记为 $M\setminus Z$ 。</p>
<p>这个操作非常好理解，就是只考虑和 $Z$ 没有交集的独立集，秩函数直接用原来的就行，非常的简单。</p>
<h2 id="收缩"><a href="#收缩" class="headerlink" title="收缩"></a>收缩</h2><p>对于拟阵 $M=(S,I)$ ，和 $Z\subset S$ ，定义拟阵 $M$ 删除子集 $Z$ 的拟阵为 $(M^<em>\setminus Z)^</em>$ 。记为 $M/Z$ 。</p>
<p>由于是用上面两个操作定义的，所以显然是个拟阵。</p>
<p>这个操作理解起来会比较困难。</p>
<p>考虑 $M/Z$ 的基，首先得是 $M^<em>\setminus Z$ 的基的补集，$M^</em>\setminus Z$ 的基又得是 $M^<em>$ 中和 $Z$ 交集最小的基去掉交集部分的集合，而 $M^</em>$ 中和 $Z$ 交集最小的基对应的是 $M$ 中和 $Z$ 交集最大的基的补集。</p>
<p>综上，可以得出，$M/Z$ 的基是原来和 $Z$ 交集最大的基去掉交集的部分，同理，独立集也是类似的。</p>
<p>当然也可以从秩的角度考虑，这里不再赘述，直接给出秩函数的式子：</p>
<p>$r_{M/Z}(U)=r_M(Z\cup U)-r_M(Z)$ 。</p>
<p>例子：图拟阵中的缩边操作。</p>
<h2 id="极小元"><a href="#极小元" class="headerlink" title="极小元"></a>极小元</h2><p>对于一个拟阵，经过一系列删除和收缩操作得到的任意拟阵 $M’$ ，称作拟阵 $M$ 的极小元。</p>
<h1 id="拟阵并"><a href="#拟阵并" class="headerlink" title="拟阵并"></a>拟阵并</h1><h2 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a>定义</h2><p>对于给定的 $k$ 个拟阵 $M_i=(S_i,\mathcal{I_i}),1\le i\le k$ 。定义这 $k$ 个拟阵的并为 $M=(S,\mathcal{I})$ ，其中 $S=\bigcup\limits_{i=1}^k S_i,\mathcal{I}=\{\bigcup\limits_{i=1}^k I_i:I_i\in \mathcal{I_i}\}$ 。</p>
<p>遗传性非常简单，重点是交换性。</p>
<details class="toggle" ><summary class="toggle-button" style="">交换性的证明</summary><div class="toggle-content"><p>不妨认为 $|I|&lt;|I’|$</p>
<p>不妨这么考虑一个事情，首先不妨认为：$I_i\cap I_j=\emptyset,i\ne j$ 。</p>
<p>同理对于 $I’_i$ 也是。</p>
<p>这样 $|I|=\sum\limits|I_i|,|I’|=\sum\limits|I’_i|$ 。</p>
<p>所以一定存在 $i:|I’_i|&gt;|I_i|$ ,所以考虑一定存在 $x\in I’_i,I_i+\{x\}\in \mathcal{I_i}$ ，如果 $x\in \mathcal{I}$ ，则说明 $x\in I_j,i\ne j$ ，所以令 $I_j$ 删掉 $x$ ，$I_i$ 加上 $x$ ，然后重新进行这个过程，反之，则交换性成立。</p>
<p>由于 $\sum\limits |I_i\cap I’_i|$ 会不断变大，所以这个过程一定会停下来，即交换性一定成立，证毕。</p>
<p>论文是一开始就找使 $\sum\limits |I_i\cap I’_i|$ 最大的 $I_i$ ，所以不用重复这个过程。</p>
</div></details>
<h2 id="秩函数-1"><a href="#秩函数-1" class="headerlink" title="秩函数"></a>秩函数</h2><script type="math/tex; mode=display">r_M(U)=\min\limits_{T\subset U}(|T|+\sum\limits_{i=1}^k r_{M_i}((U\setminus T)\cap S_i))</script><p>要证明这个定理，我们需要证明一个引理：</p>
<p><strong>引理 6.1</strong> ：拟阵 $\hat{M}=(\hat{S},\hat{\mathcal{I}})$ ，定义函数 $f:\hat{S}\to S$ ，定义拟阵 $M=(S,\mathcal{I}),I=\{f(\hat{I})\:\hat{I}\in\hat{\mathcal{I}}\}$ ，则 $M$ 的秩函数为：</p>
<script type="math/tex; mode=display">r_M(U)=\min\limits_{T\subset U}(r_{\hat{M}}(f^{-1}(U\setminus T))+|T|)</script><p>注 ： $f^{-1}(T)=\{x\in\hat{U}:f(x)\in T\}$ 。</p>
<details class="toggle" ><summary class="toggle-button" style="">证明</summary><div class="toggle-content"><p>这个证明不需要证明这是个拟阵，但是这并不难证，交换性的证明，和拟阵并交换性的证明是几乎一样的。（也可以先证了秩函数再导出其是个拟阵）</p>
<p>考虑构造一个划分拟阵 $(\hat{S},\mathcal{I_p})$ ，其中 $I\in \mathcal{I_p}$ 当且仅当 $I$ 中不存在两个元素 $f$ 的映射值相等。</p>
<p>这样的话，$r_M(U)$ 实际上就是拟阵 $\hat{M}$ 和 $(\hat{S},\mathcal{I_p})$ 限制在 $f^{-1}(U)$ 集合的拟阵交，用最小最大定理便可证明。</p>
</div></details>
<p>用引理证明秩函数并不困难，令 $S_i$ 中的元素 $e$ 变成二元元素 $(e,i)$ ，从而区分开所有的元素，再构造函数 $f((e,i))=e$ 即可得证。</p>
<h6 id="坑4"><a href="#坑4" class="headerlink" title="坑4"></a>坑4</h6><p>后面那些判断独立集啥的，还有表示法啥的还没有学，以后再说，先咕咕了，得去做些题目了，太久没敲代码手感不对了，现在。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>国家集训队2018论文：《浅谈拟阵的一些拓展及其应用》—- 江苏省淮阴中学 杨乾澜</p>
<p>图片生成：<a href="https://csacademy.com/app/graph_editor/">https://csacademy.com/app/graph_editor/</a></p>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>拟阵</tag>
      </tags>
  </entry>
  <entry>
    <title>组合计数练习</title>
    <url>/2024/02/01/%E7%BB%84%E5%90%88%E8%AE%A1%E6%95%B0%E7%BB%83%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="括号序列和折线法"><a href="#括号序列和折线法" class="headerlink" title="括号序列和折线法"></a>括号序列和折线法</h1><p>一个经典的问题：一个括号序列的最长的合法括号子序列有多长。</p>
<h2 id="折线法解决经典问题"><a href="#折线法解决经典问题" class="headerlink" title="折线法解决经典问题"></a>折线法解决经典问题</h2><p>不难发现，每一个左括号，也就是上升的部分，我们总能指定他右边和他同高度的右括号，然后消掉。</p>
<p><img src="1.png" alt=""></p>
<p>所以消到最后，我们总是会得到一条先下降后上升的折线，可以发现，这样子消不会改变整个折线的最低点，所以，<strong>一个指定起终点的折线，其最长的合法括号子序列取决于这条折线的最低点</strong> 。</p>
<p>这也是用折线法解决括号序列问题会非常方便的原因。</p>
<h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><ol>
<li><p>指定起终点，问最低点低于某个高度的折线数量。</p>
<p>对应在括号序列：指定左括号和右括号的数量，限制最长合法括号序列的长度小于某个值。</p>
<p>做法就是折一下就行了。</p>
</li>
<li><p>有多少个折线满足 $(0,0)\to(len,0)$ 且在 $y=0$ 上方，且恰好有 $m$ 个点在 $y$ 轴上。</p>
<p>对应在括号序列：有多少个合法的括号序列满足可以恰好分成 $m-1$ 份，使得满足每一份都是：$(A)$ ，$A$ 是一个合法的括号序列。</p>
<p>做法就是：考虑每次要到 $y=0$ 的那一段就去掉，认为起点是在 $(1,1)$ ，同时整条折线不能碰到 $y=0$ 这条线，则答案等价于从 $(1,1)\to (len-m+1,m-1)$ 的折线数量。（认为起点在 $(1,1)$ 是因为我们要求这条线不能碰到 $y=0$ ）</p>
<p><img src="3.png" alt=""></p>
</li>
</ol>
<h1 id="使用排列计算概率的方法"><a href="#使用排列计算概率的方法" class="headerlink" title="使用排列计算概率的方法"></a>使用排列计算概率的方法</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>有些时候，一些问题会涉及到等概率选择一些剩余的点，并且删除这个点和一些与这个点有关联的点集，然后问关于这个过程的一些概率或者是数量问题，就可以尝试使用这个方法。</p>
<p>这个方法的关键在于：考虑将被删除这个操作看成一个删除标记，只有当一个点被选中，才会被真正的删除，这样每个点恰好被选一次，只不过，如果选中了一个点有删除标记，就重新选（这个点也视作已经被选了，真正删除掉），直到选到没有标记的为止，由于没有标记的点数量不变，所以每个点在各种情况下被选中的概率不变。</p>
<p>形式化的表述就是：对于任意一个排列，其对应的情况为：每个点有被选中当且仅当能删除他的节点都在他后面，而选中的先后顺序就是排列的先后顺序。</p>
<p>则一种情况的概率就是能对应到这种情况的排列的出现概率。</p>
<p>这样，就把计算概率，变成了统计符合条件的排列数量。</p>
<h2 id="练习-1"><a href="#练习-1" class="headerlink" title="练习"></a>练习</h2><ol>
<li><p>现在有 $n$ 个数字，每次选择一个没被删除的数字，并且删除这个数字的所有倍数，问每个数字被选中的概率。</p>
<p>设 $d(i)$ 为 $i$ 的约数个数，显然答案就是 $\frac{1}{d(i)}$ 。</p>
</li>
<li><p>给定一个 $DAG$ ，每次选择一个没被删除的点，然后删除他能到达的所有点，问期望进行几轮。</p>
<p>期望可以转化为求每个点被选中的概率和，一个点被选中的概率为 $\frac{1}{能到达他的点的数量}$ 。</p>
</li>
<li><p>给定一个数字 $n$ ，令 $n=等概率选择1到n-1中的一个数字$ ，直到 $n\le k$ ，问期望轮数。</p>
<p>同理：可以看成是每个点可以删除所有 $\ge$ 他的点，和上一题基本一样，答案就是所有 $&gt;k$ 的点的经过概率之和。</p>
<p>答案为：$1+\sum\limits_{i=k+1}^{n-1}\frac{1}{i}$ 。</p>
<p>这道题目还有个加强版，但是做法基本一样，讨论一下就行了：<a href="https://codeforces.com/contest/1924/problem/E">Codeforces Round 921 Div.1 E.Paper Cutting Again</a></p>
<p>题目大意：给定 $n*m$ 的纸，每次可以等概率选择 $n-1$ 条整数横线或者 $m-1$ 条整数竖线，剪开然后丢掉下面或者右边的部分，问当面积小于 $k$ 时至多需要多少轮。</p>
<p>$n,m\le 10^{6},2\le k\le 10^{12}$  </p>
</li>
</ol>
<h1 id="图计数"><a href="#图计数" class="headerlink" title="图计数"></a>图计数</h1><h2 id="练习-2"><a href="#练习-2" class="headerlink" title="练习"></a>练习</h2><ol>
<li><p>求 $n$ 个有标号点的无向图的数量。</p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>容斥原理，枚举 $1$ 号点的连通块大小就行了。</p>
<script type="math/tex; mode=display">f_i=2^{\frac{i(i-1)}{2}}-\sum\limits_{j=1}^{i-1}\binom{i-1}{j-1}*f_{j}*2^{\frac{(i-j)(i-j-1)}{2}}</script><p>时间复杂度：$O(n^2)$ 。</p>
</div></details></li>
<li><p>求 $n$ 个有标号的点的边双联通图的数量。</p>
<details class="toggle" ><summary class="toggle-button" style="">DP做法</summary><div class="toggle-content"><p>方法 1 ：设 $dp[i][j]$ 表示有 $j$ 个点，恰好有 $i$ 个连通块的图的权值和（一个图的权值定义为每个连通块大小的乘积），然后枚举 $1$ 号点所在的边双大小进行容斥。</p>
<p>设 $f_i$ 表示 $i$ 个点的联通块数量， $g_i$ 表示 $i$ 个点的边双联通块数量。</p>
<script type="math/tex; mode=display">g_i=f_i-\sum\limits_{j=1}^{i-1}\binom{i-1}{j-1}*g_{j}*\sum\limits_{k=1}^{i-j}dp[k][i-j]*j^{k}</script><p>方法 2 ：设 $dp[i][j]$ 表示有 $j$ 个点，恰好有 $i$ 个点双连通块且点双之间不连通的图的权值和（一个图的权值定义，为每个点双连通块大小的乘积）。</p>
<p>显然：$dp[i][j]=\sum\limits_{k=1}^{j-(i-1)}dp[i-1][j-k]<em>\binom{j-1}{k-1}</em>k*g_k$ 。</p>
<p>注意到，先固定一个 $j$ ，除了 $dp[1][j]$ 以外的 $dp[i][j]$ 的转移都不依赖 $g_j$ ，所以考虑先处理出 $dp[i][j],(i\ne 1)$ ，然后用容斥算出 $g_j$ ，然后再求 $dp[1][j]$ ，从而完成 $dp[i][j]$ 对所有 $i$ 的转移。</p>
<p>实现上就是 $j$ 从小到达枚举，每一层先对 $i\ne 1$进行转移，再求 $g_j$ ，再求 $dp[1][j]$ 即可。</p>
<p>至于容斥的式子：$g_j=f_j-\sum\limits_{i=2}^{i}dp[i][j]*j^{i-2}$ 。</p>
<p>时间复杂度：$O(n^3)$ 。</p>
<p>方法 $1$ 更加自然，方法 $2$ 主要是感觉 $dp$ 顺序非常的奇妙，所以就记录一下。</p>
</div></details>
</li>
</ol>
<h1 id="一些奇奇怪怪的方法"><a href="#一些奇奇怪怪的方法" class="headerlink" title="一些奇奇怪怪的方法"></a>一些奇奇怪怪的方法</h1><h2 id="必定经过的事件集"><a href="#必定经过的事件集" class="headerlink" title="必定经过的事件集"></a>必定经过的事件集</h2><p>想法来自：</p>
<p><a href="https://www.luogu.com.cn/blog/xuanxuan001/solution-cf1924e">https://www.luogu.com.cn/blog/xuanxuan001/solution-cf1924e</a></p>
<h3 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h3><p>当你想要求一个事件的概率时，可以找一些其他事件，使得这个事件集必然发生，且在这个事件集发生的条件下，这个事件集内的每个事件的发生概率固定，那么就可以知道我们想要的事件的概率。</p>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><ol>
<li><p><a href="https://codeforces.com/contest/1924/problem/E">Codeforces Round 921 Div.1 E.Paper Cutting Again</a></p>
<p>题目大意：给定 $n*m$ 的纸，每次可以等概率选择 $n-1$ 条整数横线或者 $m-1$ 条整数竖线，剪开然后丢掉下面或者右边的部分，问当面积小于 $k$ 时至多需要多少轮。</p>
<p>$n,m\le 10^{6},2\le k\le 10^{12}$  </p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>假设纸张为 $(n’,m’)$。</p>
<p>不难想到先转化为 $(n’=x,m’=y):xy\ge k$ 的事件的经过概率之和。</p>
<p>那么经过 $(x,y)$ 的概率有多少呢？</p>
<p>不妨先假设 $m=y$ 。</p>
<p>不难发现，第一次使得 $n’\le x$ 或者 $m’&lt;m$ 的事件集构成了一个必然事件集，且内部的事件都是等概率的。</p>
<p>所以使得 $n’=x,m’=m$ 的概率为：$\frac{1}{x+m-1}$ 。</p>
<p>那么当 $x&lt;n,y&lt;m$ 如何处理？</p>
<p>首先，我们得求得第一次使得 $n’=x,m’=y$ 的概率，类似的，令第一次 $n’\le x$ 或者 $m’\le y$ 构成一个事件集，所以 $n’=x$ 或者 $m’=y$ 的概率为 $\frac{2}{x+y}$ ，然后剩下的情况就和前面的情况一样了，概率为 $\frac{1}{x+y-1}$ ，乘在一起就是：$\frac{2}{(x+y)(x+y-1)}$ 。</p>
<p>然后裂项求个和就可以在 $O(n+m)$ 的时间得到答案了。</p>
</div></details></li>
</ol>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>计数</tag>
      </tags>
  </entry>
  <entry>
    <title>经典trick汇总</title>
    <url>/2023/09/04/%E7%BB%8F%E5%85%B8trick%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<details class="toggle" ><summary class="toggle-button" style="">时间复杂度</summary><div class="toggle-content"><details class="toggle" ><summary class="toggle-button" style="">分数之和</summary><div class="toggle-content"><ol>
<li>$O(\sum\limits_{i=1}^{n})=O(\log{n})$ （调和级数）</li>
<li>$O(\sum\limits_{i=1}^n)=O(1)$ （可以用积分、裂项证明，也可以搜搜’巴塞尔问题’，这个式子收敛于 $\frac{\pi^2}{6}$ ）</li>
</ol>
</div></details></div></details>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>ACM杂类</tag>
      </tags>
  </entry>
  <entry>
    <title>CF Round 940(Div 2) F2. Frequency Mismatch</title>
    <url>/2024/06/04/CF-Round-940-Div-2-F2-Frequency-Mismatch/</url>
    <content><![CDATA[<p>题目链接：<a href="https://codeforces.com/contest/1957/problem/F2">https://codeforces.com/contest/1957/problem/F2</a></p>
<p>题目链接：每次询问给你两条链，输出出现次数不同的颜色，至多只用输出 $k$ 个颜色。</p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>不是哥们，这都要分个 easy 和 hard 吗？</p>
<p>感觉没什么区别啊。</p>
<p>考虑多项式 Hash ，考虑 Hash 值为：$\sum\limits_{i=0}cnt_iBase^i$ ，其中 $i$ 是颜色编号。</p>
<p>直接线段树合并跑出到根节点路径上的 Hash 值，然后差分一下得到路径就行了。</p>
<p>有点卡常数，需要精细实现。</p>
<p>时间复杂度：$O((n+qk)\log{n})$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> SN = <span class="number">2e6</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M = <span class="number">1e5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> L = <span class="number">18</span>;</span><br><span class="line"><span class="type">const</span> LL M1 = <span class="number">1000000181ll</span>, A1 = <span class="number">1145141ll</span>;</span><br><span class="line"><span class="type">const</span> LL M2 = <span class="number">998244353ll</span>, A2 = <span class="number">1145141ll</span>;</span><br><span class="line">LL f1[N], f2[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    f1[<span class="number">0</span>] = f1[<span class="number">1</span>] = f2[<span class="number">0</span>] = f2[<span class="number">1</span>] = <span class="number">1ll</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= M; i++) f1[i] = f1[i - <span class="number">1</span>] * A1 % M1, f2[i] = f2[i - <span class="number">1</span>] * A2 % M2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">upd1</span><span class="params">(LL x)</span></span>&#123;<span class="keyword">return</span> x &gt;= M1 ? x - M1 : x;&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">upd2</span><span class="params">(LL x)</span></span>&#123;<span class="keyword">return</span> x &gt;= M2 ? x - M2 : x;&#125;</span><br><span class="line">PII <span class="keyword">operator</span> + (PII x, PII y)&#123;<span class="keyword">return</span> &#123;<span class="built_in">upd1</span>(x.first + y.first), <span class="built_in">upd2</span>(x.second + y. second)&#125;;&#125;</span><br><span class="line">PII <span class="keyword">operator</span> - (PII x, PII y)&#123;<span class="keyword">return</span> &#123;<span class="built_in">upd1</span>(x.first - y.first + M1), <span class="built_in">upd2</span>(x.second - y. second + M2)&#125;;&#125;</span><br><span class="line">PII <span class="keyword">operator</span> * (PII x, <span class="type">int</span> y)&#123;<span class="keyword">return</span> &#123;x.first * (M1 + y) % M1, x.second * (M2 + y) % M2&#125;;&#125;</span><br><span class="line">PII <span class="keyword">operator</span> * (<span class="type">int</span> x, PII y)&#123;<span class="keyword">return</span> y * x;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> lc, rc;</span><br><span class="line">    PII val;</span><br><span class="line">&#125;tr[SN]; <span class="type">int</span> cnt, rt[N];</span><br><span class="line"><span class="type">int</span> n, q;</span><br><span class="line"><span class="type">int</span> col[N];</span><br><span class="line"><span class="comment">// void update(int x)&#123;tr[x].val = tr[tr[x].lc].val + tr[tr[x].rc].val; tr[x].cnt = tr[tr[x].lc].cnt + tr[tr[x].rc].cnt;&#125;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">link</span><span class="params">(<span class="type">int</span> &amp;x, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> p)</span></span>&#123;</span><br><span class="line">    tr[++cnt] = tr[x];</span><br><span class="line">    x = cnt;</span><br><span class="line">    tr[x].val = tr[x].val + PII&#123;f1[p], f2[p]&#125;;</span><br><span class="line">    <span class="keyword">if</span>(l == r) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="type">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(p &lt;= mid) <span class="built_in">link</span>(tr[x].lc, l, mid, p);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">link</span>(tr[x].rc, mid + <span class="number">1</span>, r, p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">PII <span class="title">calc</span><span class="params">(<span class="type">const</span> vector&lt;PII&gt; &amp;x)</span></span>&#123;</span><br><span class="line">    PII ans = &#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> [p, type] : x)&#123;</span><br><span class="line">        ans = ans + tr[p].val * type;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">vector&lt;PII&gt; <span class="title">gleft</span><span class="params">(vector&lt;PII&gt; x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; [p, type] : x) p = tr[p].lc;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">vector&lt;PII&gt; <span class="title">gright</span><span class="params">(vector&lt;PII&gt; x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; [p, type] : x) p = tr[p].rc;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">findans</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> limit, vector&lt;PII&gt; x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(limit &gt; r || <span class="built_in">calc</span>(x) == PII&#123;<span class="number">0</span>, <span class="number">0</span>&#125;) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(l == r) <span class="keyword">return</span> l;</span><br><span class="line">    <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(limit &lt;= mid) ans = <span class="built_in">findans</span>(l, mid, limit, <span class="built_in">gleft</span>(x));</span><br><span class="line">    <span class="keyword">if</span>(ans == <span class="number">-1</span>) ans = <span class="built_in">findans</span>(mid + <span class="number">1</span>, r, limit, <span class="built_in">gright</span>(x));</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span>&#123;</span><br><span class="line">    <span class="type">int</span> y, next;</span><br><span class="line">&#125;a[N * <span class="number">2</span>]; <span class="type">int</span> len, las[N];</span><br><span class="line"><span class="type">int</span> fa[N][L], dep[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ins</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>&#123;a[++len] = &#123;y, las[x]&#125;; las[x] = len;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; L; i++) fa[x][i] = fa[fa[x][i - <span class="number">1</span>]][i - <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">link</span>(rt[x], <span class="number">1</span>, M, col[x]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k = las[x]; k; k = a[k].next)&#123;</span><br><span class="line">        <span class="type">int</span> y = a[k].y;</span><br><span class="line">        <span class="keyword">if</span>(y == fa[x][<span class="number">0</span>]) <span class="keyword">continue</span>;</span><br><span class="line">        rt[y] = rt[x];</span><br><span class="line">        fa[y][<span class="number">0</span>] = x;</span><br><span class="line">        dep[y] = dep[x] + <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">findlca</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(dep[x] &lt; dep[y]) <span class="built_in">swap</span>(x, y);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = L - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(dep[x] - dep[y] &gt;= (<span class="number">1</span> &lt;&lt; i)) x = fa[x][i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(x == y) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = L - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(fa[x][i] != fa[y][i]) x = fa[x][i], y = fa[y][i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fa[x][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin.<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) cin &gt;&gt; col[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="type">int</span> x, y;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        <span class="built_in">ins</span>(x, y);</span><br><span class="line">        <span class="built_in">ins</span>(y, x);</span><br><span class="line">    &#125;</span><br><span class="line">    dep[<span class="number">1</span>] = <span class="number">1</span>; <span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">    cin &gt;&gt; q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= q; i++)&#123;</span><br><span class="line">        <span class="type">int</span> x1, y1, x2, y2, cnt;</span><br><span class="line">        cin &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2 &gt;&gt; cnt;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">        vector&lt;PII&gt; t;</span><br><span class="line">        t.<span class="built_in">resize</span>(<span class="number">8</span>);</span><br><span class="line">        <span class="type">int</span> lca = <span class="built_in">findlca</span>(x1, y1);</span><br><span class="line">        t[<span class="number">0</span>]=&#123;rt[x1], <span class="number">1</span>&#125;;</span><br><span class="line">        t[<span class="number">1</span>]=&#123;rt[y1], <span class="number">1</span>&#125;;</span><br><span class="line">        t[<span class="number">2</span>]=&#123;rt[lca], <span class="number">-1</span>&#125;;</span><br><span class="line">        t[<span class="number">3</span>]=&#123;rt[fa[lca][<span class="number">0</span>]], <span class="number">-1</span>&#125;;</span><br><span class="line">        lca = <span class="built_in">findlca</span>(x2, y2);</span><br><span class="line">        t[<span class="number">4</span>]=&#123;rt[x2], <span class="number">-1</span>&#125;;</span><br><span class="line">        t[<span class="number">5</span>]=&#123;rt[y2], <span class="number">-1</span>&#125;;</span><br><span class="line">        t[<span class="number">6</span>]=&#123;rt[lca], <span class="number">1</span>&#125;;</span><br><span class="line">        t[<span class="number">7</span>]=&#123;rt[fa[lca][<span class="number">0</span>]], <span class="number">1</span>&#125;;</span><br><span class="line">        <span class="type">int</span> pre = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= cnt; j++)&#123;</span><br><span class="line">            pre = <span class="built_in">findans</span>(<span class="number">1</span>, M, pre + <span class="number">1</span>, t);</span><br><span class="line">            <span class="keyword">if</span>(pre == <span class="number">-1</span>) <span class="keyword">break</span>;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(pre);</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; ans.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> x : ans) cout &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; x;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看了下题解，题解说的有道理，给每个权值随一个随机数也可以。</p>
<p>总之只要 Hash 支持可加就行了。</p>
</div></details>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>Hash</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title>ARC135 赛后总结</title>
    <url>/2024/06/25/ARC135-%E8%B5%9B%E5%90%8E%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>比赛链接：<a href="https://atcoder.jp/contests/arc135/tasks/arc135_a">https://atcoder.jp/contests/arc135/tasks/arc135_a</a></p>
<h1 id="A-Floor-Ceil-Decomposition"><a href="#A-Floor-Ceil-Decomposition" class="headerlink" title="A. Floor, Ceil - Decomposition"></a>A. Floor, Ceil - Decomposition</h1><p>题目链接：<a href="https://atcoder.jp/contests/arc135/tasks/arc135_a">https://atcoder.jp/contests/arc135/tasks/arc135_a</a></p>
<p>题目大意：每次你可以选择一个数字，分为 $\left\lfloor \frac{x}{2} \right\rfloor, \left\lceil \frac{x}{2} \right\rceil$ ，一开始只有一个数字 $X$ ，问你最终可能的乘积最大值是多少。</p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>很弱智，显然 $\ge 4$ 直接分就行了。</p>
<p>最后只会剩下 $2,3$ 。</p>
<p>但是我的写法比较 SB 。</p>
<p>我写了个堆 + map，每次把最大数字弹出并且记录个数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> LL mod = <span class="number">998244353</span>;</span><br><span class="line"><span class="function">LL <span class="title">ksm</span><span class="params">(LL x, LL y)</span></span>&#123;</span><br><span class="line">    x %= mod;</span><br><span class="line">    LL ans = <span class="number">1ll</span>;</span><br><span class="line">    <span class="keyword">while</span>(y)&#123;</span><br><span class="line">        <span class="keyword">if</span>(y &amp; <span class="number">1</span>) ans = ans * x % mod;</span><br><span class="line">        x = x * x % mod;</span><br><span class="line">        y &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line">map&lt;LL, LL&gt; m;</span><br><span class="line">priority_queue&lt;LL&gt; p;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(LL x, LL y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(m.<span class="built_in">find</span>(x) == m.<span class="built_in">end</span>()) p.<span class="built_in">push</span>(x);</span><br><span class="line">    m[x] += y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    LL x;</span><br><span class="line">    cin &gt;&gt; x;</span><br><span class="line">    m[x] = <span class="number">1ll</span>;</span><br><span class="line">    p.<span class="built_in">push</span>(x);</span><br><span class="line">    <span class="keyword">while</span>(p.<span class="built_in">top</span>() &gt;= <span class="number">4</span>)&#123;</span><br><span class="line">        LL x = p.<span class="built_in">top</span>();</span><br><span class="line">        p.<span class="built_in">pop</span>();</span><br><span class="line">        LL cnt = m[x];</span><br><span class="line">        LL a = x / <span class="number">2</span>, b = x - a;</span><br><span class="line">        <span class="built_in">add</span>(a, cnt);</span><br><span class="line">        <span class="built_in">add</span>(b, cnt);</span><br><span class="line">    &#125;</span><br><span class="line">    LL ans = <span class="number">1ll</span>;</span><br><span class="line">    <span class="keyword">while</span>(!p.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        LL x = p.<span class="built_in">top</span>();</span><br><span class="line">        p.<span class="built_in">pop</span>();</span><br><span class="line">        ans = ans * <span class="built_in">ksm</span>(x, m[x]) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有没有更加好写的写法？</p>
<p>有，记忆化搜索。</p>
<p>也是我认为最好写的写法。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> LL mod = <span class="number">998244353</span>;</span><br><span class="line">map&lt;LL, LL&gt; dp;</span><br><span class="line"><span class="function">LL <span class="title">dfs</span><span class="params">(LL x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(dp.<span class="built_in">find</span>(x) != dp.<span class="built_in">end</span>()) <span class="keyword">return</span> dp[x];</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> dp[x] = <span class="built_in">dfs</span>(x / <span class="number">2</span>) * <span class="built_in">dfs</span>(x - x / <span class="number">2</span>) % mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    dp[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">    dp[<span class="number">3</span>] = <span class="number">3</span>;</span><br><span class="line">    LL n; cin &gt;&gt; n;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">dfs</span>(n) &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还有一种写法是直接记录 $\left\lfloor \frac{x}{2^k} \right\rfloor, \left\lceil \frac{x}{2^k} \right\rceil$ 以及其个数，直到组合为 $\{2,3\},\{3,4\}$ 时结束。</p>
<p>但我个人感觉这种写法就算比第一种写法好写，也容易写错，所以赛时没有使用。</p>
<p>具体代码没写。</p>
</div></details>
<h1 id="B-Sum-of-Three-Terms"><a href="#B-Sum-of-Three-Terms" class="headerlink" title="B. Sum of Three Terms"></a>B. Sum of Three Terms</h1><p>题目链接：<a href="https://atcoder.jp/contests/arc135/tasks/arc135_b">https://atcoder.jp/contests/arc135/tasks/arc135_b</a></p>
<p>题目大意：给你一个数组 $S$ ，要求找到一个长度为 $n+2$ 的数组 $A$ 满足：</p>
<ol>
<li>非负。</li>
<li>$S[i]=A[i]+A[i+1]+A[i+2]$</li>
</ol>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>注意到 $S[i+1]-S[i]=A[i+3]-A[i]$ 。</p>
<p>所以条件可以等价成：$A[1]+A[2]+A[3]=S[1]$ ，以及 $A[i]-A[i-3]=k$ ，以及要求非负。</p>
<p>那么直接求出在非负条件下 $A[1],A[2],A[3]$ 的下界，然后直接随便定个初值就行了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;LL, LL&gt; PLL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">3e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> LL inf = <span class="number">1e9</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">LL S[N], sum[N];</span><br><span class="line">LL l[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n + <span class="number">1</span>; i++)&#123;</span><br><span class="line">        cin &gt;&gt; S[i];</span><br><span class="line">    &#125;</span><br><span class="line">    l[<span class="number">0</span>] = l[<span class="number">1</span>] = l[<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">3</span>; i &lt;= n + <span class="number">1</span>; i++)&#123;</span><br><span class="line">        sum[i] = sum[i - <span class="number">3</span>] + S[i] - S[i <span class="number">-1</span>];</span><br><span class="line">        l[i % <span class="number">3</span>] = <span class="built_in">max</span>(l[i % <span class="number">3</span>], -sum[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(l[<span class="number">0</span>] + l[<span class="number">1</span>] + l[<span class="number">2</span>] &gt; S[<span class="number">2</span>])&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;No\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Yes\n&quot;</span>;</span><br><span class="line">    l[<span class="number">2</span>] = S[<span class="number">2</span>] - l[<span class="number">0</span>] - l[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">3</span>; i &lt;= n + <span class="number">1</span>; i++)&#123;</span><br><span class="line">        l[i] = l[i % <span class="number">3</span>] + sum[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n + <span class="number">1</span>; i++)&#123;</span><br><span class="line">        cout &lt;&lt; l[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>跟官方做法本质相同，在此不再赘述。</p>
</div></details>
<h1 id="C-XOR-to-All"><a href="#C-XOR-to-All" class="headerlink" title="C. XOR to All"></a>C. XOR to All</h1><p>题目链接：<a href="https://atcoder.jp/contests/arc135/tasks/arc135_c">https://atcoder.jp/contests/arc135/tasks/arc135_c</a></p>
<p>题目大意：给你一个序列，每次可以选择其中一个数字，然后让序列中所有数字异或这个数字，问最后得到的和的最大值是多少，可以操作无数次。</p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>注意到一个事情，最终答案一定是所有序列异或上某个数字，而且只要操作过，就一定有数字为 $0$ ，综上，我们直到无论操作多少次，都等价于让序列异或上原来序列中的一个数字，也就是操作多次=操作一次。</p>
<p>所以直接枚举统计答案就行了。</p>
<p>时间复杂度：$O(n\log{V})$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">3e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> L = <span class="number">30</span>;</span><br><span class="line">LL cnt[L], n, a[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; L; j++) cnt[j] += (a[i] &gt;&gt; j) &amp; <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    LL ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        ans += a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        LL now = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; L; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>((a[i] &gt;&gt; j) &amp; <span class="number">1</span>) now += (<span class="number">1ll</span> &lt;&lt; j) * (n - cnt[j]);</span><br><span class="line">            <span class="keyword">else</span> now += (<span class="number">1ll</span> &lt;&lt; j) * cnt[j];</span><br><span class="line">        &#125;</span><br><span class="line">        ans = <span class="built_in">max</span>(ans, now);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></details>
<h1 id="D-Add-to-Square"><a href="#D-Add-to-Square" class="headerlink" title="D. Add to Square"></a>D. Add to Square</h1><p>题目链接：<a href="https://atcoder.jp/contests/arc135/tasks/arc135_d">https://atcoder.jp/contests/arc135/tasks/arc135_d</a></p>
<p>题目大意：给一个表格，然后可以执行一个操作：选择一个 2*2 的子矩阵，然后让其加上同一个值（可以为负数），可以执行无数次，问最小的可能的绝对值和是多少。</p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>一个很典的想法是，先给这个操作找到不变量。</p>
<p>可以发现，如果将表格奇偶染色，然后将奇数格变成负的，然后将操作做对应的变换，那么整个矩阵的和就是不变量，而且不影响最终答案。（显然取负值并不改变绝对值的和）</p>
<p>所以变成这样的问题：选择一个 2*2 的矩阵，使得 $(1,1),(2,2)$ 加上 $x$ ，$(1,2),(2,1)$ 减去 $x$ 。</p>
<p>又可以发现，这里我们相当于有 $(n-1)(m-1)$ 个方程，且不线性相关，所以我们能把左上角消成 $0$ ，只保留最右边和最下边。</p>
<p>但是剩下的数字是多少，这个时候就可以发现，其实每行和每列的和也是不变量，这决定了在把左上角矩阵消成 $0$ 后的矩阵长啥样。</p>
<p>接着就可以发现：两个矩阵能互相到达当且仅当每行和每列的和是一样的。</p>
<p>然后就可以做了，不难发现答案的上界是：行的和的绝对值和，和列的和的绝对值和的最大值。</p>
<p>构造方案就是一个匹配的活。</p>
<p>时间复杂度：$O(nm+n^2+m^2)$ 。</p>
<p>做毕。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">5e2</span> + <span class="number">5</span>;</span><br><span class="line">LL a[N][N], b[N][N];</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line">LL row[N], col[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sgn</span><span class="params">(LL x)</span></span>&#123;<span class="keyword">return</span> x &lt; <span class="number">0</span> ? <span class="number">-1</span> : (x &gt; <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>);&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++)&#123;</span><br><span class="line">            cin &gt;&gt; a[i][j];</span><br><span class="line">            <span class="keyword">if</span>((i + j) &amp; <span class="number">1</span>) a[i][j] = -a[i][j];</span><br><span class="line">            row[i] += a[i][j];</span><br><span class="line">            col[j] += a[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="built_in">sizeof</span>(a));</span><br><span class="line">    <span class="type">int</span> type = <span class="number">0</span>;</span><br><span class="line">    LL ans = <span class="number">0ll</span>;</span><br><span class="line">    &#123;</span><br><span class="line">        LL ans1 = <span class="number">0ll</span>, ans2 = <span class="number">0ll</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) ans1 += <span class="built_in">abs</span>(row[i]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) ans2 += <span class="built_in">abs</span>(col[i]);</span><br><span class="line">        <span class="keyword">if</span>(ans1 &lt; ans2)&#123;</span><br><span class="line">            type = <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">swap</span>(n, m);</span><br><span class="line">            <span class="built_in">swap</span>(row, col);</span><br><span class="line">            <span class="built_in">swap</span>(ans1, ans2);</span><br><span class="line">        &#125;</span><br><span class="line">        ans = ans1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="type">int</span> x = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(col[i] != <span class="number">0</span>) &#123;x = i; <span class="keyword">break</span>;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(x == <span class="number">-1</span>) <span class="keyword">break</span>;</span><br><span class="line">        <span class="type">int</span> y = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">sgn</span>(col[x]) == <span class="built_in">sgn</span>(row[i]))&#123;</span><br><span class="line">                y = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">assert</span>(y != <span class="number">-1</span>);</span><br><span class="line">        a[y][x] = <span class="built_in">sgn</span>(col[x]) * <span class="built_in">min</span>(<span class="built_in">abs</span>(col[x]), <span class="built_in">abs</span>(row[y]));</span><br><span class="line">        col[x] -= a[y][x];</span><br><span class="line">        row[y] -= a[y][x];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="type">int</span> x = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(row[i] != <span class="number">0</span>) &#123;x = i; <span class="keyword">break</span>;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(x == <span class="number">-1</span>) <span class="keyword">break</span>;</span><br><span class="line">        <span class="type">int</span> y = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(row[i] != <span class="number">0</span> &amp;&amp; <span class="built_in">sgn</span>(row[x]) != <span class="built_in">sgn</span>(row[i]))&#123;</span><br><span class="line">                y = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        LL val = <span class="built_in">min</span>(<span class="built_in">abs</span>(row[x]), <span class="built_in">abs</span>(row[y]));</span><br><span class="line">        a[x][<span class="number">1</span>] += <span class="built_in">sgn</span>(row[x]) * val;</span><br><span class="line">        a[y][<span class="number">1</span>] += <span class="built_in">sgn</span>(row[y]) * val;</span><br><span class="line">        row[x] -= <span class="built_in">sgn</span>(row[x]) * val;</span><br><span class="line">        row[y] -= <span class="built_in">sgn</span>(row[y]) * val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(type)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++) b[i][j] = a[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++) a[j][i] = b[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">swap</span>(n, m);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>((i + j) &amp; <span class="number">1</span>) a[i][j] = -a[i][j];</span><br><span class="line">            cout &lt;&lt; a[i][j] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></details>
<h1 id="E-Sequence-of-Multiples"><a href="#E-Sequence-of-Multiples" class="headerlink" title="E. Sequence of Multiples"></a>E. Sequence of Multiples</h1><p>题目链接：<a href="https://atcoder.jp/contests/arc135/tasks/arc135_e">https://atcoder.jp/contests/arc135/tasks/arc135_e</a></p>
<p>题目大意：给定 $N,X$ ，要求构造一个和最小的长度为 $N$ 的序列 $A$ 满足：</p>
<ol>
<li>严格递增。</li>
<li>$A_1=X$</li>
<li>$A_{i}$ 被 $i$ 整除。</li>
</ol>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>注意到一个事情：$A_i=i*B_i$ 。</p>
<p>那么 $A_{i}\equiv -B_i \mod{i+1}$ 。</p>
<p>我们显然关心 $A_{i+1}-A_{i}$ ，而这个显然等于：$B_{i}\mod i+1$ （注，由于严格递增，在整除的时候为 $i+1$）</p>
<p>当 $B_{i}&lt;i+1$ 时，就为 $B_{i}$ ，而且不难发现以后也为 $B_{i}$ 。</p>
<p>即 $B_{i}$ 是非严格单调递减的，而且当 $B_{i}\le i+1$ 后，$B_{i}$ 保持恒定。</p>
<p>具体来说：$B_{i+1}=B_{i}-\left\lfloor\frac{B_{i}-1}{i+1}\right\rfloor$</p>
<p>但是我们可以发现，这个保持恒定的量级可以到 $10^9$ 。</p>
<p>$\ge$ 是显然的，$\le$ 也不难：</p>
<p>往极坏的角度想：在 $i$ 的时候就 $+i$ 。</p>
<p>那么在 $2e9$ 的时候就是：$1e18+\frac{(2e9+1)*2e9}{2}&lt;2e9^2$ 。</p>
<p>所以在 $\le 2e9$ 的时候进入恒定状态。</p>
<p>但我们显然不可能枚举这个量级，怎么办呢？</p>
<p>在苦思冥想下，我突然意识到，复杂度有没有可能是：$O(n^{\frac{1}{3}})$ 的。</p>
<p>因为可以发现在 $1e6$ 量级后，$\frac{B_i-1}{i}$ 的量级也是 $1e6$ 的。（与上面的证明方法类似）</p>
<p>而且 $\left\lfloor\frac{B_{i}-1}{i+1}\right\rfloor$ 是单调递减的，这意味着 $B_{i+1}-B_{i}$ 在 $1e6$ 之后只会有 $1e6$ 种可能的取值。（以上指的都是量级）</p>
<p>所以直接二分出每个可能取值的分界点，就可以在 $O(n^{\frac{1}{3}}\log{n})$ 的复杂度内解决了。</p>
<p>后面发现二分的判别式是一个线性函数，因此可以 $O(1)$ 找到分界点。</p>
<p>而且类似整除分块的，在 $1e6$ 之前的部分同样也可以用这个函数处理，因为也只有 $1e6$ 种取值，不过限制取值数量的条件不是值域，而是定义域，这时求出来的分界点很集中，基本就是自己。</p>
<p>然后就做完了。</p>
<p>时间复杂度：$O(Tn^{\frac{1}{3}})$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> LL mod = <span class="number">998244353</span>;</span><br><span class="line"><span class="function">LL <span class="title">ksm</span><span class="params">(LL x, LL y)</span></span>&#123;</span><br><span class="line">    LL ans = <span class="number">1ll</span>;</span><br><span class="line">    <span class="keyword">while</span>(y)&#123;</span><br><span class="line">        <span class="keyword">if</span>(y &amp; <span class="number">1</span>) ans = ans * x % mod;</span><br><span class="line">        x = x * x % mod;</span><br><span class="line">        y &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">ni</span><span class="params">(LL x)</span></span>&#123;<span class="keyword">return</span> <span class="built_in">ksm</span>(x, mod - <span class="number">2</span>);&#125;</span><br><span class="line"><span class="type">const</span> LL n2 = <span class="built_in">ni</span>(<span class="number">2</span>), n4 = <span class="built_in">ni</span>(<span class="number">4</span>), n6 = <span class="built_in">ni</span>(<span class="number">6</span>);</span><br><span class="line"><span class="function">LL <span class="title">mt</span><span class="params">(LL x)</span></span>&#123;<span class="keyword">return</span> (x % mod + mod) % mod;&#125;</span><br><span class="line"><span class="function">LL <span class="title">q1</span><span class="params">(LL x)</span></span>&#123;<span class="keyword">return</span> <span class="built_in">mt</span>(x) * <span class="built_in">mt</span>(x + <span class="number">1</span>) % mod * n2 % mod;&#125;</span><br><span class="line"><span class="function">LL <span class="title">q1</span><span class="params">(LL l, LL r)</span></span>&#123;<span class="keyword">return</span> <span class="built_in">mt</span>(<span class="built_in">q1</span>(r) - <span class="built_in">q1</span>(l - <span class="number">1</span>));&#125;</span><br><span class="line"><span class="function">LL <span class="title">q2</span><span class="params">(LL x)</span></span>&#123;<span class="keyword">return</span> <span class="built_in">mt</span>(x) * <span class="built_in">mt</span>(x + <span class="number">1</span>) % mod * <span class="built_in">mt</span>(x + x + <span class="number">1</span>) % mod * n6 % mod;&#125;</span><br><span class="line"><span class="function">LL <span class="title">q2</span><span class="params">(LL l, LL r)</span></span>&#123;<span class="keyword">return</span> <span class="built_in">mt</span>(<span class="built_in">q2</span>(r) - <span class="built_in">q2</span>(l - <span class="number">1</span>));&#125;</span><br><span class="line"><span class="comment">// LL q3(LL x)&#123;return mt(x) * mt(x) % mod * mt(x + 1) % mod * mt(x + 1) % mod * n4 % mod;&#125;</span></span><br><span class="line"><span class="comment">// LL q3(LL l, LL r)&#123;return mt(q3(r) - q3(l - 1));&#125;</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        LL n, X, ans = <span class="number">0ll</span>;</span><br><span class="line">        cin &gt;&gt; n &gt;&gt; X;</span><br><span class="line">        ans = <span class="built_in">mt</span>(n) * <span class="built_in">mt</span>(X) % mod;</span><br><span class="line">        LL val = <span class="number">2ll</span>;</span><br><span class="line">        <span class="keyword">while</span>(val &lt; X &amp;&amp; val &lt;= n)&#123;</span><br><span class="line">            LL cnt = (X - <span class="number">1</span>) / val;</span><br><span class="line">            LL l = val + <span class="number">1</span>, r = <span class="built_in">min</span>(X / cnt, n), mid, pos = val;</span><br><span class="line">            pos = <span class="built_in">min</span>((X + cnt * val - <span class="number">1</span>) / (cnt + cnt), n);</span><br><span class="line">            ans += <span class="built_in">mt</span>(X + val * cnt) * <span class="built_in">mt</span>(n + <span class="number">1</span>) % mod * <span class="built_in">mt</span>(pos - val + <span class="number">1</span>) % mod;</span><br><span class="line">            ans -= <span class="built_in">mt</span>(X + val * cnt) * <span class="built_in">q1</span>(val, pos) % mod;</span><br><span class="line">            ans -= <span class="built_in">mt</span>(cnt + cnt) * <span class="built_in">mt</span>(n + <span class="number">1</span>) % mod * <span class="built_in">q1</span>(val, pos) % mod;</span><br><span class="line">            ans += <span class="built_in">mt</span>(cnt + cnt) * <span class="built_in">q2</span>(val, pos) % mod;</span><br><span class="line"></span><br><span class="line">            ans = <span class="built_in">mt</span>(ans);</span><br><span class="line"></span><br><span class="line">            X -= cnt * (pos - val + <span class="number">1</span>);</span><br><span class="line">            val = pos + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(val &lt;= n)&#123;</span><br><span class="line">            <span class="built_in">assert</span>(X &lt;= val);</span><br><span class="line">            ans += <span class="built_in">mt</span>(n - val + <span class="number">2</span>) * <span class="built_in">mt</span>(n - val + <span class="number">1</span>) % mod * n2 % mod * X;</span><br><span class="line">            ans = <span class="built_in">mt</span>(ans);</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但因为没在赛时推出正确的式子，导致无法在赛时 AC 。</p>
<p>不过是 VP ，问题也不是那么大。</p>
<p>和官方做法基本一致，在此不再赘述官方做法。</p>
</div></details>
<details class="toggle" ><summary class="toggle-button" style="">别的做法</summary><div class="toggle-content"><p><a href="https://www.luogu.com.cn/article/thzagqey">https://www.luogu.com.cn/article/thzagqey</a></p>
<p>有一种做法，是打表，发现在 $\sqrt{x}$ 后 $A$ 变成了等差数列。</p>
<p>差分一下，发现序列由 $n^{\frac{1}{3}}$ 段等差数列构成，并且总是在即将 $\le 0$ 后转换到下一个等差数列。</p>
<p>更准确的来讲，是说可以把序列分成若干段等差数列，每段都在即将 $\le 0$ 时结束，等差数列的长度可以为 $1$ 。（后面会讲为什么）</p>
<p>直接计算就行了。</p>
<p>时间复杂度：$O(Tn^{\frac{1}{3}})$ 。</p>
<p>问题来了，为什么？</p>
<p>首先等差数列不难理解，在我的做法中，$B_{i-1}-\left\lfloor\frac{B_{i-1}-1}{i}\right\rfloor<em>i=B_{i-1}-(B_{i-1}-B_{i})</em>i=B_{i}<em>i-B_{i-1}</em>(i-1)=A_{i}-A_{i-1}$ 就是 $A$ 的差分，二分中的每一段实际就是 $B$ 差分相等的部分，即我们认为：$B_{i+k}=B_{i}-kd$ 。</p>
<p>则有：</p>
<script type="math/tex; mode=display">\begin{align*}

&B_{i+k}(i+k)-B_{i+k-1}(i+k-1) \\
=&(B_{i}-kd)(i+k)-(B_{i}-(k-1)d)(i+k-1) \\
=&B_{i}-kd-d(i+k-1) \\
=&B_{i}-2dk-d(i-1) \\
=&-2dk+(B_{i}-d(i-1))

\end{align*}</script><p>即 $A$ 的一阶差分是个等差数列。</p>
<p>但为什么总是在即将 $\le 0$ 后转换到下一个等差数列呢？</p>
<p>而分界点的条件可以表示为：</p>
<p>最大的 $k$ 满足：$\left\lfloor\frac{B_{i+(k-1)}-1}{i+k}\right\rfloor \ge d,\left\lfloor\frac{B_{i+k}-1}{i+k+1}\right\rfloor &lt; d$ ，这里 $\ge$ 可以写成 $=$ 。</p>
<p>也就是：</p>
<script type="math/tex; mode=display">
\begin{align*}
\left\lfloor\frac{B_{i+k-1}-1}{i+k}\right\rfloor &\ge d \\
B_{i}-(k-1)d-1&\ge d(i+k)\\
B_{i}&\ge 2dk+d(i-1)+1\\
B_{i}-2dk-d(i-1)&\ge 1\\
A_{i+k}-A_{i+k-1}&\ge 1\\

\left\lfloor\frac{B_{i+k}-1}{i+k+1}\right\rfloor &< d\\
B_{i}-kd-1&<d(i+k+1)\\
B_{i}&<2d(k+1)+d(i-1)+1\\
B_{i}-2d(k+1)-d(i-1)&<1\\

\end{align*}</script><p>这就证明了这件事情。</p>
<p>但需要注意的是：可以发现，一段长度为 $len+1$ 的 $B$ 的等差数列，对应 $A$ 的差分序列的一段长度为 $len$ 的等差数列，因此会有很多长度为 $1$ 的等差数列。（虽然可以认为相邻两个数字是等差数列，但是这种等差数列并不满足上面的将要 $\le 0$ 就切换到另外一个等差数列的性质）</p>
<p>为此，在实现中的一个简单的解决方法是直接算出后 $10$ 项，如果满足等差数列就直接算，赌他不会这么巧恰好由 $10$ 个长度为 $1$ 的等差数列构成。</p>
<p>但是我们还是希望知道什么时候 $len$ 会稳定的 $\ge 2$ 呢？</p>
<p>我们先设 $C_{i}=B_{i}-1$ ，那么 $C_{i+1}=C_{i}-\left\lfloor\frac{C_{i}}{i+1}\right\rfloor$ 。</p>
<p>那么问题可以抽象成这样：</p>
<p>现在有 $i+1$ 个柱子，均匀放，每次将最少东西的柱子的东西删除，再添加一个柱子均匀放，问经过几轮后能够出现稳定两轮删除的东西数相同？</p>
<p>设 $D_{i}=\left\lfloor\frac{C_{i}}{i+1}\right\rfloor$ ，这里给一个必要条件，当 $D_{i-1} ≠ D_{i}$ 且 $6D_{i}+1\le i$ 时，在此之后 $len\ge 1$ 。</p>
<p>证明就是假定一个 $i*D_{i-1}$ 的长方形（这样对后面的亏损是最大化的），然后开做这个补的过程，发现可以做至少两次，同时可以证明此时 $D_{i-1}=D_{i}+1$ ，所以只能用最上面那一行来补就证明完了。</p>
<script type="math/tex; mode=display">\begin{align*}
D_{i}&\le \frac{i-1}{6}\\
C_{i}&\le (i+1)D_{i}+i\le \frac{i^2-1}{6}+i\\
B_{i}=C_{i}+1&\le \frac{i^2+6i+5}{6}\\
A_{i}&\le \frac{i^2+6i+5}{6}*i\\
\end{align*}</script><p>我们想要估计出 $i$ 的量级：</p>
<script type="math/tex; mode=display">\begin{align*}
A_1+\frac{i(i+1)}{2}&\le \frac{i^2+6i+5}{6}*i\\
10^{18}&\le \frac{i^2+6i+5}{6}*i-\frac{i(i+1)}{2}\\
\end{align*}</script><p>这条式子在 $\ge 2*10^6$ 处总是满足，而且显然是 $O(n^{\frac{1}{3}})$ 的。</p>
<p>问题就在于什么时候：$D_{i}≠D_{i+1}$ 。</p>
<p>设 $a_{i}=A_{i}-A_{i-1}$ 。</p>
<p>如果 $a_{i+1}&gt;a_{i}$ 或者 $a_{i}-a_{i-1}≠a_{i+1}-a_{i}$ ，那么显然 $D_{i}≠D_{i-1}$ 。</p>
<p>否则：$a_{i-1}\ge a_{i}\ge a_{i+1},a_{i-1}-a_{i}=a_{i}-a_{i+1}$ ，那么有如果 $D_{i-1}≠D_{i}$ ，那么从 $i$ 开始就有长度为 $2$ 的等差数列，公差为 $a_{i}-a_{i+1}$，否则 $D_{i-1}=D_{i}$ ，这个时候 $i$ 依旧是公差为 $a_{i}-a_{i+1}$ 的等差数列的一部分，直接计算就行了。</p>
<p>也就是说，在 $2e6$ 后我们可以在 $O(1)$ 的时间进入求等差数列的过程，这个过程就是：求出公差，一直算到 $\le 0$ 为止，然后接着求下一段直到 $\ge n$ 。（因为 $A$ 为等差数列的阶段等价于 $a$ 为恒为 $0$ 的等差数列的阶段，只不过这个等差数列不会结束而已）</p>
<p>这样这个做法就比较好实现了。</p>
<p>综上，时间复杂度：$O(Tn^{\frac{1}{3}})$ 。<del>但问题是如果我都会证明这个了为什么不直接用上面这个做法</del></p>
<p>其实说的道理，既然一开始就选择了打表，不妨在实现时就使用多算几项估计一下等差数列，也不会有多难写，还充分发扬了打表省时间的优势，如果尝试证明的话就会浪费不少时间了，不过赛后确实可以花时间证证。</p>
</div></details>]]></content>
      <categories>
        <category>信息学</category>
      </categories>
  </entry>
  <entry>
    <title>Exact Subsequences</title>
    <url>/2024/06/26/Exact-Subsequences/</url>
    <content><![CDATA[<p>题目链接：<a href="https://qoj.ac/problem/6351">https://qoj.ac/problem/6351</a></p>
<p>题目大意：问你内恰有 $n$ 个本质不同子序列的且字典序排名为 $k$ 的 $01$ 串是啥。</p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>非常 amazing 的一道题目。</p>
<p>首先想想对于一个 $01$ 串怎么求本质不同的 $01$ 串个数，因为我记得之前队友做过一道这样的题目，做法是万能欧几里得。</p>
<p>设 $f_0$ 表示添加 $0$ 后变成新的子序列的串，$f_1$ 同理。</p>
<p>初始时 $f_0=f_1=1$ ，可以发现，转移就是：</p>
<p>$f_0=f_0+f_1$ （添加 $1$）</p>
<p>$f_1=f_0+f_1$ （添加 $0$）</p>
<p>而子序列个数恰好等于 $f_0+f_1-2$ 。</p>
<p>可以发现，这个过程是 gcd 的逆过程（把取模的过程看成一个个减的过程），因此顺过来看，$f_0$ 必须满足和 $n+2$ 互质，即任意一个本质不同字串个数等于 $n+2$ 的串对应一个与 $n+2$ 互素的数字，而 $01$ 串其实就是其 gcd 的过程。（因此无解就是 $&gt;\phi(n+2)$）</p>
<p>因此现在就是要找过程字典序第 $k$ 小的与 $n+2$ 互素的 $x$ 。</p>
<p>这怎么找呢？设数字为 $(x,y=n-x)$ （为了方便，后面都认为 $n=n+2$ ），不妨考虑逆着求本质不同子序列个数，这样来做一一对应，其过程就等价于这样的字符串：</p>
<p>从左到右，出现 $0$ 就 ：$y-x$ ，出现 $1$ 就 $x-y$ ，做完后 $x=y=1$ 。</p>
<p>注：这同时也证明了，对于一个 $01$ 串，拿着 $(1,1)$ 正着跑和倒着跑最后得到的 $x+y$ 的值是一样的。同时，在后面会频繁出现拿着 $(x,y)$ 跑一遍字符串这种话，一般情况下，如果 $x,y\le 1$ ，做的是加法的那种跑，否则是减法的那种跑。</p>
<p>这样就可以二分了，由于我们知道 $gcd$ 的过程中，$01$ 转化不会超过 $O(\log)$ 次，所以总时间复杂度为 $O(\log^2)$ 的。</p>
<p>由于具体过程中并不知道二分的上界，我选择倍增。</p>
<p>倍增是这样子倍增：$x’=ax-bn,y’=-cx+dn$ ，其中要求 $x’\ge 0, y’ \ge 0,x\ge 1$ ，从而得到初值 $x$ 的上界和下界，然后上界等于下界时，得到最终答案 $x$ 。</p>
<p>当我们想要确定 $0$ 的数量时，我们就设 $y’’=y’-kx’$ ，可以发现如果 $(x’,y’)$ 对应的区间为 $[l,r]$ ，那么 $(x’,y’’)$ 对应的区间为 $[l,r’]$ ，只要确保其中的数字够 $k$ 就行了。</p>
<p>$1$ 的数量类似，不过我们需要先计算出其是这个区间中字典序排名第几大的，相当于取个反。</p>
<p>感觉还是蛮有细节需要证明的，有些东西不会证明就直接判掉了。</p>
<p>细节 1 ：$\exist x\in[l,r]:gcd(x,n)=1,$ 且 $(x,n-x)$ 进行当前跑出来的 $01$ 串能够变成 $(1,0)/(0,1)/(1,1)$ 的必要条件是 $l=r$ 或者 $l=n-1,r=n$ 。</p>
<p><details class="toggle" ><summary class="toggle-button" style="">证明</summary><div class="toggle-content"><p>$(1,1)$ ：</p></p>
<p>$ax-bn\ge0, -cx+dn\ge0$ 在取到特解 $x’$ 时满足：$ax-bn=1, -cx+dn=1$ 。</p>
<p>可以发现，上界 $\ge x’$ 。</p>
<p>$-c(x’+1)+dn=1-c$ ，当 $c&gt;1$ 时上界 $=x’$ ，否则此时 $c=1$，意味着 $d=1$ ，所以上界为 $n$ ，$x’=n-1$ ，又 $n\ge 3$ ，所以至少有一个 $1$ ，由下面的讨论知道 $l=n-1,r=n$ 。</p>
<p>$a(x’-1)-bn=1-a$ ，当 $a&gt;1$ 时下界 $&gt;x’-1$ 。</p>
<p>$a=1$ 意味着 $b=0$ ，所以过程是 $00000…$ ，这个时候可以发现下界为 $0$ ，故 $x’=1$ ，但又有额外要求：$x\ge 1$ ，所以此时区间中只有一个数字。</p>
<p>剩下的两个状态一定会经过 $(1,1)$ ，证毕。</p>
</div></details>
<p>细节 2 ：过程中的 $a,b,c,d$ 会不会爆 long long （一旦区间中只有一个数字就退出）。</p>
<details class="toggle" ><summary class="toggle-button" style="">证明</summary><div class="toggle-content"><p>不难发现，我们可以将倍增过程中的减号全部变成加号，状态改成 $(ax+bn,cx+dn)$ ，不会影响 $a,b,c,d$ ，这样我们只要拿着 $(1,1)/(1,0)$ 倒着跑一遍就可以得到 $a,b,c,d$ 的精确值。</p>
<p>首先倍增过程中一致保持着 $[l,r]$ 中是有合法解的，因此区间中一旦只有两个数字，分为两种情况讨论：</p>
<ol>
<li>此时这个唯一的合法解超过 $(1,1)$ ，即恰好或者还没到，因此绝对 $\ge (1,1)$ 。注 ：我们认为 $(a,b)\ge(c,d)$ 等价于 $a\ge c,b\ge d$ ，直接拿着 $(1,1)$ 倒着跑，就可以得到范围 $\le n$ ，不会爆。</li>
<li><p>$(0,1)/(1,0)$ ，以 $(1,0)$ 举例，初始区间为 $[1,n]$ ，因此过程是非空的，又由于是区间长度一为 $1$ 我们就退出，我们先假设上一步中的区间不是 $[n-1,n]$ ，那么过程最后一个字符一定为 $0$ ，扔掉这个字符后的结果为 $(1,1)$ ，因此我们从左边拿着 $(1,1)$ 走完这个字符串得到的结果 $\le 2n$ 。</p>
<p>如果是 $[n-1,n]$，那么 $a=n,b=n-1,c=1,d=1$ ，在倍增一次后变成：$a=n,b=n-1,c=n+1,d=n$ ，直接退出，因此，范围还是在 $O(n)$ 的。</p>
</li>
</ol>
<p>综上，范围是在 $O(n)$ 的，不会爆 long long 。</p>
</div></details>
<p>其余小的细节就不再赘述了。</p>
<p>最终时间复杂度：$O(T\sqrt{n}\log^2n)$ 。（还要算区间中与 $n$ 互素的数字个数）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;LL, LL&gt; PLL;</span><br><span class="line">PLL <span class="keyword">operator</span>+(PLL x, PLL y)&#123;<span class="keyword">return</span> &#123;x.first + y.first, x.second + y.second&#125;;&#125;</span><br><span class="line">PLL <span class="keyword">operator</span>-(PLL x, PLL y)&#123;<span class="keyword">return</span> &#123;x.first - y.first, x.second - y.second&#125;;&#125;</span><br><span class="line">PLL <span class="keyword">operator</span>*(PLL x, LL y)&#123;<span class="keyword">return</span> &#123;x.first * y, x.second * y&#125;;&#125;</span><br><span class="line">PLL <span class="keyword">operator</span>*(LL x, PLL y)&#123;<span class="keyword">return</span> y * x;&#125;</span><br><span class="line"><span class="comment">//x.first * t + y.second * n</span></span><br><span class="line">LL n, K;</span><br><span class="line"><span class="function">PLL <span class="title">getrange</span><span class="params">(PLL l, PLL r)</span></span>&#123;<span class="keyword">return</span> &#123;<span class="built_in">max</span>((l.first - <span class="number">1</span> - l.second * n) / l.first, <span class="number">1ll</span>), - r.second * n / r.first&#125;;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printans</span><span class="params">(LL x)</span></span>&#123;</span><br><span class="line">    vector&lt;PLL&gt; ans;</span><br><span class="line">    LL y = n - x;</span><br><span class="line">    <span class="keyword">while</span>(x &gt; <span class="number">1</span> || y &gt; <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">assert</span>(x &amp;&amp; y);</span><br><span class="line">        <span class="keyword">if</span>(x &gt; y)&#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(&#123;<span class="number">1ll</span>, x / y&#125;);</span><br><span class="line">            x %= y;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(&#123;<span class="number">0ll</span>, y / x&#125;);</span><br><span class="line">            y %= x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ans.<span class="built_in">back</span>().second--;</span><br><span class="line">    cout &lt;&lt; ans.<span class="built_in">size</span>() &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; (*ans.<span class="built_in">begin</span>()).first &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> [d, cnt] : ans) cout &lt;&lt; cnt &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">vector&lt;LL&gt; p;</span><br><span class="line">vector&lt;LL&gt; fac;</span><br><span class="line"><span class="function">LL <span class="title">query</span><span class="params">(LL x)</span></span>&#123;</span><br><span class="line">    LL ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; fac.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(__builtin_popcount(i) &amp; <span class="number">1</span>) ans -= x / fac[i];</span><br><span class="line">        <span class="keyword">else</span> ans += x / fac[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">query</span><span class="params">(LL l, LL r)</span></span>&#123;<span class="keyword">return</span> <span class="built_in">query</span>(r) - <span class="built_in">query</span>(l - <span class="number">1</span>);&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    p.<span class="built_in">clear</span>();</span><br><span class="line">    fac.<span class="built_in">clear</span>();</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; K;</span><br><span class="line">    n += <span class="number">2</span>;</span><br><span class="line">    &#123;</span><br><span class="line">        LL now = n;</span><br><span class="line">        <span class="keyword">for</span>(LL i = <span class="number">2</span>; i * i &lt;= now; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(now % i != <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            p.<span class="built_in">push_back</span>(i);</span><br><span class="line">            <span class="keyword">while</span>(now % i == <span class="number">0</span>) now /= i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(now &gt; <span class="number">1ll</span>) p.<span class="built_in">push_back</span>(now);</span><br><span class="line">        fac.<span class="built_in">push_back</span>(<span class="number">1ll</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> x : p)&#123;</span><br><span class="line">            <span class="type">int</span> pre = fac.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; pre; i++) fac.<span class="built_in">push_back</span>(fac[i] * x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">query</span>(<span class="number">1</span>, n) &lt; K)&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;-1\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    PLL left, right;</span><br><span class="line">    left = &#123;<span class="number">1ll</span>, <span class="number">0ll</span>&#125;;</span><br><span class="line">    right = &#123;<span class="number">-1ll</span>, <span class="number">1ll</span>&#125;;</span><br><span class="line">    <span class="type">int</span> type = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">auto</span> [l1, r1] = <span class="built_in">getrange</span>(left, right);</span><br><span class="line">        <span class="keyword">if</span>(l1 == r1) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span>(!type)&#123;<span class="comment">//determine 0 cnt</span></span><br><span class="line">            LL k;</span><br><span class="line">            <span class="keyword">for</span>(LL k = <span class="number">1ll</span>;;k *= <span class="number">2</span>)&#123;</span><br><span class="line">                PLL nex = right - left * k;</span><br><span class="line">                <span class="keyword">auto</span> [l2, r2] = <span class="built_in">getrange</span>(left, nex);</span><br><span class="line">                <span class="keyword">if</span>(l2 &gt; r2 || <span class="built_in">query</span>(l1, r2) &lt; K) <span class="keyword">break</span>;</span><br><span class="line">                right = nex;</span><br><span class="line">                <span class="keyword">if</span>(l2 == r2) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(; k; k /= <span class="number">2</span>)&#123;</span><br><span class="line">                PLL nex = right - left * k;</span><br><span class="line">                <span class="keyword">auto</span> [l2, r2] = <span class="built_in">getrange</span>(left, nex);</span><br><span class="line">                <span class="keyword">if</span>(l2 &gt; r2 || <span class="built_in">query</span>(l1, r2) &lt; K) <span class="keyword">continue</span>;</span><br><span class="line">                right = nex;</span><br><span class="line">                <span class="keyword">if</span>(l2 == r2) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            LL k;</span><br><span class="line">            <span class="keyword">for</span>(k = <span class="number">1ll</span>;;k *= <span class="number">2</span>)&#123;</span><br><span class="line">                PLL nex = left - right * k;</span><br><span class="line">                <span class="keyword">auto</span> [l2, r2] = <span class="built_in">getrange</span>(nex, right);</span><br><span class="line">                <span class="keyword">if</span>(l2 &gt; r2 || <span class="built_in">query</span>(l2, r1) &lt; K) <span class="keyword">break</span>;</span><br><span class="line">                left = nex;</span><br><span class="line">                <span class="keyword">if</span>(l2 == r2) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(; k; k /= <span class="number">2</span>)&#123;</span><br><span class="line">                PLL nex = left - right * k;</span><br><span class="line">                <span class="keyword">auto</span> [l2, r2] = <span class="built_in">getrange</span>(nex, right);</span><br><span class="line">                <span class="keyword">if</span>(l2 &gt; r2 || <span class="built_in">query</span>(l2, r1) &lt; K) <span class="keyword">continue</span>;</span><br><span class="line">                left = nex;</span><br><span class="line">                <span class="keyword">if</span>(l2 == r2) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">auto</span> [l2, r2] = <span class="built_in">getrange</span>(left, right);</span><br><span class="line">        K = <span class="built_in">query</span>(l2, r2) - K + <span class="number">1</span>;</span><br><span class="line">        type ^= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printans</span>(<span class="built_in">getrange</span>(left, right).first);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>感觉我的做法有点麻烦了，看看正解。</p></div></details>
<details class="toggle" ><summary class="toggle-button" style="">官方做法</summary><div class="toggle-content"><p>在除了实现以外的部分基本一样，但最后还是唐了，终究逃不出唐的魔爪。</p>
<p>注意到一个事情，我们在二分 $0$ 的个数的时候，上界向下，这启示我们 $x$ 越小字典序越小。</p>
<p>$1$ 的个数的时候，下界网上，这启示我们 $x$ 越大字典序越大。</p>
<p>这两件事综合起来就可以证明：$x$ 的大小等价于字典序的大小。</p>
<p>事实上，也可以直接去证明，对于 $(x_1,y_1)/(x_2,y_2)\to (1,1)$ 的过程，如果 $x_1<x_2,y_1>y_2$ ，可以用归纳法加一些小讨论证明前者的过程要 $&lt;$ 后者的过程。（注意：$gcd(x_1,y_1)=1,gcd(x_2,y_2)=1$ ）</p>
<p>然后直接二分就行了。</p>
<p>完了，感觉自己唐完了。我记得我有过这个想法，但是在发现二分 $1$ 的时候 $1$ 下界是往上走时就觉得错完了，但是忘记下界往上走对应 $1$ 的个数更多，对应字典序越大，实际上是对完了，结果就是我唐完了。</p>
<p>真是艹了，这样确实好写多了，不过我也懒得再写一遍了。</p>
</div></details>]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>gcd</tag>
      </tags>
  </entry>
  <entry>
    <title>AGC046 赛后总结</title>
    <url>/2024/06/26/AGC046-%E8%B5%9B%E5%90%8E%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>比赛链接：<a href="https://atcoder.jp/contests/agc046">https://atcoder.jp/contests/agc046</a></p>
<h1 id="A"><a href="#A" class="headerlink" title="A."></a>A.</h1>]]></content>
      <categories>
        <category>信息学</category>
      </categories>
  </entry>
</search>
