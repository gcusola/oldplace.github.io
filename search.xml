<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>2023-2024 ICPC Asia Jakarta Regional Contest K. Deck-Building Game</title>
    <url>/2024/03/21/2023-2024-ICPC-Asia-Jakarta-Regional-Contest-K-Deck-Building-Game/</url>
    <content><![CDATA[<p>题目链接：<a href="https://codeforces.com/contest/1906/problem/K">https://codeforces.com/contest/1906/problem/K</a></p>
<p>题目大意：在原数组找出两堆异或值相同的数值，问有多少种找法，可以为空，每个数字可以不在任何一堆，两堆有标号。</p>
<details class="toggle" ><summary class="toggle-button" style="">所有做法的基础</summary><div class="toggle-content"><p>一个显然的事情，这道题目相当于求 $\prod\limits_{i=1}^n(1+2x^{a_i})$ ，这里的乘法是异或卷积。</p>
<p>为了快速计算这个乘积，有了很多种搞法。</p>
</div></details>
<details class="toggle" ><summary class="toggle-button" style="">题解做法</summary><div class="toggle-content"><p>题解做法的优点就是比较自然。</p>
<p>显然这个可以分治 FWT ，但是 FWT 不同于 FFT ，分治了值域不变，不改变复杂度。</p>
<p>咋整，观察到如果分治区间是 $[l,r)$ ，那么实际上这个区间乘出来的非 $0$ 项只能落在 $[0,r-l),[l,r)$ ，直接拿出左区间的两个非 $0$ 区间和右区间的两个非 $0$ 区间互相乘一下就行了，这样能做到时间复杂度：$O(V\log^2 V)$ 。</p>
<p>代码：<a href="https://codeforces.com/contest/1906/submission/235539466">https://codeforces.com/contest/1906/submission/235539466</a></p>
</div></details>
<details class="toggle" ><summary class="toggle-button" style="">我的做法</summary><div class="toggle-content"><p>我的做法和题解想法基本一致，唯一一点不同的是，对于 $(r-l)=2^l$ ，那么二进制下 $l$ 位都是一样的，因此对于二进制位剩下的位置，要么和 $[l,r)$ 里面的每个数字一样，代表异或了奇数次，要么全是 $0$ ，代表异或了偶数次。</p>
<p>所以我们不妨给每个数字的最高位填个 $1$ ，代表了这个数字异或次数的奇偶性即可。</p>
<p>时间复杂度仍然是：$O(V\log^2 V)$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> LL mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> L=<span class="number">17</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> SN=(<span class="number">1</span>&lt;&lt;L);</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FWT</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;f,<span class="type">const</span> <span class="type">int</span> C[<span class="number">2</span>][<span class="number">2</span>],<span class="type">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(f.<span class="built_in">size</span>()==len);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> t=<span class="number">1</span>;t&lt;len;t&lt;&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">0</span>;l&lt;len;l+=t+t)&#123;</span><br><span class="line">            <span class="type">int</span> r=l+t;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;t;i++)&#123;</span><br><span class="line">                <span class="type">int</span> x=f[l+i],y=f[r+i];</span><br><span class="line">                f[l+i]=(<span class="number">1ll</span>*C[<span class="number">0</span>][<span class="number">0</span>]*x+<span class="number">1ll</span>*C[<span class="number">0</span>][<span class="number">1</span>]*y)%mod;</span><br><span class="line">                f[r+i]=(<span class="number">1ll</span>*C[<span class="number">1</span>][<span class="number">0</span>]*x+<span class="number">1ll</span>*C[<span class="number">1</span>][<span class="number">1</span>]*y)%mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> Cxor[<span class="number">2</span>][<span class="number">2</span>]=&#123;&#123;<span class="number">1</span>,<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,mod<span class="number">-1</span>&#125;&#125;;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> Ixor[<span class="number">2</span>][<span class="number">2</span>]=&#123;&#123;(mod+<span class="number">1</span>)/<span class="number">2</span>,(mod+<span class="number">1</span>)/<span class="number">2</span>&#125;,&#123;(mod+<span class="number">1</span>)/<span class="number">2</span>,mod-(mod+<span class="number">1</span>)/<span class="number">2</span>&#125;&#125;;</span><br><span class="line"><span class="type">int</span> n,a[N*<span class="number">2</span>];</span><br><span class="line">LL fc[N],nfc[N],f2[N];</span><br><span class="line"><span class="function">LL <span class="title">C</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;<span class="keyword">return</span> fc[x]*nfc[y]%mod*nfc[x-y]%mod;&#125;</span><br><span class="line">vector&lt;array&lt;<span class="type">int</span>,2&gt;&gt; <span class="built_in">solve</span>(<span class="type">int</span> dep,<span class="type">int</span> l,<span class="type">int</span> r)&#123;</span><br><span class="line">    <span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">        vector&lt;array&lt;<span class="type">int</span>,2&gt; &gt; ans;</span><br><span class="line">        ans.<span class="built_in">push_back</span>(&#123;<span class="number">0</span>,<span class="number">0</span>&#125;);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=a[l];i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i&amp;<span class="number">1</span>)ans[<span class="number">0</span>][<span class="number">0</span>]=(ans[<span class="number">0</span>][<span class="number">0</span>]+<span class="built_in">C</span>(a[l],i)*f2[i])%mod;</span><br><span class="line">            <span class="keyword">else</span> ans[<span class="number">0</span>][<span class="number">1</span>]=(ans[<span class="number">0</span>][<span class="number">1</span>]+<span class="built_in">C</span>(a[l],i)*f2[i])%mod;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">auto</span> lans=<span class="built_in">solve</span>(dep<span class="number">-1</span>,l,mid);</span><br><span class="line">    <span class="keyword">auto</span> rans=<span class="built_in">solve</span>(dep<span class="number">-1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; lf;lf.<span class="built_in">resize</span>(<span class="number">1</span>&lt;&lt;(dep+<span class="number">1</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;(<span class="number">1</span>&lt;&lt;(dep<span class="number">-1</span>));i++)&#123;</span><br><span class="line">        <span class="keyword">auto</span> [f0,f1]=lans[i];</span><br><span class="line">        lf[i]=f0;</span><br><span class="line">        lf[i+(<span class="number">1</span>&lt;&lt;dep)]=f1;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; rf;rf.<span class="built_in">resize</span>(<span class="number">1</span>&lt;&lt;(dep+<span class="number">1</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;(<span class="number">1</span>&lt;&lt;(dep<span class="number">-1</span>));i++)&#123;</span><br><span class="line">        <span class="keyword">auto</span> [f0,f1]=rans[i];</span><br><span class="line">        rf[i]=f0;</span><br><span class="line">        rf[i+(<span class="number">1</span>&lt;&lt;(dep<span class="number">-1</span>))+(<span class="number">1</span>&lt;&lt;dep)]=f1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">FWT</span>(lf,Cxor,(<span class="number">1</span>&lt;&lt;(dep+<span class="number">1</span>)));</span><br><span class="line">    <span class="built_in">FWT</span>(rf,Cxor,(<span class="number">1</span>&lt;&lt;(dep+<span class="number">1</span>)));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;(<span class="number">1</span>&lt;&lt;(dep+<span class="number">1</span>));i++)lf[i]=<span class="number">1ll</span>*lf[i]*rf[i]%mod;</span><br><span class="line">    <span class="built_in">FWT</span>(lf,Ixor,(<span class="number">1</span>&lt;&lt;(dep+<span class="number">1</span>)));</span><br><span class="line">    vector&lt;array&lt;<span class="type">int</span>,2&gt; &gt; ans;ans.<span class="built_in">resize</span>(<span class="number">1</span>&lt;&lt;dep);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;(<span class="number">1</span>&lt;&lt;dep);i++)&#123;</span><br><span class="line">        ans[i]=&#123;lf[i],lf[i+(<span class="number">1</span>&lt;&lt;dep)]&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    fc[<span class="number">0</span>]=fc[<span class="number">1</span>]=nfc[<span class="number">0</span>]=nfc[<span class="number">1</span>]=f2[<span class="number">0</span>]=<span class="number">1</span>;f2[<span class="number">1</span>]=<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)nfc[i]=(mod-mod/i)*nfc[mod%i]%mod;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)nfc[i]=nfc[i<span class="number">-1</span>]*nfc[i]%mod,fc[i]=fc[i<span class="number">-1</span>]*i%mod,f2[i]=f2[i<span class="number">-1</span>]*<span class="number">2</span>%mod;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="type">int</span> x;<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">        a[x]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">auto</span> ans=<span class="built_in">solve</span>(L,<span class="number">0</span>,(<span class="number">1</span>&lt;&lt;L)<span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,(ans[<span class="number">0</span>][<span class="number">0</span>]+ans[<span class="number">0</span>][<span class="number">1</span>])%mod);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></details>
<details class="toggle" ><summary class="toggle-button" style="">我的做法改进</summary><div class="toggle-content"><p>发现一个事情，矩阵为 $\begin{bmatrix} 1 &amp; 1\ 1 &amp; -1 \end{bmatrix}$ 的 FWT （即异或的 FWT）最终的结果其实可以写成这样：</p>
<script type="math/tex; mode=display">f[i]=\sum\limits_{i=0}^{L}(-1)^{popcount(i\And j)}a[j]</script><p>利用这个式子，可以改进分治 FWT 。</p>
<p>不妨假设：$(r-l)=2^l$ ，显然左区间的值域在 $[0,2^l)$ （高位补了 $1$ 判断奇偶性），现在要扩充到 $[0,2^{l+1})$ ，扩充规则为给原来的每个下表在最高位（算前导 $0$ ）下面塞个 $0$ （右区间塞 $1$） ，然后在剩下的位置补 $0$ 。</p>
<p>然后根据上面的式子可以利用变化前的点值，在线性时间得到变化后的点值。（具体见代码）</p>
<p>然后直接乘就行了，时间复杂度：$O(V\log{V})$ 。</p>
<p>这个做法相比较于下面的做法，或许不是最妙的，但是是最适用的，因为不依赖于系数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> LL mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> L=<span class="number">17</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> SN=(<span class="number">1</span>&lt;&lt;L);</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FWT</span><span class="params">(LL *f,<span class="type">const</span> LL C[<span class="number">2</span>][<span class="number">2</span>],<span class="type">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> t=<span class="number">1</span>;t&lt;len;t&lt;&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">0</span>;l&lt;len;l+=t+t)&#123;</span><br><span class="line">            <span class="type">int</span> r=l+t;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;t;i++)&#123;</span><br><span class="line">                LL x=f[l+i],y=f[r+i];</span><br><span class="line">                f[l+i]=(C[<span class="number">0</span>][<span class="number">0</span>]*x+C[<span class="number">0</span>][<span class="number">1</span>]*y)%mod;</span><br><span class="line">                f[r+i]=(C[<span class="number">1</span>][<span class="number">0</span>]*x+C[<span class="number">1</span>][<span class="number">1</span>]*y)%mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> LL Cxor[<span class="number">2</span>][<span class="number">2</span>]=&#123;&#123;<span class="number">1</span>,<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,mod<span class="number">-1</span>&#125;&#125;;</span><br><span class="line"><span class="type">const</span> LL Ixor[<span class="number">2</span>][<span class="number">2</span>]=&#123;&#123;(mod+<span class="number">1</span>)/<span class="number">2</span>,(mod+<span class="number">1</span>)/<span class="number">2</span>&#125;,&#123;(mod+<span class="number">1</span>)/<span class="number">2</span>,mod-(mod+<span class="number">1</span>)/<span class="number">2</span>&#125;&#125;;</span><br><span class="line"><span class="type">int</span> n,a[N*<span class="number">2</span>];</span><br><span class="line">LL fc[N],nfc[N],f2[N];</span><br><span class="line"><span class="function">LL <span class="title">C</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;<span class="keyword">return</span> fc[x]*nfc[y]%mod*nfc[x-y]%mod;&#125;</span><br><span class="line">LL f[<span class="number">2</span>][N*<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;(<span class="number">1</span>&lt;&lt;L);i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=a[i];j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(j&amp;<span class="number">1</span>)f[<span class="number">1</span>][i]=(f[<span class="number">1</span>][i]+<span class="built_in">C</span>(a[i],j)*f2[j])%mod;</span><br><span class="line">            <span class="keyword">else</span> f[<span class="number">0</span>][i]=(f[<span class="number">0</span>][i]+<span class="built_in">C</span>(a[i],j)*f2[j])%mod;</span><br><span class="line">        &#125;</span><br><span class="line">        LL lf=f[<span class="number">0</span>][i],rf=f[<span class="number">1</span>][i];</span><br><span class="line">        f[<span class="number">0</span>][i]=(lf+rf)%mod;</span><br><span class="line">        f[<span class="number">1</span>][i]=(lf+mod-rf)%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> t=<span class="number">1</span>;t&lt;=L;t++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;(<span class="number">1</span>&lt;&lt;L);i+=(<span class="number">1</span>&lt;&lt;t))&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> l=i;l&lt;i+(<span class="number">1</span>&lt;&lt;(t<span class="number">-1</span>));l++)&#123;</span><br><span class="line">                <span class="type">int</span> r=l+(<span class="number">1</span>&lt;&lt;(t<span class="number">-1</span>));</span><br><span class="line">                LL l0=f[<span class="number">0</span>][l],l1=f[<span class="number">1</span>][l];</span><br><span class="line">                LL l00=l0,l01=l0;</span><br><span class="line">                LL l10=l1,l11=l1;</span><br><span class="line">                </span><br><span class="line">                LL r0=f[<span class="number">0</span>][r],r1=f[<span class="number">1</span>][r];</span><br><span class="line">                LL r00=r0,r01=r1;</span><br><span class="line">                LL r10=r1,r11=r0;</span><br><span class="line"></span><br><span class="line">                f[<span class="number">0</span>][l]=l00*r00%mod;</span><br><span class="line">                f[<span class="number">0</span>][r]=l01*r01%mod;</span><br><span class="line">                f[<span class="number">1</span>][l]=l10*r10%mod;</span><br><span class="line">                f[<span class="number">1</span>][r]=l11*r11%mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">FWT</span>(f[<span class="number">0</span>],Ixor,(<span class="number">1</span>&lt;&lt;L));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    fc[<span class="number">0</span>]=fc[<span class="number">1</span>]=nfc[<span class="number">0</span>]=nfc[<span class="number">1</span>]=f2[<span class="number">0</span>]=<span class="number">1</span>;f2[<span class="number">1</span>]=<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)nfc[i]=(mod-mod/i)*nfc[mod%i]%mod;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)nfc[i]=nfc[i<span class="number">-1</span>]*nfc[i]%mod,fc[i]=fc[i<span class="number">-1</span>]*i%mod,f2[i]=f2[i<span class="number">-1</span>]*<span class="number">2</span>%mod;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="type">int</span> x;<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">        a[x]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,f[<span class="number">0</span>][<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></details>
<details class="toggle" ><summary class="toggle-button" style="">深刻观察法</summary><div class="toggle-content"><p>来自比赛 Announcement 评论区。</p>
<p>发现一个事情，矩阵为 $\begin{bmatrix} 1 &amp; 1\ 1 &amp; -1 \end{bmatrix}$ 的 FWT （即异或的 FWT）最终的结果其实可以写成这样：</p>
<script type="math/tex; mode=display">f[i]=\sum\limits_{i=0}^{L}(-1)^{popcount(i\And j)}a[j]</script><p>同时又观察到，结果只能是 $-1$ 或者 $3$ ，那么这有什么用呢？</p>
<p>思考一下，FWT 和 FFT 有一个很重要的不同，就是 FWT 不需要扩展数组，因为下标值域不会扩展，所以 FWT 实际上能算出所有多项式的点值表达式直接乘起来然后再逆回去，而 FFT 是不行的（除非一开始就把所有的多项式算出充足的点值）。</p>
<p>但是算出所有多项式的点值表达式的时间开销仍然很大，第一种做法采用了分治 FWT 来加速这个过程，但是这里，我们直接观察出了 FWT 后的结果长啥样，那我们是不是可以不用 FWT ，直接算出结果呢？</p>
<p>显然，求 $\prod f_k[i]$ 只需要算出有多少个 $-1$ 或者有多少个 $3$ 就行了。</p>
<p>有了这个思路，就有很多种搞法了。</p>
<p>我使用的做法是：$n=even+odd$ ，那么只需要令 $a[x]=x的出现次数$ ，然后直接跑 FWT ，就可以知道每个位置的 $even-odd$ ，然后就可以直接算出来 $-1$ 和 $3$ 的个数了。</p>
<p>还有别的搞法，例如：SOS dp，但是因为感觉这个的转移式子和 FWT 没什么本质区别，就不再赘述了，放个这个做法的代码： <a href="https://codeforces.com/contest/1906/submission/235477273">https://codeforces.com/contest/1906/submission/235477273</a> 。</p>
<p>时间复杂度：$O(V\log{V})$ 的，空间复杂度：$O(V)$，$V$ 是值域。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> LL mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> NN=<span class="number">2e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> L=(<span class="number">1</span>&lt;&lt;<span class="number">17</span>);</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FWT</span><span class="params">(LL *f,<span class="type">const</span> LL C[<span class="number">2</span>][<span class="number">2</span>],<span class="type">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> t=<span class="number">1</span>;t&lt;len;t&lt;&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">0</span>;l&lt;len;l+=t+t)&#123;</span><br><span class="line">            <span class="type">int</span> r=l+t;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;t;i++)&#123;</span><br><span class="line">                LL x=f[l+i],y=f[r+i];</span><br><span class="line">                f[l+i]=(C[<span class="number">0</span>][<span class="number">0</span>]*x+C[<span class="number">0</span>][<span class="number">1</span>]*y)%mod;</span><br><span class="line">                f[r+i]=(C[<span class="number">1</span>][<span class="number">0</span>]*x+C[<span class="number">1</span>][<span class="number">1</span>]*y)%mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">LL f3[N],a[NN];</span><br><span class="line">LL Cxor[<span class="number">2</span>][<span class="number">2</span>]=&#123;&#123;<span class="number">1</span>,<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,mod<span class="number">-1</span>&#125;&#125;;</span><br><span class="line">LL Ixor[<span class="number">2</span>][<span class="number">2</span>]=&#123;&#123;(mod+<span class="number">1</span>)/<span class="number">2</span>,(mod+<span class="number">1</span>)/<span class="number">2</span>&#125;,&#123;(mod+<span class="number">1</span>)/<span class="number">2</span>,mod-(mod+<span class="number">1</span>)/<span class="number">2</span>&#125;&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    f3[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="type">int</span> x;<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">        a[x]++;</span><br><span class="line">        f3[i]=f3[i<span class="number">-1</span>]*<span class="number">3</span>%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">FWT</span>(a,Cxor,L);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;L;i++)&#123;</span><br><span class="line">        <span class="type">int</span> num=a[i];</span><br><span class="line">        <span class="keyword">if</span>(num&gt;n)num-=mod;</span><br><span class="line">        <span class="comment">//n=f+z,num=z-f;</span></span><br><span class="line">        <span class="type">int</span> z=(n+num)/<span class="number">2</span>,f=(n-num)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(f&amp;<span class="number">1</span>)a[i]=(mod-f3[z])%mod;</span><br><span class="line">        <span class="keyword">else</span> a[i]=f3[z];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">FWT</span>(a,Ixor,L);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,a[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></details>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>FWT</tag>
        <tag>计数</tag>
        <tag>分治</tag>
      </tags>
  </entry>
  <entry>
    <title>AGC039 赛后总结</title>
    <url>/2024/05/28/AGC039-%E8%B5%9B%E5%90%8E%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="A-Connection-and-Disconnection"><a href="#A-Connection-and-Disconnection" class="headerlink" title="A. Connection and Disconnection"></a>A. Connection and Disconnection</h1><p>题目链接：<a href="https://atcoder.jp/contests/agc039/tasks/agc039_a">https://atcoder.jp/contests/agc039/tasks/agc039_a</a></p>
<p>题目大意：字符串 $S$ 放置 $K$ 次，对字符串修改最少的字符满足使相邻字符不同。</p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>我的做法是找到所有相同的字符构成的连续段，然后统计答案，开头和结尾特判一下就行了。</p>
<p>时间复杂度：$O(n)$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e2</span> + <span class="number">5</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_char_array</span><span class="params">(<span class="type">char</span> *s)</span></span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">char</span> ss[N];</span><br><span class="line">    cin &gt;&gt; ss;</span><br><span class="line">    <span class="built_in">memcpy</span>(s + <span class="number">1</span>, ss, <span class="built_in">sizeof</span>(<span class="type">char</span>) * (<span class="built_in">strlen</span>(ss) + <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">char</span> st[N];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">LL K;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">get_char_array</span>(st);</span><br><span class="line">    n = <span class="built_in">strlen</span>(st + <span class="number">1</span>);</span><br><span class="line">    cin &gt;&gt; K;</span><br><span class="line">    <span class="type">int</span> len0 = <span class="number">0</span>;</span><br><span class="line">    LL ans = <span class="number">0ll</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> l = <span class="number">1</span>; l &lt;= n; l++)&#123;</span><br><span class="line">        <span class="type">int</span> r = l;</span><br><span class="line">        <span class="keyword">while</span>(r &lt; n &amp;&amp; st[r + <span class="number">1</span>] == st[l]) r++;</span><br><span class="line">        <span class="keyword">if</span>(l &gt; <span class="number">1</span> &amp;&amp; r &lt; n) ans += (r - l  + <span class="number">1</span>) / <span class="number">2</span> * K;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(l == <span class="number">1</span> &amp;&amp; r &lt; n)&#123;</span><br><span class="line">            len0 = r - l + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(st[<span class="number">1</span>] != st[n]) ans += (r - l + <span class="number">1</span>) / <span class="number">2</span> * K;</span><br><span class="line">            <span class="keyword">else</span> ans += (r - l + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(l &gt; <span class="number">1</span> &amp;&amp; r == n)&#123;</span><br><span class="line">            <span class="keyword">if</span>(st[<span class="number">1</span>] != st[n]) ans += (r - l + <span class="number">1</span>) / <span class="number">2</span> * K;</span><br><span class="line">            <span class="keyword">else</span> ans += (r - l + <span class="number">1</span>) / <span class="number">2</span> + (r - l + <span class="number">1</span> + len0) / <span class="number">2</span> * (K - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> ans += n * K / <span class="number">2</span>;</span><br><span class="line">        l = r;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></details>
<details class="toggle" ><summary class="toggle-button" style="">其余做法</summary><div class="toggle-content"><p>看到一个很有意思的搞法：先统计 $S$ 的答案，再统计 $SS$ 的答案，两者相减得到在已经有字符串的情况下再添加字符串的贡献。</p>
<p>需要特判所有字符相同的情况。</p>
<p>这个做法感觉很牛啊。</p>
</div></details>
<h1 id="B-Graph-Partition"><a href="#B-Graph-Partition" class="headerlink" title="B. Graph Partition"></a>B. Graph Partition</h1><p>题目链接：<a href="https://atcoder.jp/contests/agc039/tasks/agc039_b">https://atcoder.jp/contests/agc039/tasks/agc039_b</a></p>
<p>题目大意：给你一张无向图，将点分成尽可能多的部分满足任何一条边只会出现在相邻两个部分之间。</p>
<details class="toggle" ><summary class="toggle-button" style="">我的做法</summary><div class="toggle-content"><p>首先注意到一个事情，这个图没有奇环是这个图有解的充要条件。（证明方法就是沿着奇数走一圈）</p>
<p>换个角度来看：题目的要求等价于相邻两个点的部分编号奇偶性不同，由这一点可以很自然的联想到二分图染色，从而知道如果二分图染色失败则无解，从而自然的想到有解的充要条件。</p>
<p>然后发现，$x\to y$ 的任何一条路径的边数都一定 $\ge |id_x-id_y|$ 。</p>
<p>我们不妨考虑从部分 $1$ 的角度来看，由于这个图是联通的，设 $h_x$ 表示 $1$ 中的点到 $x$ 的最短路，那么 $id_x\le h_x+1$ 。</p>
<p>我们不妨直接拉满，就设置一个中心 $st$ ，$id_x=h_x+1$，可以发现，在二分图上，这样子划分是一定合法的。</p>
<p>而且不难证明最优解一定长这样。</p>
<p>直接枚举 $st$ 就行了。</p>
<p>时间复杂度：$O(n^3)$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e2</span> + <span class="number">5</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_char_array</span><span class="params">(<span class="type">char</span> *s)</span></span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">char</span> ss[N];</span><br><span class="line">    cin &gt;&gt; ss;</span><br><span class="line">    <span class="built_in">memcpy</span>(s + <span class="number">1</span>, ss, <span class="built_in">sizeof</span>(<span class="type">char</span>) * (<span class="built_in">strlen</span>(ss) + <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">char</span> st[N][N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> y, next;</span><br><span class="line">&#125;a[N * N]; <span class="type">int</span> len, las[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ins</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>&#123;a[++len] = &#123;y, las[x]&#125;; las[x] = len;&#125;</span><br><span class="line"><span class="type">int</span> h[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bfs</span><span class="params">(<span class="type">int</span> spos)</span></span>&#123;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(spos);</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">0</span>, <span class="built_in">sizeof</span>(h));</span><br><span class="line">    h[spos] = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> laspos = spos;</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="type">int</span> x = q.<span class="built_in">front</span>();</span><br><span class="line">        laspos = x;</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k = las[x]; k; k = a[k].next)&#123;</span><br><span class="line">            <span class="type">int</span> y = a[k].y;</span><br><span class="line">            <span class="keyword">if</span>(!h[y])&#123;</span><br><span class="line">                h[y] = h[x] + <span class="number">1</span>;</span><br><span class="line">                q.<span class="built_in">push</span>(y);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>((h[y] &amp; <span class="number">1</span>) == (h[x] &amp; <span class="number">1</span>)) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> h[laspos];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="built_in">get_char_array</span>(st[i]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(st[i][j] == <span class="string">&#x27;1&#x27;</span>) <span class="built_in">ins</span>(i, j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) ans = <span class="built_in">max</span>(ans, <span class="built_in">bfs</span>(i));</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></details>
<h1 id="C-Division-by-Two-with-Something"><a href="#C-Division-by-Two-with-Something" class="headerlink" title="C. Division by Two with Something"></a>C. Division by Two with Something</h1><p>题目链接：<a href="https://atcoder.jp/contests/agc039/tasks/agc039_c">https://atcoder.jp/contests/agc039/tasks/agc039_c</a></p>
<p>题目大意：给 $n,X(X&lt;2^{n})$ ，求 $[0,X]$ 的权值和，权值定义为一个数字 $x$ 经过下述操作最少花几次回到自己。</p>
<p>操作：$x$ 是奇数就除二向下取整，偶数就除二后，加上 $2^{n-1}$ 。</p>
<details class="toggle" ><summary class="toggle-button" style="">我的做法</summary><div class="toggle-content"><p>注意到一个事情，上面这个操作等价于把一个 $n$ 位二进制的最低位翻转放到最高位。</p>
<p>于是，所有数字都一定会在 $2n$ 次操作后回到自己。</p>
<p>注意到，如果存在 $x,y(x&lt;y)$ 都能让 $x$ 回到自己，那么 $y-x$ 也可以，因此存在一个最小的次数 $ans$ 整除所有可行的次数，且 $ans$ 的所有倍数都可行。</p>
<p>也就是答案一定是 $2n$ 的因子。</p>
<p>又注意到 $n$ 次后一定回不到自己，因此 $ans$ 是 $2n$ 的因子而不是 $n$ 的因子。</p>
<p>注意到 $\frac{ans}{2}$ 整除于 $n$ ，我们不妨以 $\frac{ans}{2}$ 审视 $S$ ，可以发现 $S$ 可以写成 $010101010…0$ 。</p>
<p>即在 $len|n$ 的条件下，$S$ 可以以 $len$ 为单位写成 $010101…0$ 等价于 $S$ 在 $2len$ 后会回到自己。</p>
<p>综上可以得到以 $len$ 为单位的 $0101…0$ 的字符串数量等于 $ans|2len$ 的字符串数量。</p>
<p>容斥一下就可以得到每个 $ans$ 对应的字符串数量了。</p>
<p>时间复杂度：$O(n\log{n})$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> LL mod = <span class="number">998244353</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_char_array</span><span class="params">(<span class="type">char</span> *s)</span></span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">char</span> ss[N];</span><br><span class="line">    cin &gt;&gt; ss;</span><br><span class="line">    <span class="built_in">memcpy</span>(s + <span class="number">1</span>, ss, <span class="built_in">sizeof</span>(<span class="type">char</span>) * (<span class="built_in">strlen</span>(ss) + <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">char</span> st[N], t[N];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="function">LL <span class="title">solve</span><span class="params">(<span class="type">int</span> len)</span></span>&#123;</span><br><span class="line">    LL now = <span class="number">0ll</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= len; i++) now = (now * <span class="number">2</span> + st[i] - <span class="string">&#x27;0&#x27;</span>) % mod;</span><br><span class="line">    <span class="type">int</span> pos = <span class="number">1</span>, type = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        t[i] = ((st[pos] - <span class="string">&#x27;0&#x27;</span>) ^ type) + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span>(pos == len) pos = <span class="number">1</span>, type ^= <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> pos++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(t[i] &lt; st[i]) <span class="keyword">return</span> (now + <span class="number">1</span>) % mod;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(t[i] &gt; st[i]) <span class="keyword">return</span> now;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (now + <span class="number">1</span>) % mod;</span><br><span class="line">&#125;</span><br><span class="line">LL cnt[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="built_in">get_char_array</span>(st);</span><br><span class="line">    LL ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n % i == <span class="number">0</span> &amp;&amp; n % (i * <span class="number">2</span>) != <span class="number">0</span>)&#123;</span><br><span class="line">            cnt[i] = (cnt[i] + <span class="built_in">solve</span>(i)) % mod;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">2</span>; k &lt;= n / i; k++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(n / i % k == <span class="number">0</span>) cnt[i * k] = (cnt[i * k] - cnt[i] + mod) % mod;</span><br><span class="line">            &#125;</span><br><span class="line">            ans += cnt[i] * i * <span class="number">2</span>;</span><br><span class="line">            ans %= mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></details>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
  </entry>
  <entry>
    <title>AGC037 赛后总结</title>
    <url>/2024/05/28/AGC037-%E8%B5%9B%E5%90%8E%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>比赛链接：<a href="https://atcoder.jp/contests/agc037">https://atcoder.jp/contests/agc037</a></p>
<h1 id="A-Dividing-a-String"><a href="#A-Dividing-a-String" class="headerlink" title="A. Dividing a String"></a>A. Dividing a String</h1><p>题目链接：<a href="https://atcoder.jp/contests/agc037/tasks/agc037_a">https://atcoder.jp/contests/agc037/tasks/agc037_a</a></p>
<p>题目大意：将字符串分成若干个部分，满足相邻两个部分不相同。</p>
<details class="toggle" ><summary class="toggle-button" style="">我的做法</summary><div class="toggle-content"><p>我一开始的想法是基于贪心，有相同的字符就让后一个变成长度为 $2$ 的字符串。</p>
<p>然后如果在 $n-1$ 就直接把 $n-1,n$ 合并了。</p>
<p>但是在写博客的时候发现我当时漏考虑了一种情况：$aaaaa$ ，这种情况我的想法会分出：$a|aa|aa$ 。</p>
<p>但最终结果还是一样的，为啥？因为对于最后以个串，假设分成了：$a|aa|a|aa…|aa|aa$ ，那么一定能变成：$aa|a|aa|a…|a|aa$ 。</p>
<p>但是为什么这是最优解呢？</p>
<p>我们不妨先想一个弱化版问题，如果 $abcd$ 中 $b=c$ ，那么必须有 $ab,bc,cd$ 中的其中一个满足（$ab$ 指 $ab$ 在一个部分，其余同理）</p>
<p>这样，我们可以把原问题看成 $n-1$ 个数字，然后有一堆要求 $[l,r]$ 中必须删除一个数字的要求，而这个问题的答案显然是删除剩下区间中 $r$ 最小的区间的 $r$ 位置。</p>
<p>显然任何一个合法解都满足上述要求，而上面求出了在这个要求下需要的最小合并数，如果这个能够是解，则就是最优解。</p>
<p>然后讨论易证上面的这个最小合并数能够构造出一个合法解，然后就做完了。</p>
<p>时间复杂度：$O(n)$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">char</span> st[N];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_char_array</span><span class="params">(<span class="type">char</span> *s)</span></span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">char</span> ss[N];</span><br><span class="line">    cin &gt;&gt; ss;</span><br><span class="line">    <span class="built_in">memcpy</span>(s + <span class="number">1</span>, ss, <span class="built_in">sizeof</span>(<span class="type">char</span>) * <span class="built_in">strlen</span>(ss));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">get_char_array</span>(st);</span><br><span class="line">    n = <span class="built_in">strlen</span>(st + <span class="number">1</span>);</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i != n &amp;&amp; st[i] == st[i + <span class="number">1</span>])&#123;</span><br><span class="line">            <span class="keyword">if</span>(i == n - <span class="number">1</span>)&#123;</span><br><span class="line">                cnt += <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                cnt += <span class="number">2</span>;</span><br><span class="line">                i += <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; cnt &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></details>
<h1 id="B-RGB-Balls"><a href="#B-RGB-Balls" class="headerlink" title="B. RGB Balls"></a>B. RGB Balls</h1><p>题目链接：<a href="https://atcoder.jp/contests/agc037/tasks/agc037_b">https://atcoder.jp/contests/agc037/tasks/agc037_b</a></p>
<p>题目大意：给 $3N$ 个球， 红蓝黄个数相同，要求你给 $N$ 个人分球，满足每个人每个颜色各一个球，最小化每个人拿到的球的下标最大值减最小值之和。</p>
<details class="toggle" ><summary class="toggle-button" style="">我的做法</summary><div class="toggle-content"><p>我们可以这么想这个过程（用 $A,B,C$ 代表三个颜色）。</p>
<p>我们现在有一堆 $AB,A,AC…$ 然后进来一个新的颜色，我们希望去拿它匹配。</p>
<p>就比如说进来一个 $A$ 吧，那么，如果有现成的 $BC/CB$ 一定会去匹配，因为答案可以写成：$\sum\limits_{e_i-s_i}$ （$e_i$ 表示结束时间，$s_i$ 表示开始时间）。</p>
<p>证明就是交换，无论这个 $A$ 去和其他什么乱七八糟的东西匹配，最后和 $BC/CB$ 匹配的 $A’$ 交换，都会使答案下降。</p>
<p>同理，如果没有 $BC/CB$ ，但是有 $B/C$ ，也会去匹配，而不是单开一个，证明也是交换。</p>
<p>因此做法就出来了，当前剩下的对是固定的，而且和前缀每个颜色的个数有关，例如 $A&gt;B&gt;C$ ，那么就有 $A-B$ 个 $A$ ，$B-C$ 个 $AB/BA$ 。</p>
<p>根据这个 $dp$ 计数就行了。</p>
<p>时间复杂度：$O(n)$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> LL mod = <span class="number">998244353</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> B = <span class="number">5</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_char_array</span><span class="params">(<span class="type">char</span> *s)</span></span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">char</span> ss[N * <span class="number">3</span>];</span><br><span class="line">    cin &gt;&gt; ss;</span><br><span class="line">    <span class="built_in">memcpy</span>(s + <span class="number">1</span>, ss, <span class="built_in">sizeof</span>(<span class="type">char</span>) * <span class="built_in">strlen</span>(ss));</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n, now;</span><br><span class="line"><span class="type">char</span> st[N * <span class="number">3</span>];</span><br><span class="line"><span class="type">int</span> cnt[B], id[B], be[B];</span><br><span class="line"><span class="type">char</span> num[<span class="number">300</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    num[<span class="string">&#x27;R&#x27;</span>] = <span class="number">0</span>;</span><br><span class="line">    num[<span class="string">&#x27;G&#x27;</span>] = <span class="number">1</span>;</span><br><span class="line">    num[<span class="string">&#x27;B&#x27;</span>] = <span class="number">2</span>;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="built_in">get_char_array</span>(st);</span><br><span class="line">    LL ans = <span class="number">1ll</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">2</span>; i++) id[i] = i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n * <span class="number">3</span>; i++)&#123;</span><br><span class="line">        now = num[st[i]];</span><br><span class="line">        <span class="built_in">sort</span>(id, id + <span class="number">3</span>, [](<span class="type">int</span> x, <span class="type">int</span> y)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cnt[x] == cnt[y]) <span class="built_in">return</span> (x == now) &gt; (y == now);</span><br><span class="line">            <span class="keyword">return</span> cnt[x] &gt; cnt[y];</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= <span class="number">2</span>; j++) be[id[j]] = j;</span><br><span class="line">        <span class="keyword">if</span>(be[now] == <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">else</span> ans = ans * (cnt[id[be[now] - <span class="number">1</span>]] - cnt[now]) % mod;</span><br><span class="line">        cnt[now]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) ans = ans * i % mod;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不过这个做法在 $4$ 个及以上的颜色就爆了，只能 $3$ 个。</p>
<p>原因是：$ABACC$ ，在有了 $AB,A$ 后，由于 $ABC$ 不是成品，所以 $CC$ 可以以任意顺序匹配现有的串，导致性质失效，所以无法再用上述的方法计数。</p>
</div></details>
<h1 id="C-Numbers-on-a-Circle"><a href="#C-Numbers-on-a-Circle" class="headerlink" title="C. Numbers on a Circle"></a>C. Numbers on a Circle</h1><p>题目链接：<a href="https://atcoder.jp/contests/agc037/tasks/agc037_c">https://atcoder.jp/contests/agc037/tasks/agc037_c</a></p>
<p>题目大意：所有数字在环上，可以进行一个操作，选择一个数字，令其加上相邻两个数字之和，所有数字为正数，问能不能使所有数字由 $a\to b$ 。</p>
<details class="toggle" ><summary class="toggle-button" style="">我的做法</summary><div class="toggle-content"><p>注意到一个事情，由于所有数字都是正数，那么 $b$ 中的局部极大值都一定是这个局部最后操作的，或者说以他为中心的相邻三个数字中最后一个操作的，因此我们可以直接尝试从 $b$ 还原到 $a$ 。</p>
<p>注意到等价于用局部最大值去模相邻两个数字之和，每次取模一定会少一半，因此次数上界为 $O(n\log{V})$ 。</p>
<p>注意到最大值一定是局部极大值，直接用堆就行了。</p>
<p>时间复杂度：$O(n\log{V}\log{n})$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PLI;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line">priority_queue&lt;PLI&gt; p;</span><br><span class="line"><span class="type">int</span> a[N], b[N];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">preid</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="keyword">return</span> x == <span class="number">1</span> ? n : x - <span class="number">1</span>;&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">nexid</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="keyword">return</span> x == n ? <span class="number">1</span> : x + <span class="number">1</span>;&#125;</span><br><span class="line"><span class="function">LL <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        cin &gt;&gt; b[i];</span><br><span class="line">        p.<span class="built_in">push</span>(&#123;b[i], i&#125;);</span><br><span class="line">        <span class="keyword">if</span>(b[i] &lt; a[i]) <span class="keyword">return</span> <span class="number">-1ll</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    LL cnt = <span class="number">0ll</span>;</span><br><span class="line">    <span class="keyword">while</span>(!p.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="keyword">auto</span> [d, id] = p.<span class="built_in">top</span>();</span><br><span class="line">        p.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="type">int</span> pid = <span class="built_in">preid</span>(id);</span><br><span class="line">        <span class="type">int</span> nid = <span class="built_in">nexid</span>(id);</span><br><span class="line">        LL val = b[pid] + b[nid];</span><br><span class="line">        LL T = <span class="built_in">min</span>( (b[id] - a[id]) / val, (b[id] - <span class="built_in">max</span>(b[pid], b[nid])) / val + <span class="number">1</span>);</span><br><span class="line">        cnt += T;</span><br><span class="line">        b[id] -= T * val;</span><br><span class="line">        <span class="keyword">if</span>(b[id] &gt; a[id] &amp;&amp; b[id] &gt;= <span class="built_in">max</span>(b[pid], b[nid])) <span class="keyword">return</span> <span class="number">-1ll</span>;</span><br><span class="line">        <span class="keyword">if</span>(b[id] &gt; a[id]) p.<span class="built_in">push</span>(&#123;b[id], id&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">solve</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></details>
<h1 id="D-Sorting-a-Grid"><a href="#D-Sorting-a-Grid" class="headerlink" title="D. Sorting a Grid"></a>D. Sorting a Grid</h1><p>题目链接：<a href="https://atcoder.jp/contests/agc037/tasks/agc037_d">https://atcoder.jp/contests/agc037/tasks/agc037_d</a></p>
<p>题目大意：给一个矩形，矩形中的数字都是 $[1,nm]$ 且不同，然后有三次操作，第一次对所有行重排，第二次对所有列重排，第三次对所有行重排，给一种方案使得最后矩形变成 $1,2,3,….$ 的矩形。</p>
<details class="toggle" ><summary class="toggle-button" style="">我的做法</summary><div class="toggle-content"><p>很有意思的一道题目，注意到问题可以等价于在第一步行排列的时候，让每一行的数字在每一列都有一个，即把最终矩阵中每一行的数字给同一个颜色，不同行不同颜色，然后希望在行排列后，每一列中的颜色都是不一样的。</p>
<p>这个时候有一个二分图匹配的感觉，很可惜的是，建不出能过的图。</p>
<p>那么怎么做呢？注意到在列数只有两个的时候，等价于将每一行的两个颜色连边然后找环，这启示我们是与图相关的算法。<del>那还能不是二分图匹配？</del></p>
<p>又注意到，如果一定有解的话，我们可以归纳，即先摆出一列，剩下的部分就是一个子问题，因此问题是怎么摆出一列。</p>
<p>注意到这个时候用二分图匹配就可以，至于为什么二分图匹配一定有解，可以使用 Hall 定理证明。</p>
<p>时间复杂度：$O(n^4)$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e2</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> NN = <span class="number">1e4</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; cnt[N][N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getid</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="keyword">return</span> (x - <span class="number">1</span>) / m + <span class="number">1</span>;&#125;</span><br><span class="line"><span class="keyword">namespace</span> Graph&#123;</span><br><span class="line">    <span class="type">int</span> mat[N];</span><br><span class="line">    <span class="type">bool</span> e[N][N], v[N];</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ins</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>&#123;e[x][y] = <span class="number">1</span>;&#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">findmatch</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">        v[x] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!e[x][i]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(!mat[i] || (!v[mat[i]] &amp;&amp; <span class="built_in">findmatch</span>(mat[i])))&#123;</span><br><span class="line">                mat[i] = x;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="built_in">memset</span>(v, <span class="number">0</span>, <span class="built_in">sizeof</span>(v));</span><br><span class="line">            <span class="built_in">assert</span>(<span class="built_in">findmatch</span>(i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(e, <span class="number">0</span>, <span class="built_in">sizeof</span>(e));</span><br><span class="line">        <span class="built_in">memset</span>(mat, <span class="number">0</span>, <span class="built_in">sizeof</span>(mat));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> Graph::ins;</span><br><span class="line"><span class="keyword">using</span> Graph::init;</span><br><span class="line"><span class="keyword">using</span> Graph::solve;</span><br><span class="line"><span class="keyword">using</span> Graph::mat;</span><br><span class="line"><span class="type">int</span> ans1[N][N], ans2[N][N];</span><br><span class="line"><span class="type">int</span> id[N];</span><br><span class="line"><span class="type">int</span> tmp;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++)&#123;</span><br><span class="line">            <span class="type">int</span> x;</span><br><span class="line">            cin &gt;&gt; x;</span><br><span class="line">            cnt[i][<span class="built_in">getid</span>(x)].<span class="built_in">push_back</span>(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> t = <span class="number">1</span>; t &lt;= m; t++)&#123;</span><br><span class="line">        Graph::<span class="built_in">init</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!cnt[i][j].<span class="built_in">empty</span>()) <span class="built_in">ins</span>(j, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Graph::<span class="built_in">solve</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="type">int</span> col = mat[i];</span><br><span class="line">            ans1[i][t] = cnt[i][col].<span class="built_in">back</span>();</span><br><span class="line">            cnt[i][col].<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) id[i] = i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++)&#123;</span><br><span class="line">        tmp = j;</span><br><span class="line">        <span class="built_in">sort</span>(id + <span class="number">1</span>, id + n + <span class="number">1</span>, [](<span class="type">int</span> x, <span class="type">int</span> y)&#123;<span class="keyword">return</span> <span class="built_in">getid</span>(ans1[x][tmp]) &lt; <span class="built_in">getid</span>(ans1[y][tmp]);&#125;);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) ans2[i][j] = ans1[id[i]][j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++) cout &lt;&lt; ans1[i][j] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++) cout &lt;&lt; ans2[i][j] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></details>
<h1 id="E"><a href="#E" class="headerlink" title="E"></a>E</h1><p>题目链接：<a href="https://atcoder.jp/contests/agc037/tasks/agc037_e">https://atcoder.jp/contests/agc037/tasks/agc037_e</a></p>
<p>题目大意：你可以对字符串进行以下操作 $K$ 次：</p>
<p>$S$ 翻转得到 $S’$ ，在 $SS’$ 中找到长度为 $n$ 的字符串替代 $S$ 。</p>
<p>问最后得到的最小字典序的字符串。</p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>这是题？</p>
<p>显然一个事情，设 $maxlen=SS’$ 中最长的连续最小字符。</p>
<p>那么显然最后得到的字符串的前缀一定 $\le maxlen*2^{K-1}$ ，而且等号成立当且仅当每一步中都选择最长的连续最小字符段为后缀（最后一次为前缀）.</p>
<p>可以注意到，除了第一次有多种选择，后面都只有唯一选择。</p>
<p>因此直接暴力就行了，时间复杂度：$O(n^2)$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">5e3</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">char</span> st[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_char_array</span><span class="params">(<span class="type">char</span> *s)</span></span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">char</span> ss[N];</span><br><span class="line">    cin &gt;&gt; ss;</span><br><span class="line">    <span class="built_in">memcpy</span>(s + <span class="number">1</span>, ss, <span class="built_in">sizeof</span>(<span class="type">char</span>) * <span class="built_in">strlen</span>(ss));</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">char</span> ans[N], now[N], tmp[N];</span><br><span class="line"><span class="type">int</span> n, K;</span><br><span class="line"><span class="function"><span class="type">char</span> <span class="title">query</span><span class="params">(<span class="type">int</span> pos)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> pos &gt; n ? st[n + n - pos + <span class="number">1</span>] : st[pos];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">rev</span><span class="params">(<span class="type">char</span> *s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i + i &lt;= n; i++) <span class="built_in">swap</span>(s[i], s[n - i + <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">char</span> *s1, <span class="type">char</span> *s2)</span></span>&#123; <span class="comment">// s1 &lt; s2</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s1[i] != s2[i]) <span class="keyword">return</span> s1[i] &lt; s2[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">updata</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">cmp</span>(now, ans)) <span class="built_in">swap</span>(ans, now);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; K;</span><br><span class="line">    <span class="built_in">get_char_array</span>(st);</span><br><span class="line">    <span class="type">char</span> minchar = <span class="string">&#x27;z&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) minchar = <span class="built_in">min</span>(minchar, st[i]);</span><br><span class="line">    <span class="type">int</span> maxlen = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> l = <span class="number">1</span>; l &lt;= n; l++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(st[l] != minchar) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="type">int</span> r = l;</span><br><span class="line">        <span class="keyword">while</span>(r &lt; n &amp;&amp; st[r + <span class="number">1</span>] == minchar) r++;</span><br><span class="line">        <span class="keyword">if</span>(r == n) maxlen = <span class="built_in">max</span>((r - l + <span class="number">1</span>) * <span class="number">2</span>, maxlen);</span><br><span class="line">        <span class="keyword">else</span> maxlen = <span class="built_in">max</span>(maxlen, r - l + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) ans[i] = st[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> l = <span class="number">1</span>; l &lt;= n; l++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(st[l] != minchar) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="type">int</span> r = l;</span><br><span class="line">        <span class="keyword">while</span>(r &lt; n &amp;&amp; st[r + <span class="number">1</span>] == minchar) r++;</span><br><span class="line">        <span class="keyword">if</span>((r != n &amp;&amp; (r - l + <span class="number">1</span>) == maxlen) || (r == n &amp;&amp; (r - l + <span class="number">1</span>) * <span class="number">2</span> == maxlen))&#123;</span><br><span class="line">            <span class="type">int</span> endpos = n + (n - l + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> t = <span class="number">0</span>; t &lt; n; t++) tmp[n - t] = <span class="built_in">query</span>(endpos - t);</span><br><span class="line">            <span class="type">int</span> startpos = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(K &gt;= <span class="number">14</span> || maxlen * (<span class="number">1</span> &lt;&lt; (K - <span class="number">1</span>)) &gt;= n) startpos = n + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> startpos += maxlen * (<span class="number">1</span> &lt;&lt; (K - <span class="number">1</span>)) - maxlen;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> t = <span class="number">0</span>; t &lt; n; t++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(t + startpos &lt;= n) now[t + <span class="number">1</span>] = tmp[t + startpos];</span><br><span class="line">                <span class="keyword">else</span> now[t + <span class="number">1</span>] = minchar;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">rev</span>(now);</span><br><span class="line">            <span class="built_in">updata</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans + <span class="number">1</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>幽默题目。</p>
</div></details>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>dp</tag>
        <tag>Hall定理</tag>
        <tag>二分图匹配</tag>
      </tags>
  </entry>
  <entry>
    <title>AGC043 C. Giant Graph</title>
    <url>/2024/06/03/AGC043-C-Giant-Graph/</url>
    <content><![CDATA[<p>题目链接：<a href="https://atcoder.jp/contests/agc043/tasks/agc043_c">https://atcoder.jp/contests/agc043/tasks/agc043_c</a></p>
<p>题目大意：给三张无向图 $X,Y,Z$，满足点数为 $n$ ，边数分别为 $M_1,M_2,M_3$ ，然后构造一个点数为 $N^3$ 的图，满足其中的节点 $(x,y,z)$ 。</p>
<p>且其中的边为：</p>
<p>若 $(x_1,x_2)\in E_X$ ，则 $\forall y,z:((x_1,y,z),(x_2,y,z))\in E$</p>
<p>对于 $E_Y,E_Z$ 同理。</p>
<p>然后点 $(x,y,z)$ 的权值为 $10^{18(x+y+z)}$ ，问最大权值和的独立集的最大权值和是多少。</p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>注意到 $10^{18(x+y+z)}=10^{18x}10^{18y}10^{18z}$ ，由于 $10^{18}$ 很大，所以可以注意到两个独立集权值的比较，可以看成是 $(x+y+z)$ 从大到小排序后比较数组字典序。</p>
<p>首先不难证明一个结论（由于和相同的点不会互相删除，所以直接用贪心的思路证明就行了）：</p>
<p>一个独立集是最优解，当且仅当所有点 $(x,y,z)$ 要么在独立集里，要么存在 $(x’,y’,z’)(x’+y’+z’\ge x+y+z)$ 在独立集里且与他有连边。</p>
<p>因此只要能构造出这样的独立集就行了。</p>
<p>在构造的过程中，我们可以发现图中同时有一些点总是同时存在。</p>
<p>什么意思呢？我们将每条边从大到小连边，然后每次将这个 DAG 中入度为 $0$ 的点作为一个集合，然后在 DAG 上删除这个集合，重复这个过程。可以发现，每个集合中的点总是同时存在不妨按照时间顺序给每个集合编号：$X_1,X_2,X_3…$ ，则 $\forall i&lt;j:\forall x\in X_j:\exists y\in X_i:y\to x$ 。</p>
<p>从而知道 $X$ 集合的至多 $O(\sqrt{m})$ 个，同理 $Y$ 集合和 $Z$ 集合也是。</p>
<p>现在可以将原来的 $X,Y,Z$ 图等价的同构成由 $\{X_i\},\{Y_i\},\{Z_i\}$ 构成的图，其中每个图都是 $i\to j(i<j)$ ，其中权值关系为：$X_i>X_j(i&lt;j)$ （从上面的构造不难看出）。</p>
<p>由于此时的点数只有 $m\sqrt{m}$ ，直接暴力枚举就行了，可以证明此时得到的解在原图上一定满足上面说的是最优解的条件，所以我们就得到了最优解。</p>
<p>时间复杂度：$O(m\sqrt{m})$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span>  LL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> B = <span class="number">455</span>;</span><br><span class="line"><span class="type">const</span> LL mod = <span class="number">998244353</span>, base = (LL)<span class="number">1e18</span> % mod;</span><br><span class="line">vector&lt;LL&gt; val[<span class="number">3</span>];</span><br><span class="line"><span class="type">bool</span> vis[B][B][B];</span><br><span class="line">LL f[N];</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">bool</span> v[N];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; out[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    f[<span class="number">0</span>] = <span class="number">1ll</span>; <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) f[i] = f[i - <span class="number">1</span>] * base % mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> id)</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">        <span class="type">int</span> x, y;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        <span class="keyword">if</span>(x &lt; y) <span class="built_in">swap</span>(x, y);</span><br><span class="line">        out[x].<span class="built_in">push_back</span>(y);</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; pos;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = n; i &gt;= <span class="number">1</span>; i--) pos.<span class="built_in">push_back</span>(i);</span><br><span class="line">    <span class="keyword">while</span>(!pos.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; tmp;</span><br><span class="line">        LL now = <span class="number">0ll</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> x : pos)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!v[x])&#123;</span><br><span class="line">                now = (now + f[x]) % mod;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">auto</span> y : out[x]) v[y] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> tmp.<span class="built_in">push_back</span>(x);</span><br><span class="line">        &#125;</span><br><span class="line">        val[id].<span class="built_in">push_back</span>(now);</span><br><span class="line">        <span class="built_in">swap</span>(pos, tmp);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> x : pos) v[x] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) v[i] = <span class="number">0</span>, out[i].<span class="built_in">clear</span>();</span><br><span class="line">    <span class="built_in">assert</span>(val[id].<span class="built_in">size</span>() &lt;= B);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> t = <span class="number">0</span>; t &lt;= <span class="number">2</span>; t++) <span class="built_in">solve</span>(t);</span><br><span class="line">    LL ans = <span class="number">0ll</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> sum = <span class="number">0</span>; sum + <span class="number">3</span> &lt;= val[<span class="number">0</span>].<span class="built_in">size</span>() + val[<span class="number">1</span>].<span class="built_in">size</span>() + val[<span class="number">2</span>].<span class="built_in">size</span>(); sum++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= sum &amp;&amp; i &lt; val[<span class="number">0</span>].<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span> ; i + j &lt;= sum &amp;&amp; j &lt; val[<span class="number">1</span>].<span class="built_in">size</span>(); j++)&#123;</span><br><span class="line">                <span class="type">int</span> k = sum - i - j;</span><br><span class="line">                <span class="keyword">if</span>(k &gt;= val[<span class="number">2</span>].<span class="built_in">size</span>() || vis[i][j][k]) <span class="keyword">continue</span>;</span><br><span class="line">                ans = (ans + val[<span class="number">0</span>][i] * val[<span class="number">1</span>][j] % mod * val[<span class="number">2</span>][k]) % mod;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> t = i + <span class="number">1</span>; t &lt; val[<span class="number">0</span>].<span class="built_in">size</span>(); t++) vis[t][j][k] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> t = j + <span class="number">1</span>; t &lt; val[<span class="number">1</span>].<span class="built_in">size</span>(); t++) vis[i][t][k] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> t = k + <span class="number">1</span>; t &lt; val[<span class="number">2</span>].<span class="built_in">size</span>(); t++) vis[i][j][t] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></details>
<details class="toggle" ><summary class="toggle-button" style="">官方做法</summary><div class="toggle-content"><p>吐槽：不是哥们，我怎么又嗯做做出来一道题目啊。</p>
<p>这道题目的正经做法是这样子的：</p>
<p>注意到最优方案一定是每次选可选的 $i+j+k$ 中最大的，我们可以对边定向，由小指向大，那么可以注意到我们能选到的点当且仅当，将这个图当成一个博弈状态图，这个点是一个必败态。</p>
<p>然后又注意到这其实是三个图的的组合游戏，所以就是异或。</p>
<p>直接求一下 SG 函数，然后不难发现，一个图中的 SG 的上限是根号的，所以直接 $O(m)$ 求一下就行了。</p>
<p>总时间复杂度：$O(n+m)$ 。</p>
<p>反思：</p>
<p>回到我的做法中，我把每个小图中的某些点归为一类，那么这个分类代表什么呢？我当时觉得这玩意可能有实际意义，但是当时我没有看出来。</p>
<p>没看出来的一个很重要的原因：我只对小图求了等价类，但是没有对大图做等价类，因此没有注意到大图的等价类就是小图等价类的组合这个性质。</p>
<p>还有一个很重要的原因：我的建图是从大指向小的。</p>
<p>只能说做题确实需要建模，这题目基本只要想出和 SG 的联系基本就做完了。但是我觉得这并不是我的问题，因为我确实想不到其和 SG 的联系。不能说没有建，只能说建不出来，不是方法问题，是实力问题。</p>
<p>就这样吧，我觉得目前来看，在我的思考过程中，方法没有问题，要真要说优化的话，只能说希望下次做类似的题能做的快一点吧，其余没啥了。</p>
<p>收获：</p>
<p>已知现在有几个有向图游戏，那么这多个游戏同时进行，既可以表示成每个游戏上你都在一个点上，然后每次移动一个点，其意义就是多个游戏同时进行，例子：多个石堆，每次只能在一个石堆上移除石子；也可以像这道题目一样，用 $(x_1,x_2,…,x_n)$ 来表示，边也像这道题目一样标，其意义为直接将这多个游戏同时进行的这场游戏视为一个整体，一个有向图游戏。</p>
<p>这道题目给我的收获就是：发现多个同时进行的有向图游戏还可以用后面那种表示，同时也加深了一下我对有向图游戏的理解。</p>
<p>我认为这是一道好题。</p>
</div></details>]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>SG</tag>
      </tags>
  </entry>
  <entry>
    <title>AGC035 赛后总结</title>
    <url>/2024/05/25/AGC035-%E8%B5%9B%E5%90%8E%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>比赛链接：<a href="https://atcoder.jp/contests/agc035/tasks">https://atcoder.jp/contests/agc035/tasks</a></p>
<h1 id="A-XOR-Circle"><a href="#A-XOR-Circle" class="headerlink" title="A. XOR Circle"></a>A. XOR Circle</h1><p>题目链接：<a href="https://atcoder.jp/contests/agc035/tasks/agc035_a">https://atcoder.jp/contests/agc035/tasks/agc035_a</a></p>
<p>题目大意：把 $n$ 个数字放在一个环上，满足任意相邻的三个数字 $A,B,C$ 都满足： $A\otimes C = B$ 。</p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>不妨假设前三个数字为 $A,B,A\otimes B$ ，那么我们可以得到后面的数字为：$A,B,A\otimes B…$ ，可以看到 $3$ 是这个圆的周期。</p>
<p>因此，如果 $n$ 是 $3$ 的倍数，就是有三组 $n$ 个数字且异或和为 $0$ 。</p>
<p>否则就是所有数字都是 $0$ 。</p>
<p>时间复杂度：$O(n\log{n})$ ，而且不难做到 $O(n)$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n, a[N];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">pd</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a[l] == a[r];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(a + <span class="number">1</span>, a + n + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(n % <span class="number">3</span> != <span class="number">0</span>) <span class="keyword">return</span> <span class="built_in">pd</span>(<span class="number">1</span>, n) &amp;&amp; !a[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">pd</span>(<span class="number">1</span>, n / <span class="number">3</span>) &amp;&amp; <span class="built_in">pd</span>(n / <span class="number">3</span> + <span class="number">1</span>, n / <span class="number">3</span> * <span class="number">2</span>) &amp;&amp; <span class="built_in">pd</span>(n / <span class="number">3</span> * <span class="number">2</span> + <span class="number">1</span>, n) &amp;&amp; (a[n / <span class="number">3</span>] ^ a[n / <span class="number">3</span> * <span class="number">2</span>] ^ a[n]) == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">solve</span>()) cout &lt;&lt; <span class="string">&quot;Yes\n&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;No\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></details>
<h1 id="B-Even-Degrees"><a href="#B-Even-Degrees" class="headerlink" title="B. Even Degrees"></a>B. Even Degrees</h1><p>题目链接：<a href="https://atcoder.jp/contests/agc035/tasks/agc035_b">https://atcoder.jp/contests/agc035/tasks/agc035_b</a></p>
<p>题目大意：给每条边定个向，满足每个点的出度为偶数。</p>
<details class="toggle" ><summary class="toggle-button" style="">题解</summary><div class="toggle-content"><p>这个问题可以等价的转化为一个经典问题：能不能进行边匹配，满足匹配边之间有一个公共点。（无重边）</p>
<p>这个问题有解的条件是：连通且边数为偶数。</p>
<p>做法是：把 $DFS$ 树建出来，然后把所有返祖边存在子树内，然后从下到上，依次把每个点的非父亲边两两匹配，如果剩下一条就和父亲边匹配，如果没有，就把父亲边像返祖边一样丢给父亲，显然在边数为偶数的情况下，这样一定能匹配完所有的边。</p>
<p>时间复杂度：$O(n)$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> y, next;</span><br><span class="line">&#125;a[N * <span class="number">2</span>]; <span class="type">int</span> len, las[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ins</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    a[++len] = &#123;y, las[x]&#125;;</span><br><span class="line">    las[x] = len;</span><br><span class="line">&#125;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; gfa[N];</span><br><span class="line"><span class="type">int</span> fa[N], dfn[N], ti;</span><br><span class="line"><span class="type">int</span> n, m, sta[N], top;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    dfn[x] = ++ti;</span><br><span class="line">    sta[++top] = x;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k = las[x]; k; k = a[k].next)&#123;</span><br><span class="line">        <span class="type">int</span> y = a[k].y;</span><br><span class="line">        <span class="keyword">if</span>(y == fa[x]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(dfn[y] &amp;&amp; dfn[y] &lt; dfn[x]) gfa[x].<span class="built_in">push_back</span>(y);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(!dfn[y])&#123;</span><br><span class="line">            fa[y] = x;</span><br><span class="line">            <span class="built_in">dfs</span>(y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; y &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">if</span>(m &amp; <span class="number">1</span>)&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;-1\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">        <span class="type">int</span> x, y;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        <span class="built_in">ins</span>(x, y);</span><br><span class="line">        <span class="built_in">ins</span>(y, x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(gfa[i].<span class="built_in">size</span>() &gt;= <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="type">int</span> x = gfa[i].<span class="built_in">back</span>();</span><br><span class="line">            gfa[i].<span class="built_in">pop_back</span>();</span><br><span class="line">            <span class="type">int</span> y = gfa[i].<span class="built_in">back</span>();</span><br><span class="line">            gfa[i].<span class="built_in">pop_back</span>();</span><br><span class="line">            <span class="built_in">print</span>(i, x);</span><br><span class="line">            <span class="built_in">print</span>(i, y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = n; i &gt;= <span class="number">1</span>; i--)&#123;</span><br><span class="line">        <span class="type">int</span> now = sta[i];</span><br><span class="line">        <span class="keyword">while</span>(gfa[now].<span class="built_in">size</span>() &gt;= <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="type">int</span> x = gfa[now].<span class="built_in">back</span>();</span><br><span class="line">            gfa[now].<span class="built_in">pop_back</span>();</span><br><span class="line">            <span class="type">int</span> y = gfa[now].<span class="built_in">back</span>();</span><br><span class="line">            gfa[now].<span class="built_in">pop_back</span>();</span><br><span class="line">            <span class="built_in">print</span>(now, x);</span><br><span class="line">            <span class="built_in">print</span>(now, y);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!gfa[now].<span class="built_in">size</span>()) gfa[fa[now]].<span class="built_in">push_back</span>(now);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">print</span>(now, gfa[now][<span class="number">0</span>]), <span class="built_in">print</span>(now, fa[now]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>update ：</p>
<p>在看完题解后，感觉自己像个小丑，我这个做法完全可以这么翻译：</p>
<p>我在 $DFS$ 树上给非树边定向后，从下到上，对于每个点，如果出边为奇数，那么就把父亲边调转，何必多次一举去做匹配的过程。</p>
<p>或者说可以这么考虑，发现匹配过程得到的匹配对是完全没有用的，我们完全可以假装我们匹配过了，然后直接把点的所有非父亲边弹出，并根据数量决定需不需要父亲边。</p>
<p>还是写复杂了。</p>
</div></details>
<h1 id="C-Skolem-XOR-Tree"><a href="#C-Skolem-XOR-Tree" class="headerlink" title="C. Skolem XOR Tree"></a>C. Skolem XOR Tree</h1><p>题目链接：<a href="https://atcoder.jp/contests/agc035/tasks/agc035_c">https://atcoder.jp/contests/agc035/tasks/agc035_c</a></p>
<p>题目大意：给你 $2n$ 个点，$i,i+n$ 的权值都是 $n$ ，要求你构造一棵树，满足 $i,i+n$ 路径（包括端点）的异或和为 $i$ 。</p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>不懂，感觉现在不会构造题啊，比赛时被这道题卡了一路。</p>
<p>首先注意到一个事情：$n=2^n$ 无解。</p>
<p>剩下的情况，如果 $n$ 是奇数的话，我们注意到可以：</p>
<p>$1$ 放中间，然后 $2k,2k+1$ 这样子放：$2k, 2k+1, 1, 2k, 2k+1$ 。</p>
<p>而 $1$ 的匹配可以随便找一个 $2k,2k+1$ 放在其屁股后面。</p>
<p>如果 $n$ 是偶数，那么假设 $n = k + t$ ，其中 $k,t$ 的或为 $0$ ，那么可以通过走 $k,k+1$ 和 $t,t+1$ 的路来跑出 $n$ 的路。</p>
<p><img src="1.png" alt=""></p>
<p>时间复杂度：$O(n)$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="keyword">return</span> x &amp; -x;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; y &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">lowbit</span>(n) == n)&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;No\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Yes\n&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">3</span>; i &lt;= n; i += <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="built_in">print</span>(i - <span class="number">1</span>, i);</span><br><span class="line">        <span class="built_in">print</span>(i, <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">print</span>(<span class="number">1</span>, i - <span class="number">1</span> + n);</span><br><span class="line">        <span class="built_in">print</span>(i - <span class="number">1</span> + n, i + n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">print</span>(n + <span class="number">1</span>, n + <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">if</span>(n % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="type">int</span> x = <span class="built_in">lowbit</span>(n);</span><br><span class="line">        <span class="type">int</span> y = n ^ x;</span><br><span class="line">        <span class="built_in">print</span>(n, x + <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">print</span>(n + n, y + n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></details>
<h1 id="D-Add-and-Remove"><a href="#D-Add-and-Remove" class="headerlink" title="D. Add and Remove"></a>D. Add and Remove</h1><p>题目链接：<a href="https://atcoder.jp/contests/agc035/tasks/agc035_d">https://atcoder.jp/contests/agc035/tasks/agc035_d</a></p>
<p>题目大意：给你 $n$ 个数字，每次可以选择相邻的三个数字，把中间的数字删掉并且加到旁边两个数字，问最后剩下的两个数字之和的最小值。</p>
<details class="toggle" ><summary class="toggle-button" style="">我的做法</summary><div class="toggle-content"><p>一种很新的状压 $dp$ 。</p>
<p>首先不大可能同时考虑整个序列，毕竟被删的位置没法决定当前的状态，和删除的顺序也有关，因此逐个位置考虑。</p>
<p>发现一个事情，一个数字删除后在的位置一定是相邻的两个格子，而其对最终答案的贡献取决于其这两个格子左右删除的顺序。</p>
<p>因此我们可以设一个 $dp[state]$ ，$state$ 表示当前这个数字对应的删除顺序。</p>
<p>然后直接转移就行了。</p>
<p>时间复杂度：$O(n2^n)$ 。</p>
<p>感觉这个状压 $dp$ 非常的有意思。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> B = <span class="number">16</span>;</span><br><span class="line">LL dp[<span class="number">2</span>][(<span class="number">1</span> &lt;&lt; B)];</span><br><span class="line">LL cnt[(<span class="number">1</span> &lt;&lt; B)], a[B + <span class="number">5</span>];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">gethighbit</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="keyword">return</span> <span class="number">31</span> - __builtin_clz(x);&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getbit</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>&#123;<span class="keyword">return</span> (x &gt;&gt; y) &amp; <span class="number">1</span>;&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">changebit</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> k)</span></span>&#123;<span class="keyword">return</span> x ^ ((<span class="built_in">getbit</span>(x, y) ^ k) &lt;&lt; y);&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="keyword">return</span> x &amp; -x;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cnt[<span class="number">1</span>] = <span class="number">2ll</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> x = <span class="number">0</span>; x &lt; (<span class="number">1</span> &lt;&lt; i); x++)&#123;</span><br><span class="line">            <span class="type">int</span> tmp = x;</span><br><span class="line">            LL lc = <span class="number">1ll</span>, rc = <span class="number">1ll</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; j++)&#123;</span><br><span class="line">                <span class="type">int</span> now = tmp &amp; <span class="number">1</span>;</span><br><span class="line">                tmp &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(!now) rc = rc + lc;</span><br><span class="line">                <span class="keyword">else</span> lc = lc + rc;</span><br><span class="line">            &#125;</span><br><span class="line">            cnt[<span class="built_in">changebit</span>(x, i, <span class="number">1</span>)] = lc + rc;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    n -= <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n + <span class="number">1</span>; i++)&#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">0</span>)&#123;</span><br><span class="line">        cout &lt;&lt; a[<span class="number">0</span>] + a[<span class="number">1</span>] &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> now = <span class="number">0</span>, pre = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">memset</span>(dp[now], <span class="number">20</span>, <span class="built_in">sizeof</span>(dp[now]));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) dp[now][(<span class="number">1</span> &lt;&lt; i) - <span class="number">1</span>] = a[<span class="number">0</span>] + a[n + <span class="number">1</span>] + cnt[(<span class="number">1</span> &lt;&lt; i) - <span class="number">1</span>] * a[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        now ^= <span class="number">1</span>; pre ^= <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">memset</span>(dp[now], <span class="number">20</span>, <span class="built_in">sizeof</span>(dp[now]));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> state = <span class="number">1</span>; state &lt; (<span class="number">1</span> &lt;&lt; (n - <span class="number">1</span>)); state++)&#123;</span><br><span class="line">            <span class="type">int</span> nexstate = state &lt;&lt; <span class="number">1</span>;</span><br><span class="line">            dp[now][nexstate] = <span class="built_in">min</span>(dp[now][nexstate], dp[pre][state]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> state = <span class="number">1</span>; state &lt; (<span class="number">1</span> &lt;&lt; (n - <span class="number">1</span>)); state++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(__builtin_popcount(state) &gt; (n - i)) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="type">int</span> nexstate = (state &lt;&lt; <span class="number">1</span>) | <span class="number">1</span>;</span><br><span class="line">            dp[now][nexstate] = <span class="built_in">min</span>(dp[now][nexstate], dp[now][state]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> state = <span class="number">1</span>; state &lt; (<span class="number">1</span> &lt;&lt; n); state++)&#123;</span><br><span class="line">            <span class="type">int</span> next1 = <span class="built_in">lowbit</span>(state);</span><br><span class="line">            <span class="keyword">if</span>(next1 != state)&#123;</span><br><span class="line">                next1 = __lg(next1);</span><br><span class="line">                <span class="type">int</span> nexstate = (state &gt;&gt; (next1 + <span class="number">1</span>));</span><br><span class="line">                dp[now][nexstate] = <span class="built_in">min</span>(dp[now][nexstate], dp[pre][state]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> state = <span class="number">1</span>; state &lt; (<span class="number">1</span> &lt;&lt; n); state++)&#123;</span><br><span class="line">            dp[now][state] += a[i] * cnt[state];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    LL ans = dp[now][<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; (<span class="number">1</span> &lt;&lt; n); i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(__builtin_popcount(i) == <span class="number">1</span>) ans = <span class="built_in">min</span>(ans, dp[now][i]);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是这个做法又可以优化的空间吗？</p>
<p>我们来精细计算一下：</p>
<p>对于一个 $k$ 位的状态，其有效的区间是 $n-k$ 。</p>
<p>因此实际上有效的状态为：$\sum\limits_{i=0}^n 2^{i}(n-i)=\sum\limits_{i=0}^{n-1}\sum\limits_{j=0}^i2^{j}=\sum\limits_{i=0}^{n-1}2^{i+1}-1=2^{n+1}-(n+2)$ 。</p>
<p>所以如果在 $dp$ 的时候只考虑有效状态的话，实际上是 $O(2^n)$ 的。</p>
<p>能够实现出来吗？$cnt$ 的计算使用位运算技巧可以做到 $2^n$ ，而 $dp$ 如果使用 vector 提前把所有可行状态存下来，也同样可以做到 $O(状态数)$，也就是 $O(2^n)$ 。</p>
<p>因此，上述 $dp$ 完全可以做到 $O(2^n)$ 的空间和时间，但是会比较难写。</p>
<p>对此我的评价是，完全不如正解。</p>
</div></details>
<details class="toggle" ><summary class="toggle-button" style="">正解</summary><div class="toggle-content"><p>有一种形式的 $dp$ 非常的好写，相较于其余的 $dp$ 。</p>
<p>就是记忆化形式的 $dp$ ，甚至有的时候可以去掉记忆化，那样就更好写了。</p>
<p>首先把 $a_1,a_n$ 给删掉，然后在数组两边放上两个变量 $L,R$ ，这样就变成了每次删除一个数字，然后把这个数字给放到两边，这样删完这个数组后得到的答案就是 $L+R$ 。</p>
<p>因此，倒着考虑每个区间最后被删除的数字是啥，我们就可以得到如下的 dp ：</p>
<p>$dp[l][r][cl][cr]$ 表示 $[l,r]$ 区间中的数字删完后，贡献为 $L<em>cl+R</em>cr$ 后的贡献最小值。</p>
<p>然后 $dp[l][r][cl][cr]=\min\limits_{l\le i\le r}(dp[l][i-1][cl][cl+cr]+dp[i+1][r][cl+cr][cr]+(cl+cr)*a[i])$ 。</p>
<p>然后用这个式子 $dp$ 就行了。</p>
<p>最后答案就是 $dp[1][n][1][1]+a[1]+a[n]$ 。</p>
<p>那么状态是多少呢？注意到这个的状态数计算和我的做法一样，都是 $\sum\limits_{i=0}^{n}2^{i}(n-i)$ ，也就是 $O(2^n)$ 。</p>
<p>而合法的转移数是 $\sum\limits_{i=0}^{n}2^{i}(n-i)^2$ ，也是 $O(2^n)$ 的.</p>
<p>注：$\sum\limits_{i=0}^{n}2^{i}(n-i)^k$ 都是 $O(2^n)$ 的。</p>
<p>因此如果使用记忆化的话时间复杂度为：$O(2^n*T)$ ，$T$ 为使用的数据结构的储存时间。</p>
<p>但是使用数据结构储存还是麻烦了，如果使用 map 还得自己写个四元组作为键。（貌似也可以使用 array<int,4>）</p>
<p>因此不妨考虑不记忆化，那么不记忆化的复杂度是多少呢？</p>
<p>设 $T(n)$ 表示一个长度为 $r-l+1=n$ 的递归复杂度，那么 $T(n)$ 满足：</p>
<p>$T(n)=\sum\limits_{i=0}^{n-1}2T(i)$</p>
<p>那么可以得到 $T(n)=3T(n-1)$ ，从而知道复杂度就是 $O(3^n)$ 。</p>
<p>这样代码就好写很多了。</p>
<p>这里粘一份别人的代码。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> a[<span class="number">25</span>];</span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> xl,<span class="type">int</span> xr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="keyword">if</span>(r-l&lt;=<span class="number">1</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> <span class="type">long</span> <span class="type">long</span> ans=<span class="number">1e18</span>;</span><br><span class="line"> <span class="keyword">for</span>(<span class="type">int</span> i=l+<span class="number">1</span>;i&lt;=r<span class="number">-1</span>;i++)</span><br><span class="line">  ans=<span class="built_in">min</span>(ans,<span class="built_in">dfs</span>(l,i,xl,xl+xr)+<span class="built_in">dfs</span>(i,r,xl+xr,xr)+a[i]*(xl+xr));</span><br><span class="line"> <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="type">int</span> n;</span><br><span class="line"> cin&gt;&gt;n;</span><br><span class="line"> <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">  cin&gt;&gt;a[i];</span><br><span class="line"> cout&lt;&lt;a[<span class="number">1</span>]+a[n]+<span class="built_in">dfs</span>(<span class="number">1</span>,n,<span class="number">1</span>,<span class="number">1</span>)&lt;&lt;endl;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//代码来源：https://www.luogu.com.cn/article/nuav36aw</span></span><br><span class="line"><span class="comment">//代码作者：StudyingFather</span></span><br></pre></td></tr></table></figure>
<p>怎么能想出这么好写的做法？</p>
<p>我不知道，我没想出来。</p>
<p>不过我觉得答案应该是：积累。</p>
</div></details>]]></content>
      <categories>
        <category>信息学</category>
      </categories>
  </entry>
  <entry>
    <title>AGC044 C. Strange Dance</title>
    <url>/2024/04/22/AGC044-C-Strange-Dance/</url>
    <content><![CDATA[<p>题目链接：<a href="https://atcoder.jp/contests/agc044/tasks/agc044_c">https://atcoder.jp/contests/agc044/tasks/agc044_c</a></p>
<p>题目大意：给一个大小为 $3^{n}$ 的数组，下标为 $0,1,2,…,3^n -1$ ，一开始 $a_{i}=i$，然后有两个操作：</p>
<ol>
<li>令 $a’_{j}=a_{i}$ ，其中 $j$ 是 $i$ 三进制中如果是 $2$ 变成 $1$ ，是 $1$ 变成 $2$ 后的结果。</li>
<li>令 $a$ 数组循环右移一格。</li>
</ol>
<p>问给定操作序列后的数组的逆是啥。</p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>不妨分层考虑：</p>
<p>对于一个 $3^{k}$ 的元件，假如我们已经知道其在操作后进来了多少个数字，出去了什么数字，以及剩下的数字的排布，显然能够类似归并一样的处理出 $3^{k+1}$ 。</p>
<p>然后就做完了。</p>
<p>时间复杂度：$O(n*|S|+3^{n})$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> SN = <span class="number">6e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> L = <span class="number">21</span>;</span><br><span class="line"><span class="type">int</span> n, l, f3[L];</span><br><span class="line"><span class="type">char</span> st[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_char_array</span><span class="params">(<span class="type">char</span> *s)</span></span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">char</span> ss[N];</span><br><span class="line">    cin &gt;&gt; ss;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> len;</span><br><span class="line">    len = <span class="built_in">strlen</span>(ss);</span><br><span class="line">    <span class="built_in">memcpy</span>(s + <span class="number">1</span>, ss, <span class="built_in">sizeof</span>(<span class="type">char</span>) * len);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> nex[][<span class="number">3</span>] = &#123;&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">2</span>, <span class="number">-1</span>, <span class="number">1</span>&#125;&#125;;</span><br><span class="line"><span class="type">int</span> ord[][<span class="number">3</span>]= &#123;&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>&#125;, &#123;<span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>&#125;&#125;;</span><br><span class="line"><span class="type">int</span> be[SN];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; l;</span><br><span class="line">    <span class="built_in">get_char_array</span>(st);</span><br><span class="line">    n = <span class="built_in">strlen</span>(st + <span class="number">1</span>);</span><br><span class="line">    f3[<span class="number">0</span>] = <span class="number">1</span>;<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= l; i++) f3[i] = f3[i - <span class="number">1</span>] * <span class="number">3</span>;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; in, out, res;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; mov;</span><br><span class="line">    <span class="type">int</span> final_type;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> type = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(st[i] == <span class="string">&#x27;S&#x27;</span>) type ^= <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                out.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">                tmp++;</span><br><span class="line">                mov.<span class="built_in">push_back</span>(type);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">        final_type = type;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= l; i++)&#123;<span class="comment">//merge</span></span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; tmp_out = out, tmp_res = res;</span><br><span class="line">        out.<span class="built_in">clear</span>();</span><br><span class="line">        res.<span class="built_in">clear</span>();</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; now[<span class="number">3</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; mov.<span class="built_in">size</span>(); j++)&#123;</span><br><span class="line">            <span class="type">int</span> type = mov[j];</span><br><span class="line">            <span class="type">int</span> o = tmp_out[j];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> t = <span class="number">0</span>; t &lt;= <span class="number">2</span>; t++)&#123;</span><br><span class="line">                <span class="type">int</span> ne = nex[type][t], x;</span><br><span class="line">                <span class="keyword">if</span>(o &lt; f3[i - <span class="number">1</span>]) x = t * f3[i - <span class="number">1</span>] + o;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(!t) x = o - f3[i - <span class="number">1</span>] + f3[i];</span><br><span class="line">                <span class="keyword">else</span> x = now[t][o - f3[i - <span class="number">1</span>]];</span><br><span class="line">                <span class="keyword">if</span>(ne == <span class="number">-1</span>) out.<span class="built_in">push_back</span>(x);</span><br><span class="line">                <span class="keyword">else</span> now[ne].<span class="built_in">push_back</span>(x);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> t = <span class="number">0</span>; t &lt;= <span class="number">2</span>; t++)&#123;</span><br><span class="line">            <span class="type">int</span> tt = ord[final_type][t];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> x : tmp_res)&#123;</span><br><span class="line">                <span class="keyword">if</span>(x &lt; f3[i - <span class="number">1</span>]) res.<span class="built_in">push_back</span>(tt * f3[i - <span class="number">1</span>] + x);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(!tt) res.<span class="built_in">push_back</span>(x - f3[i - <span class="number">1</span>] + f3[i]);</span><br><span class="line">                <span class="keyword">else</span> res.<span class="built_in">push_back</span>(now[tt][x - f3[i - <span class="number">1</span>]]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;x : res)&#123;</span><br><span class="line">            <span class="keyword">while</span>(x &gt;= f3[l]) x = out[x - f3[l]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; f3[l]; i++) be[res[i]] = i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; f3[l]; i++) cout &lt;&lt; be[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></details>
<details class="toggle" ><summary class="toggle-button" style="">Trie 做法</summary><div class="toggle-content"><p>这都能字典树，厉害。</p>
<p>考虑将原来的数组用字典树表示。</p>
<p>首先注意到一个事情，第一个操作是全局下标变换，这在外边打个标记就行了。</p>
<p>而第二个操作全局下标 $+1$ 在传统字典树上很难实现，但是如果字典树是从低到高建的呢？那就非常简单了，处理进位的那棵子树就行了，时间复杂度：$O(n)$ 。</p>
<p>综上，时间复杂度为：$O(n*|S|+3^n)$ 。</p>
</div></details>]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>Trie</tag>
      </tags>
  </entry>
  <entry>
    <title>AGC041 赛后总结</title>
    <url>/2024/05/28/AGC041-%E8%B5%9B%E5%90%8E%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>比赛链接：<a href="https://atcoder.jp/contests/agc041">https://atcoder.jp/contests/agc041</a></p>
<h1 id="A-Table-Tennis-Training"><a href="#A-Table-Tennis-Training" class="headerlink" title="A. Table Tennis Training"></a>A. Table Tennis Training</h1><p>题目链接：<a href="https://atcoder.jp/contests/agc041/tasks/agc041_a">https://atcoder.jp/contests/agc041/tasks/agc041_a</a></p>
<p>题目大意：有 $n$ 场比赛，每次比完，$i$ 的胜者去 $i-1$ ，败者去 $i+1$ ，$1$ 的胜者和 $n$ 的败者不动，问 $A$ 和 $B$ 赛场的两个人相遇需要至少多少次比赛。</p>
<details class="toggle" ><summary class="toggle-button" style="">我的做法</summary><div class="toggle-content"><p>注意到，能改变奇偶性的只有 $1,n$ 赛场。</p>
<p>所以讨论一下就行了。</p>
<p>如果奇偶性相同就直接相遇，否则去一次 $1$ 或者 $n$ 改一下就行了。</p>
<p>时间复杂度：$O(1)$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line">LL n, A, B;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; A &gt;&gt; B;</span><br><span class="line">    <span class="keyword">if</span>((A &amp; <span class="number">1</span>) == (B &amp; <span class="number">1</span>)) cout &lt;&lt; <span class="built_in">abs</span>(A - B) / <span class="number">2</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="built_in">min</span>((A + B - <span class="number">1</span>) / <span class="number">2</span> , (n + n - A - B + <span class="number">1</span>) / <span class="number">2</span>) &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></details>
<h1 id="B-Voting-Judges"><a href="#B-Voting-Judges" class="headerlink" title="B. Voting Judges"></a>B. Voting Judges</h1><p>题目链接：<a href="https://atcoder.jp/contests/agc041/tasks/agc041_b">https://atcoder.jp/contests/agc041/tasks/agc041_b</a></p>
<p>题目大意：有 $n$ 道题目，有 $m$ 个裁判选择恰好 $V$ 个题目投票，然后每道题目基础有 $a_i$ 票，得票数最高的 $P$ 道题目会入选比赛，问每道题目有没有机会入选。</p>
<details class="toggle" ><summary class="toggle-button" style="">我的做法</summary><div class="toggle-content"><p>先从大到小排序。</p>
<p>如果我们想要让 $a_{i}$ 有可能能成为前 $P$ 个，贪心来看，投给 $a_{i}$ 优先级最高，其次是前 $P-1$ 个和 $\le a_i$ 的题目，最后才是介于 $P$ 名和 $&gt;a_i$ 的题目。</p>
<p>别人加等于我减，所以可以看成对这些题目的减法，因此问题能够转换成问 $[P,i-1]$ 区间中的数字，有 $m$ 次操作能够选择若干数字 $-1$ ，问能不能全部 $\le a_i$ 。（不难证明这是充要条件）</p>
<p>然后就做完了。</p>
<p>时间复杂度：$O(n\log{n})$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n, m, a[N], P, V;</span><br><span class="line">LL sum[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; V &gt;&gt; P;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    V = n - V;</span><br><span class="line">    <span class="built_in">sort</span>(a + <span class="number">1</span>, a + n + <span class="number">1</span>, [](<span class="type">int</span> x, <span class="type">int</span> y)&#123;<span class="keyword">return</span> x &gt; y;&#125;);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) sum[i] = sum[i - <span class="number">1</span>] + a[i];</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i &lt;= P) ans++;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="type">int</span> len = <span class="built_in">min</span>(i - P, V);</span><br><span class="line">            ans += ((sum[i - <span class="number">1</span>] - sum[P - <span class="number">1</span>] - <span class="number">1ll</span> * a[i] * (i - P)) &lt;= <span class="number">1ll</span> * len * m &amp;&amp; </span><br><span class="line">            a[P] - m &lt;= a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></details>
<h1 id="C-Domino-Quality"><a href="#C-Domino-Quality" class="headerlink" title="C. Domino Quality"></a>C. Domino Quality</h1><p>题目链接：<a href="https://atcoder.jp/contests/agc041/tasks/agc041_c">https://atcoder.jp/contests/agc041/tasks/agc041_c</a></p>
<p>题目大意：可以放一些 $1<em>2$ 的方块在矩阵里面，要求每一行每一列涉及的 $1</em>2$ 的方块数一样而且不为 $0$ 。</p>
<details class="toggle" ><summary class="toggle-button" style="">我的做法</summary><div class="toggle-content"><p>首先 $\le 2$ 是无解的。</p>
<p>$\ge 3$ 时呢？</p>
<p>一个想法是发现我们可以像矩阵那样，分成左上角和右下角，所以可以把 $n$ 写成 $n_1+n_2+…$ 的形式，只要每一部分中每行每列的涉及的方块数一样就行。</p>
<p>首先可以构造出偶数时每行每列为 $3$ 的情况：</p>
<p><img src="1.png" alt=""></p>
<p>还有 $5$ 时的情况：</p>
<p><img src="2.png" alt=""></p>
<p>$7$ 的情况：</p>
<p><img src="3.png" alt=""></p>
<p>然后就做完了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e3</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">char</span> st[N][N];</span><br><span class="line"><span class="type">char</span> ans[][<span class="number">6</span>] = &#123;<span class="string">&quot;aabbc&quot;</span> ,</span><br><span class="line">                 <span class="string">&quot;f.ggc&quot;</span> ,</span><br><span class="line">                 <span class="string">&quot;fkk.d&quot;</span> ,</span><br><span class="line">                 <span class="string">&quot;de..d&quot;</span> ,</span><br><span class="line">                 <span class="string">&quot;de.ee&quot;</span>&#125;;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">3</span>)&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;aa.\n&quot;</span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;..b\n&quot;</span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;..b\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(n == <span class="number">7</span>)&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;a..yykk\n&quot;</span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;ayy.tt.\n&quot;</span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;bkkp...\n&quot;</span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;b..p..g\n&quot;</span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;....pqg\n&quot;</span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;....pqf\n&quot;</span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;ccee..f\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(n &lt;= <span class="number">2</span>)&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;-1\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) st[i][j] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> n5 = n;</span><br><span class="line">        <span class="keyword">if</span>(n &amp; <span class="number">1</span>) n5 -= <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n5; i += <span class="number">2</span>)&#123;</span><br><span class="line">            st[i][i] = st[i + <span class="number">1</span>][i] = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            st[i][i + <span class="number">1</span>] = st[i + <span class="number">1</span>][i + <span class="number">1</span>] = <span class="string">&#x27;b&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span>(i != n5 - <span class="number">1</span>)&#123;</span><br><span class="line">                st[i][i + <span class="number">2</span>] = st[i][i + <span class="number">3</span>] = <span class="string">&#x27;c&#x27;</span>;</span><br><span class="line">                st[i + <span class="number">1</span>][i + <span class="number">2</span>] = st[i + <span class="number">1</span>][i + <span class="number">3</span>] = <span class="string">&#x27;d&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                st[i][<span class="number">1</span>] = st[i][<span class="number">2</span>] = <span class="string">&#x27;c&#x27;</span>;</span><br><span class="line">                st[i + <span class="number">1</span>][<span class="number">1</span>] = st[i + <span class="number">1</span>][<span class="number">2</span>] = <span class="string">&#x27;d&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(n &amp; <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">5</span>; j++) st[n5 + i + <span class="number">1</span>][n5 + j + <span class="number">1</span>] = ans[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) cout &lt;&lt; st[i] + <span class="number">1</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></details>
<h1 id="D-Problem-Scores"><a href="#D-Problem-Scores" class="headerlink" title="D. Problem Scores"></a>D. Problem Scores</h1><p>题目链接：<a href="https://atcoder.jp/contests/agc041/tasks/agc041_d">https://atcoder.jp/contests/agc041/tasks/agc041_d</a></p>
<p>题目大意：问有多少个数组满足非递降且任意 $k+1$ 个数字之和 $&gt;$ $k$ 个数字之和。</p>
<details class="toggle" ><summary class="toggle-button" style="">我的做法</summary><div class="toggle-content"><p>很有感觉的一道题目，每个地方设置的刚刚好。</p>
<p>首先注意到一个事情，这个条件可以的等价的写成：$k=\left \lceil \frac{n-1}{2} \right \rceil$ ，前 $k+1$ 个数字之和要 $&gt;$ 后 $k$ 个数字之和。</p>
<p>不妨以第 $k+1$ 个数字为中心，这么写：前第 $k$ 个数字和后第 $k$ 个数字的差值 + 前第 $k-1$ 个数字和后第 $k-1$ 个数字的差值 … + 第 $k+1$ 个数字。</p>
<p>可以把整个过程想象成在 $k+1$ 这个位置左边放一个数字，右边放一个数字。</p>
<p>但是这样子想，怎么设 $dp$ 都会带上一个十分讨厌的 $\log$ ，这个 $\log$ ，于是想到一个经典问题，摆阶梯。</p>
<p>如果竖着 $dp$ ，就避不开这个 $\log$ ，但是如果横着 $dp$ ，就可以避免这个 $\log$ 。</p>
<p><img src="4.png" alt=""></p>
<p>再联系到这道题目就可以得到最终的做法：</p>
<p>dp[i][r] 表示放置了 $i$ 个数字后最右边的数字处在 $r$ 而且这 $i$ 的数字的权值和为 $0$ 。</p>
<p>然后每次会在中心的数字上面放一个左边的数字和右边的数字，然后可以把左边的数字往左边推一格，右边同理，同时，在推完后把中心位置调到使权值和恰好为 $0$ 的位置。</p>
<p>可以发现，对于任意一个个数 $\ge 3$ 的方案，只要权值和为 $0$ ，就一定不会有数字 $\le 0$ 。</p>
<p>所以不用容斥就可以计算出最终答案。</p>
<p>时间复杂度：$O(n^2)$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">5e3</span> + <span class="number">5</span>;</span><br><span class="line">LL dp[N], mod;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">trans</span><span class="params">(<span class="type">int</span> cnt)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i + cnt &lt;= n; i++) dp[i + cnt] = (dp[i + cnt] + dp[i]) % mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; mod;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>)&#123;</span><br><span class="line">        cout &lt;&lt; <span class="number">1</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(n == <span class="number">2</span>)&#123;</span><br><span class="line">        cout &lt;&lt; <span class="number">3</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    dp[<span class="number">1</span>] = <span class="number">1ll</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> t = <span class="number">1</span>; t &lt;= (n - <span class="number">1</span>) / <span class="number">2</span>; t++)&#123;</span><br><span class="line">        <span class="built_in">trans</span>(t);</span><br><span class="line">        <span class="built_in">trans</span>(t + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n &amp; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">trans</span>(n / <span class="number">2</span>);</span><br><span class="line">    LL ans = <span class="number">0ll</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) ans = (dp[i] * (n - i + <span class="number">1</span>) + ans) % mod;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></details>
<h1 id="E-Balancing-Network"><a href="#E-Balancing-Network" class="headerlink" title="E. Balancing Network"></a>E. Balancing Network</h1><p>题目链接：<a href="https://atcoder.jp/contests/agc041/tasks/agc041_e">https://atcoder.jp/contests/agc041/tasks/agc041_e</a></p>
<p>题目大意：给你 $n$ 条横着的电线，然后从左到右有若干条通道，每条通道连接两根电线，然后你需要给每条通道指定向上或者向下的方向，使其满足：</p>
<p>当 $T=1$ 时，要求任何一根电线左端出发最终能到达一根电线上。</p>
<p>当 $T=2$ 时，要求不会都到一根电线上。</p>
<p>如果不存在输出无解。</p>
<details class="toggle" ><summary class="toggle-button" style="">我的做法</summary><div class="toggle-content"><p>分类讨论真的是。</p>
<p><details class="toggle" ><summary class="toggle-button" style="">$T = 1$</summary><div class="toggle-content"><p>当你想着这个问题足够久或者手动的模拟过一会后，你会感到一种熟悉的感觉从脑袋中流淌。</p></p>
<p>没错，它就是可达性统计。</p>
<p>这个部分分神似可达性统计。</p>
<p>所以你可能会想，我能不能设 $dp[x]$ 表示前 $i$ 条边能到达 $x$ 的集合，然后当存在边 $(x,y)$ 时。</p>
<p>就更新：$dp[x]=dp[y]=dp[x]|dp[y]$ ？</p>
<p>这为什么是对的？</p>
<p><details class="toggle" ><summary class="toggle-button" style="">证明</summary><div class="toggle-content"><p>归纳证明，我们先认为 $\exists$ 一种局面使得前 $i$ 条边过后 $dp[x]$ 中的电线都能到达 $x$ 这条电线，其中设 $E_x$ 表示与 $dp[x]$ 有关的边，即从 $dp[x]$ 回溯回去，任何和产生 $dp[x]$ 有关的边。</p></p>
<p>而 $dp[x],E_x$ 显然可以通过从 $x$ 的当前位置倒着 BFS 回去得到。</p>
<p>从而可以得到这么一个结论：无论任何局面，$dp[x]$ 外的点都不会经过 $E_x$ 中的边，也不会到达 $x$ 。</p>
<p>而在 $E_x$ 固定正确的方向后， $E_x$ 外的边满足更改方向不会影响 $dp[x]$ 中的点到达 $x$ ，换句话说，$E_x$ 外的边不会影响最终到达电线 $x$ 的集合，且该集合就等于 $dp[x]$ 。</p>
<p>然后当出现边 $(x,y)$ 时，显然 $x,y$ 外的点不受影响，关键是 $x,y$ 。</p>
<p>不妨只证明新的 $dp[x]$ 仍然满足要求。</p>
<p>构造一种新的局面：$E_x$ 的边方向照旧，$E_y\setminus E_x$ 的边方向同样照旧，其余随意。</p>
<p>首先知道 $dp[x]$ 一定能到达 $x$ ，然后是 $dp[y]\setminus dp[x]$ ，对于 $z\in dp[y]\setminus dp[x]$ ，$z$ 到 $y$ 的路径只会在 $E_y\setminus E_x$ 中，而不会有 $E_x$ ，否则 $z\in dp[x]$ ，所以 $z$ 能到达 $y$ ，然后走到 $x$ 。对于 $dp[x],dp[y]$ 之外的点，根据上面的性质，在去掉 $(x,y)$ 时，其永远到不了 $x,y$ ，加上显然也到不了，因此这种局面下到达 $x$ 的集合就是 $dp[x]\cup dp[y]$ 。</p>
<p>证毕。</p>
<p>那么为什么是最优解呢？</p>
<p>可以注意到 $dp[x]$ 可以由 $x$ 倒着 BFS 得到，因此如果 $y$ 存在一种局面可以到达 $x$ ，根据路径可逆，$x$ 一定能倒着 BFS 到 $y$ ，因此所有局面中到达 $x$ 的集合一定是 $dp[x]$ 的子集。</p>
<p>从而得到 $dp[x]$ 就是最优集合，证毕。</p>
<p>综上，该 $dp$ 正确，证毕。</p>
</div></details>
<p>然后在跑完 $dp$ 后得到谁可以是那个汇聚万物的电线，最后直接倒着 $BFS$ 回去还原一下方案就行了，时间复杂度：$O(\frac{nm}{w})$ 。</p></div></details>
<details class="toggle" ><summary class="toggle-button" style="">$T = 2$</summary><div class="toggle-content"><p>首先 $n\le 2$ 的时候一定无解。</p>
<p>当 $n&gt;2$ 时，我们考虑为什么 $n=2$ 时无解，是不是我们能够知道一开始 $(1,2)$ 是两个合法终点，但是如果存在一条边给他们两个连起来，就寄了。</p>
<p>但是如果我们能够存储两对不一样的合法终点呢？这样每次连至多终结其中一个，而另外一个手动模拟一下就知道，可以重新生成两对不一样的合法终点，然后就做完了。</p>
<p>时间复杂度：$O(n)$ 。</p>
</div></details>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">5e4</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n, m, T;</span><br><span class="line"><span class="keyword">namespace</span> Solve1&#123;</span><br><span class="line">    PII e[M];</span><br><span class="line">    bitset&lt;N&gt; f[N];</span><br><span class="line">    <span class="type">char</span> st[M];</span><br><span class="line">    <span class="type">bool</span> v[N];</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) f[i][i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">            <span class="keyword">auto</span>&amp; [x, y] = e[i];</span><br><span class="line">            cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">            f[x] |= f[y];</span><br><span class="line">            f[y] |= f[x];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(f[i].<span class="built_in">count</span>() == n)&#123;</span><br><span class="line">                ans = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!ans)&#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;-1\n&quot;</span>;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        v[ans] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = m; i &gt;= <span class="number">1</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">auto</span> [x, y] = e[i];</span><br><span class="line">            <span class="keyword">if</span>(!v[x] &amp;&amp; !v[y]) st[i] = <span class="string">&#x27;^&#x27;</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(!v[x] &amp;&amp; v[y])&#123;</span><br><span class="line">                st[i] = <span class="string">&#x27;v&#x27;</span>;</span><br><span class="line">                v[x] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(v[x] &amp;&amp; !v[y])&#123;</span><br><span class="line">                st[i] = <span class="string">&#x27;^&#x27;</span>;</span><br><span class="line">                v[y] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> st[i] = <span class="string">&#x27;v&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; st + <span class="number">1</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> Solve2&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">        <span class="type">int</span> x, y;</span><br><span class="line">        string type;</span><br><span class="line">    &#125;p1, p2;</span><br><span class="line">    string ans;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">pd</span><span class="params">(<span class="type">int</span> x, <span class="type">const</span> node &amp;y)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x == y.x) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(x == y.y) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getp</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">const</span> node &amp;z)</span></span>&#123;<span class="keyword">return</span> (<span class="type">int</span>) (<span class="built_in">pd</span>(x, z) &gt; <span class="number">0</span>) + (<span class="type">int</span>) (<span class="built_in">pd</span>(y, z) &gt; <span class="number">0</span>);&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">cl</span><span class="params">(node &amp;x)</span></span>&#123;</span><br><span class="line">        node y = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="string">&quot;&quot;</span>&#125;;</span><br><span class="line">        <span class="built_in">swap</span>(x, y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">2</span>)&#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;-1\n&quot;</span>;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        p1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="string">&quot;&quot;</span>&#125;;</span><br><span class="line">        p2 = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="string">&quot;&quot;</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">            <span class="type">int</span> x, y;</span><br><span class="line">            cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">            node now;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">getp</span>(x, y, p1) == <span class="number">1</span> || <span class="built_in">getp</span>(x, y, p2) == <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">getp</span>(x, y, p1) == <span class="number">1</span>)&#123;</span><br><span class="line">                    ans += p1.type;</span><br><span class="line">                    now = &#123;p1.x, p1.y, <span class="string">&quot;&quot;</span>&#125;;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    ans += p2.type;</span><br><span class="line">                    now = &#123;p2.x, p2.y, <span class="string">&quot;&quot;</span>&#125;;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">cl</span>(p1); <span class="built_in">cl</span>(p2);</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">pd</span>(x, now) == <span class="number">1</span>)&#123;</span><br><span class="line">                    p2 = &#123;x, now.y, <span class="string">&quot;^&quot;</span>&#125;;</span><br><span class="line">                    p1 = &#123;<span class="built_in">min</span>(now.y, y), <span class="built_in">max</span>(now.y, y), <span class="string">&quot;v&quot;</span>&#125;;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">pd</span>(x, now) == <span class="number">2</span>)&#123;</span><br><span class="line">                    p1 = &#123;now.x, now.y, <span class="string">&quot;^&quot;</span>&#125;;</span><br><span class="line">                    p2 = &#123;now.x, y, <span class="string">&quot;v&quot;</span>&#125;;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">pd</span>(y, now) == <span class="number">1</span>)&#123;</span><br><span class="line">                    p1 = &#123;x, now.y, <span class="string">&quot;^&quot;</span>&#125;;</span><br><span class="line">                    p2 = &#123;now.x, now.y, <span class="string">&quot;v&quot;</span>&#125;;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">pd</span>(y, now) == <span class="number">2</span>)&#123;</span><br><span class="line">                    p1 = &#123;<span class="built_in">min</span>(now.x, x), <span class="built_in">max</span>(now.x, x), <span class="string">&quot;^&quot;</span>&#125;;</span><br><span class="line">                    p2 = &#123;now.x, now.y, <span class="string">&quot;v&quot;</span>&#125;;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                p1.type += <span class="string">&quot;^&quot;</span>;</span><br><span class="line">                p2.type += <span class="string">&quot;^&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans += p1.type;</span><br><span class="line">        cout &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; T;</span><br><span class="line">    <span class="keyword">if</span>(T == <span class="number">1</span>) Solve1::<span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">else</span> Solve2::<span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>好屎的分类讨论，能在考场写出来的人真是神仙吧。</p>
<p>update ：$T=1$ 的证明写了这么久，其实我都忽略了一个最关键的东西：$dp[x]$ 就是由 $x$ 倒着 BFS 得到的终点集合，我只需要构造出一种局面使得 $dp[x]$ 能全部到达 $x$ ，再说明一下最优性，就可以直接把问题转换成求 $x$ 倒着 BFS 能到达的集合，这样就可以很轻松的证明这个做法的正确性了，根本不用搞得那么繁琐。</p>
<p>而构造一种局面使得 $dp[x]$ 能全部到达 $x$ 是简单的，倒着考虑就行了。</p></div></details>
<details class="toggle" ><summary class="toggle-button" style="">其他题解</summary><div class="toggle-content"><ol>
<li>$T=1$ 的做法和我的做法一样，但证明比我的证明更加简单，已经更新到我的做法最后的 update 部分。</li>
<li><p>同样做复杂了，我们设 $ed_x$ 表示第 $x$ 条线最后到哪条线，设 $cnt_i$ 表示 $ed_x=i$ 的 $x$ 的个数，倒着跑，注意到每次添加 $(x,y)$ 后，定向只会导致两个 $cnt$ 加减一，因此在 $n&gt;2$ 的情况下，一定存在一种定向，使得不存在 $i$ 满足 $cnt_i=n$ 。</p>
<p>这种做法相较于我的做法没有繁杂的讨论，非常的好写。</p>
</li>
</ol>
<p>这种讨论题难就难在想出好写的做法，反正我没想出来，投降 ┗( T﹏T )┛ 。</p>
</div></details>]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>构造</tag>
      </tags>
  </entry>
  <entry>
    <title>AGC036 赛后总结</title>
    <url>/2024/05/27/AGC036-%E8%B5%9B%E5%90%8E%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>比赛链接：<a href="https://atcoder.jp/contests/agc036/tasks">https://atcoder.jp/contests/agc036/tasks</a></p>
<h1 id="A-Triangle"><a href="#A-Triangle" class="headerlink" title="A. Triangle"></a>A. Triangle</h1><p>题目链接：<a href="https://atcoder.jp/contests/agc036/tasks/agc036_a">https://atcoder.jp/contests/agc036/tasks/agc036_a</a></p>
<p>题目大意：要求构造一个整点三角形满足面积是 $\frac{S}{2}$ 。</p>
<details class="toggle" ><summary class="toggle-button" style="">我的做法</summary><div class="toggle-content"><p>首先注意到有一边平行于坐标轴就肯定构造不出 $S$ 是素数解的情况。</p>
<p>因此考虑这么一张图：</p>
<p><img src="1.png" alt=""></p>
<p>注意到上面的三角形在面积乘 $2$ 后相比正方形会删去浅蓝色区域，于是考虑以此为基础给一组构造。</p>
<p>于是就得到下面这么一个构造：</p>
<p>给一个 $h$ ，得到宽度：$w=\left \lceil \frac{S}{h} \right \rceil$ 。</p>
<p>设 $\epsilon = hw-S$ 。</p>
<p>那么其中一个点在 $(0,\epsilon)$ ，一个点在 $(w-1,h)$ ，一个点在 $(w,0)$ 。</p>
<p>由于长宽还有范围要求，所以建议直接把 $h$ 拉到能拉到的最大，但是在比赛时我的选择是 $\left\lceil\sqrt{n}\right\rceil$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(LL x, LL y)</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; y &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    LL n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    LL l = <span class="number">1</span>, r = <span class="number">1e9</span>, mid, ans;</span><br><span class="line">    <span class="keyword">while</span>(l &lt;= r)&#123;</span><br><span class="line">        mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(mid * mid &gt;= n)&#123;</span><br><span class="line">            ans = mid;</span><br><span class="line">            r = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    LL wide = (n + ans - <span class="number">1</span>) / ans;</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">0ll</span>, ans * wide - n);</span><br><span class="line">    <span class="built_in">print</span>(wide - <span class="number">1</span>, ans);</span><br><span class="line">    <span class="built_in">print</span>(wide, <span class="number">0</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还是麻烦了，可以不用写这个二分的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(LL x, LL y)</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; y &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    LL n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    LL ans = <span class="built_in">min</span>((LL)<span class="number">1e9</span>, n);</span><br><span class="line">    LL wide = (n + ans - <span class="number">1</span>) / ans;</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">0ll</span>, ans * wide - n);</span><br><span class="line">    <span class="built_in">print</span>(wide - <span class="number">1</span>, ans);</span><br><span class="line">    <span class="built_in">print</span>(wide, <span class="number">0</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></details>
<details class="toggle" ><summary class="toggle-button" style="">其余做法</summary><div class="toggle-content"><p>每日一个求三角形面积小技巧。</p>
<p>对于三点 $(x_1,y_1),(x_2,y_2),(x_3,y_3)$ ，其的面积就是 $|\frac12\begin{vmatrix}x_1&amp;y_1&amp;1\\x_2&amp;y_2&amp;1\\x_3&amp;y_3&amp;1\end{vmatrix}|$ 。</p>
<p>原理就是添加一个高度 $1$ ，然后在三维用行列式算其体积。</p>
<p>当然，如果 $x_1=y_1=0$ ，可以直接在二维中利用叉积计算面积，就是：$\frac{1}{2}|x_2y_3-x_3y_2|$ 。</p>
<p>因此，在本题中，我们不妨假设 $x_2=10^9,y_2=1$ 。</p>
<p>这样就可以得到 ：$y_3=\left\lceil\frac{S}{10^9}\right\rceil$ ，然后 $y_2=x_2y_3-S$ 。</p>
<p>显然不需要担心共线问题，因此共线的话上面算出来会是 $0$ ，不是 $0$ 就说明 $(x_2,y_2),(x_3,y_3)$。 不是共线的。</p>
</div></details>
<h1 id="B-Do-Not-Duplicate"><a href="#B-Do-Not-Duplicate" class="headerlink" title="B. Do Not Duplicate"></a>B. Do Not Duplicate</h1><p>题目链接：<a href="https://atcoder.jp/contests/agc036/tasks/agc036_b">https://atcoder.jp/contests/agc036/tasks/agc036_b</a></p>
<p>题目大意：给你一个长度为 $n$ 的数组和一个空栈，然后你可以对栈执行一个操作：</p>
<p>如果 $x$ 在栈，弹出到 $x$ 不在栈中，否则加入栈。</p>
<p>依次对数组从左到右每个元素执行此操作，重复这个过程 $K$ 次，问最后栈是啥。</p>
<details class="toggle" ><summary class="toggle-button" style="">我的做法</summary><div class="toggle-content"><p>注意到一个事情，一个栈会从非空到空当且仅当栈底元素进行了操作。</p>
<p>因此当栈为空加入 $x$ 时，下一次栈为空就是 $x$ 下一次入栈的时候，因此可以在数组上维护每个位置下一个出现相同数字的位置，实现出现空栈的位置的快速转移，而这个过程对于数组中每个位置，下一次出现空栈的位置是固定的。</p>
<p>所以会有循环，直接快速计算就行了。</p>
<p>等到最后不会出现空栈时，肯定只会剩下不超过 $n$ 个元素，直接模拟就行了。</p>
<p>时间复杂度：$O(n)$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> nex[N], n, las[N], m = <span class="number">2e5</span>;</span><br><span class="line"><span class="type">int</span> a[N * <span class="number">2</span>];</span><br><span class="line">LL pre[N], K;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getpos</span><span class="params">(LL x)</span></span>&#123;<span class="keyword">return</span> (x - <span class="number">1</span>) % n + <span class="number">1</span>;&#125;</span><br><span class="line"><span class="type">int</span> sta[N], top;</span><br><span class="line"><span class="type">bool</span> v[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = x; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!v[a[i]])&#123;</span><br><span class="line">            v[a[i]] = <span class="number">1</span>;</span><br><span class="line">            sta[++top] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(a[sta[top]] != a[i]) v[a[sta[top--]]] = <span class="number">0</span>;</span><br><span class="line">            v[a[sta[top--]]] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= top; i++) cout &lt;&lt; a[sta[i]] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; K;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">        a[i + n] = a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n + n; i++)&#123;</span><br><span class="line">        <span class="type">int</span> x = a[i];</span><br><span class="line">        <span class="keyword">if</span>(las[x] &amp;&amp; las[x] &lt;= n) nex[las[x]] = i - las[x] + <span class="number">1</span>;</span><br><span class="line">        las[x] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">fill</span>(pre + <span class="number">1</span>, pre + n + <span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">    <span class="type">int</span> pos;</span><br><span class="line">    LL limit = (K - <span class="number">1</span>) * n + <span class="number">1</span>, now = <span class="number">1ll</span>;</span><br><span class="line">    <span class="keyword">while</span>(now &lt; limit &amp;&amp; pre[pos = <span class="built_in">getpos</span>(now)] == <span class="number">-1</span>)&#123;</span><br><span class="line">        pre[pos] = now;</span><br><span class="line">        now += nex[pos];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(now &lt; limit)&#123; <span class="comment">//circle</span></span><br><span class="line">        LL T = now - pre[pos];</span><br><span class="line">        now += (limit - now) / T * T;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(now &lt; limit)&#123;</span><br><span class="line">        pos = <span class="built_in">getpos</span>(now);</span><br><span class="line">        now += nex[pos];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">solve</span>(<span class="built_in">getpos</span>(now));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>update：注意到这个有向图不只是每个点出度为 $1$ ，入度也为 $1$ ，因此每个点都在一个环上，所以代码可以更短更好写。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> nex[N], n, las[N], m = <span class="number">2e5</span>;</span><br><span class="line"><span class="type">int</span> a[N * <span class="number">2</span>];</span><br><span class="line">LL K;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getpos</span><span class="params">(LL x)</span></span>&#123;<span class="keyword">return</span> (x - <span class="number">1</span>) % n + <span class="number">1</span>;&#125;</span><br><span class="line"><span class="type">int</span> sta[N], top;</span><br><span class="line"><span class="type">bool</span> v[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = x; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!v[a[i]])&#123;</span><br><span class="line">            v[a[i]] = <span class="number">1</span>;</span><br><span class="line">            sta[++top] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(a[sta[top]] != a[i]) v[a[sta[top--]]] = <span class="number">0</span>;</span><br><span class="line">            v[a[sta[top--]]] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= top; i++) cout &lt;&lt; a[sta[i]] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; K;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">        a[i + n] = a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n + n; i++)&#123;</span><br><span class="line">        <span class="type">int</span> x = a[i];</span><br><span class="line">        <span class="keyword">if</span>(las[x] &amp;&amp; las[x] &lt;= n) nex[las[x]] = i - las[x] + <span class="number">1</span>;</span><br><span class="line">        las[x] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    LL ti = <span class="number">1ll</span>;</span><br><span class="line">    <span class="type">int</span> pos = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        ti += nex[pos];</span><br><span class="line">    &#125; <span class="keyword">while</span>((pos = <span class="built_in">getpos</span>(ti)) != <span class="number">1</span>);</span><br><span class="line">    K %= (ti - <span class="number">1</span>) / n;</span><br><span class="line">    <span class="keyword">if</span>(!K) K += (ti - <span class="number">1</span>) / n;</span><br><span class="line">    ti = <span class="number">1ll</span>;</span><br><span class="line">    <span class="keyword">while</span>(K * n - ti &gt;= n)&#123;</span><br><span class="line">        pos = <span class="built_in">getpos</span>(ti);</span><br><span class="line">        ti += nex[pos];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">solve</span>(<span class="built_in">getpos</span>(ti));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></details>
<h1 id="C-GP-2"><a href="#C-GP-2" class="headerlink" title="C. GP 2"></a>C. GP 2</h1><p>题目链接：<a href="https://atcoder.jp/contests/agc036/tasks/agc036_c">https://atcoder.jp/contests/agc036/tasks/agc036_c</a></p>
<p>题目大意：每次你可以选择两个数字进行操作，一个 $+1$ ，一个 $+2$ ，问进行 $M$ 次后有多少种不同的结果。</p>
<details class="toggle" ><summary class="toggle-button" style="">我的做法</summary><div class="toggle-content"><p>很有感觉的一道题目，难在既要找条件又要计数。</p>
<p>首先注意到一个事情：最大值必须 $\le 2M$ ，但是这显然不是充要的，注意到如果有超过 $M$ 个 $1$ ，那么肯定不是可行解。</p>
<p>由此又注意到只会有和 $M$ 奇偶性相同且 $\le M$ 个数字是奇数（事实上在和为 $3M$ 时这句话可以直接换成：$\le M$ 个数字是奇数）</p>
<p>那么这是充要的吗？是的，用归纳法证明一下就行了。</p>
<p>接下来就是计数，注意到我们可以枚举奇数的个数，然后把剩下的数字两个两个分，但是这样最大值可能爆 $2M$ ，但是注意到如果最大值 $&gt;2M$ ，那么奇数个数一定 $\le M$ ，所以所有最大值 $&gt;2M$ 的分配都会被恰好记一次，直接删去即可。</p>
<p>所以答案就是：$\sum\limits_{i=0}^{min(n,M)}\binom{n}{i}\binom{\frac{3M-i}{2}+n-1}{n-1}-\sum\limits_{i=2M+1}^{3M}\binom{n}{1}\binom{3M-i+n-2}{n-2}$ 。</p>
<p>时间复杂度：$O(n)$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e6</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> LL mod = <span class="number">998244353</span>;</span><br><span class="line">LL fc[N], nfc[N];</span><br><span class="line"><span class="function">LL <span class="title">C</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>&#123;<span class="keyword">return</span> fc[x] * nfc[y] % mod * nfc[x - y] % mod;&#125;</span><br><span class="line"><span class="function">LL <span class="title">xuan</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!y) <span class="keyword">return</span> <span class="number">0ll</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">C</span>(x + y - <span class="number">1</span>, y - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> lim)</span></span>&#123;</span><br><span class="line">    fc[<span class="number">0</span>] = fc[<span class="number">1</span>] = nfc[<span class="number">0</span>] = nfc[<span class="number">1</span>] = <span class="number">1ll</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= lim; i++) nfc[i] = (mod - mod / i) * nfc[mod % i] % mod;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= lim; i++) nfc[i] = nfc[i - <span class="number">1</span>] * nfc[i] % mod, fc[i] = fc[i - <span class="number">1</span>] * i % mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="built_in">init</span>(n + m + m);</span><br><span class="line">    LL ans = <span class="number">0ll</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= m &amp;&amp; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>((i &amp; <span class="number">1</span>) != (m &amp; <span class="number">1</span>)) <span class="keyword">continue</span>;</span><br><span class="line">        ans += <span class="built_in">xuan</span>((m * <span class="number">3</span> - i) / <span class="number">2</span>, n) * <span class="built_in">C</span>(n, i);</span><br><span class="line">        ans %= mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">        ans = (ans - n * <span class="built_in">xuan</span>(i, n - <span class="number">1</span>));</span><br><span class="line">        ans = (ans % mod + mod) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>update：最后容斥那个部分，还有一个组合意义，就是如果我直接把最大值减去 $2m+1$ ，那么就变成 $m-1$ 个数字分配，因此又可以写成：$n\binom{M+n-2}{n-1}$ 。</p>
<p>再看前面容斥的那个式子，可以写成：$n\sum\limits_{i=0}^{M-1}\binom{i+n-2}{n-2}$ ，在杨辉三角形上，其对应的一条斜线，所以可以写成：$n\binom{M+n-2}{n-1}$ 。</p>
<p>注意到上面的等式为：$\frac{1}{(n-2)!}\sum\limits_{i=0}^{M-1}\frac{(i+n-2)!}{i!}=\binom{M+n-2}{n-1}$ 。</p>
<p>这启示我们连续 $n$ 个数字相乘的和可以用组合数进行快速计算。</p>
</div></details>
<h1 id="D-Negative-Cycle"><a href="#D-Negative-Cycle" class="headerlink" title="D. Negative Cycle"></a>D. Negative Cycle</h1><p>题目链接：<a href="https://atcoder.jp/contests/agc036/tasks/agc036_d">https://atcoder.jp/contests/agc036/tasks/agc036_d</a></p>
<p>题目大意：现在有 $n-1$ 条不能删的边 ：$(i,i+1,0)$ ，同时又有 $n(n-1)$ 条边，对于 $i\to j$ ，如果 $i&lt;j$ ，边权就是 $-1$ ，反之为 $1$ ，问需要花多少代价删边后图中没有负环。</p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>非常有意思的一道题目，需要注意到负环和最短路之间密切的关系。</p>
<p>我们令 $d$ 数组为从 $1$ 开始跑最短路得到的数组，由于不能删的边的存在，$d$ 是非升的，显然，任何一个不存在负环的图都对应这么一个 $d$ ，我们希望在知道 $d$ 的情况下保留尽可能多的边。</p>
<p>注意到只能保留非同段的 $-1$ 和同段或者相邻段的 $1$ 。</p>
<p>因此直接设 $dp[i][j]$ 表示最后一段为 $[j+1][i]$ 的最小代价就行了。</p>
<p>时间复杂度：$O(n^3)$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> LL mod = <span class="number">998244353</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">5e2</span> + <span class="number">5</span>;</span><br><span class="line">LL dp[N][N], a[N][N], f[N];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="function">LL <span class="title">findans</span><span class="params">(<span class="type">int</span> l1, <span class="type">int</span> r1, <span class="type">int</span> l2, <span class="type">int</span> r2)</span></span>&#123;<span class="keyword">return</span> a[r1][r2] - a[l1 - <span class="number">1</span>][r2] - a[r1][l2 - <span class="number">1</span>] + a[l1 - <span class="number">1</span>][l2 - <span class="number">1</span>];&#125;</span><br><span class="line"><span class="function">LL <span class="title">queryf</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span>&#123;<span class="keyword">return</span> f[r] - f[l - <span class="number">1</span>];&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i == j) <span class="keyword">continue</span>;</span><br><span class="line">            cin &gt;&gt; a[i][j];</span><br><span class="line">            <span class="keyword">if</span>(i &lt; j) f[j] += a[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) f[i] += f[i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) a[i][j] += a[i - <span class="number">1</span>][j] + a[i][j - <span class="number">1</span>] - a[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">30</span>, <span class="built_in">sizeof</span>(dp));</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0ll</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= i; j++)&#123;<span class="comment">//j + 1 ~ i</span></span><br><span class="line">            <span class="comment">// if(i &amp;&amp; i == j) continue;</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k = i + <span class="number">1</span>; k &lt;= n; k++)&#123;</span><br><span class="line">                dp[k][i] = <span class="built_in">min</span>(dp[k][i], </span><br><span class="line">                        dp[i][j] + (<span class="built_in">queryf</span>(i + <span class="number">1</span>, k) - <span class="built_in">findans</span>(<span class="number">1</span>, i, i + <span class="number">1</span>, k)) + <span class="built_in">findans</span>(i + <span class="number">1</span>, k, <span class="number">1</span>, j));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    LL ans = dp[n + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) ans = <span class="built_in">min</span>(ans, dp[n][i]);</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></details>
<h1 id="E-ABC-String"><a href="#E-ABC-String" class="headerlink" title="E. ABC String"></a>E. ABC String</h1><p>题目链接：<a href="https://atcoder.jp/contests/agc036/tasks/agc036_e">https://atcoder.jp/contests/agc036/tasks/agc036_e</a></p>
<p>题目大意：给你一个只有 $A,B,C$ 的字符串，要求找到最长的一个子序列，满足相邻字符不同，而且每个字符出现次数相同。</p>
<details class="toggle" ><summary class="toggle-button" style="">我的做法</summary><div class="toggle-content"><p>又是屎中屎讨论，吐了。</p>
<p>注意到可以先把原串变成相邻字符不同，毕竟相邻的相同字符无论如果只会出现一次，因此这样子变换不会影响最终答案。</p>
<p>换一下字符，满足 $A\ge B\ge C$ （出现次数）。</p>
<p>然后注意到在不管 $A$ 的情况下，剩下的 $BC$ 可以分成若干段 $BCBCB…$ ，相邻段满足首位字母相同，例如：$BCB,BC,CB$ 。</p>
<p>注意到每一段中间的 $A$ 都可以删完，所以 $A$ 个数此时的下界为段数 $-1$ ，而且显然当前 $A$ 的个数和下界中间任何一个数字都能取到。</p>
<p>我们考虑先让 $B=C$ ，为了降低 $A$ 的下界（后面会看到，$A$ 的下界比较高的话，可能会在后面产生浪费），我们希望能最小化段数，因此明智的删法就是删每一段开头结尾的 $C$ ，然后缝合两段，由于 $C&gt;B$ ，总是存在这样的 $C$ 直到只剩下一段，这个时候就只能删开头了。</p>
<p>注意到这个过程中，每次删一个 $C$ ，也可能会删一个 $A$ ，但不会影响 $A\ge B\ge C$ 的偏序关系。</p>
<p>在 $B=C$ 后，如果下界 $\le C$ ，那么我们就可以得到一个取到上界的解，就是 $3C$ ，但是如果不是，注意到此时一定会有孤立的 $B,C$ ，删一个 $B,C$ （其实只要删 $B,C$ 的时候能让段数减少就行，但是直接删孤立的 $B,C$ 是最方便的），直到下界等于 $C$ 即可。</p>
<p>但是这为什么是对的呢？ $ans=3C$ 的情况可以理解，但是 $ans&lt;3C$ 的呢？注意到另外一个限制条件：段数，显然最终答案的段数 $-1$ 必须 $\le C$ ，而删一个 $B$ 或 $C$ 只能使段数 $-1$ ，由此可以证明这种情况已经取得了最优解。</p>
<p>理论上这就做完了，但是确实不好写。</p>
<p>我的实现思路是：</p>
<p>如果我们一直在字符串上操作，那不太好操作，因此我希望直接在段信息上操作，忽略所有的 $A$ ，然后在最后再通过匹配等方式补上一个合法的填 $A$ 的方案。</p>
<p>同时注意到上面那个做法删除的 $B,C$ 位置都是非常有讲究的。</p>
<p>不妨给去掉 $A$ 后的字符串每个 $B,C$ 贴上个原来的位置标签，然后在每次要删除 $B$ 或者 $C$ 时，找到最后面的同字符，满足这两个位置间的字符都是相同的，将操作变成删除这个字符，例如：$BBBBC$ ，本来要删除第一个 $B$ ，现在变成删除第四个 $B$ 。</p>
<p>这样子操作后，我们对剩下的字符串在原串中做能匹就匹的匹配，则每个字符的匹配位置和其位置标签一致。</p>
<p>不妨设匹配完后的位置为 $x_1,x_2,x_3…$ ，那么 $(x_1,x_2)$ 区间内，肯定只由 $B$ 或者 $C$ 和 $A$ 构成，具体是 $B$ 还是 $C$ 取决于 $x_1$ 是啥，其余区间同理。</p>
<p>例如：<strong>B</strong>ABABABA<strong>C</strong> ，加粗表示匹配上的位置。</p>
<p>那么在 $ans=3C$ 的时候，每个区间里面只有 $C$ ，因此我们删除 $C$ 后导致 $A$ 碰撞而必须删除的 $A$ 的数量 $\le C$ ，因此在 $x1,x2,…$ 之间可以塞的 $A$ 的数量 $\ge C$ 。</p>
<p>同理，如果 $ans&lt;3C$ ，那么下界也就是 $A$ 的数量和 $C$ 相等，此时不需要多塞，直接将 $A$ 塞入原来的 $BC$ 串直接做匹配就可以得到结果。</p>
<p>因此这样就得到了一种相对好写的复原方案的方法。</p>
<p>时间复杂度：$O(n)$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span> + <span class="number">5</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_char_array</span><span class="params">(<span class="type">char</span> *s)</span></span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">char</span> ss[N];</span><br><span class="line">    cin &gt;&gt; ss;</span><br><span class="line">    <span class="built_in">memcpy</span>(s + <span class="number">1</span>, ss, <span class="built_in">sizeof</span>(<span class="type">char</span>) * <span class="built_in">strlen</span>(ss));</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">char</span> st[N];</span><br><span class="line"><span class="type">int</span> n, a[N], cnt[<span class="number">4</span>], id[<span class="number">4</span>], be[<span class="number">4</span>];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;<span class="type">int</span> lt, rt, len;&#125; sta[N]; <span class="type">int</span> top;</span><br><span class="line">string ans, zans;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// assert(false);</span></span><br><span class="line">    <span class="built_in">get_char_array</span>(st);</span><br><span class="line">    n = <span class="built_in">strlen</span>(st + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">2</span>; i++) id[i] = i;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> pre = <span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="type">int</span> now = st[i] - <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span>(now != pre) a[++tmp] = now, cnt[now]++;</span><br><span class="line">            pre = now;</span><br><span class="line">        &#125;</span><br><span class="line">        n = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(id, id + <span class="number">3</span>, [](<span class="type">int</span> x, <span class="type">int</span> y)&#123;<span class="keyword">return</span> cnt[x] &gt; cnt[y];&#125;);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">2</span>; i++) be[id[i]] = i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) a[i] = be[a[i]];</span><br><span class="line">    <span class="built_in">sort</span>(cnt, cnt + <span class="number">3</span>, [](<span class="type">int</span> x, <span class="type">int</span> y)&#123;<span class="keyword">return</span> x &gt; y;&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> l = <span class="number">1</span>; l &lt;= n; l++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(l &lt;= n &amp;&amp; !a[l]) l++;</span><br><span class="line">        <span class="keyword">if</span>(l &gt; n) <span class="keyword">break</span>;</span><br><span class="line">        <span class="type">int</span> cnt0 = <span class="number">0</span>, now = a[l], r = l;</span><br><span class="line">        <span class="keyword">while</span>(r &lt; n &amp;&amp; a[r + <span class="number">1</span>] != now)&#123;</span><br><span class="line">            r++;</span><br><span class="line">            <span class="keyword">if</span>(a[r]) now = a[r];</span><br><span class="line">            <span class="keyword">else</span> cnt0++;</span><br><span class="line">        &#125;</span><br><span class="line">        sta[++top] = &#123;a[l], now, r - l + <span class="number">1</span> - cnt0&#125;;</span><br><span class="line">        l = r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= top; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!tmp || cnt[<span class="number">1</span>] == cnt[<span class="number">2</span>] || sta[i].lt == <span class="number">2</span>) sta[++tmp] = sta[i];</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                sta[tmp].rt = sta[i].rt;</span><br><span class="line">                sta[tmp].len += sta[i].len - <span class="number">1</span>;</span><br><span class="line">                cnt[<span class="number">1</span>]--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cnt[<span class="number">1</span>] == cnt[<span class="number">2</span>] + <span class="number">1</span> &amp;&amp; sta[<span class="number">1</span>].lt == <span class="number">1</span>)&#123;</span><br><span class="line">            cnt[<span class="number">1</span>]--;</span><br><span class="line">            sta[<span class="number">1</span>].lt = <span class="number">2</span>;</span><br><span class="line">            sta[<span class="number">1</span>].len--;</span><br><span class="line">            <span class="keyword">if</span>(!sta[<span class="number">1</span>].len)&#123;</span><br><span class="line">                <span class="built_in">assert</span>(tmp == <span class="number">1</span>);</span><br><span class="line">                tmp--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">assert</span>(cnt[<span class="number">1</span>] == cnt[<span class="number">2</span>]);</span><br><span class="line">        top = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!top)&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(top - <span class="number">1</span> &gt; cnt[<span class="number">1</span>])&#123;</span><br><span class="line">        <span class="type">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> goal = cnt[<span class="number">1</span>] - ((top - <span class="number">1</span>) - cnt[<span class="number">1</span>]);</span><br><span class="line">        <span class="built_in">assert</span>(goal &gt;= <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= top; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(sta[i].len == <span class="number">1</span> &amp;&amp; cnt[sta[i].lt] &gt; goal) cnt[sta[i].lt]--;</span><br><span class="line">            <span class="keyword">else</span> sta[++tmp] = sta[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">assert</span>(cnt[<span class="number">1</span>] == goal &amp;&amp; cnt[<span class="number">2</span>] == goal &amp;&amp; cnt[<span class="number">1</span>] == tmp - <span class="number">1</span>);</span><br><span class="line">        top = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= top; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>, now = sta[i].lt; j &lt;= sta[i].len; j++, now = <span class="number">3</span> - now) ans += now + <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span>(i != top) ans += <span class="string">&quot;A&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cnt[<span class="number">0</span>] = cnt[<span class="number">1</span>] - (top - <span class="number">1</span>);</span><br><span class="line">    <span class="type">int</span> now = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(now &lt; ans.<span class="built_in">length</span>() &amp;&amp; a[i] == ans[now] - <span class="string">&#x27;A&#x27;</span>)&#123;</span><br><span class="line">            zans += ans[now++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(!a[i] &amp;&amp; cnt[<span class="number">0</span>] &amp;&amp; (zans.<span class="built_in">empty</span>() || zans.<span class="built_in">back</span>() != <span class="string">&#x27;A&#x27;</span>) &amp;&amp; (now == ans.<span class="built_in">length</span>() || ans[now] != <span class="string">&#x27;A&#x27;</span>))&#123;</span><br><span class="line">            zans += <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">            cnt[<span class="number">0</span>]--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">assert</span>(!cnt[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">memset</span>(cnt, <span class="number">0</span>, <span class="built_in">sizeof</span>(cnt));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;c : zans) c = id[c - <span class="string">&#x27;A&#x27;</span>] + <span class="string">&#x27;A&#x27;</span>, cnt[c - <span class="string">&#x27;A&#x27;</span>]++;</span><br><span class="line">    <span class="built_in">assert</span>(cnt[<span class="number">0</span>] == cnt[<span class="number">1</span>] &amp;&amp; cnt[<span class="number">1</span>] == cnt[<span class="number">2</span>]);</span><br><span class="line">    cout &lt;&lt; zans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是即使相对好写，还是很难写，考场上我是肯定写不出来的。</p>
</div></details>
<details class="toggle" ><summary class="toggle-button" style="">正解</summary><div class="toggle-content"><p>上面的做法虽然说比较自然，但是正确性和实现都不好想。</p>
<p>不妨换个角度看待问题。</p>
<p>第一部分使 $C=B$ ，等价于如果有 $CAC$ 就删除到只剩下 $C$ 。</p>
<p>如果没有 $CAC$ ，但是 $B&gt;C$ ，那么就说明原串变成：$CBCBCB….C$ ，把开头或者结尾的 $C$ 删了就行。</p>
<p>然后对于第二部分，显然我们可以提前计算出我们需要删多少的 $B,C$ ，然后进行等量的 $BAB\to B,CAC\to C$ 的操作。</p>
<p>然后就是删 $A$ ，开头的 $A$ ，结尾的 $A$ ，以及 $BAC,CAB$ 中的 $A$ 删一下，删到 $A=C$ 为止，这样再看这个过程，是不是就清晰很多了呢？</p>
<p>虽然看起来还是很大便，但是实现上的细节少了很多，而且正确性更加容易理解了。</p>
<p>要是我在考场写这个做法，写出来的概率要比我原来的做法高得多。</p>
</div></details>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
  </entry>
  <entry>
    <title>AGC045 赛后总结</title>
    <url>/2024/07/12/AGC045-%E8%B5%9B%E5%90%8E%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>打得一坨屎。</p>
<p>比赛链接：<a href="https://atcoder.jp/contests/agc045">https://atcoder.jp/contests/agc045</a></p>
<h1 id="A-Xor-Battle"><a href="#A-Xor-Battle" class="headerlink" title="A. Xor Battle"></a>A. Xor Battle</h1><p>题目链接：<a href="https://atcoder.jp/contests/agc045/tasks/agc045_a">https://atcoder.jp/contests/agc045/tasks/agc045_a</a></p>
<p>题目大意：第 $i$ 轮第 $S_{i}$ 个人行动 ：将 $x$ 异或 $A_{i}$ 或者不操作，$x$ 初始为 $0$ ，如果最后 $x=0$ 则 $0$ 赢，否则 $1$ 赢，问最后谁必赢。</p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>显然，先手必胜的条件是从后往前，每个 $1$ 的 $A_{i}$ 可以被其后面 $0$ 的 $A_{i}$ 表示。</p>
<p>写个线性基就行了。</p>
<p>时间复杂度：$O(n\log{V})$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e2</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> L = <span class="number">60</span>;</span><br><span class="line">LL mi[L + <span class="number">5</span>];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">add</span><span class="params">(LL x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = L - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">        <span class="keyword">if</span>((x &gt;&gt; i) &amp; <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!mi[i])&#123;</span><br><span class="line">                mi[i] = x;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> x ^= mi[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">LL a[N];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">pd</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(mi, <span class="number">0</span>, <span class="built_in">sizeof</span>(mi));</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) cin &gt;&gt; a[i];</span><br><span class="line">    string st;</span><br><span class="line">    cin &gt;&gt; st;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = n; i &gt;= <span class="number">1</span>; i--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(st[i - <span class="number">1</span>] == <span class="string">&#x27;0&#x27;</span>) <span class="built_in">add</span>(a[i]);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">add</span>(a[i])) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        cout &lt;&lt; <span class="built_in">pd</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>没开 long long WA 了一发，真唐氏儿吧。</p>
<p>和题解一致。</p>
</div></details>
<h1 id="B-01-Unbalanced"><a href="#B-01-Unbalanced" class="headerlink" title="B. 01 Unbalanced"></a>B. 01 Unbalanced</h1><p>题目链接：<a href="https://atcoder.jp/contests/agc045/tasks/agc045_b">https://atcoder.jp/contests/agc045/tasks/agc045_b</a></p>
<p>题目大意：给 $?$ 填 $01$ ，使得任意区间中 $01$ 个数差值绝对值的最大值最小。</p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>显然，可以把 $0$ 看成 $-1$ ，$1$ 看成 $1$ ，然后就是求前缀和最大值减最小值的最小可能值。</p>
<p>做法很简单，就是对于当前字符串，维护未来可能成为答案的值域范围，即指在所有可能的值域范围中，不存在一个范围是这个范围的真子集的范围。</p>
<p>注意到 $0$ 的转移就是所有区域向下移动，同时如果上界 $&lt;0$ 就补成 $0$ ，显然已经丢掉的区间不需要考虑，只考虑现在有的区间，其余转移类似，于是这样能发现结果只有两种情况：</p>
<ol>
<li>相同长度的区间，可以右移有限步，例如：$[-2,0],[-1,1],[0,2]$ 这样的。</li>
<li><p>相同长度的区间，可以右移有限的两步，即每次移动都是移动两步，同时左边和右边可能还有长度 $+1$ 的区间，但是相对位置是固定的，设基准区间为 $[l,r]$：</p>
<p>$([l-2,r-1],)[l,r],[l+2,r+2],…,<a href=",[l+2k+1,r+2k+2]">l+2k,r+2k</a>$</p>
</li>
</ol>
<p>理论上这个时候只需要讨论就行了。</p>
<p>但是我觉得讨论太麻烦了，发现你只关心左右两个区间，至多四个区间，就可以维护当前的状态。</p>
<p>但是需要注意，转移的时候如果总区间数 $&gt;4$ ，那么需要往内补至多两个区间（左右各一个），防止左右端点失效个数减少。</p>
<p>转移的时候就拿不超过 $6$ 个区间转移出他们的后继区间，然后去重，保留没有真子集的区间，按左端点为第一关键字，右端点为第二关键字排序，然后选最小的两个和最大的两个就行了，可以发现仍然是上面两种情况的合法维护，然后就行了。</p>
<p>证明正确也不难，可以发现只拿左右 $6$ 个区间转移，显然下一步的 $4$ 个区间是能转移出来的，其次的区间如果是下一步的其余合法区间，不会干扰最后选择，如果不是，又没被 $4$ 个区间去掉，说明被中间区间去掉了，研究此时这个区间的位置，左端点大于第二个区间，右端点小于第三个区间，所以也不会干扰最后选择，综上，这个转移是正确的，上面的表述可能不够严谨，但反正按照这个思路我觉得能证，应该大差不差了，懒得细想了。</p>
<p>时间复杂度：$O(n)$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span> + <span class="number">5</span>;</span><br><span class="line">PII <span class="keyword">operator</span> + (PII x, <span class="type">int</span> y)&#123;<span class="keyword">return</span> &#123;<span class="built_in">min</span>(x.first + y, <span class="number">0</span>), <span class="built_in">max</span>(x.second + y, <span class="number">0</span>)&#125;;&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    string ss;</span><br><span class="line">    cin &gt;&gt; ss;</span><br><span class="line">    vector&lt;PII&gt; f;</span><br><span class="line">    f.<span class="built_in">push_back</span>(&#123;<span class="number">0</span>, <span class="number">0</span>&#125;);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> c : ss)&#123;</span><br><span class="line">        <span class="keyword">if</span>(f.<span class="built_in">size</span>() == <span class="number">4</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(f[<span class="number">1</span>].first == f[<span class="number">0</span>].first + <span class="number">2</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(f[<span class="number">1</span>].second + <span class="number">2</span> &lt; f[<span class="number">2</span>].second) f.<span class="built_in">push_back</span>(f[<span class="number">1</span>] + <span class="number">2</span>);</span><br><span class="line">                <span class="keyword">if</span>(f[<span class="number">1</span>].second + <span class="number">4</span> &lt; f[<span class="number">2</span>].second) f.<span class="built_in">push_back</span>(f[<span class="number">2</span>] + (<span class="number">-2</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(f[<span class="number">1</span>].first == f[<span class="number">0</span>].first + <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(f[<span class="number">1</span>].second + <span class="number">1</span> &lt; f[<span class="number">2</span>].second) f.<span class="built_in">push_back</span>(f[<span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span>(f[<span class="number">1</span>].second + <span class="number">2</span> &lt; f[<span class="number">2</span>].second) f.<span class="built_in">push_back</span>(f[<span class="number">2</span>] + (<span class="number">-1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;PII&gt; g;</span><br><span class="line">        <span class="keyword">if</span>(c == <span class="string">&#x27;0&#x27;</span> || c == <span class="string">&#x27;?&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> x : f) g.<span class="built_in">push_back</span>(x + (<span class="number">-1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(c == <span class="string">&#x27;1&#x27;</span> || c == <span class="string">&#x27;?&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> x : f) g.<span class="built_in">push_back</span>(x + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(g.<span class="built_in">begin</span>(), g.<span class="built_in">end</span>(), [](PII x, PII y)&#123;<span class="keyword">return</span> x.first == y.first ? x.second &lt; y.second : x.second &lt; y.second;&#125;);</span><br><span class="line">        g.<span class="built_in">erase</span>(<span class="built_in">unique</span>(g.<span class="built_in">begin</span>(), g.<span class="built_in">end</span>()), g.<span class="built_in">end</span>());</span><br><span class="line">        vector&lt;PII&gt; tmp;</span><br><span class="line">        <span class="built_in">swap</span>(g, tmp);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> x : tmp)&#123;</span><br><span class="line">            <span class="type">bool</span> bk = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> y : tmp)&#123;</span><br><span class="line">                <span class="keyword">if</span>(x != y &amp;&amp; y.first &gt;= x.first &amp;&amp; y.second &lt;= x.second)&#123;bk = <span class="number">0</span>; <span class="keyword">break</span>;&#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(bk) g.<span class="built_in">push_back</span>(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(g.<span class="built_in">size</span>() &lt;= <span class="number">4</span>) <span class="built_in">swap</span>(f, g);</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            f.<span class="built_in">clear</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">1</span>; i++) f.<span class="built_in">push_back</span>(g[i]);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = g.<span class="built_in">size</span>() - <span class="number">2</span>; i &lt; g.<span class="built_in">size</span>(); i++) f.<span class="built_in">push_back</span>(g[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans = ss.<span class="built_in">length</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> x : f) ans = <span class="built_in">min</span>(ans, x.second - x.first);</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><details class="toggle" ><summary class="toggle-button" style="">犯罪记录</summary><div class="toggle-content"><p>很早的意识到这道题目前缀和的性质。</p></p>
<p>在最开始的时候，考虑每一段不是 $?$ 的区间，发现研究值域很有效，感觉需要讨论。</p>
<p>再后来，发现可能需要维护一系列可能的值域区间，而且这些区间的长度还不一定相等，猜想所需要维护的区间一定满足某种性质。</p>
<p>但是因为是一段一段字符考虑，不是一个个字符考虑，猜到了结论，但是不会证明，更不会讨论和转移，卡了一个小时。</p>
<p>最后意识到可以是一个个字符转移，遂会做，想到维护四个区间的做法，很快 AC 。（可能也不快）</p>
<p>首先，深刻反思：</p>
<ol>
<li>赛时不能颓废，颓废是犯大罪。</li>
<li>其次，$?$ 也是一种字符，当时应该尝试把 $?01$ 一起考虑，虽然这并不普遍，但是在卡题的时候思考一下是合理的。</li>
<li><p>再其次，应该意识到，如果考虑区间不行，就考虑单个字符，这是有理有据的，虽然确实也有很多题目是应该考虑区间的，但是卡题的时候，换个思路思考是十分合理的，重点不是可能不可能成为答案，而是我没有尝试过这么思考，这很危险（虽然最后还是想到了，但是卡了一个小时基本完蛋了）。</p>
<p>而且本身也有很多题目，是从考虑区间变成考虑单个数字的时候，就豁然开朗了，所以这是一个合理的方向。</p>
<p>再其次，这道题目考虑单个字符是有迹可循的，区间本质上是一堆字符中间加了 $0$ 个操作，而一堆 $?$ 是中间有 $0$ 长度的区间，而一般的算法，尤其是 $dp$ ，一般能处理 $&gt;0$ 的情况就能处理 $=0$ 的情况，所以就应该把区间拆成单个字符，一堆问号拆成单个问号想想的。</p>
</li>
</ol>
<p>总之，赛时因为没想到考虑单个字符，一直卡在考虑区间，我认为是犯大罪，是不应该犯的错误，警钟敲烂。</p>
</div></details>
<p>看了题解，越来越感觉自己很唐了。</p></div></details>
<details class="toggle" ><summary class="toggle-button" style="">别的做法 1</summary><div class="toggle-content"><p>我们考虑固定一个上界，求最大的下界，注意到肯定是把所有的 $?$ 填成 $0$ ，然后从左到右，维护后缀最小值，能填 $1$ 填 $1$ 。</p>
<p>正确的道理就是：修改相当于后缀 $+2$ ，考虑原来的每个后缀最大值，实际上限制了前面至多有多少个修改，显然在不超过限制的情况下，修改越往前，全局最小值越小。</p>
<p>考虑把上界 $+2$ ，显然至多导致多修改一个 $1$ ，所以答案不优，所以求最小的上界和最小的上界 $+1$ 就行了，最小上界就是全填 $0$ 的最大值。</p>
<p>时间复杂度：$O(n)$ 。</p>
<p><details class="toggle" ><summary class="toggle-button" style="">反思</summary><div class="toggle-content"><p>首先，我有想过这个固定上界的思路，但是为什么没想出来怎么求出最大下界了？</p></p>
<p>因为有个唐氏儿一开始没有把所有的问号写成 $0$ ，首先，问一个位置变成 $±1$ 还是原本是 $0$ ，是否修改成 $1$ ，虽然都是两个选择，但是在贪心和 dp 中，后者的思考难度和维护难度一般都远小于前者，因为将两个操作变成不操作和操作两个选择是一个很优秀的变化，做多了就知道了。</p>
<p>但是某个唐氏儿都大一了，打了八年以上，还能忘记这一点，全程带着 $0$ 来想，好想中途有想过先全部填成 $0$ 或者 $1$ ，但是当时还在想维护区间那个思路，发现这个思路没用，想了一会就没想了，结果痛失良机，真是唐吧。想怎么求最大下界想了不下几十分钟，怎么就是没想到先把 $?$ 填成 $0$ 或者 $1$ 呢？</p>
<p>当然，后面那个上界那一步我不一定能想出来，但我恨就恨在我怎么菜到第一步都没想出来，而且还不是方向错了那种，是方向对了，但就是没想出来。</p>
<p>真是菜啊。</p>
<p>一开始全填 $1$ 也能做，就是每个后缀必须要变多少个 $0$ ，差分一下看是否能满足要求就行，在此基础上，$0$ 越靠后，全局最小值越大。</p>
</div></details>
<p>这好像就是官方做法。</p>
<p>我真是菜啊，我真是废物啊。</p></div></details>
<details class="toggle" ><summary class="toggle-button" style="">别的做法 2</summary><div class="toggle-content"><p><a href="https://www.luogu.com.cn/article/na9yv0ep">https://www.luogu.com.cn/article/na9yv0ep</a></p>
<p>一个很有意思的做法，赏心悦目。</p>
<p>二分值域范围，这样就只需要 check ，但是一开始不知道区间落在哪里，一个很有意思的搞法是一开始就把起点尝试放在区间中的每个位置（我记得我以前好想也见过这个 trick ，但是现在已经忘了），即同时维护长度个路径，然后每次转移的时候，注意到可以到达的范围是个区间，然后就做完了，时间复杂度：$O(n\log{n})$ 。</p>
<p>这里放一张图，来自上面那篇博客的。</p>
<p><img src="1.png" alt=""></p>
<p>很有意思的做法，看这种做法真是让人感到愉悦啊。<del>虽然时间复杂度劣于正解就是了</del></p>
</div></details>]]></content>
      <categories>
        <category>信息学</category>
      </categories>
  </entry>
  <entry>
    <title>AGC043 赛后总结</title>
    <url>/2024/05/30/AGC043-%E8%B5%9B%E5%90%8E%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>比赛链接：<a href="https://atcoder.jp/contests/agc043">https://atcoder.jp/contests/agc043</a></p>
<h1 id="A-Range-Flip-Find-Route"><a href="#A-Range-Flip-Find-Route" class="headerlink" title="A. Range Flip Find Route"></a>A. Range Flip Find Route</h1><p>题目链接：<a href="https://atcoder.jp/contests/agc043/tasks/agc043_a">https://atcoder.jp/contests/agc043/tasks/agc043_a</a></p>
<p>题目大意：一个 01 矩阵，每次可以选择一个子矩阵翻转，问最少需要多少次操作能够存在一条 $(1,1)$ 到 $(n,m)$ 的全 $1$ 路径。（只能向右向下走）</p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>对于一条固定的路径，可以变成一个序列考虑，发现每次操作最多少一段 $0$ ，因此就是找到一条路径最小化 $0$ 的段数。</p>
<p>时间复杂度：$O(nm)$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e2</span> + <span class="number">5</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_char_array</span><span class="params">(<span class="type">char</span> *ss)</span></span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">char</span> s[N];</span><br><span class="line">    cin &gt;&gt; s;</span><br><span class="line">    <span class="built_in">memcpy</span>(ss + <span class="number">1</span>, s, <span class="built_in">sizeof</span>(<span class="type">char</span>) * (<span class="built_in">strlen</span>(s) + <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">char</span> st[N][N];</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> dp[N][N];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">pd</span><span class="params">(<span class="type">char</span> x, <span class="type">char</span> y)</span></span>&#123;<span class="keyword">return</span> x == <span class="string">&#x27;#&#x27;</span> &amp;&amp; y == <span class="string">&#x27;.&#x27;</span>;&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">get_char_array</span>(st[i]);</span><br><span class="line">    dp[<span class="number">1</span>][<span class="number">1</span>] = st[<span class="number">1</span>][<span class="number">1</span>] == <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">1</span> &amp;&amp; j == <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="type">int</span> now = <span class="number">1e9</span>;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">1</span>) now = <span class="built_in">min</span>(now, dp[i - <span class="number">1</span>][j] + <span class="built_in">pd</span>(st[i][j], st[i - <span class="number">1</span>][j]));</span><br><span class="line">            <span class="keyword">if</span>(j &gt; <span class="number">1</span>) now = <span class="built_in">min</span>(now, dp[i][j - <span class="number">1</span>] + <span class="built_in">pd</span>(st[i][j], st[i][j - <span class="number">1</span>]));</span><br><span class="line">            dp[i][j] = now;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; dp[n][m] &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>和官方题解一样。</p>
</div></details>
<h1 id="B-123-Triangle"><a href="#B-123-Triangle" class="headerlink" title="B. 123 Triangle"></a>B. 123 Triangle</h1><p>题目链接：<a href="https://atcoder.jp/contests/agc043/tasks/agc043_b">https://atcoder.jp/contests/agc043/tasks/agc043_b</a></p>
<p>题目大意：给你一个只包含 $1,2,3$ 的序列，每次操作会将这个序列相邻两个数字相减并取绝对值，得到一个长度 $-1$ 的序列，操作到只剩下一个值，问这个值是多少。</p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>首先答案只能是 $0,1,2$ 。</p>
<p>所以先把初始序列减 $1$ ，这样全局过程中我们都只需要考虑 $0,1,2$ 。</p>
<p>注意到 $\mod 2$ 意义下可以把 $|x-y|$ 变成 $x+y$ ，从而可以直接用组合数算出最终数字的奇偶性。</p>
<p>现在问题是怎么区分 $0/2$ ？</p>
<p>可以归纳证明，只要初始序列中有 $1$ ，最终答案就一定不可能是 $2$ 。</p>
<p>在序列有 $0/2$ 的情况下，显然后面都只有 $0/2$ ，因此在模 $4$ 意义下 $|x-y|=x+y$ ，所以类似上面组合数直接算答案就行了。</p>
<p>当然也可以把所有数字除 $2$ 然后在 $\mod 2$ 的意义下计算，没区别。</p>
<p>时间复杂度：$O(n)$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span> + <span class="number">5</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_char_array</span><span class="params">(<span class="type">char</span> *ss)</span></span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">char</span> s[N];</span><br><span class="line">    cin &gt;&gt; s;</span><br><span class="line">    <span class="built_in">memcpy</span>(ss + <span class="number">1</span>, s, <span class="built_in">sizeof</span>(<span class="type">char</span>) * (<span class="built_in">strlen</span>(s) + <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">char</span> st[N];</span><br><span class="line"><span class="type">int</span> n, a[N];</span><br><span class="line"><span class="type">int</span> cnt[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span>&#123;<span class="keyword">return</span> cnt[r] - cnt[l - <span class="number">1</span>];&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">calc</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>&#123;<span class="keyword">return</span> (<span class="built_in">query</span>(<span class="number">1</span>, x) - <span class="built_in">query</span>(<span class="number">1</span>, y) - <span class="built_in">query</span>(<span class="number">1</span>, x - y)) ? <span class="number">0</span> : <span class="number">1</span>;&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="built_in">get_char_array</span>(st);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        cnt[i] = cnt[i - <span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> tmp = i;</span><br><span class="line">        <span class="keyword">while</span>(tmp % <span class="number">2</span> == <span class="number">0</span>) tmp /= <span class="number">2</span>, cnt[i]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> cnt1 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        a[i] = st[i] - <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">        ans = (a[i] * <span class="built_in">calc</span>(n - <span class="number">1</span>, i - <span class="number">1</span>) + ans) % <span class="number">2</span>;</span><br><span class="line">        cnt1 += (a[i] == <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(ans == <span class="number">1</span>) cout &lt;&lt; <span class="number">1</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(cnt1) cout &lt;&lt; <span class="number">0</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            a[i] = a[i] / <span class="number">2</span>;</span><br><span class="line">            ans = (a[i] * <span class="built_in">calc</span>(n - <span class="number">1</span>, i - <span class="number">1</span>) + ans) % <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(ans == <span class="number">1</span>) cout &lt;&lt; <span class="number">2</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; <span class="number">0</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>和官方题解一样，我麻烦的地方在于判断组合数的奇偶性：</p>
<p>$\binom{n}{m}\equiv [n \&amp; m = m]\mod2$</p>
<p>但比赛时不知道就没办法了，不可能花时间去想这个东西的，直接数 $2$ 的个数花不了什么时间，在比赛中肯定是选择时间更短的方案。</p>
<p>至于这是为什么，我记得组合数取模有一个专门的定理，到时候会专门出一篇博客讲解，这里不再赘述。</p>
</div></details>
<h1 id="C-Giant-Graph"><a href="#C-Giant-Graph" class="headerlink" title="C. Giant Graph"></a>C. Giant Graph</h1><p>单独开了一篇题解。</p>
<h1 id="D-Merge-Triplets"><a href="#D-Merge-Triplets" class="headerlink" title="D. Merge Triplets"></a>D. Merge Triplets</h1><p>题目链接：<a href="https://atcoder.jp/contests/agc043/tasks/agc043_d">https://atcoder.jp/contests/agc043/tasks/agc043_d</a></p>
<p>题目大意：问有多少个 $3N$ 的合法排列，合法排列的定义是：</p>
<p>给 $N$ 个长度为 $3$ 的序列，序列中的数互不相同且都在 $[1,3N]$ 。</p>
<p> $P$ 初始为空，然后每次选择所有序列开头最小的数字，删掉，加入 $P$ 中，最后得到的 $P$ 称为合法排列。</p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>合法的 $P$ 有什么要求呢？</p>
<p>如果出现 $P_{i} &gt; P_{i+1}$ ，说明肯定是某个序列中连续弹出了两个数字，这启示我们可以把排列分成若干段：$[l_1,r_1],[l_2,r_2],…,[l_m,r_m]$ 。</p>
<p>满足：</p>
<ol>
<li>$\forall l_i\le j\le r_i:P_{j}\le P_{l_i}$</li>
<li>$P_{l_i} &lt; P_{l_{i+1}}$</li>
</ol>
<p>可以注意到对于每个排列 $P$ ，分法是唯一的。</p>
<p>那么可以注意到 $P$ 合法当且仅当每段长度 $\le 3$ ，而且长度 $\ge 2$ 的段数 $\le n$ 。</p>
<p>然后直接 dp 就行了。</p>
<p>时间复杂度：$O(n^2)$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e3</span> + <span class="number">5</span>;</span><br><span class="line">LL mod, f[N * <span class="number">3</span>][N];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; mod;</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1ll</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n * <span class="number">3</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= n; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i + <span class="number">1</span> &lt;= n * <span class="number">3</span>) f[i + <span class="number">1</span>][j] = (f[i + <span class="number">1</span>][j] + f[i][j]) % mod;</span><br><span class="line">            <span class="keyword">if</span>(i + <span class="number">2</span> &lt;= n * <span class="number">3</span> &amp;&amp; j + <span class="number">1</span> &lt;= n) f[i + <span class="number">2</span>][j + <span class="number">1</span>] = (f[i + <span class="number">2</span>][j + <span class="number">1</span>] + f[i][j] * (i + <span class="number">1</span>)) % mod;</span><br><span class="line">            <span class="keyword">if</span>(i + <span class="number">3</span> &lt;= n * <span class="number">3</span> &amp;&amp; j + <span class="number">1</span> &lt;= n) f[i + <span class="number">3</span>][j + <span class="number">1</span>] = (f[i + <span class="number">3</span>][j + <span class="number">1</span>] + f[i][j] * (i + <span class="number">1</span>) % mod * (i + <span class="number">2</span>)) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    LL ans = <span class="number">0ll</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i++) ans = (ans + f[n * <span class="number">3</span>][i]) % mod;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>和官方题解基本一致。</p>
<p>学到一个新词汇，上面的划分方法可以用一个更加专业的说法说：按照前缀 $max$ 分段。</p>
</div></details>]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>SG</tag>
      </tags>
  </entry>
  <entry>
    <title>AGC061 C. First Come First Serve</title>
    <url>/2023/08/25/AGC061-C-First-Come-First-Serve/</url>
    <content><![CDATA[<p>题目链接：<a href="https://atcoder.jp/contests/agc061/tasks/agc061_c">https://atcoder.jp/contests/agc061/tasks/agc061_c</a></p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>显然的方向：我们可以让一些选择非法，使得每个答案对应一个合法的选择。</p>
<p>准确来说，我们定义 $ff[i]$ 表示最大的 $j$ 使得 $i&lt;k\le j$ 满足 $l_k&lt;r_i$ 。</p>
<p>我们考虑每个顾客，填 $1$ 表示选择离开时候记录，$0$ 表示选择进入时记录。</p>
<p>那么一个位置填 $0$ 的条件为 $(i,ff[i]]$ 中有一个位置填 $0$ 或者存在一个位置 $k$ 填 $1$ 且 $i\in (k,ff[k]]$ 。</p>
<p>然后用 DP 维护合法方案即可。</p>
<p>一个显然的傻瓜式 DP 是：</p>
<p>$f_1[i]$ 表示 $i$ 填 $1$ 的目前合法序列个数。</p>
<p>$f_2[i]$ 表示 $i$ 填 $0$ 的可能合法序列个数。</p>
<p>$f_3[i]$ 表示 $i$ 填 $0$ ，$i-1$ 填 $1$ 的合法序列个数。</p>
<p>转移即可。</p>
<p>但是这里要讲一个优化，把 $f_3$ 优化掉，就是有一个转移是：</p>
<p>$f_2-&gt;f_3$ ，内容为往后放若干 $1$ 后放一个 $0$ ,那我们不妨先转移到 $f_1$ ，再减去没有放 $0$ 的序列（即减去不合法的序列）</p>
<p>于是：</p>
<p>$f_1[j]+=f2<a href="j\in (i,ff[i]">i</a>),f_1[j]-=(j\in (i+1,ff[i]])$</p>
<p>但是这时又产生了一个疑惑，在化简了式子后可以缩减为：</p>
<p>$f_1[i+1]+=f_2[i],f_1[ff[i]]-=f_2[i]$ 。</p>
<p>其实不难发现，所有的不合法方案在 DP 过程中都一定会经过 $f_1[ff[i]]$ 且贡献为 $1$ ，减掉即可。</p>
<p>时间复杂度：$O(n)$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 510000</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> LL mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> l,r;</span><br><span class="line">&#125;a[N];<span class="type">int</span> ff[N],n;</span><br><span class="line">LL f1[N],f2[N],f3[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a[i].l,&amp;a[i].r);</span><br><span class="line">    <span class="type">int</span> now=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(now&lt;n &amp;&amp; a[now+<span class="number">1</span>].l&lt;=a[i].r)now++;</span><br><span class="line">        ff[i]=now;</span><br><span class="line">    &#125;</span><br><span class="line">    LL fnow=<span class="number">0</span>;f1[<span class="number">1</span>]=f2[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        (f1[i]+=fnow)%=mod;(f2[ff[i]+<span class="number">1</span>]+=f1[i])%=mod;</span><br><span class="line">        <span class="keyword">if</span>(ff[i]&gt;i)(f2[i+<span class="number">1</span>]+=f2[i])%=mod,(f1[i+<span class="number">1</span>]+=f2[i])%=mod,(f1[ff[i]]+=mod-f2[i])%=mod;</span><br><span class="line">        (fnow+=f1[i])%=mod;(f3[ff[i]+<span class="number">1</span>]+=f1[i])%=mod;</span><br><span class="line">        (fnow+=mod-f3[i])%=mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// for(int i=1;i&lt;=n;i++)printf(&quot;%d:%d %lld %lld\n&quot;,i,ff[i],f1[i],f2[i]);</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,fnow);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></details>]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>AGC046 赛后总结</title>
    <url>/2024/06/26/AGC046-%E8%B5%9B%E5%90%8E%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>比赛链接：<a href="https://atcoder.jp/contests/agc046">https://atcoder.jp/contests/agc046</a></p>
<h1 id="A-Takahashikun-The-Strider"><a href="#A-Takahashikun-The-Strider" class="headerlink" title="A. Takahashikun, The Strider"></a>A. Takahashikun, The Strider</h1><p>题目链接：<a href="https://atcoder.jp/contests/agc046/tasks/agc046_a">https://atcoder.jp/contests/agc046/tasks/agc046_a</a></p>
<p>题目大意：二维平面在原点，初始在原点，朝向南方，每次往面朝方向走一格，然后逆时针转 $X$ 度角，问经过几次后回到原点。</p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>为啥能这么快就做出来了？猜结论吗？</p>
<p>手动模拟一下，好像是最小的 $n$ 满足：$nX\equiv 0\mod 360$ 。</p>
<p>也就是：</p>
<script type="math/tex; mode=display">\begin{align*}
t=&\frac{2X\pi}{360}\\
&\sum\limits_{i=0}^{n-1}sin(it)\\
=&\frac{cos\frac{2n-1}{2}t-cos\frac{t}{2}}{2sin\frac{t}{2}}\\
=&0\\
\end{align*}</script><p>等价于：$(n-1)t=2k\pi$ 或者 $nt=2k\pi$ 。</p>
<p>即：$\frac{2X(n-1)\pi}{360}=2k\pi\to (n-1)X=360k$ ，或者 $\frac{2Xn\pi}{360}=2k\pi\to nX=360k$ 。</p>
<p>同理：</p>
<script type="math/tex; mode=display">\begin{align*}
&\sum\limits_{i=0}^{n-1}cos(it)\\
=&\frac{sin\frac{2n-1}{2}t+sin\frac{t}{2}}{2sin\frac{t}{2}}\\
=&0\\
\end{align*}</script><p>等价于：$nt=2k\pi\to nX=360k$ 。</p>
<p>综上，$nX=360k$ 是回到原点的充要条件，显然就是上面说的那个东西。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>&#123;<span class="keyword">return</span> !x ? y : <span class="built_in">gcd</span>(y % x, x);&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    cout &lt;&lt; <span class="number">360</span> / <span class="built_in">gcd</span>(n, <span class="number">360</span>) &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></details>
<h1 id="B-Extension"><a href="#B-Extension" class="headerlink" title="B. Extension"></a>B. Extension</h1><p>题目链接：<a href="https://atcoder.jp/contests/agc046/tasks/agc046_b">https://atcoder.jp/contests/agc046/tasks/agc046_b</a></p>
<p>题目大意：给定一个初始为白 $A<em>B$ 的矩形，要求执行下列操作到 $C</em>D$ 的矩形，问有多少种不同的染色。</p>
<ol>
<li>在上面添加一行白色，并将这一行白色中添加任意一格黑色。</li>
<li>在右边添加一列白色，并将这一列白色中添加任意一格黑色。</li>
</ol>
<details class="toggle" ><summary class="toggle-button" style="">我的做法</summary><div class="toggle-content"><p>这种东西很典，就是给每种染色规定一个唯一的添加行列的顺序，然后直接 $dp$ 就行了。</p>
<p>首先肯定想着行列交换，显然在一种方案中行列能交换当且仅当后者不会在交点处涂黑，我们尽可能的让列靠前，对于所有 “ 行列 ” 无法交换的方案称为驻点。</p>
<p>问题来了，会有两个驻点方案吗？</p>
<p>不会，因为可以证明，以下构造出来的方案是驻点方案，且不是这个的方案都不是驻点方案：</p>
<p>对于任意一个染色方案，显然每一行或者每一列在生成的时候都会生成所在行或者列的第一个黑色。</p>
<p>知道每一行每一列生成的黑色是啥后，我们看当前的行数是否能生成下一列的黑色，能就生成，不能就先生成行的。</p>
<p>显然只要染色合法，就一定能生成一个方案，而且极其显然的是，一个方案能对应一个染色。</p>
<p>然后直接 $dp$ 计数就行了，时间复杂度：$O(n^2)$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">3e3</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> LL mod = <span class="number">998244353</span>;</span><br><span class="line">LL dp[N][N][<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> A, B, C, D;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; A &gt;&gt; B &gt;&gt; C &gt;&gt; D;</span><br><span class="line">    dp[A][B][<span class="number">0</span>] = <span class="number">1ll</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = A; i &lt;= C; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = B; j &lt;= D; j++)&#123;</span><br><span class="line">            dp[i + <span class="number">1</span>][j][<span class="number">1</span>] = (dp[i + <span class="number">1</span>][j][<span class="number">1</span>] + (dp[i][j][<span class="number">0</span>] + dp[i][j][<span class="number">1</span>]) * j) % mod;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; A) dp[i][j + <span class="number">1</span>][<span class="number">0</span>] = (dp[i][j + <span class="number">1</span>][<span class="number">0</span>] + dp[i][j][<span class="number">1</span>]) % mod;</span><br><span class="line">            dp[i][j + <span class="number">1</span>][<span class="number">0</span>] = (dp[i][j + <span class="number">1</span>][<span class="number">0</span>] + dp[i][j][<span class="number">0</span>] * i) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; (dp[C][D][<span class="number">0</span>] + dp[C][D][<span class="number">1</span>]) % mod &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></details>
<details class="toggle" ><summary class="toggle-button" style="">一个有意思的容斥做法</summary><div class="toggle-content"><p><a href="https://www.luogu.com.cn/article/pgbld0pu">https://www.luogu.com.cn/article/pgbld0pu</a></p>
<p>先不管记重，$f_{i,j}=f_{i-1,j}<em>j+f_{i,j-1}</em>i$ ，假设前面是正确的，这里开始容斥，发现当 $(i,j)$ 不是黑色的时候会计两次。（这可以从转移分析得到）</p>
<p>所以正确的转移为 $f_{i,j}=f_{i-1,j}<em>j+f_{i,j-1}</em>i-f_{i-1,j-1}<em>(i-1)</em>(j-1)$ 。</p>
</div></details>
<h1 id="C-Shift"><a href="#C-Shift" class="headerlink" title="C. Shift"></a>C. Shift</h1><p>题目链接：<a href="https://atcoder.jp/contests/agc046/tasks/agc046_c">https://atcoder.jp/contests/agc046/tasks/agc046_c</a></p>
<p>题目大意：每次选择字符串中的 $i&lt;j$ 满足 $s[i]=0,s[j]=1$ ，然后把 $1$ 放到 $0$ 左边，问经过至多 $K$ 次操作后能产生多少不同的字符串。</p>
<details class="toggle" ><summary class="toggle-button" style="">我的做法</summary><div class="toggle-content"><p>注意到可以用 $0$ 给 $1$ 分段，用 $1$ 的数量变成数组 $A$，然后状态 $A$ 能到状态 $B$ 当且仅当：</p>
<ol>
<li>$\sum\limits_{i=1}^{len}|A_{i}-B_{i}|\le K$</li>
<li>$\sum\limits_{i=1}^{j}B_{i}-A_{i}\ge 0$</li>
</ol>
<p>直接 $dp[i][j][k]$ 计数就行了。</p>
<p>但是需要加个类似前缀和优化的东西保证时间复杂度是 $O(n^3)$ 的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> LL mod = <span class="number">998244353</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">3e2</span> + <span class="number">5</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_char_array</span><span class="params">(<span class="type">char</span> *s)</span></span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">char</span> ss[N];</span><br><span class="line">    cin &gt;&gt; ss;</span><br><span class="line">    <span class="built_in">memcpy</span>(s + <span class="number">1</span>, ss, <span class="built_in">sizeof</span>(<span class="type">char</span>) * (<span class="built_in">strlen</span>(ss) + <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">char</span> st[N];</span><br><span class="line"><span class="type">int</span> n, m, a[N], b[N], K;</span><br><span class="line">LL dp[N][N][N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">get_char_array</span>(st); n = <span class="built_in">strlen</span>(st + <span class="number">1</span>);</span><br><span class="line">    cin &gt;&gt; K;</span><br><span class="line">    &#123;</span><br><span class="line">        st[++n] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> l = <span class="number">1</span>; l &lt;= n; l++)&#123;</span><br><span class="line">            <span class="type">int</span> r = l;</span><br><span class="line">            <span class="keyword">while</span>(st[r] == <span class="string">&#x27;1&#x27;</span>) r++;</span><br><span class="line">            a[++m] = r - l;</span><br><span class="line">            l = r;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) b[i] = b[i - <span class="number">1</span>] + a[i];</span><br><span class="line">    K = <span class="built_in">min</span>(K, b[m]);</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1ll</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= K; j++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k = j; k &lt;= K; k++)&#123;</span><br><span class="line">                dp[i][j][k] = (dp[i][j][k] + dp[i - <span class="number">1</span>][j][k]) % mod;</span><br><span class="line">                <span class="keyword">if</span>(j) dp[i][j][k] = (dp[i][j][k] + dp[i][j - <span class="number">1</span>][k - <span class="number">1</span>]) % mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= K; j++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k = j; k &lt;= K; k++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!dp[i - <span class="number">1</span>][j][k]) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> t = <span class="number">1</span>; t &lt;= j &amp;&amp; t &lt;= a[i]; t++) dp[i][j - t][k] = (dp[i][j - t][k] + dp[i - <span class="number">1</span>][j][k]) % mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    LL ans = <span class="number">0ll</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= K; i++) ans = (ans + dp[m][<span class="number">0</span>][i]) % mod;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>和官方做法基本一致。</p>
</div></details>
<h1 id="D-Secret-Passage"><a href="#D-Secret-Passage" class="headerlink" title="D. Secret Passage"></a>D. Secret Passage</h1><p>题目链接：<a href="https://atcoder.jp/contests/agc046/tasks/agc046_d">https://atcoder.jp/contests/agc046/tasks/agc046_d</a></p>
<p>题目大意：你可以对 $01$ 字符串做以下操作若干次，问有多少个本质不同字符串：</p>
<p>若字符串长度 $\ge 2$ ，删除前面两个字符中的一个，并且将另外一个插入到字符串中的任意位置。</p>
<details class="toggle" ><summary class="toggle-button" style="">我的做法</summary><div class="toggle-content"><p>首先一个典中典的事情，我们可以先不把没删除的字符插入，而是等到需要用时再插入，因此我们只关心在删除了一个前缀的情况下，我们手里能有多少个 $0$ ，多少个 $1$ 。</p>
<p>由于时间十分充裕，我们可以在 $O(n^3)$ 的时间处理出来。</p>
<p>现在的问题是，我们怎么在 $O(n^3)$ 的时间内，处理出所有可能的串？</p>
<p>首先先给所有的可能串分个类，根据其拥有的 $0$ 的个数和 $1$ 的个数，可以发现，在这两个确定后，我们其实只关心一个事情，能删的前缀的最大值是多少？</p>
<p>或者具体来说，在前面那个 $dp$ 做完后，我们实际上有一堆三元数：有多少个可以自由支配的 $0/1$ ，以及多长的后缀是固定的，可以看到在 $0/1$ 总数固定的情况下，后缀越短越好，因此总共有 $n^2$ 种不同的后缀。</p>
<p>这启示我们需要在 $O(n)$ 的时间针对一个种类求出答案，但是如果单独 $dp$ 这个复杂度寄中寄，注意到后缀长度是共同变量，启示我们一起处理一个大的 $dp$ ，然后每种是其中的部分和。</p>
<p>得到以下的 $dp$ ：</p>
<p>$f[i][j][k]$ 表示后缀匹配长度为 $i$ ，有 $j$ 个 $0$ ，$k$ 个 $1$ 的不同字符串数，匹配指最长的后缀满足是子序列，即能匹配就匹配。</p>
<p>对于三元数 $(j,k,len)$ ，显然其答案就是：$\sum\limits_{i=1}^{n-len+1}f[i][j][k]$ 。</p>
<p>总时间复杂度：$O(n^3)$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> LL mod = <span class="number">998244353</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">3e2</span> + <span class="number">5</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_char_array</span><span class="params">(<span class="type">char</span> *s)</span></span>&#123;</span><br><span class="line">    <span class="type">char</span> ss[N];</span><br><span class="line">    cin &gt;&gt; ss;</span><br><span class="line">    <span class="built_in">memcpy</span>(s + <span class="number">1</span>, ss, <span class="built_in">sizeof</span>(<span class="type">char</span>) * (<span class="built_in">strlen</span>(ss) + <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool</span> dp[N][N][N];</span><br><span class="line">LL sum[N][N][N];</span><br><span class="line"><span class="type">char</span> st[N];</span><br><span class="line"><span class="type">int</span> n, cnt0[N], cnt1[N], las[N][N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">get_char_array</span>(st); n = <span class="built_in">strlen</span>(st + <span class="number">1</span>);</span><br><span class="line">    sum[n + <span class="number">1</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1ll</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = n + <span class="number">1</span>; i &gt;= <span class="number">2</span>; i--)&#123;<span class="comment">//i = 1 no operator</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= n; j++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; j + k &lt;= n; k++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(st[i - <span class="number">1</span>] == <span class="string">&#x27;0&#x27;</span>)&#123;</span><br><span class="line">                    sum[i - <span class="number">1</span>][j + <span class="number">1</span>][k] = (sum[i - <span class="number">1</span>][j + <span class="number">1</span>][k] + sum[i][j][k]) % mod;</span><br><span class="line">                    sum[i][j][k + <span class="number">1</span>] = (sum[i][j][k + <span class="number">1</span>] + sum[i][j][k]) % mod;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    sum[i - <span class="number">1</span>][j][k + <span class="number">1</span>] = (sum[i - <span class="number">1</span>][j][k + <span class="number">1</span>] + sum[i][j][k]) % mod;</span><br><span class="line">                    sum[i][j + <span class="number">1</span>][k] = (sum[i][j + <span class="number">1</span>][k] + sum[i][j][k]) % mod;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = n; i &gt;= <span class="number">1</span>; i--)&#123;</span><br><span class="line">        cnt0[i] += cnt0[i + <span class="number">1</span>] + (st[i] == <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        cnt1[i] += cnt1[i + <span class="number">1</span>] + (st[i] == <span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">        las[cnt0[i]][cnt1[i]] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = i / <span class="number">2</span>; j &gt;= <span class="number">0</span>; j--)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k = i / <span class="number">2</span> - j; k &gt;= <span class="number">0</span>; k--)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!dp[i][j][k]) <span class="keyword">continue</span>;</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="type">int</span> c0 = cnt0[i + <span class="number">1</span>] + j, c1 = cnt1[i + <span class="number">1</span>] + k;</span><br><span class="line">                    <span class="keyword">if</span>(c0 + c1) las[c0][c1] = <span class="built_in">max</span>(las[c0][c1], i + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(i + <span class="number">2</span> &lt;= n)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(st[i + <span class="number">1</span>] == <span class="string">&#x27;0&#x27;</span> || st[i + <span class="number">2</span>] == <span class="string">&#x27;0&#x27;</span>) dp[i + <span class="number">2</span>][j + <span class="number">1</span>][k] = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">if</span>(st[i + <span class="number">1</span>] == <span class="string">&#x27;1&#x27;</span> || st[i + <span class="number">2</span>] == <span class="string">&#x27;1&#x27;</span>) dp[i + <span class="number">2</span>][j][k + <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(j &gt;= <span class="number">1</span> &amp;&amp; j + k &gt;= <span class="number">2</span>) dp[i][j - <span class="number">1</span>][k] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(k &gt;= <span class="number">1</span> &amp;&amp; j + k &gt;= <span class="number">2</span>) dp[i][j][k - <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(i + <span class="number">1</span> &lt;= n)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(j || k) dp[i + <span class="number">1</span>][j][k] = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">if</span>(st[i + <span class="number">1</span>] == <span class="string">&#x27;0&#x27;</span> &amp;&amp; k) dp[i + <span class="number">1</span>][j + <span class="number">1</span>][k - <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">if</span>(st[i + <span class="number">1</span>] == <span class="string">&#x27;1&#x27;</span> &amp;&amp; j) dp[i + <span class="number">1</span>][j - <span class="number">1</span>][k + <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    LL ans = <span class="number">0ll</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; i + j &lt;= n; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!i &amp;&amp; !j) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k = las[i][j]; k &gt;= <span class="number">1</span>; k--)&#123;</span><br><span class="line">                ans = (ans + sum[k][i][j]) % mod;</span><br><span class="line">            &#125;</span><br><span class="line">            ans--;</span><br><span class="line">            ans++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但感觉这种做法尽显暴力，等会看看正解是怎么优雅的做出这道题目的。</p>
<p>在此之前，我来证明一个在赛时没时间证明的想法：</p>
<p>删除任何一个前缀，假设可支配 $x$ 个 $0$ 和 $y$ 个 $1$ ，并且 $x+y$ 确定，那么 $x$ 的范围是个区间。</p>
<p><details class="toggle" ><summary class="toggle-button" style="">证明</summary><div class="toggle-content"><p>我们可以考虑这么一个事情，给定一个前缀，给其标 $0/1$ ，$0$ 表示保留，$1$ 表示删掉，然后问这是否是一种合法的方案。</p></p>
<p>注：由于博主疏忽大意，后面记得根据语境区分 $0/1$ 指的是删除标记还是字符串的 $0/1$ 。</p>
<p>这个问题存在一种简单的判法，从左到右，如果接下来有两个字符，而且有至少一个 $1$ ，那么就直接对这两个字符操作，如果有两个 $0$ 或者只剩下一个字符，就搭一个 $1$ 进去操作（手中没有 $0$ 就不合法），等到没有剩余字符在前缀的时候，就拿手中的 $0$ 去消除手中的 $1$ 就行了（手中有 $1$ 但没 $0$ 就不合法），这样就能判断是否合法。</p>
<p>这个判法的证明也不难：</p>
<p><details class="toggle" ><summary class="toggle-button" style="">证明</summary><div class="toggle-content"><p>对于 $2$ 个以上连续的 $0$ ，我们不妨设为 $L00R$ ，一定可以把这个过程分为 $L0,0R$ ，即一定是先做完 $L0$ ，再做 $0R$ （手中 $0,1$ 数量不会消失），注意到不合法当且仅当 $1$ 的数量不够了，因此我们希望在 $L0$ 处获得尽可能多的 $1$ ，对应的，上面的过程中遇到 $00$ ，我们都能进行这样子的划分，对于每一段，证明就变得十分的简单了，一定是：</p></p>
<p>$AB$ ，其中 $A$ 是长度为 $2len$ 的字符串，满足 $2i-1,2i$ 中至少有一个 $1$ ，$B$ 全是 $0$ ，这种段的最优策略是显然的，而显然，将这些最优策略拼起来就是整体最优的，而拼起来的策略就是上面的策略，所以就证明了上面的策略就是整体最优的。</p>
<p>证毕。</p>
</div></details>
<p>根据这个判法，我们可以将任意一种方案在每次只移动一个 $1$ 的情况下，变成下面这种方案：</p>
<p>假设总共有 $t$ 个 $1$ ，现在所有奇数位置放个 $1$ ，剩下的 $1$ 从左往右依次放在空着的偶数里。</p>
<p>鉴于这种移动可逆，所以所有的方案都可以通过这种方式互达，同时这种移动只会造成 $1$ 的变化，从而证明是个区间。</p>
<p>事实上，我们也可以加上加一个 $1$ 减一个 $1$ 的操作，从而得到在不固定 $x+y$ 的情况下 $(x+y,x)$ 的所在范围。</p>
<p>但是这个范围并没有很好，举个例子：</p>
<p>$111100110011001100$</p>
<p>至少需要 $4$ 步才能变成 $-1$ 的局面，而显然，利用这个例子，我们可以轻松的构造一个字符串使得 $x+y$ 相差为 $1$ 的 $x$ 的范围差别很大（指上下界差别很大）。</p>
<p>那难道是在 $x+y=\left\lceil\frac{n}{2}\right\rceil$ 时才会发生这种情况吗？</p>
<p>不对，可以通过类似的方法，构造出 $x+y-\left\lceil\frac{n}{2}\right\rceil$ 任意大的错误例子：</p>
<p>核心思路是：开头若干个 $11$ 提供多出来的 $1$ ，然后一个单独的 $0$ 消耗 $1$ ，然后若干个 $0110$ 加大相邻两个单独的 $1$ 之间的距离，然后再放一个单独的 $0$ 循环往复。</p>
<p>上面例子拆分就是：$11/11/0/0110/0110/0110/0$ ，为什么这个需要花多步呢？</p>
<p>因为每次尝试把 $1$ 放到 $0$ 上面时，会发现影响只是整体右移，不会导致最后手里有多余的 $1$ （因为注意到如果最后手中有多余的 $1$ ，就可以删除这个 $1$ 证明在 $x+y$ 插值绝对值不超过 $1$ 的情况下， $x$ 的上下界差值的绝对值也不超过 $1$）。</p>
<p>这里实操一下就知道了：</p>
<p>$11/11/0/0110/0110/0110/0\to 10/11/1/0110/0110/0110/0\to 10/11/1011/0/0110/0110/0$</p>
<p>而最后能多出 $1$ 一定是通过移动把两个单独的 $0$ 放到了一起，然后再放一个 $1$ 同时把两个单独的 $0$ 用一个 $1$ 解决了，从而节省一个 $1$ 。但是这个移动的过程所花费的大量的移动就已经足够把相邻 $x+y$ 的 $x$ 的上下界拉得足够大了。</p>
<p>所以不固定 $x+y$ 的情况下 $(x+y,x)$ 的范围不一定是好的。</p>
<p>虽然但是，上面的反例似乎只是说明这种方法无法证明范围是好的，也许范围就是好的，或者部分好的，只是方法问题？不知道，感觉这个的证明或者证伪已经超出了博主目前的实力范围了。</p>
<p>但是还是用代码验证一下刚才的那个说法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> LL mod = <span class="number">998244353</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">3e2</span> + <span class="number">5</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_char_array</span><span class="params">(<span class="type">char</span> *s)</span></span>&#123;</span><br><span class="line">    <span class="type">char</span> ss[N];</span><br><span class="line">    cin &gt;&gt; ss;</span><br><span class="line">    <span class="built_in">memcpy</span>(s + <span class="number">1</span>, ss, <span class="built_in">sizeof</span>(<span class="type">char</span>) * (<span class="built_in">strlen</span>(ss) + <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool</span> dp[N][N][N];</span><br><span class="line"><span class="type">char</span> st[N];</span><br><span class="line"><span class="type">int</span> n, cnt0[N], cnt1[N], las[N][N];</span><br><span class="line"><span class="type">int</span> ll[N], rr[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">get_char_array</span>(st); n = <span class="built_in">strlen</span>(st + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = n; i &gt;= <span class="number">1</span>; i--)&#123;</span><br><span class="line">        cnt0[i] += cnt0[i + <span class="number">1</span>] + (st[i] == <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        cnt1[i] += cnt1[i + <span class="number">1</span>] + (st[i] == <span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">        las[cnt0[i]][cnt1[i]] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = i / <span class="number">2</span>; j &gt;= <span class="number">0</span>; j--)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k = i / <span class="number">2</span> - j; k &gt;= <span class="number">0</span>; k--)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!dp[i][j][k]) <span class="keyword">continue</span>;</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="type">int</span> c0 = cnt0[i + <span class="number">1</span>] + j, c1 = cnt1[i + <span class="number">1</span>] + k;</span><br><span class="line">                    <span class="keyword">if</span>(c0 + c1) las[c0][c1] = <span class="built_in">max</span>(las[c0][c1], i + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(i + <span class="number">2</span> &lt;= n)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(st[i + <span class="number">1</span>] == <span class="string">&#x27;0&#x27;</span> || st[i + <span class="number">2</span>] == <span class="string">&#x27;0&#x27;</span>) dp[i + <span class="number">2</span>][j + <span class="number">1</span>][k] = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">if</span>(st[i + <span class="number">1</span>] == <span class="string">&#x27;1&#x27;</span> || st[i + <span class="number">2</span>] == <span class="string">&#x27;1&#x27;</span>) dp[i + <span class="number">2</span>][j][k + <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(j &gt;= <span class="number">1</span> &amp;&amp; j + k &gt;= <span class="number">2</span>) dp[i][j - <span class="number">1</span>][k] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(k &gt;= <span class="number">1</span> &amp;&amp; j + k &gt;= <span class="number">2</span>) dp[i][j][k - <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(i + <span class="number">1</span> &lt;= n)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(j || k) dp[i + <span class="number">1</span>][j][k] = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">if</span>(st[i + <span class="number">1</span>] == <span class="string">&#x27;0&#x27;</span> &amp;&amp; k) dp[i + <span class="number">1</span>][j + <span class="number">1</span>][k - <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">if</span>(st[i + <span class="number">1</span>] == <span class="string">&#x27;1&#x27;</span> &amp;&amp; j) dp[i + <span class="number">1</span>][j - <span class="number">1</span>][k + <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n / <span class="number">2</span>; i++) ll[i] = n + <span class="number">1</span>, rr[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> l = <span class="number">0</span>; l &lt;= n / <span class="number">2</span>; l++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> r = <span class="number">0</span>; l + r &lt;= n / <span class="number">2</span>; r++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dp[n][l][r]) ll[l + r] = <span class="built_in">min</span>(ll[l + r], l), rr[l + r] = <span class="built_in">max</span>(rr[l + r], l);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n / <span class="number">2</span>; i++)&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;x + y = &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; : [&quot;</span> &lt;&lt; ll[i] &lt;&lt; <span class="string">&quot; , &quot;</span> &lt;&lt; rr[i] &lt;&lt; <span class="string">&quot;]&quot;</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">input:</span><br><span class="line"></span><br><span class="line">111111110011001100110011001100110001100110011001100110011000110011001100110011001100011001100110011001100110</span><br><span class="line"></span><br><span class="line">output:</span><br><span class="line">x + y = 1 : [0 , 1]</span><br><span class="line">x + y = 2 : [0 , 2]</span><br><span class="line">x + y = 3 : [0 , 3]</span><br><span class="line">x + y = 4 : [0 , 4]</span><br><span class="line">x + y = 5 : [0 , 5]</span><br><span class="line">x + y = 6 : [0 , 6]</span><br><span class="line">x + y = 7 : [0 , 7]</span><br><span class="line">x + y = 8 : [0 , 8]</span><br><span class="line">x + y = 9 : [0 , 9]</span><br><span class="line">x + y = 10 : [0 , 10]</span><br><span class="line">x + y = 11 : [0 , 11]</span><br><span class="line">x + y = 12 : [0 , 12]</span><br><span class="line">x + y = 13 : [0 , 13]</span><br><span class="line">x + y = 14 : [0 , 14]</span><br><span class="line">x + y = 15 : [0 , 15]</span><br><span class="line">x + y = 16 : [0 , 16]</span><br><span class="line">x + y = 17 : [0 , 17]</span><br><span class="line">x + y = 18 : [0 , 18]</span><br><span class="line">x + y = 19 : [0 , 19]</span><br><span class="line">x + y = 20 : [0 , 20]</span><br><span class="line">x + y = 21 : [0 , 21]</span><br><span class="line">x + y = 22 : [0 , 22]</span><br><span class="line">x + y = 23 : [0 , 23]</span><br><span class="line">x + y = 24 : [0 , 24]</span><br><span class="line">x + y = 25 : [0 , 25]</span><br><span class="line">x + y = 26 : [0 , 26]</span><br><span class="line">x + y = 27 : [0 , 27]</span><br><span class="line">x + y = 28 : [0 , 28]</span><br><span class="line">x + y = 29 : [0 , 29]</span><br><span class="line">x + y = 30 : [0 , 30]</span><br><span class="line">x + y = 31 : [0 , 31]</span><br><span class="line">x + y = 32 : [0 , 32]</span><br><span class="line">x + y = 33 : [0 , 33]</span><br><span class="line">x + y = 34 : [0 , 34]</span><br><span class="line">x + y = 35 : [0 , 35]</span><br><span class="line">x + y = 36 : [0 , 36]</span><br><span class="line">x + y = 37 : [0 , 37]</span><br><span class="line">x + y = 38 : [0 , 38]</span><br><span class="line">x + y = 39 : [0 , 39]</span><br><span class="line">x + y = 40 : [0 , 40]</span><br><span class="line">x + y = 41 : [0 , 41]</span><br><span class="line">x + y = 42 : [0 , 42]</span><br><span class="line">x + y = 43 : [0 , 43]</span><br><span class="line">x + y = 44 : [0 , 44]</span><br><span class="line">x + y = 45 : [0 , 45]</span><br><span class="line">x + y = 46 : [0 , 46]</span><br><span class="line">x + y = 47 : [0 , 47]</span><br><span class="line">x + y = 48 : [0 , 48]</span><br><span class="line">x + y = 49 : [0 , 49]</span><br><span class="line">x + y = 50 : [0 , 50]</span><br><span class="line">x + y = 51 : [0 , 51]</span><br><span class="line">x + y = 52 : [0 , 52]</span><br><span class="line">x + y = 53 : [7 , 45]</span><br><span class="line">x + y = 54 : [14 , 38]</span><br></pre></td></tr></table></figure>
<p>至少从例子上来看，范围不是绝对好的，至于是不是部分好的，这就不在我能力范围之内了。</p></div></details>
<p>证完了，看看题解。</p>
<p>看完了，基本一致。</p>
<p>但是看到一份很短的代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MOD=<span class="number">998244353</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> &amp;x,<span class="type">int</span> v)</span></span>&#123;((x+=v)&gt;=MOD)&amp;&amp;(x-=MOD);&#125;</span><br><span class="line"><span class="type">int</span> n,ok[<span class="number">305</span>][<span class="number">305</span>][<span class="number">305</span>],dp[<span class="number">305</span>][<span class="number">305</span>][<span class="number">305</span>],res;</span><br><span class="line"><span class="type">char</span> s[<span class="number">305</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s+<span class="number">1</span>);n=<span class="built_in">strlen</span>(s+<span class="number">1</span>);ok[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="keyword">for</span>(<span class="type">int</span> j=n;~j;j--)<span class="keyword">for</span>(<span class="type">int</span> k=n;~k;k--)&#123;</span><br><span class="line">		ok[i][j][k]|=ok[i<span class="number">-1</span>][j][k];</span><br><span class="line">		ok[i][j][k]|=ok[i][j+<span class="number">1</span>][k];</span><br><span class="line">		ok[i][j][k]|=ok[i][j][k+<span class="number">1</span>];</span><br><span class="line">		<span class="keyword">if</span>(j&amp;&amp;i&gt;=<span class="number">2</span>&amp;&amp;(s[i]==<span class="string">&#x27;0&#x27;</span>||s[i<span class="number">-1</span>]==<span class="string">&#x27;0&#x27;</span>))ok[i][j][k]|=ok[i<span class="number">-2</span>][j<span class="number">-1</span>][k];</span><br><span class="line">		<span class="keyword">if</span>(k&amp;&amp;i&gt;=<span class="number">2</span>&amp;&amp;(s[i]==<span class="string">&#x27;1&#x27;</span>||s[i<span class="number">-1</span>]==<span class="string">&#x27;1&#x27;</span>))ok[i][j][k]|=ok[i<span class="number">-2</span>][j][k<span class="number">-1</span>];</span><br><span class="line">		<span class="keyword">if</span>(j&amp;&amp;s[i]==<span class="string">&#x27;0&#x27;</span>)ok[i][j][k]|=ok[i<span class="number">-1</span>][j<span class="number">-1</span>][k+<span class="number">1</span>];</span><br><span class="line">		<span class="keyword">if</span>(k&amp;&amp;s[i]==<span class="string">&#x27;1&#x27;</span>)ok[i][j][k]|=ok[i<span class="number">-1</span>][j+<span class="number">1</span>][k<span class="number">-1</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	dp[n][<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=n;i;i--)<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=n;j++)<span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;=n;k++)&#123;</span><br><span class="line">		<span class="built_in">add</span>(dp[i<span class="number">-1</span>][j][k],dp[i][j][k]);</span><br><span class="line">		<span class="keyword">if</span>(s[i]==<span class="string">&#x27;0&#x27;</span>)<span class="built_in">add</span>(dp[i][j][k+<span class="number">1</span>],dp[i][j][k]);</span><br><span class="line">		<span class="keyword">if</span>(s[i]==<span class="string">&#x27;1&#x27;</span>)<span class="built_in">add</span>(dp[i][j+<span class="number">1</span>][k],dp[i][j][k]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;i++)<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=n;j++)<span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;=n;k++)</span><br><span class="line">		<span class="keyword">if</span>(ok[i][j][k])<span class="built_in">add</span>(res,dp[i][j][k]);</span><br><span class="line">	<span class="built_in">add</span>(res,MOD<span class="number">-1</span>);<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,res);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//https://www.luogu.com.cn/article/vjo8hwnx</span></span><br></pre></td></tr></table></figure>
<p>很厉害啊，就算不压行也比我的短。</p>
<p>可以从我的做法导出这个写法是对的。但考场上我是不会这么写的，主要是不稳，本来做法就需要证明，现在还要写一份需要证明的代码，这在考场上性价比是不高的，万一代码实际上计多了或少了，就又得花时间，所以我不会在考场上写这种代码。</p>
<p>但是在考场外用来观赏或者炫技的话，美观度确实是拉满了，可以学习一下。</p>
<p>至于为什么这样写是对的，不难证明，在此就不再赘述了。</p></div></details>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
  </entry>
  <entry>
    <title>AGC062 B. Split and Insert</title>
    <url>/2023/09/01/AGC062-B-Split-and-Insert/</url>
    <content><![CDATA[<p>题目链接：<a href="https://atcoder.jp/contests/agc062/tasks/agc062_b">https://atcoder.jp/contests/agc062/tasks/agc062_b</a></p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>非常有意思的一道题目。</p>
<p>我们考虑一个序列被切割以后进入一种如放的状态，简单来说就是我手里现在有两个序列可以拼起来。</p>
<p>当操作一次后会发现手里的两个序列变成了四个序列，而代价实际上就是原来两个序列裂成两个序列的代价之和（因为代价的计算公式是一次式）。</p>
<p>因此，显然，我们要把原串切成一堆上升序列，而代价都是可以自己独立统计后再加起来的，直接上区间 DP ，时间复杂度：$O(Kn^3)$ 。</p>
<p>无解的充分必要条件：最少的上升序列个数 $&gt;2^K$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 110</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line">LL dp[N][N][N],C[N];</span><br><span class="line"><span class="type">int</span> n,K,a[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;K);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=K;i++)<span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;C[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="type">int</span> x;<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">        a[x]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// for(int i=1;i&lt;=n;i++)printf(&quot;%d &quot;,a[i]);</span></span><br><span class="line">    <span class="comment">// printf(&quot;\n&quot;);</span></span><br><span class="line">    <span class="built_in">memset</span>(dp,<span class="number">20</span>,<span class="built_in">sizeof</span>(dp));</span><br><span class="line">    <span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i]&gt;a[i+<span class="number">1</span>])cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=K;i++)cnt&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(cnt)&#123;<span class="built_in">printf</span>(<span class="string">&quot;-1\n&quot;</span>);<span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        dp[K+<span class="number">1</span>][i][i]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[j]&lt;a[j<span class="number">-1</span>])<span class="keyword">break</span>;</span><br><span class="line">            dp[K+<span class="number">1</span>][i][j]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> t=K;t&gt;=<span class="number">1</span>;t--)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i;j&lt;=n;j++)&#123;</span><br><span class="line">                dp[t][i][j]=dp[t+<span class="number">1</span>][i][j];</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k=i;k&lt;j;k++)dp[t][i][j]=<span class="built_in">min</span>(dp[t+<span class="number">1</span>][i][k]+dp[t+<span class="number">1</span>][k+<span class="number">1</span>][j]+(j-k)*C[t],dp[t][i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// for(int i=1;i&lt;=K+1;i++)&#123;</span></span><br><span class="line">    <span class="comment">//     for(int j=1;j&lt;=n;j++)&#123;</span></span><br><span class="line">    <span class="comment">//         for(int k=j;k&lt;=n;k++)printf(&quot;%d %d %d:%lld\n&quot;,i,j,k,dp[i][j][k]);</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,dp[<span class="number">1</span>][<span class="number">1</span>][n]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></details>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
  </entry>
  <entry>
    <title>AGC061 B. Summation By Construction</title>
    <url>/2023/09/06/AGC061-B-Summation-By-Construction/</url>
    <content><![CDATA[<p>题目链接：<a href="https://atcoder.jp/contests/agc061/tasks/agc061_b">https://atcoder.jp/contests/agc061/tasks/agc061_b</a></p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>Mad，纯纯折磨题。</p>
<p>首先，$n=2$ 的时候是无解的，因为连出 $i=2$ 的路径后剩下的两条边无法连到一起。</p>
<p>做法的核心思想是，将两条路径拼到一起，考虑找出一个更长的路径，然后再拆开。</p>
<p>例如奇数的情况，是把路径拼成 $\frac{n+1}{2}$ 条长度为 $2n$ 的路径，然后拆出结果。</p>
<p>做法就是，下面分别从 $1,3,5..$ 开时重复连 M 型。（下面默认二分图上面部分有 $n$ 个点，下面部分有 $n+1$ 个点）</p>
<p>$n=5$ 的情况如下：</p>
<p><img src="1.png" alt=""></p>
<p>然后当时因为 $2$ 无解，而且偶数的情况我想不出来，感觉应该是无解，然后还证明了，然后就写了交上去，WA飞了，百思不得其解，下了数据才发现除了 $2$ 都有解，但是由于已经忘了怎么证了，也就不知道证明哪里假了。</p>
<p>所以，在做这种题目的时候，不能因为没想出来就主观认为无解（不然你猜猜这道题目的评级为什么 3000+ ），还是应该写个暴力或者手动再验证几组数据再下结论。</p>
<p>那么偶数怎么做呢？</p>
<p>同样的思路，我们发现 $i=n$ 一定会在下面产生两个奇数点，需要一条路径消掉，所以不妨考虑处理 $\frac{n}{2}+2$ 条路经，其中 $\frac{n}{2}-1$ 条处理上面为起终点的长度为 $2(n-1)$ 的路径，然后剩下三条路径一条以上面剩下两个奇数点为起终点，两条在下面。</p>
<p>首先是 $\frac{n}{2}-1$ 的路径，在上面分别以 $3,5,7…$ 为起点，以下面的 $n-1$ 个点为中转点抛出类似 M 的路径，被去掉的 $2$ 个点也是有规律的，按照 $(n-2,n-1),(n-4,n-3)…$ 这样下去。</p>
<p>剩下的边可以凑数长度为 $4,2n,2(n-3)$ 的路径，至于怎么凑，看代码吧。</p>
<p>时间复杂度：$O(Tn^2)$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 110</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NN 210</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> v[N][N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> T;<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">2</span>)&#123;<span class="built_in">printf</span>(<span class="string">&quot;No\n&quot;</span>);<span class="keyword">continue</span>;&#125;</span><br><span class="line">        <span class="keyword">if</span>(n&amp;<span class="number">1</span>)&#123;</span><br><span class="line">           <span class="type">int</span> x=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i+i&lt;=n;i++)&#123;</span><br><span class="line">                <span class="type">int</span> cnt=<span class="number">0</span>;<span class="type">int</span> y=x;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">                    cnt++;</span><br><span class="line">                    <span class="keyword">if</span>(cnt&lt;=i+i)v[j][y]=i;</span><br><span class="line">                    <span class="keyword">else</span> v[j][y]=n-i;</span><br><span class="line">                    cnt++;y++;<span class="keyword">if</span>(y==n+<span class="number">2</span>)y=<span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">if</span>(cnt&lt;=i+i)v[j][y]=i;</span><br><span class="line">                    <span class="keyword">else</span> v[j][y]=n-i;</span><br><span class="line">                &#125;</span><br><span class="line">                x+=<span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="type">int</span> pre=<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n/<span class="number">2</span>;i++)&#123;</span><br><span class="line">                <span class="type">int</span> x=i*<span class="number">2</span>+<span class="number">1</span>,t=n-i*<span class="number">2</span>,y=<span class="number">1</span>,cnt=pre+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span>(cnt==<span class="number">2</span> || cnt==n<span class="number">-3</span>)cnt++;</span><br><span class="line">                pre=cnt;</span><br><span class="line">                <span class="type">int</span> type=cnt;</span><br><span class="line">                <span class="comment">// printf(&quot;%d %d %d\n&quot;,x,y,t);</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;n;j++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(j&gt;cnt)type=n<span class="number">-1</span>-cnt;</span><br><span class="line">                    v[x][y]=type;</span><br><span class="line">                    x++;<span class="keyword">if</span>(x==n+<span class="number">1</span>)x=<span class="number">1</span>;</span><br><span class="line">                    <span class="comment">// printf(&quot;%d %d %d\n&quot;,x,y,t);</span></span><br><span class="line">                    v[x][y]=type;</span><br><span class="line">                    y++;<span class="keyword">if</span>(y==n+<span class="number">2</span>)y=<span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">while</span>(y==t || y==t+<span class="number">1</span>)&#123;y++;<span class="keyword">if</span>(y==n+<span class="number">2</span>)y=<span class="number">1</span>;&#125;</span><br><span class="line">                    <span class="comment">// printf(&quot;%d %d %d\n&quot;,x,y,t);</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            v[<span class="number">1</span>][<span class="number">1</span>]=v[<span class="number">1</span>][<span class="number">2</span>]=v[n][<span class="number">2</span>]=v[n][n+<span class="number">1</span>]=n;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n<span class="number">-2</span>;i++)v[n-i][n+<span class="number">2</span>-i]=v[n-i][n+<span class="number">1</span>-i]=n;</span><br><span class="line">            v[<span class="number">2</span>][<span class="number">1</span>]=v[<span class="number">2</span>][<span class="number">2</span>]=v[<span class="number">3</span>][<span class="number">2</span>]=v[<span class="number">3</span>][<span class="number">3</span>]=<span class="number">2</span>;</span><br><span class="line">            v[<span class="number">1</span>][<span class="number">3</span>]=v[<span class="number">4</span>][<span class="number">3</span>]=n<span class="number">-3</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">4</span>;i&lt;n;i++)v[i][i]=v[i+<span class="number">1</span>][i]=n<span class="number">-3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Yes\n&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n+<span class="number">1</span>;j++)<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,v[i][j]);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>回顾：</p>
<p>这道题目其实还是挺有难度的，回顾一下做题过程纪念纪念自己花了这么久时间做出来的一道题目。</p>
<p>而且这道题目的做题过程其实也可以推广到很多存在性构造题上。</p>
<p>首先看到一个构造题，尤其是比较难的构造题，如果直接从其的题目条件出发很多时候不一定能做，因为情况太多，太过复杂和没有规律，这个时候就需要把问题缩小到一个有规律的题目上面，只不过这种缩小有时候可能会无解。</p>
<p>例如奇数的情况我就认为一定存在一种方案使得路径能够连接成 $\frac{n+1}{2}$ 条长度为 $2n$ 的路径，从而把题目变成了一个有规律更好想的题目，但是这种缩小有时候不一定正确，思考缩小的过程也是凭直觉，比较感性，灵感往往来源于自己手动模拟多次后作出的猜想。</p>
<p>再例如，我认为偶数也可以拼成 $\frac{n}{2}$ 条长度为 $2(n-1)$ 的路径，但是却发现剩下的边构成了一个环（事实上想想也知道肯定不是路径，因为此时图中不存在奇数度的点），那么就把一条路径放回去，尝试人为的构造出三条路径。</p>
<p>而且这一步从度数的角度考虑也非常的正确，因为 $i=n$ 的路径一定会在下面创造一对奇数度点，所以我们必须把上面一条由两条路径拼成的路径拆回两条，一条占住他们本来的奇数度点，一条下来消掉 $i=n$ 创造的奇数度点。</p>
<p>然后通过这个操作，问题规模就缩小很多了，接下来就可以自己不断手模求一个通用解了，这样偶数的情况也就搞定了。</p>
<p>所以构造题，往往就是你自己再给题目加上一些约束条件，看看能否找到一个解，找不到就不断调整约束条件，直到找到为止。</p>
</div></details>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>构造</tag>
        <tag>二分图</tag>
      </tags>
  </entry>
  <entry>
    <title>AGC063 B. Insert 1, 2, 3, ...</title>
    <url>/2023/08/25/AGC063-B-Insert-1-2-3/</url>
    <content><![CDATA[<p>题目链接：<a href="https://atcoder.jp/contests/agc063/tasks/agc063_b">https://atcoder.jp/contests/agc063/tasks/agc063_b</a></p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>对于一个序列的检验，我们可以认为是每次选择一个递增序列，删掉，看最后能不能删完，能删完就是合法序列。</p>
<p>证明两个定理：</p>
<ol>
<li>假如我在后面某步删除了某个序列，且这个序列在现在就存在且能删除，那么现在直接删除不会影响最终判断。<br>例如：1231234，我先删了 123 再删除 1234，但是其实一开始就能删除 1234，那么我一开始就删除 1234 不会影响最终判断。</li>
<li>加入我在某一步删除了一个序列，那么如果我在之前的某一步的瞬间突然删除掉了这个序列某一个后缀，不会导致将原本合法的序列判断为不合法。<br>例如：1231212456 ，显然删除顺序是：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure></div></details>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
  </entry>
  <entry>
    <title>AGC064 D. Red and Blue Chips</title>
    <url>/2023/09/07/AGC064-D-Red-and-Blue-Chips/</url>
    <content><![CDATA[<p>题目链接：<a href="https://atcoder.jp/contests/agc064/tasks/agc064_d">https://atcoder.jp/contests/agc064/tasks/agc064_d</a></p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>Mad，做这道题目的时候把某个定理想错了，想的既错误又复杂，笑死，根本不会做，后面发现想错了，就简单很多了，不久就知道怎么做了。</p>
<p>定理1：假如给每个 B 标号，那么最终的芯片排列中 B 的不同排列有 $(n-1)!$ 种，因为最底下的 B 是固定的，而且每个排列对应一种操作方式（指的是 B 的操作方式）。（这个定理解决了 B 的位置）</p>
<p>定理2：我们定义最终排列中 B 下面的 R 的数量为其的权值，那么前 $i$ 个 B 的权值不超过第 $i$ 个 B 前面的 R 的数量，且只要满足这个要求，就一定能够构造出来。（这个定理解决了 R 的位置）</p>
<p>定理2的构造方法是在放第 $i$ 个 B 之前提前把芯片放到他即将覆盖的 B 的上面就行了，不难发现，在第 $i$ 个 B 放之前一定能放，不管即将被覆盖的 B 怎么移动，同时覆盖了之后一定不能再放。</p>
<p>那么接下来就是怎么做的问题了，显然求出每个 $B$ 的权值然后排列就行了，不难发现，我们可以人为的规定权值非严格单调递增。</p>
<p>接下来我的 DP 是：$dp[i][j][k]$ 表示前 $i$ 个 B 被考虑过了，前面还有 $j$ 个 R ，同时第 $i$ 个芯片的权值为 $k$ 。</p>
<p>不难发现 $k-&gt;k+1$ 的更新最多跑 $\frac{n}{k+1}$ 步，然后就会触发无法放置然后终止后续的更新。</p>
<p>所以这里有个调和级数，时间复杂度： $O(n^3\log{n})$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 310</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> LL mod=<span class="number">998244353</span>;</span><br><span class="line">LL nfc[N],fc[N];</span><br><span class="line">LL dp[N][N][N];</span><br><span class="line"><span class="type">int</span> n,m,a[N];</span><br><span class="line"><span class="type">char</span> st[N];</span><br><span class="line"><span class="function">LL <span class="title">C</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;<span class="keyword">return</span> fc[x]*nfc[y]%mod*nfc[x-y]%mod;&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%s&quot;</span>,&amp;n,st+<span class="number">1</span>);</span><br><span class="line">    fc[<span class="number">0</span>]=fc[<span class="number">1</span>]=nfc[<span class="number">0</span>]=nfc[<span class="number">1</span>]=<span class="number">1</span>;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)nfc[i]=nfc[mod%i]*(mod-mod/i)%mod;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)nfc[i]=nfc[i<span class="number">-1</span>]*nfc[i]%mod,fc[i]=fc[i<span class="number">-1</span>]*i%mod;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(st[i]==<span class="string">&#x27;B&#x27;</span>)m++;</span><br><span class="line">        <span class="keyword">else</span> a[m+<span class="number">1</span>]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)a[i]+=a[i<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">        dp[i][a[i]][<span class="number">0</span>]=<span class="built_in">C</span>(m<span class="number">-1</span>,i);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=a[i];j++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=a[m<span class="number">-1</span>];k++)dp[i][j][k]=(dp[i][j][k]+dp[i][j][k<span class="number">-1</span>])%mod;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=a[i];j++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=a[m<span class="number">-1</span>];k&gt;=<span class="number">1</span>;k--)&#123;</span><br><span class="line">                <span class="type">int</span> t=k<span class="number">-1</span>,now=j;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> q=i+<span class="number">1</span>;q&lt;m;q++)&#123;</span><br><span class="line">                    now+=a[q]-a[q<span class="number">-1</span>]-k;<span class="keyword">if</span>(now&lt;<span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">                    dp[q][now][k]=(dp[q][now][k]+dp[i][j][t]*<span class="built_in">C</span>(m<span class="number">-1</span>-i,q-i))%mod;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    LL ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=a[m<span class="number">-1</span>];i++)ans=(ans+dp[m<span class="number">-1</span>][i][a[m<span class="number">-1</span>]])%mod;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然而一翻题解，发现题解的复杂度没有 $\log$ ，于是我又去优化。</p>
<p>然后就改了一个地方，就是对于 $i$ ，实际上能够更新到答案的有效的 $i$ 只会到 $n-\frac{n}{k}$ 左右。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 310</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> LL mod=<span class="number">998244353</span>;</span><br><span class="line">LL nfc[N],fc[N];</span><br><span class="line">LL dp[N][N][N];</span><br><span class="line"><span class="type">int</span> n,m,a[N];</span><br><span class="line"><span class="type">char</span> st[N];</span><br><span class="line"><span class="function">LL <span class="title">C</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;<span class="keyword">return</span> fc[x]*nfc[y]%mod*nfc[x-y]%mod;&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%s&quot;</span>,&amp;n,st+<span class="number">1</span>);</span><br><span class="line">    fc[<span class="number">0</span>]=fc[<span class="number">1</span>]=nfc[<span class="number">0</span>]=nfc[<span class="number">1</span>]=<span class="number">1</span>;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)nfc[i]=nfc[mod%i]*(mod-mod/i)%mod;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)nfc[i]=nfc[i<span class="number">-1</span>]*nfc[i]%mod,fc[i]=fc[i<span class="number">-1</span>]*i%mod;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(st[i]==<span class="string">&#x27;B&#x27;</span>)m++;</span><br><span class="line">        <span class="keyword">else</span> a[m+<span class="number">1</span>]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)a[i]+=a[i<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">        dp[i][a[i]][<span class="number">0</span>]=<span class="built_in">C</span>(m<span class="number">-1</span>,i);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=a[i];j++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=a[m<span class="number">-1</span>];k++)dp[i][j][k]=(dp[i][j][k]+dp[i][j][k<span class="number">-1</span>])%mod;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i!=m<span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=a[i];j++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k=(a[m<span class="number">-1</span>]-a[i]+j)/(m<span class="number">-1</span>-i);k&gt;=<span class="number">1</span>;k--)&#123;</span><br><span class="line">                    <span class="type">int</span> t=k<span class="number">-1</span>,now=j;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> q=i+<span class="number">1</span>;q&lt;m;q++)&#123;</span><br><span class="line">                        now+=a[q]-a[q<span class="number">-1</span>]-k;<span class="keyword">if</span>(now&lt;<span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">                        dp[q][now][k]=(dp[q][now][k]+dp[i][j][t]*<span class="built_in">C</span>(m<span class="number">-1</span>-i,q-i))%mod;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    LL ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=a[m<span class="number">-1</span>];i++)ans=(ans+dp[m<span class="number">-1</span>][i][a[m<span class="number">-1</span>]])%mod;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么这个复杂度是多少呢？答案是 $O(n^3)$ 。</p>
<p>因为我们不妨考虑枚举 $k$ ，那么有效的 $i$ 有 $O(\frac{n}{k})$ 个，向后转移就平方 $O(n*(\sum\limits_{k=1}^n\frac{n^2}{k^2}))=O(n^3\sum\limits_{i=1}^n\frac{1}{i^2})=O(n^3)$ 。</p>
<p>奇妙吧，这就是时间复杂度分析的美妙之处，一个看似只改变常数的优化竟然能优化掉复杂度中的一个 $\log$ ，实在是奇妙无比。</p>
</div></details>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>计数</tag>
        <tag>DP</tag>
        <tag>经典trick</tag>
      </tags>
  </entry>
  <entry>
    <title>AGC066 D. A Independent Set</title>
    <url>/2024/05/13/AGC066-D-A-Independent-Set/</url>
    <content><![CDATA[<p>题目链接：<a href="https://atcoder.jp/contests/agc066/tasks/agc066_d">https://atcoder.jp/contests/agc066/tasks/agc066_d</a></p>
<p>题目大意：给你一个 $AB$ 串，保证 $A\le \frac{n + 1}{2}$ ，每次可以交换 $i$ 和 $i + 1$ 的字符，代价为 $w_{i + 1}$ ，要求最小的代价满足：任意两个 $A$ 不相邻。</p>
<details class="toggle" ><summary class="toggle-button" style="">我的做法</summary><div class="toggle-content"><p>观察到一个事情：考任意一种可能成为最优方案的方案，一定可以表示成某几个位置的展开。</p>
<p>展开的意思是是说：选择一个 $A$ ，然后从左到右依次将 $A$ 推开，直到某个小区间内没有 $A$ 相邻。</p>
<p>举个例子：$BBBAAABBB$ ，选择中间的 $A$ ，那么中间的 $A$ 就会想着把周围的 $A$ 推开，推成：$BBABABABB$ 。</p>
<p>证明的话，考虑每个 $A$ 是往左移还是往右移的，显然，每一段往左移和每一段往右移中间存在一个数字是不动，否则一定可以更加优秀，所以，每一个不动和左边的往左移动，和右边的往右移动构成了上面所描述的一个小区间。</p>
<p>那么处理出所有的这些区间就行了，处理方法就是把 $A$ 看成 $1$ ，把 $B$ 看成 $-1$ ，然后在折线法左右第一次出现等高的位置，就是区间的左右端点。</p>
<p>然后转移就行了，时间复杂度 ： $O(n)$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span> + <span class="number">5</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_char_array</span><span class="params">(<span class="type">char</span> *s)</span></span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">char</span> st[N];</span><br><span class="line">    cin &gt;&gt; st;</span><br><span class="line">    <span class="built_in">memcpy</span>(s + <span class="number">1</span>, st, <span class="built_in">sizeof</span>(<span class="type">char</span>) * <span class="built_in">strlen</span>(st));</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> y, next;</span><br><span class="line">    LL c;</span><br><span class="line">&#125;a[N]; <span class="type">int</span> len, las[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ins</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, LL c)</span></span>&#123;a[++len] = &#123;y, las[x], c&#125;; las[x] = len;&#125;</span><br><span class="line"><span class="type">char</span> st[N];</span><br><span class="line"><span class="type">int</span> pre[N * <span class="number">2</span>], val[N];</span><br><span class="line"><span class="type">int</span> ll[N], rr[N];</span><br><span class="line">LL cost[N], f1[N], f2[N];</span><br><span class="line">LL dp[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        cin &gt;&gt; n;</span><br><span class="line">        <span class="built_in">get_char_array</span>(st + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        n += <span class="number">2</span>;</span><br><span class="line">        st[<span class="number">1</span>] = st[n] = <span class="string">&#x27;B&#x27;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(st[i] == <span class="string">&#x27;A&#x27;</span>) val[i] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> val[i] = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        LL ans = <span class="number">0ll</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">3</span>; i &lt; n; i++)&#123;</span><br><span class="line">            cin &gt;&gt; cost[i];</span><br><span class="line">            cost[i] += cost[i - <span class="number">1</span>];</span><br><span class="line">            f1[i] = f1[i - <span class="number">2</span>] + cost[i];</span><br><span class="line">            f2[i] = f2[i - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(val[i] == <span class="number">1</span>) f2[i] = f2[i] + cost[i];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> sum = n;</span><br><span class="line">        <span class="built_in">fill</span>(pre + <span class="number">1</span>, pre + n + n + <span class="number">1</span>, <span class="number">-10ll</span>);</span><br><span class="line">        pre[n] = <span class="number">0ll</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            sum += val[i];</span><br><span class="line">            ll[i] = pre[sum] + <span class="number">1</span>;</span><br><span class="line">            pre[sum] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        sum = n;</span><br><span class="line">        <span class="built_in">fill</span>(pre + <span class="number">1</span>, pre + n + n + <span class="number">1</span>, <span class="number">-10ll</span>);</span><br><span class="line">        pre[n] = (n + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = n; i &gt;= <span class="number">1</span>; i--)&#123;</span><br><span class="line">            sum += val[i];</span><br><span class="line">            rr[i] = pre[sum] - <span class="number">1</span>;</span><br><span class="line">            pre[sum] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(st[i] == <span class="string">&#x27;A&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(ll[i] &gt;= <span class="number">0</span> &amp;&amp; rr[i] &gt;= <span class="number">-1</span>)&#123;</span><br><span class="line">                    LL val = ((f2[i] - f2[ll[i] - <span class="number">1</span>]) - (f1[i] - f1[ll[i] - <span class="number">1</span>])) +</span><br><span class="line">                             ((f1[rr[i] - <span class="number">1</span>] - f1[i - <span class="number">2</span>]) - (f2[rr[i] - <span class="number">1</span>] - f2[i - <span class="number">1</span>]));</span><br><span class="line">                    <span class="built_in">ins</span>(ll[i], rr[i], val);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">ins</span>(i - <span class="number">1</span>, i, <span class="number">0ll</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0ll</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) dp[i] = <span class="number">1e18</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k = las[i]; k; k = a[k].next)&#123;</span><br><span class="line">                <span class="type">int</span> y = a[k].y;</span><br><span class="line">                dp[y] = <span class="built_in">min</span>(dp[y], dp[i] + a[k].c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; dp[n] &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i++) las[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不懂啊，感觉完全不如 $BCE$ 难，奇怪的难度评价。</p>
</div></details>
<details class="toggle" ><summary class="toggle-button" style="">官方题解</summary><div class="toggle-content"><p>好吧，官方题解确实难想。</p>
<p>其先基于这么一个转化：如果在原字符串后面添上 $B$ ，那么原题可以转化为：花最小的代价使得原串可以被分割成 $AB,B$ 。</p>
<p>那么一个观察就是 $AB$ 中的 $A$ 一定不会跨过 $B$ ，否则 $A$ 与这个 $B$ 组合一定更优。</p>
<p>证明要详细写出来可能会比较麻烦，大致就是讨论一下，因为最优方案一定可以写成每个 $A$ 按顺序往某个方案移动，而且 $A/B$ 与 $A/B$ 之间不会交换，根据这个原理讨论一下就行了。</p>
<p>由这个观察，我们可以证明，满足这个观察的最优答案一定可以分成若干段，其中 $[l_i,r_i]$ 满足两个字符串在这个区间上的 $A,B$ 数量一样，且最终字符串要么是 $B$ ，要么是 $ABABAB…AB$ ，那么就能得到下面的 $dp$ 。</p>
<p>设 $dp[i]$ 表示前 $i$ 个字母变成可以分割成 $AB,B$ 的字符串最小代价。</p>
<p>如果 $i$ 后面是 $B$ ，则可以 $dp[i]\to dp[i+1]$ 。</p>
<p>或者可以在后面放 $AB$ ，根据上面的条件可以得到 $dp[i]\to dp[j]+cost(i+1,j)$ ，满足 $[i+1,j]$ 中的 $A,B$ 数量一样，可以注意到，等价于 $A$ 看成 $1$ ，$B$ 看成 $-1$ 后 $s_{i}=s_{j}$ ，而且又显然，$s_{i}$ 只需要更新到后面第一个满足要求的 $j$ 就行了，因为若 $j,k$ 都满足要求的话：$cost(i+1,k)=cost(i+1,j)+cost(j+1,k)$ ，所以只需要 $i\to j\to k$ 就行了。</p>
<p>至于算 $cost$ 的话，注意到，每一段的 $j$ 都是往一个方向移动的，所以可以很方便的算出 $cost$ 。（原因：根据上面的 $dp$ 过程不难得到，这一段的前缀和都是同号的，要么 $&gt;0$ ，要么 $&lt;0$ ，除了整段是 $=0$ 的）</p>
<p>综上，时间复杂度：$O(n)$ 。</p>
<p>这个做法比我的做法难想，但是比我的做法好写。</p>
<p>而且其中很多思考的细节是值得认真想想的，很有意义的一个做法，感觉能想明白这个做法对提升 $dp$ 能力很有帮助。</p>
</div></details>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
  </entry>
  <entry>
    <title>AGC063 A. Mex Game</title>
    <url>/2023/08/25/AGC063-A-Mex-Game/</url>
    <content><![CDATA[<p>题目链接：<a href="https://atcoder.jp/contests/agc063/tasks/agc063_a">https://atcoder.jp/contests/agc063/tasks/agc063_a</a></p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>显然，如果我是 $A$ ，我一定会把数字放在最小的没被堵上的 $B$ 。</p>
<p> $B$ 同理，最终结果为最小的没有被堵上的位置上面的字符。</p>
<p>时间复杂度：$O(n)$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 210000</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">char</span> st[N];<span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> now1,now2,now3;</span><br><span class="line"><span class="type">bool</span> v[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,st);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i&amp;<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span>(now1&lt;n &amp;&amp; st[now1]!=<span class="string">&#x27;B&#x27;</span>)now1++;</span><br><span class="line">            <span class="keyword">if</span>(now1&lt;=n)v[now1++]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(now2&lt;n &amp;&amp; st[now2]!=<span class="string">&#x27;A&#x27;</span>)now2++;</span><br><span class="line">            <span class="keyword">if</span>(now2&lt;=n)v[now2++]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(now3&lt;=n &amp;&amp; v[now3])now3++;</span><br><span class="line">        <span class="keyword">if</span>(!v[now3])&#123;</span><br><span class="line">            <span class="keyword">if</span>(st[now3]==<span class="string">&#x27;A&#x27;</span>)<span class="built_in">printf</span>(<span class="string">&quot;Alice\n&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;Bob\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></details>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>博弈</tag>
      </tags>
  </entry>
  <entry>
    <title>AGC063 C. Add Mod Operations</title>
    <url>/2023/09/01/AGC063-C-Add-Mod-Operations/</url>
    <content><![CDATA[<p>题目链接：<a href="https://atcoder.jp/contests/agc063/tasks/agc063_c">https://atcoder.jp/contests/agc063/tasks/agc063_c</a></p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>无解的充分必要条件：</p>
<p>存在 $i,j(i≠j)$ ，使得 $a_i=a_j,b_i≠b_j$ 。</p>
<p>有解时的构造方法：</p>
<p>设 $c_i$ 表示 $a_i$ 在 $a$ 序列里面从大到小排序的位置。</p>
<p>考虑构造一个这样的序列：$b_i+c_i*K$ ，$K$ 表示一个大于所有 $a$ 的数字。</p>
<p>然后最后全部模 $K$ 就行了。</p>
<p>怎么构造这个序列呢？考虑不算次数的情况，那么先把所有数字加个 INF ，然后每次让当前最大的数字变成 $0$，并且再变成 $0$ 之前加上这个数字与前一个变成 $0$ 的数字之间的间隔，然后就做完了。</p>
<p>然后只要精细化的处理一下这个过程，就可以办到恰好 $n$ 次做完这个过程。</p>
<p>时间复杂度：$O(n\log{n})$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 1100</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;LL,LL&gt; PLL;</span><br><span class="line"><span class="type">const</span> LL inf=<span class="number">1e16</span>;</span><br><span class="line">LL a[N],b[N];<span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> top,sta[N];LL now,d[N];</span><br><span class="line">PLL c[N];LL maxcost=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;<span class="keyword">return</span> a[x]&gt;a[y];&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;a[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;<span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;b[i]);maxcost=<span class="built_in">max</span>(maxcost,b[i]+<span class="number">1</span>);&#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="type">bool</span> bk=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>((a[j]==a[i]) &amp;&amp; (b[j]!=b[i]))&#123;<span class="built_in">printf</span>(<span class="string">&quot;No\n&quot;</span>);<span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line">            <span class="keyword">if</span>(j&lt;i &amp;&amp; a[j]==a[i])bk=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!bk)sta[++top]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(sta+<span class="number">1</span>,sta+top+<span class="number">1</span>,cmp);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;top;i++)d[i]=(top-i<span class="number">-1</span>)*maxcost+b[sta[i]];</span><br><span class="line">    now=inf;LL nowx=now%maxcost;now+=(b[sta[top]]-nowx+maxcost)%maxcost;now-=a[sta[top]];</span><br><span class="line">    c[top].second=maxcost;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Yes\n%d\n&quot;</span>,top);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=top;i&gt;=<span class="number">1</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i!=top)c[i].second=now+a[sta[i]];</span><br><span class="line">        <span class="keyword">if</span>(i!=<span class="number">1</span>)c[i].first=d[i<span class="number">-1</span>]-d[i],now-=c[i].first;</span><br><span class="line">    &#125;</span><br><span class="line">    c[<span class="number">1</span>].first=now;</span><br><span class="line">    <span class="keyword">if</span>(top==<span class="number">1</span>)c[<span class="number">1</span>].first%=c[<span class="number">1</span>].second;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=top;i++)<span class="built_in">printf</span>(<span class="string">&quot;%lld %lld\n&quot;</span>,c[i].first,c[i].second);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></details>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>构造</tag>
      </tags>
  </entry>
  <entry>
    <title>AGC065 D. Not Intersect</title>
    <url>/2024/02/11/AGC065-D-Not-Intersect/</url>
    <content><![CDATA[<p>题目链接：<a href="https://atcoder.jp/contests/agc065/tasks/agc065_d">https://atcoder.jp/contests/agc065/tasks/agc065_d</a></p>
<p>题目大意：圆上有 $n$ 个点，问有多少种连法，使得有 $m$ 条边且边不交叉（可以在端点处相交）</p>
<p>$n,m\le 10^7$ </p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>神仙组合意义，投降。</p>
<p>当 $m=0$ 或者 $m&gt;2n-3$ 时可以直接输出答案，下面默认 $n\ge 2,0&lt;m\le 2n-3$</p>
<p>设 $f_i$ 表示 $n$ 个点 $i$ 条边的答案，$g_i$ 表示 $n$ 个点 $i$ 条边且允许重边的答案。</p>
<p>显然有：$f_n=\sum\limits_{i=1}^n\binom{n-1}{i-1}g_i$</p>
<p>则由二项式反演有：$g_n=\sum\limits_{i=1}^{n}(-1)^{n-i}\binom{n-1}{i-1}f_i$ 。</p>
<p>现在考虑怎么计算 $g_i$ ，考虑边不能交叉这个条件，如果你足够智慧，你就会发现有一个结构很符合这个要求：栈。</p>
<p>现在我们用这么一个过程去描述连边的过程：</p>
<p>从 $1$ 到 $n$ ，到达 $i$ 的时候，先弹出栈内的若干元素，再往栈内加入若干个 $i$ ，到最后栈为空，如果 $i$ 在 $j$ 的时候弹出就代表了一条 $(i,j)$ 的边。</p>
<p>显然，这个过程一一对应，现在就是计数了。</p>
<p>可以发现，$1$ 只能入栈，$n$ 只能出栈，所以我们不妨改为 $n-1$ 次入栈和出栈。（接下来假设要求 $g_k$ 的值）</p>
<p>现在就是 $a_i$ 表示入栈的次数，$b_i$ 表示出栈的次数，满足：</p>
<script type="math/tex; mode=display">1\le i\le n-1,a_i\ge b_i,0\le a_i,b_i \le k,a_i\le a_{i+1},b_i\le b_{i+1},a_{n-1}=b_{n-1}=k</script><p>显然，一个合法的 $a$ 序列代表了一条从 $(0,0)$ 到 $(n-2,k)$ 只能向右或者向上的的路径，$b$ 同理。</p>
<p>则一个合法的 $a,b$ 序列对应了两条合法的路径，且满足一条路径始终在另外一条路径下端。</p>
<p>可以发现，我们设 $0$ 为向右，$1$ 为向上，假设我们能计算有 $a$ 个 $0$ ，$b$ 个 $1$ 时有多少对路径满足第二条路径在第一条路径下方，称作函数 $calc(a,b)$ ，那么我们所求的就是 $calc(n-2,k)$ 。</p>
<p>研究第 $i$ 步，可以发现就四种情况：$(0,0),(0,1),(1,0),(1,1)$ ，可以发现，就是要让每个时刻 $(1,0)$ 的数量不少于 $(0,1)$ 的数量，如果用折线法描述就是上面是：$0,-1,0,1$ ，然后不要让折线低过 $x$ 轴，显然，$-1,1$ 的数量是一样的，枚举 $1$ 的数量就可以知道四种情况的数量了：</p>
<script type="math/tex; mode=display">
\begin{align*} 
calc(a,b)&=\sum\limits_{i=0}^{min(a,b)}\frac{(2i)!}{i!(i+1)!}*\binom{a+b-2i}{a-i}*\binom{(a+b-2i)+(2i+1)-1}{(2i+1)-1}\\
&=\sum\limits_{i=0}^{min(a,b)}\frac{(2i)!}{i!(i+1)!}*\binom{a+b-2i}{a-i}*\binom{a+b}{2i}\\ 
&=\sum\limits_{i=0}^{min(a,b)}\frac{(2i)!}{i!(i+1)!}*\frac{(a+b-2i)!}{(a-i)!(b-i)!}*\frac{(a+b)!}{(2i)!(a+b-2i)!}\\ 
&=\sum\limits_{i=0}^{min(a,b)}\frac{(a+b)!}{i!(i+1)!(a-i)!(b-i)!}\\
&=\frac{(a+b)!}{a!(b+1)!}\sum\limits_{i=0}^{min(a,b)}\frac{a!}{i!(a-i)!}\frac{(b+1)!}{(i+1)!(b-i)!}\\
&=\frac{(a+b)!}{a!(b+1)!}\sum\binom{a}{i}\binom{b+1}{b-i}\\
&=\frac{(a+b)!}{a!(b+1)!}\binom{a+b+1}{b}\\
&=\frac{(a+b)!(a+b+1)!}{a!b!(a+1)!(b+1)!}
\end{align*}</script><p>然后直接算就行了。</p>
<p>时间复杂度：$O(n)$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> LL mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">3e7</span>+<span class="number">105</span>;</span><br><span class="line">LL fc[N],nfc[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> L=<span class="number">3e7</span>+<span class="number">3</span>;</span><br><span class="line">    fc[<span class="number">0</span>]=fc[<span class="number">1</span>]=nfc[<span class="number">0</span>]=nfc[<span class="number">1</span>]=<span class="number">1</span>;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=L;i++)nfc[i]=(mod-mod/i)*nfc[mod%i]%mod;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=L;i++)nfc[i]=nfc[i<span class="number">-1</span>]*nfc[i]%mod,fc[i]=fc[i<span class="number">-1</span>]*i%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n;LL m;</span><br><span class="line">LL g[N];</span><br><span class="line"><span class="function">LL <span class="title">calc</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fc[a+b+<span class="number">1</span>]*fc[a+b]%mod*nfc[a]%mod*nfc[b]%mod*nfc[a+<span class="number">1</span>]%mod*nfc[b+<span class="number">1</span>]%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">C</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fc[x]*nfc[y]%mod*nfc[x-y]%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%lld&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">if</span>(!m)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;1\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(m&gt;n+n<span class="number">-3</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;0\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//n&gt;=2</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)g[i]=<span class="built_in">calc</span>(n<span class="number">-2</span>,i);</span><br><span class="line">    LL ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>((m-i)&amp;<span class="number">1</span>)ans=(ans-g[i]*<span class="built_in">C</span>(m<span class="number">-1</span>,i<span class="number">-1</span>)%mod+mod)%mod;</span><br><span class="line">        <span class="keyword">else</span> ans=(ans+g[i]*<span class="built_in">C</span>(m<span class="number">-1</span>,i<span class="number">-1</span>))%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></details>
<h6 id="坑"><a href="#坑" class="headerlink" title="坑"></a>坑</h6><p>没有生成函数做法。</p>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>计数</tag>
      </tags>
  </entry>
  <entry>
    <title>ARC170 E. BDFS</title>
    <url>/2024/02/20/ARC170-E-BDFS/</url>
    <content><![CDATA[<p>题目链接：<a href="https://atcoder.jp/contests/arc170/tasks/arc170_e">https://atcoder.jp/contests/arc170/tasks/arc170_e</a></p>
<p>题目大意：现在有一个 $n$ 个点的环，然后每个点的权值 $a_i$ ，一开始都是 $-1$ ，然后有个队列，初始只有一个 $(1,0)$，</p>
<p>然后每次弹出队首 $(d,v)$，若 $a_d=-1$ ，则：</p>
<ol>
<li>$a_d=v$ 。</li>
<li>从小到大考虑 $d$ 相邻的权值为 $-1$ 的邻居 $x$ ，然后有 $p$ 的概率把 $(x,v+1)$ 加入队首，否则加入队尾。</li>
</ol>
<p>问最后所有点的权值和的期望。</p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>唐，太唐了，转换完题意不会做，一个经典的二阶期望不会，唐，太烫了。</p>
<p>首先，这道题目显然可以转换成这个题意：</p>
<p>现在有一个长度为二的数组：$a[0]=-1,a[1]=0$ ，然后 $type=0$ ，现在进行 $n-1$ 轮：</p>
<ol>
<li><code>a[type]++</code> 。</li>
<li>有 $p$ 的概率不发生变化，有 $1-p$ 的概率 <code>type^=1</code> 。</li>
</ol>
<p>问最后 $\frac{a<a href="a[0]+1">0</a>}{2}+\frac{a<a href="a[1]+1">1</a>}{2}$ 的期望值。</p>
<p>首先，多少阶的期望都是能做的，开对应阶数个状态就行了，像自然数幂求和那样推一下式子就行了。</p>
<p>这里是二阶期望，开两个状态即可。</p>
<p>但这里由于数组有两个位置，所以还要再多开一个状态，总共三个状态，分别为：</p>
<p>$f_{ans}[n]$ 表示 $n$ 轮后的期望答案，$f_0[n]$ 表示 $a[type]$ 的期望值，$f_1[n]$ 表示 $a[1-type]$ 的期望值。</p>
<p>则式子为：</p>
<script type="math/tex; mode=display">
\begin{align*}
    f_{ans}[n+1]&=f_{ans}[n]+f_{0}[n]+1\\
    f_{0}[n+1]&=p(f_{0}[n]+1)+(1-p)f_{1}[n]\\
    f_{1}[n+1]&=(1-p)(f_{0}[n]+1)+pf_{1}[n]\\
\end{align*}</script><p>然后直接矩阵快速幂就行了。</p>
<p>时间复杂度：$O(T\log{n})$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> LL mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Matrix</span>&#123;</span><br><span class="line">    LL a[<span class="number">4</span>][<span class="number">4</span>];</span><br><span class="line">    <span class="built_in">Matrix</span>()&#123;</span><br><span class="line">        <span class="built_in">memset</span>(a,<span class="number">0</span>,<span class="built_in">sizeof</span>(a));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;O,tr;</span><br><span class="line">Matrix <span class="keyword">operator</span>*(Matrix x,Matrix y)&#123;</span><br><span class="line">    Matrix z;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">3</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=<span class="number">3</span>;j++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;=<span class="number">3</span>;k++)&#123;</span><br><span class="line">                z.a[i][j]=(z.a[i][j]+x.a[i][k]*y.a[k][j])%mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> z;</span><br><span class="line">&#125;</span><br><span class="line">Matrix <span class="keyword">operator</span>+(Matrix x,Matrix y)&#123;</span><br><span class="line">    Matrix z;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">3</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=<span class="number">3</span>;j++)z.a[i][j]=(x.a[i][j]+y.a[i][j])%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> z;</span><br><span class="line">&#125;</span><br><span class="line">Matrix <span class="keyword">operator</span>%(Matrix x,LL y)&#123;<span class="keyword">return</span> x;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">ksm</span><span class="params">(T x,LL y,T o)</span></span>&#123;</span><br><span class="line">    T ans=o;</span><br><span class="line">    <span class="keyword">while</span>(y)&#123;</span><br><span class="line">        <span class="keyword">if</span>(y&amp;<span class="number">1</span>)ans=ans*x%mod;</span><br><span class="line">        x=x*x%mod;y&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">3</span>;i++)&#123;</span><br><span class="line">        O.a[i][i]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> T;<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        LL n,p;<span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>,&amp;n,&amp;p);</span><br><span class="line">        p=p*<span class="built_in">ksm</span>(<span class="number">100ll</span>,mod<span class="number">-2</span>,<span class="number">1ll</span>)%mod;</span><br><span class="line">        LL pn=(<span class="number">1</span>-p+mod)%mod;</span><br><span class="line">        </span><br><span class="line">        tr.a[<span class="number">0</span>][<span class="number">0</span>]=tr.a[<span class="number">1</span>][<span class="number">0</span>]=tr.a[<span class="number">3</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        tr.a[<span class="number">1</span>][<span class="number">1</span>]=tr.a[<span class="number">3</span>][<span class="number">1</span>]=p;tr.a[<span class="number">2</span>][<span class="number">1</span>]=pn;</span><br><span class="line">        tr.a[<span class="number">1</span>][<span class="number">2</span>]=tr.a[<span class="number">3</span>][<span class="number">2</span>]=pn;tr.a[<span class="number">2</span>][<span class="number">2</span>]=p;</span><br><span class="line">        tr.a[<span class="number">3</span>][<span class="number">3</span>]=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        Matrix ans=<span class="built_in">ksm</span>(tr,n,O);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,(ans.a[<span class="number">3</span>][<span class="number">0</span>]-ans.a[<span class="number">1</span>][<span class="number">0</span>]+mod)%mod);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我当时其实写出了一个正确的式子，但我不知道怎么推了，在文章的最后放一下吧，悲。</p>
<script type="math/tex; mode=display">\frac{(n-1)n}{2}-\sum\limits_{x=1}^{n-1}(x-1)(n-x)\sum\limits_{i=1}^x\binom{x-1}{i}\binom{n-1-x}{i-1}p^{n-1-2i}(1-p)^{2i}+\binom{x-1}{i-1}\binom{n-1-x}{i-1}p^{n-2i}(1-p)^{2i-1}</script><p>唐，怎么每次碰到dp+矩阵快速幂的题都不会做啊，悲。</p>
</div></details>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>概率与期望</tag>
        <tag>矩阵</tag>
      </tags>
  </entry>
  <entry>
    <title>AGC066 赛后总结</title>
    <url>/2024/04/02/AGC066-%E8%B5%9B%E5%90%8E%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>比赛链接：<a href="https://atcoder.jp/contests/agc066/tasks">https://atcoder.jp/contests/agc066/tasks</a></p>
<p>别TM出你那构造了，我TM真的要做吐了。</p>
<h1 id="A-Adjacent-Difference"><a href="#A-Adjacent-Difference" class="headerlink" title="A Adjacent Difference"></a>A Adjacent Difference</h1><p>题目链接：<a href="https://atcoder.jp/contests/agc066/tasks/agc066_a">https://atcoder.jp/contests/agc066/tasks/agc066_a</a></p>
<p>题目大意：给一个 $n*n$ 的方阵，给一个数字增减 $x$ 的代价是 $|x|$ ，然后给出一种方案使得相邻数字差距 $\ge d$ ，同时代价 $\le \frac{dn^2}{2}$ 。</p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>一个经典的思考模型：由一般到特殊。</p>
<ol>
<li><p>如果 $d=1$ 怎么做？</p>
<p>我当时的想法是：奇数格子跑奇数或这偶数，偶数格子跑另外一类。</p>
</li>
<li><p>如果所有数字在 $[0,d]$ 内，怎么做？</p>
<p>我当时的想法是：奇数格子跑 $0$ 或者 $d$ ，偶数格子跑另外一类。</p>
</li>
</ol>
<p>这都指向了一个想法：奇数格跑向最近的 $0/d \mod{2d}$ ，然后偶数格子跑向另外一个。</p>
<p>至于证明，同样从一般到特殊，考虑上面两个问题，都是两种情况的和为 $dn^2$ ，则必定有一个 $\le \frac{dn^2}{2}$ 。</p>
<p>这个想法的证明也类似，不难发现，问题等价于：给偶数格子的值 $-d$ ，然后问所有格子最近的到 $0/d \mod{2d}$ ，是否有一种可能使得代价 $\le \frac{dn^2}{2}$ 。</p>
<p>不难发现，一个数字到达最近的 $0/d \mod{2d}$ ，两种情况的距离和是 $d$ 的，因此两种情况的代价是 $dn^2$ ，因此必定有一个情况 $\le \frac{dn^2}{2}$ ，证毕。</p>
<p>一个比较形象的图：</p>
<p><img src="1.png" alt=""></p>
<p>时间复杂度：$O(n^2)$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">5e2</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n, d;</span><br><span class="line"><span class="type">int</span> a[N][N], b[N][N];</span><br><span class="line"><span class="type">int</span> base;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> cost = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)&#123;</span><br><span class="line">            <span class="type">int</span> goal;</span><br><span class="line">            <span class="keyword">if</span>((i + j) &amp; <span class="number">1</span>) goal = base;</span><br><span class="line">            <span class="keyword">else</span> goal = base + d;</span><br><span class="line">            <span class="keyword">if</span>(goal &lt; a[i][j])&#123;</span><br><span class="line">                <span class="type">int</span> x = a[i][j] - goal;</span><br><span class="line">                x = x / (d + d) * (d + d) + goal;</span><br><span class="line">                <span class="keyword">if</span>( <span class="built_in">abs</span>(x - a[i][j]) &gt; <span class="built_in">abs</span>(x + d + d - a[i][j])) x += d + d;</span><br><span class="line">                goal = x;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="type">int</span> x = goal - a[i][j];</span><br><span class="line">                x = goal - x / (d + d) * (d + d);</span><br><span class="line">                <span class="keyword">if</span>( <span class="built_in">abs</span>(x - a[i][j]) &gt; <span class="built_in">abs</span>(x - d - d - a[i][j])) x -= d + d;</span><br><span class="line">                goal = x;</span><br><span class="line">            &#125;</span><br><span class="line">            b[i][j] = goal;</span><br><span class="line">            cost += <span class="built_in">abs</span>(a[i][j] - b[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cost;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; d;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)&#123;</span><br><span class="line">            cin &gt;&gt; a[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    base = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">2</span> * <span class="built_in">solve</span>() &gt; d * n *n)&#123;</span><br><span class="line">        base = d;</span><br><span class="line">        <span class="built_in">assert</span>(<span class="number">2</span> * <span class="built_in">solve</span>() &lt;= d * n * n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)&#123;</span><br><span class="line">            cout &lt;&lt; b[i][j] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实感觉想的还是慢了点，感觉还能再快一点的。</p>
</div></details>
<h1 id="B-Decreasing-Digit-Sums"><a href="#B-Decreasing-Digit-Sums" class="headerlink" title="B Decreasing Digit Sums"></a>B Decreasing Digit Sums</h1><p>题目链接：<a href="https://atcoder.jp/contests/agc066/tasks/agc066_b">https://atcoder.jp/contests/agc066/tasks/agc066_b</a></p>
<p>题目大意：给一个长度不超过 $9999$ 的数字，满足乘 $50$ 次 $2$ 时每次乘之后数位和都严格下降。</p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>非常有意思的题目，有时候来这么几道确实能开阔视野，但是考场时恶心我也确实有一手。</p>
<p>首先注意到一个事情：$5$ 乘 $2$ 后会变成 $10$ ，不影响数位和，也就是对于 $5<em>x$ ，在乘 $2$ 后变成 $10</em>x$ ，等价于 $x$ ，也就是乘 $2$ 后数字反而减小了，那么直接搞一个 $5^50$ ，最后直接减小到 $1$ 。</p>
<p>但是数字在减小不代表数字的数位和在减少，事实也确实如此，那么怎么搞呢？</p>
<p>考虑 $n*5^{50}$ ，如果 $5x\le y$ ，虽然 $x$ 的数位和可能大于等于 $y$ ，但是 $nx$ 与 $ny$ 在 $n$ 不断变化时的平均值应该是满足：$nx\le ny$ 的。</p>
<p>因此，直接将不同的 $n$ 得到的 $n*5^{50}$ 拼在一起即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e4</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> SN = <span class="number">1e2</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> a[SN], len;</span><br><span class="line">    <span class="built_in">node</span>()&#123;len = <span class="number">1</span>;<span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="built_in">sizeof</span>(a));&#125;</span><br><span class="line">&#125;a;</span><br><span class="line">node <span class="keyword">operator</span>*(node x, <span class="type">int</span> y)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= x.len; i++) x.a[i] *= y;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= x.len; i++)&#123;</span><br><span class="line">        x.a[i + <span class="number">1</span>] += x.a[i] / <span class="number">10</span>;</span><br><span class="line">        x.a[i] %= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(x.a[x.len + <span class="number">1</span>])&#123;</span><br><span class="line">        x.len++;</span><br><span class="line">        x.a[x.len + <span class="number">1</span>] += x.a[x.len] / <span class="number">10</span>;</span><br><span class="line">        x.a[x.len] %= <span class="number">10</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">char</span> st[N];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> T;</span><br><span class="line">        cin &gt;&gt; T;</span><br><span class="line">    &#125;</span><br><span class="line">    a.a[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    LL now = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">50</span>; i++) a = a * <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">400</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i % <span class="number">2</span> == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">        node b = a * i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= b.len; j++) st[++n] = b.a[j] + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i + i &lt;= n; i++) <span class="built_in">swap</span>(st[i], st[n - i + <span class="number">1</span>]);</span><br><span class="line">    <span class="comment">// cout &lt;&lt; n &lt;&lt; &#x27;\n&#x27; ;</span></span><br><span class="line">    cout &lt;&lt; st + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></details>
<details class="toggle" ><summary class="toggle-button" style="">反思</summary><div class="toggle-content"><p>特有的没做题，看题解后开始马后炮反思。</p>
<ol>
<li><p>思考是否是一些显性的数字组合，例如 ：5555，这种。</p>
<p>否决理由：可以控制很小的 $n$ ，但是 $n$ 比较大时根本控制不住。</p>
<p>特别发现： $9999…999$ ，只要 $n$ 的数量级小于位数的数量级，则位数和不变。</p>
</li>
<li><p>思考是否是分段加循环节，忽略一些小量的变化。</p>
<p>否决理由：循环起来可以发现平均变化量为 $0$ ，那么最终影响减小的还是总变化量。</p>
</li>
<li><p>开始思考可能是一些会损耗的构造，突然发现 $5*2=10$ ，逐步接近正解。</p>
<p>但以为是 $5^k$ 里面存在一段 $[l,r]$ 纯递增。</p>
<p>否决理由：试了，不存在这样的 $[l,r]$ 。</p>
</li>
<li><p>难道是 $n*5^k$ ？最接近正解的一集，可惜思维困在了找 $[l,r]$ 。</p>
<p>否决理由：试了，找不到。</p>
</li>
<li><p>难道不是 $5^k$ ，而是其他幂次，比如 $2^k$ ？。</p>
<p>否决理由：没找到，发现这么想其实已经和乱试没什么区别了，纯纯没有道理。</p>
</li>
<li><p>思考是否是搞几个串，不同的 $n$ 增量不同，然后列个方程，找个可行解。</p>
<p>否决理由：怎么判断方程是否有解，又怎么找到有解的方程。</p>
</li>
<li><p>回到第 $2$ 点，难道是列一堆状态，然后不同状态之间相互联动，然后用算法找一下可行解？</p>
<p>否决理由：根本没想出来个所以然，其实这个时候也知道这样想希望不大，没有正解的感觉，但也没有新的点子了。</p>
</li>
<li>投降，看题解，膜拜。</li>
</ol>
<p>回顾整个过程，其实可以发现做法就是 $3,4,6$ 的组合，但唯独就是没有想到小的数字虽然数位和不一定小，但是在乘 $n$ 后的平均值感觉上是小的。</p>
<p>回顾一下过程：</p>
<p>$1,2$ 步我认为是我目前必须经历的过程，尝试解法是很正常的，但重要的是要在更加短的时间否定这些想法，当能够大致的给出一个想法不对的点的时候，就应该去尝试想想其他想法了。</p>
<p>$3,4,6$ 步我认为没有问题，有一些新的想法是好事。</p>
<p>$5$ 纯粹的乱试，不过赛场也确实没有花太多时间在这一点上。</p>
<p>$7$ 的时候已经黔驴技穷了，也不知道自己在干嘛了，但又必须经历，感觉变强的过程就是在一步步经历 $7$ 的过程中，突然想到可以这么干的过程。但其实也不能硬撑，如果经历 $7$ 一段时间后还没想到新的点子（大概是半个小时到两个小时左右），大概率就是超能力范围了，这个时候硬想基本上是浪费时间，不如直接看题解，我认为在自己最困惑的时候，学习一下别人是怎么解决自己的困惑，是进步最快的方法。</p>
<p>当然，如果赛时进入 $7$ 阶段一小段时间的话，直接跳题才是收益最大化的选择，毕竟这场的 $E$ 我觉得不是不能做的，多一种选择就多一种可能。</p>
<p>怎么更快的想出这道题呢？关键的两点：</p>
<ol>
<li>$2*5=10$ 。（就算再难的构造也要有些比较关键的小性质，而注意到 $5$ 因子能够让数字“从小变大”变成“由大变小”是这道题目一个关键的突破。）</li>
<li>感觉上如果 $x&lt;y$ ，那么 $nx$ 和 $ny$ 的数位和的平均值应该会满足 $nx &lt; ny$ ，在有足够多且随机的 $n$ 时。（这个性质能够很好的利用 $5$ 由大变小的性质，并通过此题）</li>
</ol>
<p>提升“感觉”思维是我下次能够且更快做出这一类题目的关键。</p>
</div></details>
<h1 id="C"><a href="#C" class="headerlink" title="C"></a>C</h1><p>题目大意：给一个只有 $A,B$ 的字符串，每次只能删除 $AAB$ 或者 $BAA$ ，问最多删除多少次。</p>
<details class="toggle" ><summary class="toggle-button" style="">我的做法</summary><div class="toggle-content"><p>首先注意到一个事情，题目不能删除 $ABA$ 的字符串，这意味着单个的 $A$ 有可能被浪费，所以这道题目的核心就是如何减少 $A$ 的浪费。</p>
<p>在足够的思考后，观察到这么一个性质：如果把 $A$ 看成 $1$ ，$B$ 看成 $-2$ ，如果一个子串的和 $&gt;0$ ，那么这个子串一定可以变成一串 $A$ 。</p>
<p>原因是如果不是一串 $A$，最终一定是 $AB…BAB…BA…$ ，那么一定是 $\le 0$ 的。</p>
<p>因此这样合并条件就有了。</p>
<p>因此我们能够将原问题用该问题表示：用一些不相交的段覆盖所有的 $+1$ ，要求段的和 $&gt;0$，然后浪费的 $A$ 为和为奇数的段，最小化浪费。</p>
<p>这个时候其实已经可以 $dp$ 了。</p>
<p>使用某种数据结构维护一下转移过程就能 $O(n\log{n})$ 。</p>
<p>同时注意到，如果 $x\to x+2k$ ，那么一定有 $x\to x+2 \to x+2k$ ，因此转移能只从 $x-1,x-2$ 转移过来，时间复杂度：$O(n)$ 。</p>
<p>不过当时我没意识到到这就已经做完了，发现一个很自然的事情：如果和为奇数，代表可能有浪费，和为偶数，代表没有浪费，因此我们总是希望和为奇数，这个时候就很自然会想，奇数能不能分成两段 $&gt;0$ ？</p>
<p>答案是可以，对于一段我们先将正数合并，负数合并，两端是正数，然后从左边一段正数开始，然后另外一段是去掉下一段负数的右边，然后如果右边 $&lt;0$ ，那么左边的和大于中间负数段的绝对值，那么可以将左边往右推一格，由于最后会推到右边只有正数，所以一定存在一个时刻，左右两端都是正数，证毕。</p>
<p>因此，一段长度 $\ge 2$ 的 $&gt;0$ 一定能分成两段 $&gt;0$ ，综上，和为奇数的一定能分成一段奇数，一段偶数，所以奇数的长度可以至多为 $1$ 。</p>
<p>这样就得到了我的最终做法。</p>
<p>时间复杂度：$O(n)$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">1e9</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_char_array</span><span class="params">(<span class="type">char</span> *s, <span class="type">int</span> &amp;n)</span></span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">char</span> ss[N];</span><br><span class="line">    cin &gt;&gt; ss;</span><br><span class="line">    n = <span class="built_in">strlen</span>(ss);</span><br><span class="line">    <span class="built_in">memcpy</span>(s + <span class="number">1</span>, ss, <span class="built_in">sizeof</span>(<span class="type">char</span>) * n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">char</span> st[N];</span><br><span class="line"><span class="type">int</span> sum[N], a[N], dp[N];</span><br><span class="line"><span class="type">int</span> f[N * <span class="number">3</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="built_in">get_char_array</span>(st, n);</span><br><span class="line">        <span class="built_in">fill</span>(f, f + <span class="number">3</span> * n + <span class="number">2</span> + <span class="number">1</span>, inf);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(st[i] == <span class="string">&#x27;A&#x27;</span>) a[i] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> a[i] = <span class="number">-2</span>;</span><br><span class="line">            sum[i] = sum[i - <span class="number">1</span>] + a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        f[n + n + <span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i] &lt; <span class="number">0</span>) dp[i] = dp[i - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">else</span> dp[i] = <span class="built_in">min</span>(dp[i - <span class="number">1</span>] + <span class="number">1</span>, f[sum[i] + (n + n + <span class="number">2</span>) - <span class="number">2</span>]);</span><br><span class="line">            f[sum[i] + (n + n + <span class="number">2</span>)] = <span class="built_in">min</span>(f[sum[i] + (n + n + <span class="number">2</span>)], dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> A = (sum[n] + n + n) / <span class="number">3</span>, B = n - A;</span><br><span class="line">        A -= dp[n];</span><br><span class="line">        <span class="built_in">assert</span>(A % <span class="number">2</span> == <span class="number">0</span>);</span><br><span class="line">        cout &lt;&lt; <span class="built_in">min</span>(A / <span class="number">2</span>, B) &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>$O(n\log{n})$ 版的代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_char_array</span><span class="params">(<span class="type">char</span> *s, <span class="type">int</span> &amp;n)</span></span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">char</span> ss[N];</span><br><span class="line">    cin &gt;&gt; ss;</span><br><span class="line">    n = <span class="built_in">strlen</span>(ss);</span><br><span class="line">    <span class="built_in">memcpy</span>(s + <span class="number">1</span>, ss, <span class="built_in">sizeof</span>(<span class="type">char</span>) * n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">char</span> st[N];</span><br><span class="line">set&lt;PII&gt; f[<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> sum[N], a[N], dp[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="built_in">get_char_array</span>(st, n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(st[i] == <span class="string">&#x27;A&#x27;</span>) a[i] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> a[i] = <span class="number">-2</span>;</span><br><span class="line">            sum[i] = sum[i - <span class="number">1</span>] + a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        f[<span class="number">0</span>].<span class="built_in">insert</span>(&#123;<span class="number">0</span>, <span class="number">0</span>&#125;);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i] &lt; <span class="number">0</span>) dp[i] = dp[i - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                dp[i] = dp[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                <span class="type">int</span> type = sum[i] &amp; <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">auto</span> tmp = f[type].<span class="built_in">lower_bound</span>(&#123;sum[i], <span class="number">0</span>&#125;);</span><br><span class="line">                <span class="keyword">if</span>(tmp != f[type].<span class="built_in">begin</span>())&#123;</span><br><span class="line">                    tmp--;</span><br><span class="line">                    dp[i] = <span class="built_in">min</span>((*tmp).second, dp[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> type = sum[i] &amp; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">auto</span> tmp = f[type].<span class="built_in">lower_bound</span>(&#123;sum[i], dp[i]&#125;);</span><br><span class="line">                <span class="keyword">if</span>(tmp == f[type].<span class="built_in">end</span>()) <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">if</span>((*tmp).second &gt;= dp[i]) f[type].<span class="built_in">erase</span>(tmp);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">auto</span> tmp = f[type].<span class="built_in">upper_bound</span>(&#123;sum[i], dp[i]&#125;);</span><br><span class="line">            <span class="keyword">if</span>(tmp != f[type].<span class="built_in">begin</span>() &amp;&amp; (*(--tmp)).second &lt;= dp[i]);</span><br><span class="line">            <span class="keyword">else</span> f[type].<span class="built_in">insert</span>(&#123;sum[i], dp[i]&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> A = (sum[n] + n + n) / <span class="number">3</span>, B = n - A;</span><br><span class="line">        A -= dp[n];</span><br><span class="line">        <span class="built_in">assert</span>(A % <span class="number">2</span> == <span class="number">0</span>);</span><br><span class="line">        cout &lt;&lt; <span class="built_in">min</span>(A / <span class="number">2</span>, B) &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        f[<span class="number">0</span>].<span class="built_in">clear</span>();</span><br><span class="line">        f[<span class="number">1</span>].<span class="built_in">clear</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></details>
<details class="toggle" ><summary class="toggle-button" style="">反思</summary><div class="toggle-content"><p>想题过程：</p>
<ol>
<li>发现奇数个 $A$ 与浪费。</li>
<li><p>开始思考合并 $A$ 的条件，觉得可能和和有关。</p>
<p>否决理由：发现 $sum=0$ 时可以 $ABA$ 是反例。</p>
</li>
<li>开始思考能不能调整合并顺序。</li>
<li>发现非奇数的段可以直接与两端的最短的负数段合并，问题变成考虑奇数-负数-奇数-负数 … 。</li>
<li>手玩突然发现 $&gt;0$ 是充要条件。</li>
<li>证明分割的那个定理。</li>
<li>得到做法。</li>
<li>看题解发现可以线性，回来将自己的做法优化到线性。</li>
</ol>
<p>感觉这次想题的问题不大，第二步虽然很早的想到与和有关，这可以说是直觉，但是否决掉就说明实力还是有待提高，我并不觉得这个时候否决是多大的问题。</p>
<p>因为此时我的主要想法是通过调整合并顺序来实现更容易的合并，而 $&gt;0$ 这个条件如果是奇数，最后还会剩一个，如果是偶数，找 $B$ 一定能变成 $=0$ ，所以我当时就局限在我当时的思维卡了一下，以为条件如果有，一定是和为 $0$ 然后加上一些条件，但一直没找到就放弃这个想法了。</p>
<p>一直到后面手玩才发现 $ABB..BA…$ 这种东西和 $\le 0$ ，所以 $&gt;0$ 就是充要条件，你要说问题大吗？我觉得不大，因为当时的思维方向而否决掉一些对的想法这件事，我认为是正常的。</p>
<p>而最后第 $6$ 步也反映了这个想法，我当时觉得和为奇数一定会浪费一个，这种情况是不优且奇怪的，所以在明明已经能做的情况下，第一想法是找个方法把奇数段切割，直到奇数的长度为 $1$ 。</p>
<p>我认为这次的最大问题是思维局限住了，合并奇数的方法不止考虑调整合并顺序这么一种，假如不是运气好手玩发现了 $&gt;0$ 的这个充要条件，我估计要局限在这个思路很久。</p>
<p>当然在某种方向上想一段时间没有问题，保证深度，但是最大的问题是在这种方向上久久没有新的成果的时候，就要考虑换个方向想了，毕竟想题除了深度，还要考虑广度问题，而能有多广，就是实力问题了。</p>
<p>比如这题，我一开始的想法是调整，没有问题，否决掉正确想法，也没有问题，但是后面没有转换思维，去找其余可能的解决方法，就是我最大的问题，虽然最后运气好发现了，那也只能说 $&gt;0$ 这个条件还是比较浅，可以在不深挖的情况下就发现，一旦做法是需要深挖的话（指的是需要在另外一个方向深挖），这个时候不转换思维就只有死路一条。</p>
<p>因此在思路卡住的时候，最有效的解决方法就是跳出原有思路，扩宽想题广度。</p>
<p>（我其实觉得我现在和高中最大的区别就是广度变小了很多，导致我没法做很多我高中会做的题目，现在要注重培养想题的广度了）</p>
</div></details>
<details class="toggle" ><summary class="toggle-button" style="">官方做法</summary><div class="toggle-content"><p>坏了，非要说的话我一开始的想法还真没问题，真就和为 $0$ 且加一些条件就能判断这一段能不能被消除（虽然我当时的想法主要是减少奇数，减少浪费，因此也不太可能往这个方向想）。</p>
<p>菜就多练了只能说。</p>
<p>官方做法基于一个定理：</p>
<p>一个段能够完整的消除的充要条件：</p>
<p>能够分成多段使得每一段和为 $0$ 且两端中有一端为 $B$ 。</p>
<p>充分性：将 $B$ 去掉，这一段就 $&gt;0$ 了，可以只用 $A$ 表示，然后用 $B$ 消掉即可。</p>
<p>必要性：归纳。</p>
<p>然后直接 $dp$ 就行了，时间复杂度：$O(n)$ 。</p>
</div></details>
<h1 id="D"><a href="#D" class="headerlink" title="D"></a>D</h1><p>独立成一篇题解。</p>
<h1 id="E"><a href="#E" class="headerlink" title="E"></a>E</h1><p>独立成一篇题解。</p>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>构造</tag>
        <tag>感觉</tag>
      </tags>
  </entry>
  <entry>
    <title>AGC066 E. Sliding Puzzle On Tree</title>
    <url>/2024/05/16/AGC066-E-Sliding-Puzzle-On-Tree/</url>
    <content><![CDATA[<p>题目链接：<a href="https://atcoder.jp/contests/agc066/tasks/agc066_e">https://atcoder.jp/contests/agc066/tasks/agc066_e</a></p>
<p>题目大意：</p>
<p>给一棵树，然后依次在编号为 $1,2,…,n$ 上面放不同的石子，每次放完石子后，问经过下面操作任意次后能得到多少种不同的局面：</p>
<p>将一个石子移到相邻没有石头的位置。</p>
<details class="toggle" ><summary class="toggle-button" style="">我的做法</summary><div class="toggle-content"><p>首先做这道题目一个直观的感受是，答案的结构会不会是可以把石头分成一个个集合，集合内的石头可交换吧？</p>
<p>但是首先就有一个问题，树上没有偏序结构，什么叫可交换？没有次序怎么定义可交换？</p>
<p>注意到一个事情，假设把石头看成没区别的，那么石头可以摆成任意一个局面，我们不妨固定一个局面 $A$ ，然后对于每种其他局面 $B$，我们也固定一种从 $A$ 到 $B$ 的交换方法，而这个交换方法可以用 $\{(x,y)\}$ 来表示，逆过来同理，具体表示为将 $A$ 中的 $x$ 位置的石子放到了 $B$ 的 $y$ 位置。</p>
<p>因此对于 $A$ 的同一局面的不同标号，一定可以对应 $B$ 的不同标号，同理 $B$ 的也可以变成 $A$ 的。</p>
<p>所以最终答案一定可以表示成 $\binom{n}{k}*cnt$ ，$cnt$ 表示同一局面有多少种不同的标号。</p>
<p>因此交换就可以定义了，固定一个局面下两个点的标号是否可交换。</p>
<p>那么怎么判断可交换呢？我在思考这个问题的时候是在 $fix$ 一条直径的情况下做的，然后再推广到不 $fix$ 的情况，这里直接给出我的最终做法，对我的思考过程感兴趣的读者可以去看反思部分。</p>
<p>考虑以某个叶子为根，然后根据某种神奇的 $dfs$ 序开始放下每一个石子（多叉树的后序遍历）。（下面的讨论和证明都默认是基于这个局面，基本上换个局面下面的观察就大概率是错的了）</p>
<p>先特判 $k\ge n-1$ 的情况。</p>
<p>剩下的情况，然后我们考虑两个石子什么时候可以交换，至于不能用交换形容的情况，我们等会再说。</p>
<p>显然只要两个石子是同父亲的，就可以交换，考虑石子什么时候和自己的儿子可交换，一个充分条件是，设 $f_{x}$ 表示 $x$ 到第一个二叉父亲（不包括自己）的所需要的边数，则 $k\le n-(f_{x}+2)$。</p>
<p>这也是为什么要选个叶子当根，否则还要讨论跨过根去到根的另一个子树的情况。</p>
<p><details class="toggle" ><summary class="toggle-button" style="">充分性证明</summary><div class="toggle-content"><p>根据我们放石子的顺序，我们一定可以摆出下面的局面：</p></p>
<p><img src="1.png" alt=""></p>
<p>手模一下就行了，证毕。</p>
</div></details>
<p>但是，这就够了吗？</p>
<p>事实上是够了。</p>
<details class="toggle" ><summary class="toggle-button" style="">必要性及只用考虑交换的证明</summary><div class="toggle-content"><p>可以发现，由于我们的放法，$x$ 这个位置的石子在放下时，其子树就满了，因此空位都在 $x$ 子树外。</p>
<p>设 $gfa_x$ 表示 $x$ 的第一个有两个以上儿子的祖先。</p>
<p>大致情况就和下面的图一样，将 $x$ 移动到 $gfa_x$ 部分，这样石子就分成了两个部分，显然这两个部分之间无法产生交换。</p>
<p><img src="2.png" alt=""></p>
<p>因此，这个节点就像是一个分界点，将子树和外面的点分开，两部分之间不会产生交换。</p>
<p>要严谨写证明过程的话，归纳证明就行了。</p>
<p>证毕。</p>
</div></details>
<p>那么上面的情况就够了吗？</p>
<p>够了，在讨论了上面的情况后，两个石子不能交换的充要条件就是中间有个第二种情况的拦路虎，而显然发生这种情况时，两个石子一定不能交换，因此这不仅是只考虑上面情况的充要，而是原问题的充要条件。</p>
<p>但是问题是，我们现在考虑完交换，那这是否就覆盖了所有的情况呢？</p>
<p>我们这么想，假设 $x,y$ 不可交换，但是存在一个变换，能使 $x$ 到达 $y$ 所在的位置，那么根据上面 $x,y$ 不可交换的条件，中间一定存在一个类似分界一样的东西，会限制 $x$ 不能到达 $y$ 能到达的一些地方，而前面说法矛盾，故不存在这种情况。因此，只考虑交换便能覆盖所有的局面。</p>
<p>做完了。</p>
<p>实现方面，注意到对于 $\forall x,y$ ，上面只给了在 $x\to y$ 这条路径上都已经按照顺序放了石头之后 $x,y$ 可交换的条件，但是如果还没放满呢？</p>
<p>显然除了 $lca$ 外，如果一个位置放了石子，且其的一个儿子也在这条路径上，则显然必须满足这个位置能和儿子交换，而且这显然是充要的，但我们注意到一个事情，如果 $x$ 在 $t$ 的时间假如，则其能与儿子交换的条件要么一直不满足，要么在 $\le t-1$ 时一定能满足。</p>
<p>因此 $x,y$ 可交换的条件在放不放满石头的时候都是一样的（除了 $lca$ 外，如果一个位置和其的一个儿子都在这条路径上，则必须满足这个位置能和儿子交换），直接实现就行了。</p>
<p>时间复杂度：$O(n\alpha(n))$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="type">const</span> LL mod = <span class="number">998244353</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line">LL fc[N], nfc[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> L = <span class="number">2e5</span>;</span><br><span class="line">    nfc[<span class="number">0</span>] = nfc[<span class="number">1</span>] = fc[<span class="number">0</span>] = fc[<span class="number">1</span>] = <span class="number">1ll</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= L; i++) nfc[i] = (mod - mod / i) * nfc[mod % i] % mod;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= L; i++) nfc[i] = nfc[i - <span class="number">1</span>] * nfc[i] % mod, fc[i] = fc[i - <span class="number">1</span>] * i % mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">C</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>&#123;<span class="keyword">return</span> fc[x] * nfc[y] % mod * nfc[x - y] % mod;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> y, next;</span><br><span class="line">&#125;a[N * <span class="number">2</span>]; <span class="type">int</span> len, las[N], du[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ins</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>&#123;a[++len] = &#123;y, las[x]&#125;; las[x] = len;&#125;</span><br><span class="line"><span class="type">int</span> n, rt;</span><br><span class="line"><span class="type">int</span> siz[N];</span><br><span class="line"><span class="type">int</span> dfn[N], be[N], ti;</span><br><span class="line">vector&lt;PII&gt; event[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> fa, <span class="type">int</span> c)</span></span>&#123;</span><br><span class="line">    siz[x] = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> son = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k = las[x]; k; k = a[k].next)&#123;</span><br><span class="line">        <span class="type">int</span> y = a[k].y;</span><br><span class="line">        <span class="keyword">if</span>(y == fa) <span class="keyword">continue</span>;</span><br><span class="line">        son = y;</span><br><span class="line">        <span class="keyword">if</span>(du[x] &gt;= <span class="number">3</span>) <span class="built_in">dfs</span>(y, x, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">dfs</span>(y, x, !c ? <span class="number">0</span> : c + <span class="number">1</span>);</span><br><span class="line">        siz[x] += siz[y];</span><br><span class="line">    &#125;</span><br><span class="line">    be[ dfn[x] = ++ti ] = x;</span><br><span class="line">    <span class="keyword">if</span>(son &amp;&amp; c) event[n - c - <span class="number">2</span>].<span class="built_in">push_back</span>(&#123;x, son&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LL contribution = <span class="number">1ll</span>;</span><br><span class="line"><span class="type">int</span> fa[N], cnt[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">findfa</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="keyword">return</span> fa[x] == x ? x : fa[x] = <span class="built_in">findfa</span>(fa[x]);&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mer</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    x = <span class="built_in">findfa</span>(x);</span><br><span class="line">    y = <span class="built_in">findfa</span>(y);</span><br><span class="line">    <span class="keyword">if</span>(x == y) <span class="keyword">return</span> ;</span><br><span class="line">    contribution = contribution * nfc[cnt[x]] % mod * nfc[cnt[y]] % mod;</span><br><span class="line">    fa[x] = y;</span><br><span class="line">    cnt[y] += cnt[x];</span><br><span class="line">    contribution = contribution * fc[cnt[y]] % mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">del</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    x = <span class="built_in">findfa</span>(x);</span><br><span class="line">    contribution = contribution * nfc[cnt[x]] % mod;</span><br><span class="line">    cnt[x]--;</span><br><span class="line">    contribution = contribution * fc[cnt[x]] % mod;</span><br><span class="line">&#125;</span><br><span class="line">LL ans[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        cin &gt;&gt; n;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="type">int</span> x, y;</span><br><span class="line">            cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">            <span class="built_in">ins</span>(x, y);</span><br><span class="line">            <span class="built_in">ins</span>(y, x);</span><br><span class="line">            du[x]++;</span><br><span class="line">            du[y]++;</span><br><span class="line">        &#125;</span><br><span class="line">        rt = <span class="number">1</span>;<span class="comment">//n = 1;</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(du[i] == <span class="number">1</span>)&#123;</span><br><span class="line">                rt = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">dfs</span>(rt, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="type">int</span> pre = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k = las[i]; k; k = a[k].next)&#123;</span><br><span class="line">                <span class="type">int</span> y = a[k].y;</span><br><span class="line">                <span class="keyword">if</span>(dfn[y] &gt; dfn[i]) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(pre) event[n - <span class="number">2</span>].<span class="built_in">push_back</span>(&#123;pre, y&#125;);</span><br><span class="line">                pre = y;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            fa[i] = i;</span><br><span class="line">            cnt[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ans[n] = <span class="number">1ll</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">1</span>; i--)&#123;</span><br><span class="line">            <span class="built_in">del</span>(be[i + <span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> [x, y] : event[i]) <span class="built_in">mer</span>(x, y);</span><br><span class="line">            ans[i] = <span class="built_in">C</span>(n, i) * contribution % mod;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) cout &lt;&lt; ans[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        contribution = <span class="number">1ll</span>;</span><br><span class="line">        len = ti = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(las + <span class="number">1</span>, <span class="number">0</span>, <span class="built_in">sizeof</span>(<span class="type">int</span>) * n);</span><br><span class="line">        <span class="built_in">memset</span>(du + <span class="number">1</span>, <span class="number">0</span>, <span class="built_in">sizeof</span>(<span class="type">int</span>) * n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span> ; i &lt;= n; i++) event[i].<span class="built_in">clear</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>真是场酣畅淋漓的做题啊。</p></div></details>
<details class="toggle" ><summary class="toggle-button" style=""></summary><div class="toggle-content"><p>破案了，我说为什么难度比 $D$ 低，原来是原题加强，但是原题做法能过。 </p>
</div></details>
<details class="toggle" ><summary class="toggle-button" style="">反思</summary><div class="toggle-content"><p>想想我的想题过程：</p>
<ol>
<li><p>觉得肯定要思考哪些石头是能交换的。（卡了至少 30 分钟）</p>
<p>否决理由：“交换”的定义非常奇怪，对于两种不同的摆石子方式，怎么判断两个石头已经被交换了？（但实际在后面发现，只要解决了这个问题，就已经成功很大一步了，可惜我当时的第一想法是放弃而不是解决）</p>
</li>
<li><p>觉得可能是通过一个石子能够到达哪些位置进行解答，显然处于等价关系的点应该能到达的位置是一样的，本质是尝试在定义上面的交换关系。（卡了至少 30 分钟）</p>
<p>否决理由：能到达的点这个东西并不好量化，而且求出来也十分困难，讨论起来也很麻烦，还不一定能讨论出来，直觉上正解肯定不是这么搞的，直接放弃了。</p>
</li>
<li>发现答案一定是：同种石子的答案 * 一种摆石子方式的不同局面（同一种方式的不同局面通过同一种映射一定到达另一种方式的不同局面，是个双射），所以可以直接固定一个摆石子的方式，研究有多少种不同的局面，这个时候猜测一定是一个集合里面的点可互相交换。（其实也就是严格定义了第一点）</li>
<li><p>断定三个石头共线，则左右两个石头能交换当且仅当和中间的石头能交换。（卡了至少 30 分钟）</p>
<p>否决理由：</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 2</span><br><span class="line">2 3</span><br><span class="line">2 4</span><br><span class="line">2 5</span><br></pre></td></tr></table></figure>
<p> 其中石头在 $1,2,3$ ，$1,3$ 可交换，但 $2$ 不可交换。</p>
</li>
<li><p>接下来卡了很久，因为总觉得这个交换非常的难思考，直到我拿着 $4$ 的例子思考了一下，打算先假设只用接下来这一种方法来判断交换（即找到了一种比较好的判断交换的充分条件进行思考）：</p>
<p><img src="2.png" alt=""></p>
<p>上面黑点表示有石子，白点表示没有石子，那么上面的所有石子都是可交换的，但是如果上下再多一个石子，多出来的石子不可交换，也就是在这种三叉路口上，没有石头的路的长度决定了可交换的有石头的路的长度。</p>
</li>
<li>那么这种结构想到了啥？直径！可以发现，如果我们放石头的时候，有限把树的直径以外的部分填满，那么石头都是可交换的，用上面的结构，但是如果必须要填在直径上呢？</li>
<li><p>继续开始思考，我们发现，我们可以不断的移动直径上没有填石头的部分到某些三叉路口，来使得某些石头是可交换的，但这个时候发现了一种情况：</p>
<p><img src="3.png" alt=""></p>
<p>可以发现，无论没有石子的部分怎么移动，这个石头都不能通过 $5$ 的结构与任何石子交换，但是上面这个例子显然能够证明这个石子无法与其余石子交换，因为其在一条直道上，无法走向左右任意一个交叉口的某个子树里（即使能走到交叉口，不能走到子树里也是白搭），那么能否这样类似的证明其余无法用 $5$ 构造交换的情况其实也是不可交换的呢？（其实这个时候就和下面说的一样，本质上是找到了一个判断不能交换的必要条件，证明这个必要条件是充分的，毕竟想想，证明无法交换就必定满足这个必要条件，反过来就是不满足这个必要条件的就是可交换的，因此这个过程其实就是判断这个必要条件是充要的过程）</p>
</li>
<li><p>刚刚那个问题的答案是可以的，可以移动整段没有石子的路段（这里其实假定了整段不分裂的移动更优，但事实是在后面在这种假设下证明了必要条件是充要的后，这个假设自然也就成立了，也就是下面说的第三点），到一个个石子路口，且只假设会不断向叶子前进，不会做多余的操作，可以用上面的方法证明不能用这种方法交换的一定都是不能交换的。</p>
<p><img src="4.png" alt=""></p>
<p>注：不会多余就是一端在交叉路口，而另一端一定是指向直径方向的。</p>
<p>同时，用上面这个方法也能同时证明，只需要考虑交换就够了，不会出现 $x,y,z$ 可以三轮换但是不能交换的情况。</p>
</li>
<li><p>这个时候这道题目就已经做出来了，但是感觉这个做法有点难写（在直径上操作），而且也并不广泛。</p>
<p> 用到的直径性质也不多（只有在直径上没有石头的时候用到了直径性质），也就是说在直径上做这件事并不本质，直觉告诉我题解肯定不是这么做的。</p>
</li>
<li>这个时候尝试推广这个做法，并最终得到了我自己的最终做法。</li>
</ol>
<p>显然这个思考过程是非常长的，因此需要优化！</p>
<p>在没有看题解之前，我判断这个过程中有什么东西是可以优化的呢？</p>
<ol>
<li><p>就是我发现我在思考一些结论时，总是想着怎么证明，但正确做法应该是先想能不能构造反例，因为构造反例的难度往往比证明要低，而且构造不出来的过程可以指导证明</p>
<p>也就是我之前喜欢先从证明入手，然后因为证明不出来从而发现反例，这是很低效的，因为面对一个棘手的问题往往没有从正面切入的点。</p>
<p>但是如果从反面切入，如果发现是错的，结束了，不是错的，研究为什么对，这样又能对这个问题更加深入一步，而不至于摸不着头绪。</p>
</li>
<li><p>像这种题目，要先多去思考必要条件，也就是两个点不能交换的必要条件，在找到足够多后，再尝试证明或找到充要条件，这样会快很多。</p>
<p>显然，根据我上面的过程，我其实一种都在想两个点能交换的充要条件，但如果我先想两个点不能交换（尤其是两个相邻点）的必要条件，我想会更快想出正解。</p>
<p>虽然最后我想出来正解其实也是找了两个点能交换的充分条件进行思考得到的，因为一般情况下充要条件很难想出来，这个时候就需要找一些比较强的充分或者必要条件进行思考，而且很多情况下，其实这些就是充要条件，只是还没有证明的思路罢了。</p>
</li>
<li><p>假设法，在无法证明某些结论前先假设其是对的，然后进行进一步思考，如果找到反例再来推翻这个假设。</p>
<p>例如如果我一开始就假定两个石头能交换，则中间绝对不能隔着超过一个不能交换的石头，那么这种更加优秀的结构能够更好的引导接下来的思考（至少比原来抓瞎好），我想在这种假设下，也能更快的想出正解，而且事实是，一般想到正解后，这种假设的正确性也就迎刃而解了，尤其是在各种贪心和计数题上。</p>
</li>
</ol>
<p>在看了题解之后，我又有了什么新的感悟？</p>
<p>update：没什么感悟。</p>
</div></details>
<details class="toggle" ><summary class="toggle-button" style="">官方题解</summary><div class="toggle-content"><p>幽默了。原来我想题过程中，从“一个点能到达的集合”作为出发点是真的可行的啊。</p>
<p>接下来认为 $a,b,c$ 是石子，$x,y,z$ 是位置，石子和位置并不绑定，石子是石子，位置是位置，需要的时候可以把石子摆成任意想要的局面。（这里的局面指忽略标号的局面）</p>
<p>同时规定 $dis(x,y)$ 或者 $dis(a,x)$ 表示两点或者石子所在位置到 $x$ 的距离。</p>
<p>设 $S(a)$ 表示石子 $a$ 能到达的位置的集合。（注意，这里的 $S(a)$ 定义是基于石子的）</p>
<p>对于位置 $x$ ，我们称 $a$ 能够利用 $x$ 当且仅当 $x$ 有两个相邻节点属于 $S(a)$ 。</p>
<p>那么以下这三句话等价：</p>
<ol>
<li>$S(a)=S(b)$</li>
<li>$a,b$ 能够利用同一个度数 $\ge 3$ 的节点。</li>
<li>$a,b$ 能够在不影响其他位置的情况下交换他们身上的石子。（这其实给了交换的另外一种定义，但是我认为在没有想到去标号后任何局面可达这件事时，这种定义思考和证明起来是极其麻烦的，反正我不会）</li>
</ol>
<p>$3\to 1,3\to 2, 1\to 2$ 都是显然的。</p>
<p>现在简单的证明一下 $1\to 2$ 。</p>
<p><details class="toggle" ><summary class="toggle-button" style="">证明</summary><div class="toggle-content"><p>首先你需要注意到这么一个形式：$x\in S(a)$ ，如果 $x$ 有一个相邻节点 $y\notin S$ 是什么情况？</p></p>
<p>手动模拟可以发现一定是长这样：</p>
<p><img src="3.png" alt=""></p>
<p>总之就是 $x$ 和 $y$ 之间有一个分界线，两边的集合除了中间外无法互相到达。</p>
<p>从而知道 $x$ 只有一个相邻节点在 $S(a)$ 中。</p>
<p>因此我们可以知道 $S(a)$ 中的节点要么所有相邻节点都在里面，要么只有一个，我们又知道 $S(a)$ 是一个子连通块，因此这等价于这个子连通块中所有非叶子节点的所有相邻节点都在这个 $S(a)$ 中，这样有一个好处，任何一条从集合内走到集合外的简单路径都满足会经过子连通块的叶子（注：这个性质和定义其实是等价的，两者能互推）。</p>
<p>通过上面的描述，我们可以知道 $a$ 能利用 $x$ 等价于 $x\in S(a)$  且 $x$ 不是叶子。</p>
<p>同时通过上面那个例子，我们知道，对于 $S(a)$ 的叶子 $x$ ，如果 $x\in S(b)$ ，那么：</p>
<p><img src="4.png" alt=""></p>
<p>（准确来说这个图画的有点错，$a$ 不一定能到达左边的所有点）</p>
<p>要么 $b\in S(a)$ ，从而 $x$ 也是 $S(b)$ 的叶子，要么 $b\in V’$ ，则 $a,b$ 不可能利用同一个节点。</p>
<p>因此我们知道，如果 $S(a),S(b)$ 有交，且利用的节点有交集，可以通过上面的性质证明，$S(a)=S(b)$ ，同时因为他们利用同一个节点，所以一定有交，所以 $S(a)=S(b)$ ，证毕。</p>
</div></details>
<p>但是 $2\to 3,1\to 3$ 就十分麻烦了，因为在树上讨论交换是一个十分麻烦的事情，树的结构千变万化，很难用少量的讨论去说清楚这个事情。</p>
<p>因此一般情况下，给树赋予某种结构后再进行讨论会比较好，而 DFS 序就是树上一种比较一般且比较好的结构，所以很多树的证明都会涉及到 DFS 序，包括我的做法在最终证明和实现道题目的时候，也是用 DFS 序的。（虽然也可以用直径就是了）</p>
<p>在知道我的做法的正确性后，可以说明 $2\to 3,1\to 3$ 的正确性。首先可以用交换表述所有的情况，其次在 DFS 序上，两石子不能交换当且仅当路径中存在分界线那种结构，这个时候两个石子一定不能利用同一个节点。</p>
<p>因此两石子能利用一个节点则代表他们可以交换，证毕。</p>
<p>但是如果不基于我那个做法，单独给一个证明，我不会，我也没看懂题解那个证明。</p>
<p><img src="5.png" alt=""></p>
<p>我很想知道题解中这一步是怎么构造方案的，反正我感觉不基于某种结构是几乎不可能构造出来的，反正我的智商不支持我这么干，投降。</p>
<p>在假设上面都是对的后有意思的事情就来了。</p>
<p>现在可以建立一张图，其中以石子和度数 $\ge 3$ 的点为节点，其中如果石子可以利用一个位置，我们就给两点间连一条无向边，可以发现，这个图的每个连通块中的石子就是交换的。</p>
<p>以下都讨论都默认节点度数为 $3$ 。</p>
<p>但是这个图的量级是 $O(n^2)$ 的，不够得劲。注意到一个事情，如果 $a$ 能够同时利用 $x,y$ ，那么任何一个石子一定要么能同时利用 $x,y$ ，要么都不能，所以我们可以认为此时 $x,y$ 等价，可以发现这个等价也具有传递性。</p>
<p>同时又因为 $S(a)$ 也是联通块，我们可以得到，如果存在这样一条简单路径：$x\to y\to z$ ，那么 $a$ 能利用 $y$ / $x,y,z$ 等价。</p>
<p>这启示我们这么建图：$a$ 只向其各个方向上最近的 $x$ 连边，$x$ 只向其各个方向上最近的等价的 $y$ 连边，不难证明，这个图与上面那个图的连通性一样，而这个图的边数是 $O(n)$ 的。</p>
<p>开始讨论每条边在什么时候存在。</p>
<ol>
<li>$x,y$ 等价，可以发现在 $[1,n-dis(x,y)-2]$ 都存在，证明很好证明，不存在显然，存在只需要证明存在一个石头既能到 $x$ 又能到 $y$ ，这是显然的，直接先把所有石子移动到两边然后随便拿一个外面的石子就行了。</li>
<li>$a,x$ ，且 $a$ 初始时就在 $x$ 上，要么有至少两个子树（以 $x$ 为根）有空位，要么 $x$ 能等价于另外一个其他节点。</li>
<li><p>$a,x$ ，且 $a$ 初始不在 $x$ 上，条件为去掉 $a$ 所在的子树（以 $x$ 为根）和 $x$ 后的空位数量大于等于 $a$ 到 $x$ 路径上的石子数量 （包括 $a,x$）</p>
<p>首先满足肯定 $a$ 能利用 $x$ ，不满足，但 $a$ 能利用 $x$ ，那肯定是 $a$ 的儿子子树发力了，考虑 $a$ 的子树中最靠近 $a$ 的 $\ge 3$ 度点 $y$ （包括 $a$ 脚下的节点），能发生这种情况则 $a,y$ 一定能满足上面那个条件。（手模一下就知道了）</p>
<p>所以此时 $a$ 能利用 $y$ ，$x,y$ 等价，那么就算没有 $a,x$ 的边，$a$ 也能通过 $a-y-x$ 走到 $x$ ，所以不连也无所谓。</p>
</li>
</ol>
<p>然后就讨论完每条边的条件了。</p>
<p>其中第二种可以线性处理，而第三种边的条件等价于去掉 $x$ 为根时 $a$ 的子树，剩下的空位要 $\ge$ $dis(a,x)+1$ 需要用线段树合并处理出第 $k$ 个空位消失的时间。</p>
<p>这样我们就能知道每条边出现时间的右边界，而左边界显然是石子的出现时间，这个时候就已经可以用 $O(n\log^2 n)$ 的时间做完整道题目了。</p>
<p>但问题来了，一个石头真的需要放下了我们才能将其加入图中吗？</p>
<p>发现一个事情，第一种边也就是节点等价的边是不依赖于石子的，而且这个图的建立是绝对正确的，没有偷工减料，也就是只有第一种边的时候， $x,y$ 之间连通等价于他们等价。（注：有了第二、三种边也不影响这条性质成立）</p>
<p>同时可以证明：$\forall x≠y$ ，且此时满足了 $a$ 和 $x,y$ 连边的条件，那么无论此时 $a$ 放没放上去，$x,y$ 都等价。（发现第二三种边的条件不依赖于 $a$ 放没放上去，因此如果此时 $a$ 还没放上去，就先放上去，此时 $x,y$ 等价，然后再把 $a$ 拿走，空位增多，则此时 $x,y$ 还等价，证毕）</p>
<p>因此，先认为 $k$ 从大到小，则无论任何时候，与 $a$ 相关的边都只会导致一部分节点连通，而显然就算没有这些边，只靠第一种边，他们此时也是连通的，因此在 $k$ 小的时候没必要删掉 $a$ 和 $a$ 相关的那些边，只要记得不要把 $a$ 统计进答案里面就行了。</p>
<p>所以所有边的左边界都可以设为 $1$ ，因此可以用并查集维护，此时正道题目时间复杂度为 $O(n\log{n})$ 。</p>
<p>题外话：因为只有第一种边时就已经满足 $x,y$ 之间连通等价于他们等价，所以理论上 $a$ 只需要和其中一个其能利用的节点连边就行了，第三种边的部分边可以不建立就是这个原理。</p>
<p>但是能不能在 $O(n\alpha(n))$ 的时间完成这道题目呢？</p>
<p>答案是可以，和我的做法同样的手法，按照 DFS 序放石子就行了，这样每个子树都是一个区间，上面所有的查询都变得十分简单，能够在 $O(1)$ 的时间得到，这样就不用线段树合并了，时间复杂度瓶颈变为并查集，总时间复杂度变为 $O(n\alpha(n))$。</p>
<p>写一下我对这个做法的评价：</p>
<p>首先我突然觉得我的做法比他的做法好想，我搞这个做法我会直接卡在那一步 $1,2\to 3$ ，直接放弃接下来的思考（虽然接下来的部分也不简单就是了）。</p>
<p>但就这个做法而言，我给予高度的评价，首先他这个做法并不像我的做法一样特化，我的做法是必须在 DFS 序这个结构上的，并不一般。而他这个做法在任意的石子局面下都能做到 $O(n\log{n})$ ，就已经比我的做法强了不知道多少了（我当时其实有试过把我的做法推向一般局面，但是失败了），而在 DFS 序下也能做到 $O(n\alpha(n))$ ，不输我的做法。</p>
<p>同时他的做法还引进了一个新的概念 $S(a)$ ，并且深挖出了很多和 $S(a)$ 有关的性质，我当时试图从这个角度上想，但是失败了，因此单就这个新的概念本身以及很多相关的性质，就又赢了我的做法很多。</p>
<p>反正我认为这个做法的意义是多方面的，在这当中我学到了很多新的东西。<del>虽然花了很多时间</del></p>
<p>此时再看看我的做法，也就胜在好想了。<del>但是这是比赛，好想胜过一切，我的做法，赢！</del></p></div></details>]]></content>
      <categories>
        <category>信息学</category>
      </categories>
  </entry>
  <entry>
    <title>ARC135 赛后总结</title>
    <url>/2024/06/25/ARC135-%E8%B5%9B%E5%90%8E%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>比赛链接：<a href="https://atcoder.jp/contests/arc135/tasks/arc135_a">https://atcoder.jp/contests/arc135/tasks/arc135_a</a></p>
<h1 id="A-Floor-Ceil-Decomposition"><a href="#A-Floor-Ceil-Decomposition" class="headerlink" title="A. Floor, Ceil - Decomposition"></a>A. Floor, Ceil - Decomposition</h1><p>题目链接：<a href="https://atcoder.jp/contests/arc135/tasks/arc135_a">https://atcoder.jp/contests/arc135/tasks/arc135_a</a></p>
<p>题目大意：每次你可以选择一个数字，分为 $\left\lfloor \frac{x}{2} \right\rfloor, \left\lceil \frac{x}{2} \right\rceil$ ，一开始只有一个数字 $X$ ，问你最终可能的乘积最大值是多少。</p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>很弱智，显然 $\ge 4$ 直接分就行了。</p>
<p>最后只会剩下 $2,3$ 。</p>
<p>但是我的写法比较 SB 。</p>
<p>我写了个堆 + map，每次把最大数字弹出并且记录个数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> LL mod = <span class="number">998244353</span>;</span><br><span class="line"><span class="function">LL <span class="title">ksm</span><span class="params">(LL x, LL y)</span></span>&#123;</span><br><span class="line">    x %= mod;</span><br><span class="line">    LL ans = <span class="number">1ll</span>;</span><br><span class="line">    <span class="keyword">while</span>(y)&#123;</span><br><span class="line">        <span class="keyword">if</span>(y &amp; <span class="number">1</span>) ans = ans * x % mod;</span><br><span class="line">        x = x * x % mod;</span><br><span class="line">        y &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line">map&lt;LL, LL&gt; m;</span><br><span class="line">priority_queue&lt;LL&gt; p;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(LL x, LL y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(m.<span class="built_in">find</span>(x) == m.<span class="built_in">end</span>()) p.<span class="built_in">push</span>(x);</span><br><span class="line">    m[x] += y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    LL x;</span><br><span class="line">    cin &gt;&gt; x;</span><br><span class="line">    m[x] = <span class="number">1ll</span>;</span><br><span class="line">    p.<span class="built_in">push</span>(x);</span><br><span class="line">    <span class="keyword">while</span>(p.<span class="built_in">top</span>() &gt;= <span class="number">4</span>)&#123;</span><br><span class="line">        LL x = p.<span class="built_in">top</span>();</span><br><span class="line">        p.<span class="built_in">pop</span>();</span><br><span class="line">        LL cnt = m[x];</span><br><span class="line">        LL a = x / <span class="number">2</span>, b = x - a;</span><br><span class="line">        <span class="built_in">add</span>(a, cnt);</span><br><span class="line">        <span class="built_in">add</span>(b, cnt);</span><br><span class="line">    &#125;</span><br><span class="line">    LL ans = <span class="number">1ll</span>;</span><br><span class="line">    <span class="keyword">while</span>(!p.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        LL x = p.<span class="built_in">top</span>();</span><br><span class="line">        p.<span class="built_in">pop</span>();</span><br><span class="line">        ans = ans * <span class="built_in">ksm</span>(x, m[x]) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有没有更加好写的写法？</p>
<p>有，记忆化搜索。</p>
<p>也是我认为最好写的写法。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> LL mod = <span class="number">998244353</span>;</span><br><span class="line">map&lt;LL, LL&gt; dp;</span><br><span class="line"><span class="function">LL <span class="title">dfs</span><span class="params">(LL x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(dp.<span class="built_in">find</span>(x) != dp.<span class="built_in">end</span>()) <span class="keyword">return</span> dp[x];</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> dp[x] = <span class="built_in">dfs</span>(x / <span class="number">2</span>) * <span class="built_in">dfs</span>(x - x / <span class="number">2</span>) % mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    dp[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">    dp[<span class="number">3</span>] = <span class="number">3</span>;</span><br><span class="line">    LL n; cin &gt;&gt; n;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">dfs</span>(n) &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还有一种写法是直接记录 $\left\lfloor \frac{x}{2^k} \right\rfloor, \left\lceil \frac{x}{2^k} \right\rceil$ 以及其个数，直到组合为 $\{2,3\},\{3,4\}$ 时结束。</p>
<p>但我个人感觉这种写法就算比第一种写法好写，也容易写错，所以赛时没有使用。</p>
<p>具体代码没写。</p>
</div></details>
<h1 id="B-Sum-of-Three-Terms"><a href="#B-Sum-of-Three-Terms" class="headerlink" title="B. Sum of Three Terms"></a>B. Sum of Three Terms</h1><p>题目链接：<a href="https://atcoder.jp/contests/arc135/tasks/arc135_b">https://atcoder.jp/contests/arc135/tasks/arc135_b</a></p>
<p>题目大意：给你一个数组 $S$ ，要求找到一个长度为 $n+2$ 的数组 $A$ 满足：</p>
<ol>
<li>非负。</li>
<li>$S[i]=A[i]+A[i+1]+A[i+2]$</li>
</ol>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>注意到 $S[i+1]-S[i]=A[i+3]-A[i]$ 。</p>
<p>所以条件可以等价成：$A[1]+A[2]+A[3]=S[1]$ ，以及 $A[i]-A[i-3]=k$ ，以及要求非负。</p>
<p>那么直接求出在非负条件下 $A[1],A[2],A[3]$ 的下界，然后直接随便定个初值就行了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;LL, LL&gt; PLL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">3e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> LL inf = <span class="number">1e9</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">LL S[N], sum[N];</span><br><span class="line">LL l[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n + <span class="number">1</span>; i++)&#123;</span><br><span class="line">        cin &gt;&gt; S[i];</span><br><span class="line">    &#125;</span><br><span class="line">    l[<span class="number">0</span>] = l[<span class="number">1</span>] = l[<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">3</span>; i &lt;= n + <span class="number">1</span>; i++)&#123;</span><br><span class="line">        sum[i] = sum[i - <span class="number">3</span>] + S[i] - S[i <span class="number">-1</span>];</span><br><span class="line">        l[i % <span class="number">3</span>] = <span class="built_in">max</span>(l[i % <span class="number">3</span>], -sum[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(l[<span class="number">0</span>] + l[<span class="number">1</span>] + l[<span class="number">2</span>] &gt; S[<span class="number">2</span>])&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;No\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Yes\n&quot;</span>;</span><br><span class="line">    l[<span class="number">2</span>] = S[<span class="number">2</span>] - l[<span class="number">0</span>] - l[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">3</span>; i &lt;= n + <span class="number">1</span>; i++)&#123;</span><br><span class="line">        l[i] = l[i % <span class="number">3</span>] + sum[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n + <span class="number">1</span>; i++)&#123;</span><br><span class="line">        cout &lt;&lt; l[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>跟官方做法本质相同，在此不再赘述。</p>
</div></details>
<h1 id="C-XOR-to-All"><a href="#C-XOR-to-All" class="headerlink" title="C. XOR to All"></a>C. XOR to All</h1><p>题目链接：<a href="https://atcoder.jp/contests/arc135/tasks/arc135_c">https://atcoder.jp/contests/arc135/tasks/arc135_c</a></p>
<p>题目大意：给你一个序列，每次可以选择其中一个数字，然后让序列中所有数字异或这个数字，问最后得到的和的最大值是多少，可以操作无数次。</p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>注意到一个事情，最终答案一定是所有序列异或上某个数字，而且只要操作过，就一定有数字为 $0$ ，综上，我们直到无论操作多少次，都等价于让序列异或上原来序列中的一个数字，也就是操作多次=操作一次。</p>
<p>所以直接枚举统计答案就行了。</p>
<p>时间复杂度：$O(n\log{V})$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">3e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> L = <span class="number">30</span>;</span><br><span class="line">LL cnt[L], n, a[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; L; j++) cnt[j] += (a[i] &gt;&gt; j) &amp; <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    LL ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        ans += a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        LL now = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; L; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>((a[i] &gt;&gt; j) &amp; <span class="number">1</span>) now += (<span class="number">1ll</span> &lt;&lt; j) * (n - cnt[j]);</span><br><span class="line">            <span class="keyword">else</span> now += (<span class="number">1ll</span> &lt;&lt; j) * cnt[j];</span><br><span class="line">        &#125;</span><br><span class="line">        ans = <span class="built_in">max</span>(ans, now);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></details>
<h1 id="D-Add-to-Square"><a href="#D-Add-to-Square" class="headerlink" title="D. Add to Square"></a>D. Add to Square</h1><p>题目链接：<a href="https://atcoder.jp/contests/arc135/tasks/arc135_d">https://atcoder.jp/contests/arc135/tasks/arc135_d</a></p>
<p>题目大意：给一个表格，然后可以执行一个操作：选择一个 2*2 的子矩阵，然后让其加上同一个值（可以为负数），可以执行无数次，问最小的可能的绝对值和是多少。</p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>一个很典的想法是，先给这个操作找到不变量。</p>
<p>可以发现，如果将表格奇偶染色，然后将奇数格变成负的，然后将操作做对应的变换，那么整个矩阵的和就是不变量，而且不影响最终答案。（显然取负值并不改变绝对值的和）</p>
<p>所以变成这样的问题：选择一个 2*2 的矩阵，使得 $(1,1),(2,2)$ 加上 $x$ ，$(1,2),(2,1)$ 减去 $x$ 。</p>
<p>又可以发现，这里我们相当于有 $(n-1)(m-1)$ 个方程，且不线性相关，所以我们能把左上角消成 $0$ ，只保留最右边和最下边。</p>
<p>但是剩下的数字是多少，这个时候就可以发现，其实每行和每列的和也是不变量，这决定了在把左上角矩阵消成 $0$ 后的矩阵长啥样。</p>
<p>接着就可以发现：两个矩阵能互相到达当且仅当每行和每列的和是一样的。</p>
<p>然后就可以做了，不难发现答案的上界是：行的和的绝对值和，和列的和的绝对值和的最大值。</p>
<p>构造方案就是一个匹配的活。</p>
<p>时间复杂度：$O(nm+n^2+m^2)$ 。</p>
<p>做毕。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">5e2</span> + <span class="number">5</span>;</span><br><span class="line">LL a[N][N], b[N][N];</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line">LL row[N], col[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sgn</span><span class="params">(LL x)</span></span>&#123;<span class="keyword">return</span> x &lt; <span class="number">0</span> ? <span class="number">-1</span> : (x &gt; <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>);&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++)&#123;</span><br><span class="line">            cin &gt;&gt; a[i][j];</span><br><span class="line">            <span class="keyword">if</span>((i + j) &amp; <span class="number">1</span>) a[i][j] = -a[i][j];</span><br><span class="line">            row[i] += a[i][j];</span><br><span class="line">            col[j] += a[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="built_in">sizeof</span>(a));</span><br><span class="line">    <span class="type">int</span> type = <span class="number">0</span>;</span><br><span class="line">    LL ans = <span class="number">0ll</span>;</span><br><span class="line">    &#123;</span><br><span class="line">        LL ans1 = <span class="number">0ll</span>, ans2 = <span class="number">0ll</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) ans1 += <span class="built_in">abs</span>(row[i]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) ans2 += <span class="built_in">abs</span>(col[i]);</span><br><span class="line">        <span class="keyword">if</span>(ans1 &lt; ans2)&#123;</span><br><span class="line">            type = <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">swap</span>(n, m);</span><br><span class="line">            <span class="built_in">swap</span>(row, col);</span><br><span class="line">            <span class="built_in">swap</span>(ans1, ans2);</span><br><span class="line">        &#125;</span><br><span class="line">        ans = ans1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="type">int</span> x = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(col[i] != <span class="number">0</span>) &#123;x = i; <span class="keyword">break</span>;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(x == <span class="number">-1</span>) <span class="keyword">break</span>;</span><br><span class="line">        <span class="type">int</span> y = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">sgn</span>(col[x]) == <span class="built_in">sgn</span>(row[i]))&#123;</span><br><span class="line">                y = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">assert</span>(y != <span class="number">-1</span>);</span><br><span class="line">        a[y][x] = <span class="built_in">sgn</span>(col[x]) * <span class="built_in">min</span>(<span class="built_in">abs</span>(col[x]), <span class="built_in">abs</span>(row[y]));</span><br><span class="line">        col[x] -= a[y][x];</span><br><span class="line">        row[y] -= a[y][x];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="type">int</span> x = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(row[i] != <span class="number">0</span>) &#123;x = i; <span class="keyword">break</span>;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(x == <span class="number">-1</span>) <span class="keyword">break</span>;</span><br><span class="line">        <span class="type">int</span> y = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(row[i] != <span class="number">0</span> &amp;&amp; <span class="built_in">sgn</span>(row[x]) != <span class="built_in">sgn</span>(row[i]))&#123;</span><br><span class="line">                y = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        LL val = <span class="built_in">min</span>(<span class="built_in">abs</span>(row[x]), <span class="built_in">abs</span>(row[y]));</span><br><span class="line">        a[x][<span class="number">1</span>] += <span class="built_in">sgn</span>(row[x]) * val;</span><br><span class="line">        a[y][<span class="number">1</span>] += <span class="built_in">sgn</span>(row[y]) * val;</span><br><span class="line">        row[x] -= <span class="built_in">sgn</span>(row[x]) * val;</span><br><span class="line">        row[y] -= <span class="built_in">sgn</span>(row[y]) * val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(type)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++) b[i][j] = a[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++) a[j][i] = b[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">swap</span>(n, m);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>((i + j) &amp; <span class="number">1</span>) a[i][j] = -a[i][j];</span><br><span class="line">            cout &lt;&lt; a[i][j] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></details>
<h1 id="E-Sequence-of-Multiples"><a href="#E-Sequence-of-Multiples" class="headerlink" title="E. Sequence of Multiples"></a>E. Sequence of Multiples</h1><p>题目链接：<a href="https://atcoder.jp/contests/arc135/tasks/arc135_e">https://atcoder.jp/contests/arc135/tasks/arc135_e</a></p>
<p>题目大意：给定 $N,X$ ，要求构造一个和最小的长度为 $N$ 的序列 $A$ 满足：</p>
<ol>
<li>严格递增。</li>
<li>$A_1=X$</li>
<li>$A_{i}$ 被 $i$ 整除。</li>
</ol>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>注意到一个事情：$A_i=i*B_i$ 。</p>
<p>那么 $A_{i}\equiv -B_i \mod{i+1}$ 。</p>
<p>我们显然关心 $A_{i+1}-A_{i}$ ，而这个显然等于：$B_{i}\mod i+1$ （注，由于严格递增，在整除的时候为 $i+1$）</p>
<p>当 $B_{i}&lt;i+1$ 时，就为 $B_{i}$ ，而且不难发现以后也为 $B_{i}$ 。</p>
<p>即 $B_{i}$ 是非严格单调递减的，而且当 $B_{i}\le i+1$ 后，$B_{i}$ 保持恒定。</p>
<p>具体来说：$B_{i+1}=B_{i}-\left\lfloor\frac{B_{i}-1}{i+1}\right\rfloor$</p>
<p>但是我们可以发现，这个保持恒定的量级可以到 $10^9$ 。</p>
<p>$\ge$ 是显然的，$\le$ 也不难：</p>
<p>往极坏的角度想：在 $i$ 的时候就 $+i$ 。</p>
<p>那么在 $2e9$ 的时候就是：$1e18+\frac{(2e9+1)*2e9}{2}&lt;2e9^2$ 。</p>
<p>所以在 $\le 2e9$ 的时候进入恒定状态。</p>
<p>但我们显然不可能枚举这个量级，怎么办呢？</p>
<p>在苦思冥想下，我突然意识到，复杂度有没有可能是：$O(n^{\frac{1}{3}})$ 的。</p>
<p>因为可以发现在 $1e6$ 量级后，$\frac{B_i-1}{i}$ 的量级也是 $1e6$ 的。（与上面的证明方法类似）</p>
<p>而且 $\left\lfloor\frac{B_{i}-1}{i+1}\right\rfloor$ 是单调递减的，这意味着 $B_{i+1}-B_{i}$ 在 $1e6$ 之后只会有 $1e6$ 种可能的取值。（以上指的都是量级）</p>
<p>所以直接二分出每个可能取值的分界点，就可以在 $O(n^{\frac{1}{3}}\log{n})$ 的复杂度内解决了。</p>
<p>后面发现二分的判别式是一个线性函数，因此可以 $O(1)$ 找到分界点。</p>
<p>而且类似整除分块的，在 $1e6$ 之前的部分同样也可以用这个函数处理，因为也只有 $1e6$ 种取值，不过限制取值数量的条件不是值域，而是定义域，这时求出来的分界点很集中，基本就是自己。</p>
<p>然后就做完了。</p>
<p>时间复杂度：$O(Tn^{\frac{1}{3}})$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> LL mod = <span class="number">998244353</span>;</span><br><span class="line"><span class="function">LL <span class="title">ksm</span><span class="params">(LL x, LL y)</span></span>&#123;</span><br><span class="line">    LL ans = <span class="number">1ll</span>;</span><br><span class="line">    <span class="keyword">while</span>(y)&#123;</span><br><span class="line">        <span class="keyword">if</span>(y &amp; <span class="number">1</span>) ans = ans * x % mod;</span><br><span class="line">        x = x * x % mod;</span><br><span class="line">        y &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">ni</span><span class="params">(LL x)</span></span>&#123;<span class="keyword">return</span> <span class="built_in">ksm</span>(x, mod - <span class="number">2</span>);&#125;</span><br><span class="line"><span class="type">const</span> LL n2 = <span class="built_in">ni</span>(<span class="number">2</span>), n4 = <span class="built_in">ni</span>(<span class="number">4</span>), n6 = <span class="built_in">ni</span>(<span class="number">6</span>);</span><br><span class="line"><span class="function">LL <span class="title">mt</span><span class="params">(LL x)</span></span>&#123;<span class="keyword">return</span> (x % mod + mod) % mod;&#125;</span><br><span class="line"><span class="function">LL <span class="title">q1</span><span class="params">(LL x)</span></span>&#123;<span class="keyword">return</span> <span class="built_in">mt</span>(x) * <span class="built_in">mt</span>(x + <span class="number">1</span>) % mod * n2 % mod;&#125;</span><br><span class="line"><span class="function">LL <span class="title">q1</span><span class="params">(LL l, LL r)</span></span>&#123;<span class="keyword">return</span> <span class="built_in">mt</span>(<span class="built_in">q1</span>(r) - <span class="built_in">q1</span>(l - <span class="number">1</span>));&#125;</span><br><span class="line"><span class="function">LL <span class="title">q2</span><span class="params">(LL x)</span></span>&#123;<span class="keyword">return</span> <span class="built_in">mt</span>(x) * <span class="built_in">mt</span>(x + <span class="number">1</span>) % mod * <span class="built_in">mt</span>(x + x + <span class="number">1</span>) % mod * n6 % mod;&#125;</span><br><span class="line"><span class="function">LL <span class="title">q2</span><span class="params">(LL l, LL r)</span></span>&#123;<span class="keyword">return</span> <span class="built_in">mt</span>(<span class="built_in">q2</span>(r) - <span class="built_in">q2</span>(l - <span class="number">1</span>));&#125;</span><br><span class="line"><span class="comment">// LL q3(LL x)&#123;return mt(x) * mt(x) % mod * mt(x + 1) % mod * mt(x + 1) % mod * n4 % mod;&#125;</span></span><br><span class="line"><span class="comment">// LL q3(LL l, LL r)&#123;return mt(q3(r) - q3(l - 1));&#125;</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        LL n, X, ans = <span class="number">0ll</span>;</span><br><span class="line">        cin &gt;&gt; n &gt;&gt; X;</span><br><span class="line">        ans = <span class="built_in">mt</span>(n) * <span class="built_in">mt</span>(X) % mod;</span><br><span class="line">        LL val = <span class="number">2ll</span>;</span><br><span class="line">        <span class="keyword">while</span>(val &lt; X &amp;&amp; val &lt;= n)&#123;</span><br><span class="line">            LL cnt = (X - <span class="number">1</span>) / val;</span><br><span class="line">            LL l = val + <span class="number">1</span>, r = <span class="built_in">min</span>(X / cnt, n), mid, pos = val;</span><br><span class="line">            pos = <span class="built_in">min</span>((X + cnt * val - <span class="number">1</span>) / (cnt + cnt), n);</span><br><span class="line">            ans += <span class="built_in">mt</span>(X + val * cnt) * <span class="built_in">mt</span>(n + <span class="number">1</span>) % mod * <span class="built_in">mt</span>(pos - val + <span class="number">1</span>) % mod;</span><br><span class="line">            ans -= <span class="built_in">mt</span>(X + val * cnt) * <span class="built_in">q1</span>(val, pos) % mod;</span><br><span class="line">            ans -= <span class="built_in">mt</span>(cnt + cnt) * <span class="built_in">mt</span>(n + <span class="number">1</span>) % mod * <span class="built_in">q1</span>(val, pos) % mod;</span><br><span class="line">            ans += <span class="built_in">mt</span>(cnt + cnt) * <span class="built_in">q2</span>(val, pos) % mod;</span><br><span class="line"></span><br><span class="line">            ans = <span class="built_in">mt</span>(ans);</span><br><span class="line"></span><br><span class="line">            X -= cnt * (pos - val + <span class="number">1</span>);</span><br><span class="line">            val = pos + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(val &lt;= n)&#123;</span><br><span class="line">            <span class="built_in">assert</span>(X &lt;= val);</span><br><span class="line">            ans += <span class="built_in">mt</span>(n - val + <span class="number">2</span>) * <span class="built_in">mt</span>(n - val + <span class="number">1</span>) % mod * n2 % mod * X;</span><br><span class="line">            ans = <span class="built_in">mt</span>(ans);</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但因为没在赛时推出正确的式子，导致无法在赛时 AC 。</p>
<p>不过是 VP ，问题也不是那么大。</p>
<p>和官方做法基本一致，在此不再赘述官方做法。</p>
</div></details>
<details class="toggle" ><summary class="toggle-button" style="">别的做法</summary><div class="toggle-content"><p><a href="https://www.luogu.com.cn/article/thzagqey">https://www.luogu.com.cn/article/thzagqey</a></p>
<p>有一种做法，是打表，发现在 $\sqrt{x}$ 后 $A$ 变成了等差数列。</p>
<p>差分一下，发现序列由 $n^{\frac{1}{3}}$ 段等差数列构成，并且总是在即将 $\le 0$ 后转换到下一个等差数列。</p>
<p>更准确的来讲，是说可以把序列分成若干段等差数列，每段都在即将 $\le 0$ 时结束，等差数列的长度可以为 $1$ 。（后面会讲为什么）</p>
<p>直接计算就行了。</p>
<p>时间复杂度：$O(Tn^{\frac{1}{3}})$ 。</p>
<p>问题来了，为什么？</p>
<p>首先等差数列不难理解，在我的做法中，$B_{i-1}-\left\lfloor\frac{B_{i-1}-1}{i}\right\rfloor<em>i=B_{i-1}-(B_{i-1}-B_{i})</em>i=B_{i}<em>i-B_{i-1}</em>(i-1)=A_{i}-A_{i-1}$ 就是 $A$ 的差分，二分中的每一段实际就是 $B$ 差分相等的部分，即我们认为：$B_{i+k}=B_{i}-kd$ 。</p>
<p>则有：</p>
<script type="math/tex; mode=display">\begin{align*}

&B_{i+k}(i+k)-B_{i+k-1}(i+k-1) \\
=&(B_{i}-kd)(i+k)-(B_{i}-(k-1)d)(i+k-1) \\
=&B_{i}-kd-d(i+k-1) \\
=&B_{i}-2dk-d(i-1) \\
=&-2dk+(B_{i}-d(i-1))

\end{align*}</script><p>即 $A$ 的一阶差分是个等差数列。</p>
<p>但为什么总是在即将 $\le 0$ 后转换到下一个等差数列呢？</p>
<p>而分界点的条件可以表示为：</p>
<p>最大的 $k$ 满足：$\left\lfloor\frac{B_{i+(k-1)}-1}{i+k}\right\rfloor \ge d,\left\lfloor\frac{B_{i+k}-1}{i+k+1}\right\rfloor &lt; d$ ，这里 $\ge$ 可以写成 $=$ 。</p>
<p>也就是：</p>
<script type="math/tex; mode=display">
\begin{align*}
\left\lfloor\frac{B_{i+k-1}-1}{i+k}\right\rfloor &\ge d \\
B_{i}-(k-1)d-1&\ge d(i+k)\\
B_{i}&\ge 2dk+d(i-1)+1\\
B_{i}-2dk-d(i-1)&\ge 1\\
A_{i+k}-A_{i+k-1}&\ge 1\\

\left\lfloor\frac{B_{i+k}-1}{i+k+1}\right\rfloor &< d\\
B_{i}-kd-1&<d(i+k+1)\\
B_{i}&<2d(k+1)+d(i-1)+1\\
B_{i}-2d(k+1)-d(i-1)&<1\\

\end{align*}</script><p>这就证明了这件事情。</p>
<p>但需要注意的是：可以发现，一段长度为 $len+1$ 的 $B$ 的等差数列，对应 $A$ 的差分序列的一段长度为 $len$ 的等差数列，因此会有很多长度为 $1$ 的等差数列。（虽然可以认为相邻两个数字是等差数列，但是这种等差数列并不满足上面的将要 $\le 0$ 就切换到另外一个等差数列的性质）</p>
<p>为此，在实现中的一个简单的解决方法是直接算出后 $10$ 项，如果满足等差数列就直接算，赌他不会这么巧恰好由 $10$ 个长度为 $1$ 的等差数列构成。</p>
<p>但是我们还是希望知道什么时候 $len$ 会稳定的 $\ge 2$ 呢？</p>
<p>我们先设 $C_{i}=B_{i}-1$ ，那么 $C_{i+1}=C_{i}-\left\lfloor\frac{C_{i}}{i+1}\right\rfloor$ 。</p>
<p>那么问题可以抽象成这样：</p>
<p>现在有 $i+1$ 个柱子，均匀放，每次将最少东西的柱子的东西删除，再添加一个柱子均匀放，问经过几轮后能够出现稳定两轮删除的东西数相同？</p>
<p>设 $D_{i}=\left\lfloor\frac{C_{i}}{i+1}\right\rfloor$ ，这里给一个必要条件，当 $D_{i-1} ≠ D_{i}$ 且 $6D_{i}+1\le i$ 时，在此之后 $len\ge 1$ 。</p>
<p>证明就是假定一个 $i*D_{i-1}$ 的长方形（这样对后面的亏损是最大化的），然后开做这个补的过程，发现可以做至少两次，同时可以证明此时 $D_{i-1}=D_{i}+1$ ，所以只能用最上面那一行来补就证明完了。</p>
<script type="math/tex; mode=display">\begin{align*}
D_{i}&\le \frac{i-1}{6}\\
C_{i}&\le (i+1)D_{i}+i\le \frac{i^2-1}{6}+i\\
B_{i}=C_{i}+1&\le \frac{i^2+6i+5}{6}\\
A_{i}&\le \frac{i^2+6i+5}{6}*i\\
\end{align*}</script><p>我们想要估计出 $i$ 的量级：</p>
<script type="math/tex; mode=display">\begin{align*}
A_1+\frac{i(i+1)}{2}&\le \frac{i^2+6i+5}{6}*i\\
10^{18}&\le \frac{i^2+6i+5}{6}*i-\frac{i(i+1)}{2}\\
\end{align*}</script><p>这条式子在 $\ge 2*10^6$ 处总是满足，而且显然是 $O(n^{\frac{1}{3}})$ 的。</p>
<p>问题就在于什么时候：$D_{i}≠D_{i+1}$ 。</p>
<p>设 $a_{i}=A_{i}-A_{i-1}$ 。</p>
<p>如果 $a_{i+1}&gt;a_{i}$ 或者 $a_{i}-a_{i-1}≠a_{i+1}-a_{i}$ ，那么显然 $D_{i}≠D_{i-1}$ 。</p>
<p>否则：$a_{i-1}\ge a_{i}\ge a_{i+1},a_{i-1}-a_{i}=a_{i}-a_{i+1}$ ，那么有如果 $D_{i-1}≠D_{i}$ ，那么从 $i$ 开始就有长度为 $2$ 的等差数列，公差为 $a_{i}-a_{i+1}$，否则 $D_{i-1}=D_{i}$ ，这个时候 $i$ 依旧是公差为 $a_{i}-a_{i+1}$ 的等差数列的一部分，直接计算就行了。</p>
<p>也就是说，在 $2e6$ 后我们可以在 $O(1)$ 的时间进入求等差数列的过程，这个过程就是：求出公差，一直算到 $\le 0$ 为止，然后接着求下一段直到 $\ge n$ 。（因为 $A$ 为等差数列的阶段等价于 $a$ 为恒为 $0$ 的等差数列的阶段，只不过这个等差数列不会结束而已）</p>
<p>这样这个做法就比较好实现了。</p>
<p>综上，时间复杂度：$O(Tn^{\frac{1}{3}})$ 。<del>但问题是如果我都会证明这个了为什么不直接用上面这个做法</del></p>
<p>其实说的道理，既然一开始就选择了打表，不妨在实现时就使用多算几项估计一下等差数列，也不会有多难写，还充分发扬了打表省时间的优势，如果尝试证明的话就会浪费不少时间了，不过赛后确实可以花时间证证。</p>
</div></details>]]></content>
      <categories>
        <category>信息学</category>
      </categories>
  </entry>
  <entry>
    <title>Border学习笔记</title>
    <url>/2024/02/11/Border%E7%90%86%E8%AE%BA/</url>
    <content><![CDATA[<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://www.luogu.com.cn/blog/command-block/border-li-lun-xiao-ji">https://www.luogu.com.cn/blog/command-block/border-li-lun-xiao-ji</a></p>
<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><h2 id="Border"><a href="#Border" class="headerlink" title="Border"></a>Border</h2><p>$Border$ ：字符串的某个前缀（非原串），能与后缀完全匹配。</p>
<p>例：$S[1,m]=S[n-m+1,n]$ ，那么称 $S[1,m]$ 为 $S$ 的一个 $Border$ 。</p>
<p>接下来简称 $Border$ 为 $Bd$ 。</p>
<p>我们称 $mxBd(S)$ 为 $S$ 最长的 $Bd$ ，$Bd(S)$ 为 $S$ 的 $Bd$ 集合。</p>
<h2 id="周期"><a href="#周期" class="headerlink" title="周期"></a>周期</h2><p>若对于 $p$ ，有 $S[i]=S[i+p]$ ，称 $p$ 是 $S$ 的周期。</p>
<p>若 $p| |S|$ ，则称 $p$ 为整周期。</p>
<p>显然，$S[1,p]$ 是 $Bd$ $\Leftrightarrow$ $|S|-p$ 是周期。</p>
<h1 id="与-kmp-的关系"><a href="#与-kmp-的关系" class="headerlink" title="与 kmp 的关系"></a>与 kmp 的关系</h1><h2 id="求每个前缀的最长-Border"><a href="#求每个前缀的最长-Border" class="headerlink" title="求每个前缀的最长 Border"></a>求每个前缀的最长 Border</h2><p>显然，$fail[i]$ 表示的就是 $mxBd(S[1,i])$ 的长度。</p>
<h2 id="求一个串的-Bd-集合。"><a href="#求一个串的-Bd-集合。" class="headerlink" title="求一个串的 $Bd$ 集合。"></a>求一个串的 $Bd$ 集合。</h2><p>无脑 Hash 可以，但是有个更加有理有据的做法：</p>
<p>$Bd(S)=\{mxBd(S)\}+Bd(mxBd(S))$</p>
<p>然后直接用 kmp 的 fail 指针不断跳就行了，即 $Bd(S)$ 对应了 $fail$ 树上的一条链。</p>
<h1 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h1><h2 id="弱周期引理-Weak-Periodicity-Lemma，简称：WPL"><a href="#弱周期引理-Weak-Periodicity-Lemma，简称：WPL" class="headerlink" title="弱周期引理(Weak Periodicity Lemma，简称：WPL)"></a>弱周期引理(Weak Periodicity Lemma，简称：WPL)</h2><p>$p,q$ 都是 $S$ 的周期 ，且 $p+q\le |S|$ ，则 $gcd(p,q)$ 也是 $S$ 的周期。</p>
<p>证明：不妨假设 $p&lt;q$ 。</p>
<p>$S[i]=S[i+q]=S[i+q-p],i\le n-q$</p>
<p>$S[i]=S[i-p]=S[i+q-p],p\le n-q&lt;i\le n+q-p$</p>
<p>所以 $q-p$ 也是一个周期，辗转相减即可证明该结论。</p>
<p>PS：强周期定理：把条件改成 $p+q-gcd(p,q)\le n$ ，不会证明，大部分情况下用弱周期就行了，强周期了解即可。</p>
<p>推论：如果一个串有 $&lt;|S|$ 的整周期，则最小周期也是整周期。</p>
<h2 id="等差数列"><a href="#等差数列" class="headerlink" title="等差数列"></a>等差数列</h2><p><strong>性质 1</strong> ：$S,T,2|S|\ge |T|$ ，则 $S$ 在 $T$ 中的出现位置构成等差数列。</p>
<details class="toggle" ><summary class="toggle-button" style="">证明</summary><div class="toggle-content"><p>如果出现次数小于 $3$ 次，显然成立。</p>
<p>考虑第一次出现位置 $S1$ 、第二次出现位置 $S2$ 和任意一次（除了前两次）出现位置 $S3$ ，假设 $S2-S1=l1,S3-S2=l2$ 。</p>
<p><img src="1.png" alt=""></p>
<p>现在证明 $l1 | l2$ ，考虑 $S1\cup S2$ 这个字符串，显然 $l1,l2$ 都是一个周期，且 $l2\le |S|$ ，则 $l1+l2\le l1+|S|=|S1\cup S2|$ ，所以 $gcd(l1,l2)$ 也是一个周期，如果 $gcd(l1,l2)&lt;l1$ ，则在 $S1$ 和 $S2$ 中间显然还出现了至少一次，与假设矛盾，证毕。</p>
<p>所以 $l1 | l2$ ，则结论显然成立 ，$l1$ 就是公差。</p>
</div></details>
<p><strong>性质 2</strong> ：一个字符串 $S$ 的长度 $\ge \frac{|S|}{2}$ 的 Border 构成等差数列。</p>
<details class="toggle" ><summary class="toggle-button" style="">证明</summary><div class="toggle-content"><p>第一个证明方法是用周期和 Border 的等价性，然后用 WPL 很容易就能证明。</p>
<p>还有一个证明方法是用上面的性质 $1$ ，设 $s$ 为 $\ge \frac{|S|}{2}$ 的长度最短的 Border 。</p>
<p>考虑 $s$ 的所有出现位置，显然，一个 $\ge \frac{|S|}{2}$ 的 Border 对应一个 $s$ 的出现位置，只需要证明一个 $s$ 的出现位置（除了最后一个位置）也对应一个 Border 即可。</p>
<p>（对应方式为：除了最后一个出现位置外的出现位置，考虑这个出现位置的右端点，右端点对应的前缀就是一个 Border ，实际上，如果把原串也视作一个 border 的话，那么最后一个出现位置也有对应了）</p>
<p><img src="2.png" alt=""></p>
<p>证明方法为：观察性质 $1$ 的证明可以发现，$s$ 出现位置的公差就是 $S$ 的周期，所以显然除了最后一个位置外的每一个出现位置都对应了一个 Border 。</p>
<p>但是上面两个方法我还是推荐用周期进行考虑。</p>
</div></details>
<p><strong>性质 3</strong> ：一个字符串的 Border 从小到大排序可以划分成 $O(\log{|S|})$ 个等差数列。</p>
<details class="toggle" ><summary class="toggle-button" style="">证明</summary><div class="toggle-content"><p>考虑 $\ge \frac{|S|}{2}$ 的 Border 构成等差数列，然后考虑 $&lt;\frac{|S|}{2}$ 的最大的 Border ，显然，剩下的 Border 也是这个 Border 的 Border ，然后接着考虑就行了，所以至多 $O(\log{|S|})$ 个。</p>
</div></details>
<p>事实上，通过上面的描述，不难发现：</p>
<p>长度在 $(\frac{|S|}{2},|S|],(\frac{|S|}{4},\frac{|S|}{2}],(\frac{|S|}{8},\frac{|S|}{4}],(\frac{|S|}{16},\frac{|S|}{8}]…$ 即 $(\frac{|S|}{2^{k+1}},\frac{|S|}{2^k}]$ 的 Border 构成等差数列。</p>
<p>或者长度在 $[1,2),[2,4),…,[2^i,2^{i+1}),[2^{i+1},|S|]$ 的 Border 也构成等差数列。（ $|S|&lt;2^{i+2}$ ）</p>
<p>显然，长度在 $<a href="2a\ge b">a,b</a>$ 的 Border 都构成等差数列。</p>
<h2 id="失配树"><a href="#失配树" class="headerlink" title="失配树"></a>失配树</h2><p>对于一个串，考虑对于每个前缀建立一个节点，其父亲是其的 $mxBd$ ，这样构成的一棵根为空串的树叫做失配树，显然，Kmp 的 fail 数组就代表了这棵树。</p>
<p>这棵树有很多性质。</p>
<p><strong>性质 1</strong> ：根据 $Bd(S)=\{mxBd(S)\}+Bd(mxBd(S))$ 可以得出，一个前缀的所有 Bd 就是到父亲的这条链。</p>
<p>这个性质可以用于解决这个题目：</p>
<p><a href="https://www.luogu.com.cn/problem/P5829">https://www.luogu.com.cn/problem/P5829</a></p>
<p>题目大意：给一个串，$q$ 次询问，每次询问询问两个前缀的最长公共 border 长度。</p>
<p>显然就是失配树上找 LCA 就行了。</p>
<p><strong>性质 2</strong> ：每个点到根节点的路径可以划分成 $O(\log)$ 段，每段父子间长度差恒定。（也就是上面 $O(\log)$ 段等差数列的失配树版本）</p>
<p>这个性质可以产生上面那道题目的另外一个做法：</p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>首先，先介绍一种常数更加小的划分 Border 的方式：</p>
<p>如果 $2fail[x]\ge x$ ，令 $p=x-fail[x]$ ，那么 $x$ 到 $x\mod {p}+p$ 构成等差数列，否则 $x$ 自己就是个等差数列。</p>
<p>然后令 $x$ 跳到最大的没有被划分进等差数列的位置就行了，实操中当 $2fail[x]\ge x$ 时，往往直接跳到 $x\mod {p}+p$ ，即认为等差数列间可以有交叉，这样处理方便一些，而且显然，不难证明这么跳 $x’&lt;\frac{2x}{3}$ ，所以仍然是 $O(\log)$ 段。</p>
<p>（这个划分方式还有个小性质，如果 $2fail[x]\ge x$ ，则等差数列至少有两项，否则只有一项）</p>
<p>在划分完 Border 后，显然可以用扩展欧几里得去处理，但是这样是两个 $\log$ 的，而且写起来还没 LCA 好写。</p>
<p>考虑利用性质进行优化，现在考虑找 $x,y$ 前缀的最长公共 Bd ，不妨认为原串也算 Bd，且 $x&gt;y$ ，考虑上述划分中 $x$ 的第一个等差数列。</p>
<p>如果 $2fail[x]&lt;x$，那么显然 $x=fail[x]$ 即可。</p>
<p>如果 $2fail[x]\ge x$ ，那么显然如果 $x\equiv y\mod p$ ，则 $y$ 就是最长公共 Bd ，否则考虑 $y$ 的长度：</p>
<ol>
<li>如果 $y&lt;2p$ ，那么显然这个等差数列，也就是分配树上的这条链除了链头没有别的串可能是公共 Bd 。</li>
<li>如果 $y\ge 2p$ ，显然 $y$ 的最小周期也是 $p$ ，则根据 WPL 可以得出链上 $\ge 2p$ 的点都不可能是公共 Bd（考虑 $x,y$ $\ge 2p$ 的所有 Bd ，显然互不相同），也即只有链头还有可能成为答案，所以 $x=x\mod p+p$。</li>
</ol>
<p>不难发现，这个做法的复杂度与 $x,y$ 按照上述方法划分的等差数列个数同阶（因为上面的过程其实就是从一个等差数列的列尾，跳到下一个等差数列的列尾），也就是 $O(n+q\log{n})$ ，而且显然好写很多，空间也只用 $O(n)$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e6</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">char</span> st[N];</span><br><span class="line"><span class="type">int</span> fail[N],n,q;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,st+<span class="number">1</span>);n=<span class="built_in">strlen</span>(st+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    fail[<span class="number">0</span>]=<span class="number">-1</span>;<span class="type">int</span> now=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(now!=<span class="number">-1</span> &amp;&amp; st[now+<span class="number">1</span>]!=st[i])now=fail[now];</span><br><span class="line">        fail[i]=++now;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;q);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=q;i++)&#123;</span><br><span class="line">        <span class="type">int</span> x,y;<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;x,&amp;y);</span><br><span class="line">        x=fail[x];y=fail[y];</span><br><span class="line">        <span class="keyword">while</span>(x!=y)&#123;</span><br><span class="line">            <span class="keyword">if</span>(x&lt;y)<span class="built_in">swap</span>(x,y);</span><br><span class="line">            <span class="keyword">if</span>(fail[x]*<span class="number">2</span>&lt;x)x=fail[x];</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="built_in">assert</span>(x);</span><br><span class="line">                <span class="type">int</span> d=x-fail[x];</span><br><span class="line">                <span class="keyword">if</span>(x%d==y%d)x=y;</span><br><span class="line">                <span class="keyword">else</span> x=x%d+d;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></details>
<h2 id="一些其他性质"><a href="#一些其他性质" class="headerlink" title="一些其他性质"></a>一些其他性质</h2><ol>
<li><p>如果一个串 $S$ 有 $\ge \frac{|S|}{2}$ 的 Border，则最小的 $\ge \frac{|S|}{2}$ 的 Border 长度 $&lt;\frac{3|S|}{4}$ 。</p>
<details class="toggle" ><summary class="toggle-button" style="">证明</summary><div class="toggle-content"><p>假如最小周期 $p\le \frac{|S|}{4}$ ，则显然 Border $\ge \frac{3|S|}{4}$ 时，还能再去掉一个周期，直到 $&lt;\frac{3|S|}{4}$ 。</p>
<p>假如 $&gt;$ ，显然所有的 Border 都 $&lt;\frac{3|S|}{4}$ ，所以也显然成立。</p>
<p>证毕。</p>
</div></details>
</li>
<li><p>如果一个串 $s$ 有一个 $t$ 作为 mxBd ，且 $2|t|\ge|s|$ ，那么 $t$ 在 $s$ 中只出现了两次。</p>
<details class="toggle" ><summary class="toggle-button" style="">证明</summary><div class="toggle-content"><p>由性质 $1$ 知道出现位置是等差数列，如果出现 $3$ 次及以上可以构造出更长的 Bd ，矛盾。</p>
<p>这个证法和性质 2 的证明 2 挺像的，都是利用了某个 Bd 的出现位置和一些 Bd 的对应关系。</p>
</div></details>
<p>这个性质可以应用在某些 Bd 优化题中，以确定 mxBd 上次出现的位置。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>Border</tag>
      </tags>
  </entry>
  <entry>
    <title>CCPC Final 2023 赛后总结</title>
    <url>/2024/04/10/CCPC-Final-2023-%E8%B5%9B%E5%90%8E%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>这就最纯粹的坐牢的乐趣啊。</p>
<h1 id="B"><a href="#B" class="headerlink" title="B"></a>B</h1><p>题目大意：</p>
<p>一个合法的字符串数组（不是字符数组），满足：</p>
<ol>
<li>$1\le |S_i| \le n$</li>
<li>$S_{i}$ 是 $S_{i+1}$ 的周期。</li>
<li>$S_i$ 互不相同</li>
</ol>
<p>这里 $S$ 是 $T$ 的周期的定义是：</p>
<p>如果 $|S|&gt;|T|$ ，则 $T$ 是 $S$ 的前缀，否则和一般的周期定义一致。</p>
<p>问对于 $n$ 从 $1$ 到 $n$ ，每个 $n$ 能构造的最大的合法字符串数组有多大。</p>
<details class="toggle" ><summary class="toggle-button" style="">观察</summary><div class="toggle-content"><p>这是个计数题，但我们首先要知道我们在记什么。</p>
<p>一个基本的观察是：</p>
<p>我们构造 $S_1$ 为 $n$ 个不同的字符组成。</p>
<p>那么一个显然的上界是：能由 $S_1$ 的所有前缀拼接出来的不同字符串数量。</p>
<p>现在证明这个上界是对的：</p>
<p>我们可以将上面的字符串集建成一棵字典树，我们令这棵字典树左儿子为这个位置在 $S_1$ 中的下一个字符（这个位置指的是在前缀中的位置），右儿子为第一个字符。</p>
<p>然后考虑做中序遍历，得到的就是一个合法的构造。</p>
<p>证毕。</p>
<p>但是字符集是小写字母咋办，其实可以发现，把 $S_1$ 换成 $ab….$ 仍然成立，只要满足任意一个字符串的 $S_1$ 的前缀表示不存在或者唯一即可。</p>
<p>而这样的字符串构造也非常的简单，只要字符串中除了第一个位置以外的其余位置都和第一个位置不一样就行了，这是充要条件。</p>
<p>那么现在问题可以等价的转换为：</p>
<p>问多少个数列满足：</p>
<p>$1 \le \sum a_i \le n, a_{i}\le a_1$</p>
</div></details>
<details class="toggle" ><summary class="toggle-button" style="">大佬做法</summary><div class="toggle-content"><p>来自于机房的大佬。</p>
<p>首先根据上面的说法，我们不难设计一个计数方法：</p>
<p>$dp[i][j]$ 表示第一个数字为 $i$ ，同时当前的 $\sum a_i = j$ 的方案数。</p>
<p>初始时 $dp[i][i] = dp[i][i + 1] = 1$ 。</p>
<p>当 $j &gt; i + 1$ 时，满足 $dp[i][j] = dp[i][j - 1] * 2 - dp[i][j - i -1]$ 。</p>
<p>原因是你可以在 $dp[i][j - 1]$ 的基础上选择使最后一个 $a_m+1$ 或者新增一个 $a_m=1$ ，当需要容斥掉 $a_m&gt;i$ 的情况。</p>
<p>另外一方面，从背包的角度看：</p>
<p>$dp[i][j] = \sum\limits_{k=1}^{i}dp[i][j-k]$ 。</p>
<p>然后用 $dp[i][j]$ 的式子减去 $dp[i][j - 1]$ 的式子即可得到上面的转移式。</p>
<p>我们设 $f[n]$ 为 $\sum a_i = n, a_{i}\le a_1$ 的方案数，显然这就是答案的差分，又显然 $f[n] = \sum dp[i][n]$</p>
<p>那么如何维护 $dp[i][n]$ 呢？</p>
<p>可以发现，对于 $dp[i][n]$ ，显然我们只要知道 $dp[i][n],dp[i][n-i],dp[i][n-2i]…$ 就足以完成转移。</p>
<p>即：$b[j]=dp[i][n-(j-1)i]$ 。</p>
<p>显然，下一次：$b[i]=b[i]*2-b[i+1]$ 。</p>
<p>观察到多个 $dp$ 数组的 $b$ 数组转移类似，可以直接累加，而 $b_{1}$ 即为所求。</p>
<p>但是这样还是 $O(n^2)$ ，怎么优化？</p>
<p>注意到当 $i&gt;\sqrt{n}$ 时，$b$ 数组只会开到 $\sqrt{n}$ ，所以直接暴力处理 $i\le \sqrt{n}$ 的 $dp$ 数组，大的用 $b$ 数组转移即可做到 $O(n\sqrt{n})$ 的复杂度。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> B1 = <span class="number">450</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> B2 = <span class="number">450</span>;</span><br><span class="line">LL mod;</span><br><span class="line">LL ans[N];</span><br><span class="line">LL a[N];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, LL val)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i * i &lt;= x; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(x % i == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="type">int</span> j = x / i;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; B1)&#123;</span><br><span class="line">                a[j] = (a[j] + val) % mod;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(j != i &amp;&amp; j &gt; B1)&#123;</span><br><span class="line">                a[i] = (a[i] + val) % mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; mod;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= B1; i++)&#123;</span><br><span class="line">        <span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="built_in">sizeof</span>(a));</span><br><span class="line">        a[i] = <span class="number">1</span>;</span><br><span class="line">        a[i + <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = i + <span class="number">2</span>; j &lt;= n; j++) a[j] = (a[j - <span class="number">1</span>] * <span class="number">2</span> - a[j - i - <span class="number">1</span>] + mod) % mod;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) ans[j] = (ans[j] + a[j]) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="built_in">sizeof</span>(a));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= B2; j++)&#123;</span><br><span class="line">            a[j] = (a[j] * <span class="number">2</span> - a[j + <span class="number">1</span>] + mod) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">add</span>(i, <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">add</span>(i - <span class="number">1</span>, mod - <span class="number">1</span>);</span><br><span class="line">        ans[i] = (ans[i] + a[<span class="number">1</span>]) % mod;</span><br><span class="line">        ans[i] = (ans[i] + ans[i - <span class="number">1</span>]) % mod;</span><br><span class="line">        cout &lt;&lt; ans[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我观察到了一般，可惜一没观察到 $b$ 是可以合并的，二没观察到可以根号分治（不过一没观察到自然也就观察不到二了）。</p>
<p>对于这个做法一个更加形象的解释是：</p>
<p><img src="1.png" alt=""></p>
<p>如果把 $b[i]$ 看成维护一条条直线的话，那么 $b[i]$ 的斜率就是 $i-1$ ，因此在 $i&gt;\sqrt{n}$ 后，直线就只会处在 $i&lt;\sqrt{n}$ 的位置了，直接根号分治，这样就只用维护 $\sqrt{n}$ 条直线了。</p>
</div></details>
<details class="toggle" ><summary class="toggle-button" style="">官方做法</summary><div class="toggle-content"><p>我最学不懂的东西，生成函数启动！</p>
<p>考虑做法 $1$ 中背包的角度开始算生成函数：</p>
<p>先枚举第一个数字是啥，再枚举有多少个 $a$ ，则对于 $n$ 的答案就是：</p>
<script type="math/tex; mode=display">\begin{align*}

 & [x^{n}]\frac{1}{1-x}\sum\limits_{k=1}^n x^{k} \sum\limits_{i=0}^{\infty} (x\frac{1-x^{k}}{1-x})^i \\
 = & [x^{n}]\frac{1}{1-x}\sum\limits_{k=1}^n \frac{x^{k}}{1-x\frac{1-x^k}{1-x}} \\
 = & [x^{n}]\sum\limits_{k=1}^n \frac{x^{k}}{(1-x)-x+x^k} \\
 = & [x^{n}]\sum\limits_{k=1}^n \frac{x^{k}}{1-2x+x^k}
\end{align*}</script><p>然后这个咋处理呢？</p>
<p>不会。</p>
</div></details>
<h1 id="L"><a href="#L" class="headerlink" title="L"></a>L</h1><p>另外开了篇题解详细讲述。</p>
<h1 id="K"><a href="#K" class="headerlink" title="K"></a>K</h1><p>题目大意：</p>
<p>给一个 $n*n$ 的网格，要求在网格上放一些顶着上边界的竖棒或者贴着左边界的横棒，要求棒之间不能相交，且要求一些位置不能被棒覆盖，一些位置必须被棒覆盖，问有多少种合法的放棒方案，两种方案不同当且仅当被覆盖的位置集合不同。</p>
<p>形式化的：</p>
<p>合法的 $a,b$ 数组（长度都为 $n$ ，$a$ 表示横着的棒长，$b$ 表示竖着的棒长）需要满足：</p>
<p>$0\le a_{i},b_{i} \le n$</p>
<p>$[a_{i}\ge j] \ne [b_{j}\ge i]$ </p>
<p>且有一些额外的要求：</p>
<p>$[a_{c_{k}}\ge d_{k}]+[b_{d_{k}}\ge c_{k}]=1$</p>
<p>$[a_{c’_{k}}\ge d_{k}]+[b_{d_{k}}\ge c’_{k}]=0$</p>
<p>但是不是问有多少种不同的合法数组，具体见原题意。</p>
<details class="toggle" ><summary class="toggle-button" style="">我的做法</summary><div class="toggle-content"><p>我们要计数的话，更好计数的是合法的 $a,b$ 数组个数，而不大可能去以覆盖的位置集合为状态去计数（后效性太强）。</p>
<p>但是问题是：不同的 $a,b$ 数组可能是同一个放棒方案。</p>
<p>因此我们需要给合法的 $a,b$ 数组加上一些限制，使其与放棒方案构成双射。</p>
<p>我加上的条件是：</p>
<p>$\forall 1 \le i\le n : a_{b_{i} + 1} \ne i$</p>
<p>证明：</p>
<p>单射：</p>
<p>假设有两组 $a,b$ 、$a’,b’$ 不同但对应的是同一个放棒方案。</p>
<p>不妨设 $b_{i} &gt; b’_{i}$ ，那么 $a’_{b’_{i} + 1} \ge i$ 。</p>
<p>那么显然：$\forall i\le j \le a’_{b’_{i} + 1}:b_{j}\ge b’_{i} + 1,b’_{j} = b’_{i}$ 。</p>
<p>因此 $a’_{1+b’_{a’_{b’_{i} + 1}}} = a’_{b’_{i} + 1}$ ，所以 $a’,b’$ 不是合法的，矛盾。</p>
<p><img src="2.png" alt=""></p>
<p>满射：</p>
<p>对于任意一个没加限制的合法的 $a,b$ 数组，如果违反了限制，那么显然可以让 $b_{i}+1$ ，$a_{b_{i}+1}-1$ ，这样就得到了一个覆盖位置集合不变的新的 $a,b$ 数组，由于 $\sum b$ 在不断增加，因此这个过程一定可以停下来，所以是个满射。</p>
<p>证毕。</p>
<p>接下来就是计数了，还挺麻烦的。</p>
<p>设 $dp[i][j]$ 表示前 $i-1$ 个 $b$ 的值都 $&lt;j$ 且 $b_{i}=j$ ，且已经填了 $a_{1}\sim a_{j}$ 的方案数。</p>
<p>$dp[i][j]\to dp[i’][j’]$ 需要考虑的贡献有 $i\to i’$ 的贡献（填 $b$ 的方案）和 $j\to j’$ 的贡献（填 $b$ 的方案）。</p>
<p>然后优化这个 $dp$ 过程就行了。</p>
<p>时间复杂度 ： $O(n^2)$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> LL mod = <span class="number">998244353</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">3e3</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line">LL nf[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    nf[<span class="number">0</span>] = nf[<span class="number">1</span>] = <span class="number">1ll</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= <span class="built_in">max</span>(n, m); i++) nf[i] = (mod - mod / i) * nf[mod % i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Key</span>&#123;</span><br><span class="line">    LL val;</span><br><span class="line">    <span class="type">int</span> cnt;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> row[N][N], col[N][N];</span><br><span class="line"><span class="type">bool</span> br[N][N], bc[N][N];</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> st[N][N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getst</span><span class="params">(<span class="type">char</span> *s)</span></span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">char</span> ss[N];</span><br><span class="line">    cin &gt;&gt; ss;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) s[i + <span class="number">1</span>] = ss[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//g is consider next row</span></span><br><span class="line">LL f[N], g[N], tmp[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    m = n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="built_in">getst</span>(st[i]);</span><br><span class="line">        st[i][m + <span class="number">1</span>] = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    m++;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        br[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> cnt = row[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="type">bool</span> lock = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(st[i][j] == <span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(lock) cnt = <span class="number">0ll</span>;</span><br><span class="line">                <span class="keyword">else</span> cnt = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(st[i][j] == <span class="string">&#x27;0&#x27;</span>) lock = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(!lock) cnt++;</span><br><span class="line">            <span class="keyword">if</span>(!lock) br[i][j] = <span class="number">1</span>;</span><br><span class="line">            row[i][j] = cnt;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++)&#123;</span><br><span class="line">        bc[<span class="number">0</span>][j] = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> cnt = col[<span class="number">0</span>][j] = <span class="number">1</span>;</span><br><span class="line">        <span class="type">bool</span> lock = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(st[i][j] == <span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(lock) cnt = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">else</span> cnt = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(st[i][j] == <span class="string">&#x27;0&#x27;</span>) lock = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(!lock) cnt++;</span><br><span class="line">            <span class="keyword">if</span>(!lock) bc[i][j] = <span class="number">1</span>;</span><br><span class="line">            col[i][j] = cnt;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    f[<span class="number">0</span>] = <span class="number">1ll</span>;</span><br><span class="line">    g[<span class="number">0</span>] = <span class="number">1ll</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i++) tmp[i] = g[i];</span><br><span class="line">        LL now = <span class="number">0ll</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            now = now * row[i][j - <span class="number">1</span>] % mod;</span><br><span class="line">            <span class="keyword">if</span>(i)&#123;</span><br><span class="line">                now = (now + tmp[i - <span class="number">1</span>]) % mod;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!bc[i][j]) now = <span class="number">0ll</span>;</span><br><span class="line">            <span class="keyword">if</span>(i != n)&#123;</span><br><span class="line">                <span class="keyword">if</span>(st[i + <span class="number">1</span>][j] != <span class="string">&#x27;1&#x27;</span>) g[i] = g[i] * col[i][j] % mod;</span><br><span class="line">                <span class="keyword">else</span> g[i] = <span class="number">0ll</span>;</span><br><span class="line">                <span class="keyword">if</span>(i &amp;&amp; br[i + <span class="number">1</span>][j] &amp;&amp; st[i][j] != <span class="string">&#x27;1&#x27;</span>) g[i] = (g[i] + f[i] * col[i - <span class="number">1</span>][j]) % mod;</span><br><span class="line">                <span class="keyword">if</span>(st[i + <span class="number">1</span>][j] != <span class="string">&#x27;1&#x27;</span>) g[i] = (g[i] + now * row[i + <span class="number">1</span>][j - <span class="number">1</span>]) % mod;</span><br><span class="line">            &#125;</span><br><span class="line">            f[i] = (f[i] * col[i][j] + now) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; f[n] &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>大概的优化就是注意到 $a$ 的贡献可以用类似前缀和的方式搞搞，也就是代码中的 $now$ 。</p>
<p>而 $b$ 的贡献也是类似前缀和，在每一列的转移结束后，用 $O(n)$ 的时间维护一下 $b$ 的贡献，就可以得到对下一列的贡献了。</p>
<p>大概解释一下 $f,g$ ，就是注意到 $a$ 的贡献中，恰好处于 $j + 1$ 位置的行的贡献，由于限制的存在，这一行的限制要比其余行的限制要多，因此 $g$ 就是存储考虑 $j+1$ 行的列的贡献，而 $f$ 就是不考虑 $j+1$ 行的列的贡献，作用是去维护出新的 $g$ 。</p>
<p>我感觉正解肯定不是这么做的，感觉这个做法有一种力大砖飞的感觉，太不优美了。</p>
</div></details>
<details class="toggle" ><summary class="toggle-button" style="">官方做法</summary><div class="toggle-content"><p>如何判断一个 $01$ 矩阵是合法的？（下面以 $f$ 为 $01$ 矩阵）</p>
<p>只需要找到一条从左上到右下的路径（只能向下或者向右），满足左边的都是横条，上面的都是竖条。</p>
<p>但问题是，一个矩阵可能对应多条路径，怎么办？</p>
<p>我们设 $a$ 数组满足：$a_{i}$ 是最小的满足：$f_{i,a_{i}}=0,f_{i,a_{i}+1}=1$ ，如果这一行没有这种东西则认为 $a_{i}=0$ 。</p>
<p>可以用 $a$ 可以表示出一条路径 $p_{l}$ ，同理，可以用 $b$ 表示列，然后同样表示出一条路径 $p_r$ 。</p>
<p>如果这个矩阵是合法的，则一条路径是合法的充要条件是在 $p_l,p_r$ 之间。</p>
<p>显然，$f$ 合法当且仅当 $p_l,p_r$ 合法，因此只需要将 $f$ 放在 $p_l$ 或者 $p_r$ 计数就行了。</p>
<p>简单来说，用 $dp$ 计算每个 $p$ 作为 $p_l$ 时有多少合法的 $f$ 与其对应就行了。</p>
<p>时间复杂度：$O(n^2)$ 。</p>
<p>可以发现，与 $p_r$ 对应的合法的 $f$ 的充要条件就是我的做法所加的那个新限制。</p>
<p>非常的 $interesting$ ，相当于是从不同的角度得到了同一个做法了。</p>
</div></details>
<details class="toggle" ><summary class="toggle-button" style="">更好的实现：</summary><div class="toggle-content"></div></details>
<h1 id="M"><a href="#M" class="headerlink" title="M"></a>M</h1><p>题目大意：在一个数轴上有 $n+1$ 个洞 $n$ 个球，间隔分布，然后假设球的滚动方向确定，你可以自由确定球的滚动顺序使最大化不会落入相邻洞的球的数量，然后现在给你一些球的滚动方向，要求你确定一些球的滚动方向使最大化数量。</p>
<details class="toggle" ><summary class="toggle-button" style="">我的做法</summary><div class="toggle-content"><p>这道题目最难的就是：假设确定了滚动方向，如何找出最大数量。</p>
<p>这个问题可以等价的转化为：将 $&gt;$ 变成 $($ ，将 $&lt;$ 变成 $)$ ，删除若干个括号，使得最终是个合法括号序列，那么这个删法的贡献为：删除的括号数量加上，原来的 $()$ 且最后没有删除其中任何一个括号的数量。</p>
<p>这里可以解释以下后面那个的数量代表什么：和 $&gt;&lt;$ 一定会至少浪费一个球的原因一致。</p>
<p>首先，上面的一种删法可以对应一种顺序。</p>
<p>证明：</p>
<p>首先，对于一个区间的球，其能覆盖的洞的情况分三种：左闭右开，左开右闭，左闭右闭中间开。</p>
<p>但无论是哪种，对于 $()$ ，只要中间其实是有球且已经滚完了，都一定存在一种方式使得这两个球都不会被浪费，滚完以后认为 $()$ 已经被删了就行，所以，初始条件就是对于所有的 $()$ ，要么中间已经有球，要么一开始就是 $()$ ，因此综上，至多浪费上面那个数量，证毕。</p>
<p>其次，最优顺序一定对应上面的一种删法。</p>
<p>证明：</p>
<p>考虑最优顺序一定可以调整成下面的情况：先让所有被浪费的球滚进去，然后每次让一个球跨过一个区间。</p>
<p>现在归纳的证明：对于任意一个左闭右开的区间，一定存在一个上面的一个删法使得在浪费的数量相等的情况下，剩下的括号序列要么是合法的，要么多一个 $)$ ，左开右闭则是 $($ 。</p>
<p>比如一开始有个 $)$ ，那么形成的就是一个左闭右开的洞，所以下次如果有洞跨过它一定是左边有一个 $($ 跨过来，那么合法多个 $($ ，$)$ 和 $($ 匹配，同时左闭右开变成左开右闭。</p>
<p>区间合并同理。</p>
<p>证毕。</p>
<p>然后直接拿着这东西 DP 一下就行了，时间复杂度：$O(n^2)$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">5e3</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf=<span class="number">1e9</span>;</span><br><span class="line"><span class="type">int</span> dp[N][N][<span class="number">2</span>];<span class="comment">//need destroy?</span></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">char</span> st[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        cin &gt;&gt; (st + <span class="number">1</span>);</span><br><span class="line">        n = <span class="built_in">strlen</span>(st + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(st[i] == <span class="string">&#x27;&gt;&#x27;</span>) st[i] = <span class="string">&#x27;(&#x27;</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(st[i] == <span class="string">&#x27;&lt;&#x27;</span>) st[i] = <span class="string">&#x27;)&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= n; j++) dp[i][j][<span class="number">0</span>]=dp[i][j][<span class="number">1</span>]=inf;</span><br><span class="line">        &#125;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; j++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> t = <span class="number">0</span>; t &lt;= <span class="number">1</span>; t++)&#123;</span><br><span class="line">                    <span class="comment">//add &#x27;(&#x27;</span></span><br><span class="line">                    <span class="keyword">if</span>(st[i] != <span class="string">&#x27;)&#x27;</span>)&#123;</span><br><span class="line">                        dp[i][j + <span class="number">1</span>][<span class="number">0</span>] = <span class="built_in">min</span>(dp[i][j + <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][j][t]);</span><br><span class="line">                        dp[i][j + <span class="number">1</span>][<span class="number">1</span>] = <span class="built_in">min</span>(dp[i][j + <span class="number">1</span>][<span class="number">1</span>], dp[i<span class="number">-1</span>][j][t] + <span class="number">1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(st[i] != <span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(j &amp;&amp; t) dp[i][j - <span class="number">1</span>][<span class="number">1</span>] = <span class="built_in">min</span>(dp[i][j - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][j][t]);</span><br><span class="line">                        <span class="keyword">if</span>(j) dp[i][j - <span class="number">1</span>][<span class="number">1</span>] = <span class="built_in">min</span>(dp[i][j - <span class="number">1</span>][<span class="number">1</span>], dp[i<span class="number">-1</span>][j][t] + <span class="number">1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    dp[i][j][<span class="number">1</span>] = <span class="built_in">min</span>(dp[i][j][<span class="number">1</span>], dp[i<span class="number">-1</span>][j][t] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; n-<span class="built_in">min</span>(dp[n][<span class="number">0</span>][<span class="number">0</span>], dp[n][<span class="number">0</span>][<span class="number">1</span>]) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></details>
<details class="toggle" ><summary class="toggle-button" style="">反思</summary><div class="toggle-content"><p>感觉这一类题目就是没想出来脑子里面就是一坨，想出来了就豁然开朗。</p>
<p>赛时花了很多时间还没有做出来，我的问题。</p>
<p>感觉确实难，但做这么久确实蠢。</p>
<p>基本上这道题目知道如何根据滚动方向判断出最大数量就做完了。</p>
<p>但这一步我就卡了很久，下面是最小化浪费的球数。</p>
<ol>
<li><p>首先以为是当成括号匹配，然后是 $&gt;&lt;$ 的数量加上失配的数量。<br>否决理由：</p>
<p>$&gt;&lt;&lt;$，注意到 $&gt;&lt;$ 可以把洞填成左开右闭和左闭右开。</p>
</li>
<li><p>然后以为是相邻两个失配的 $&lt;$ 中间如果有匹配的括号对，那么右边的 $&lt;$ 不会浪费。<br>否决理由：</p>
<p>$&gt;&lt;&gt;&lt;&lt;&lt;$，注意到只有 $&gt;&lt;$ 会浪费中间的洞。</p>
</li>
<li>发现只要有一个 $&gt;&lt;$ 就可以改变一次洞的分布，得到最终做法。</li>
</ol>
<p>别看上面这个过程非常短，实际过了很长的时间。</p>
<p>虽然我认为这里犯了和之前一样的错误：没有先想着证伪（找例子），而是先想着证明（这个往往是困难的），但是我认为以我当时觉得很对的脑子，我觉得我也找不到例子。（虽然这个时候更好的解决方法是找队友，询问他们对这个正确性的看法，因为队友没经过错误的思考回路，当局者迷，旁观者清，反而更容易找到错误）</p>
<p>可以发现，上面最终发现错误的原因都是：找到了个反例，从而加深了对这道题目的认知，最终更加靠近了正解。</p>
<p>然而我找到上面反例的过程都是写了代码，发现没过样例，发现样例里面就有反例。</p>
<p>因此改进措施为（仅针对比较难的题目）：</p>
<ol>
<li>比赛时先手玩一遍数据（非比赛时不手玩是因为我觉得这样其实比较应试，找数据也是实力的一部分）</li>
<li>难题多想一想比较极端或者有代表性的数据，很多时候，在大多数情况足够最优就是在全体情况足够最优，某些数据的最优解法是能够指引最终做法的，我认为这不是一种应试，因为找到数据并说明这个数据的最优做法我认为也是实力的一部分。（简单来说，就是用更多手玩数据的过程去代替更多想证明的过程）</li>
</ol>
<p>第二条其实已经比较接近队长的思考方式了，就是先想一些极端数据，然后找到一个在这些极端数据下仍然对的做法，根据对的理由思考出最终做法，然后再基于大量数据的思考下，给出最终做法的正确性，这其实是一个很好的思考方式，至少比抓瞎要好得多。</p>
<p>希望下一次能够更快的想出这些题目。</p>
</div></details>
<p>官方题解没看懂，感觉非常的奇妙。</p>
<p>还有一些奇奇怪怪的做法，比如花费 $1$ 的代价删除具有某种形式的子串等等，感觉这个题目的做法很多，在此就不一一赘述了。<del>其实是因为我都没看懂</del></p>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
  </entry>
  <entry>
    <title>CF Round 921 Div.1 赛后总结</title>
    <url>/2024/02/01/CF-Round-921-Div-1-%E8%B5%9B%E5%90%8E%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>比赛链接：<a href="https://codeforces.com/contest/1924/problem/D">https://codeforces.com/contest/1924/problem/D</a></p>
<h1 id="A"><a href="#A" class="headerlink" title="A"></a>A</h1><p>弱智题，每次选最远就行了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e3</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M=<span class="number">26</span>;</span><br><span class="line"><span class="type">int</span> nex[N][M],las[M];</span><br><span class="line"><span class="type">char</span> st[N],ans[N];</span><br><span class="line"><span class="type">int</span> n,k,m;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">work</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;k,&amp;m);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,st+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;k;i++)las[i]=m+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=m;i&gt;=<span class="number">1</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;k;j++)nex[i][j]=las[j];</span><br><span class="line">        las[st[i]-<span class="string">&#x27;a&#x27;</span>]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;k;j++)nex[<span class="number">0</span>][j]=las[j];</span><br><span class="line">    <span class="type">int</span> now=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="type">int</span> maxpos=<span class="number">0</span>,num=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;k;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nex[now][j]&gt;maxpos)maxpos=nex[now][j],num=j;</span><br><span class="line">        &#125;</span><br><span class="line">        ans[i]=num+<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        now=maxpos;</span><br><span class="line">        <span class="keyword">if</span>(now&gt;m)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;=n;j++)ans[j]=<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            ans[n+<span class="number">1</span>]=<span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line">    <span class="comment">// T=1;</span></span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">work</span>())&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Yes\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;No\n%s\n&quot;</span>,ans+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="B"><a href="#B" class="headerlink" title="B"></a>B</h1><p>典中典线段树题，我还以为有高论，想多了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">3e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> NN=<span class="number">6e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Segment</span>&#123;</span><br><span class="line">    <span class="type">int</span> lc,rc;</span><br><span class="line">    LL lazy,c1,c2,d1,d2;</span><br><span class="line">&#125;tr[NN];<span class="type">int</span> len;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">updata</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    tr[x].c1=tr[tr[x].lc].c1+tr[tr[x].rc].c1;</span><br><span class="line">    tr[x].c2=tr[tr[x].lc].c2+tr[tr[x].rc].c2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushlazy</span><span class="params">(<span class="type">int</span> x,LL c)</span></span>&#123;</span><br><span class="line">    tr[x].c1+=c*tr[x].d1;</span><br><span class="line">    tr[x].c2+=c*tr[x].d2;</span><br><span class="line">    tr[x].lazy+=c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tr[x].lazy)&#123;</span><br><span class="line">        <span class="built_in">pushlazy</span>(tr[x].lc,tr[x].lazy);</span><br><span class="line">        <span class="built_in">pushlazy</span>(tr[x].rc,tr[x].lazy);</span><br><span class="line">        tr[x].lazy=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bt</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> x=++len;</span><br><span class="line">    tr[x].d1=r-l+<span class="number">1</span>;tr[x].d2=<span class="number">1ll</span>*(r+l)*(r-l+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(l&lt;r)&#123;</span><br><span class="line">        <span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        tr[x].lc=<span class="built_in">bt</span>(l,mid);</span><br><span class="line">        tr[x].rc=<span class="built_in">bt</span>(mid+<span class="number">1</span>,r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">change</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> ll,<span class="type">int</span> rr,LL c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ll&gt;rr || r&lt;ll || l&gt;rr)<span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">if</span>(l&gt;=ll &amp;&amp; r&lt;=rr)&#123;</span><br><span class="line">        <span class="built_in">pushlazy</span>(x,c);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pushdown</span>(x);</span><br><span class="line">    <span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">change</span>(tr[x].lc,l,mid,ll,rr,c);</span><br><span class="line">    <span class="built_in">change</span>(tr[x].rc,mid+<span class="number">1</span>,r,ll,rr,c);</span><br><span class="line">    <span class="built_in">updata</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">findans</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> id)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&gt;id)<span class="keyword">return</span> <span class="number">0ll</span>;</span><br><span class="line">    <span class="keyword">if</span>(r&lt;=id)<span class="keyword">return</span> (id+<span class="number">1</span>)*tr[x].c1-tr[x].c2;</span><br><span class="line">    <span class="built_in">pushdown</span>(x);</span><br><span class="line">    <span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">findans</span>(tr[x].lc,l,mid,id)+<span class="built_in">findans</span>(tr[x].rc,mid+<span class="number">1</span>,r,id);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,m,q;</span><br><span class="line">set&lt;<span class="type">int</span>&gt; pos;</span><br><span class="line">LL V[N];<span class="type">bool</span> v[N];<span class="type">int</span> p[N];</span><br><span class="line"><span class="type">int</span> ll[N];<span class="comment">//(ll[i],i)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modif</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,LL c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&gt;r)<span class="keyword">return</span> ;</span><br><span class="line">    <span class="built_in">change</span>(<span class="number">1</span>,<span class="number">1</span>,n,l,r,c);</span><br><span class="line">    <span class="built_in">change</span>(<span class="number">1</span>,<span class="number">1</span>,n,r+<span class="number">1</span>,r+<span class="number">1</span>,-c*(r-l+<span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld &quot;</span>,<span class="built_in">findans</span>(<span class="number">1</span>,<span class="number">1</span>,n,i)-<span class="built_in">findans</span>(<span class="number">1</span>,<span class="number">1</span>,n,i<span class="number">-1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;q);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="type">int</span> x;<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);x=n-x+<span class="number">1</span>;</span><br><span class="line">        v[x]=<span class="number">1</span>;</span><br><span class="line">        p[i]=x;</span><br><span class="line">        pos.<span class="built_in">insert</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        LL x;<span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;x);</span><br><span class="line">        V[p[i]]=x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">bt</span>(<span class="number">1</span>,n);</span><br><span class="line">    <span class="type">int</span> pre=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!v[i])<span class="keyword">continue</span>;</span><br><span class="line">        ll[i]=pre;pre=i;</span><br><span class="line">        <span class="built_in">modif</span>(ll[i]+<span class="number">1</span>,i<span class="number">-1</span>,V[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// print();</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=q;i++)&#123;</span><br><span class="line">        <span class="type">int</span> t;<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;t);</span><br><span class="line">        <span class="keyword">if</span>(t==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="type">int</span> x,val;<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;x,&amp;val);x=n-x+<span class="number">1</span>;</span><br><span class="line">            v[x]=<span class="number">1</span>;V[x]=val;pos.<span class="built_in">insert</span>(x);</span><br><span class="line">            <span class="type">int</span> nex=*pos.<span class="built_in">upper_bound</span>(x);</span><br><span class="line">            <span class="built_in">modif</span>(ll[nex]+<span class="number">1</span>,nex<span class="number">-1</span>,-V[nex]);</span><br><span class="line">            ll[x]=ll[nex];</span><br><span class="line">            <span class="built_in">modif</span>(ll[x]+<span class="number">1</span>,x<span class="number">-1</span>,V[x]);</span><br><span class="line">            ll[nex]=x;</span><br><span class="line">            <span class="built_in">modif</span>(ll[nex]+<span class="number">1</span>,nex<span class="number">-1</span>,V[nex]);</span><br><span class="line">            <span class="comment">// print();</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="type">int</span> l,r;<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;l,&amp;r);l=n-l+<span class="number">1</span>;r=n-r+<span class="number">1</span>;</span><br><span class="line">            <span class="built_in">swap</span>(l,r);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,<span class="built_in">findans</span>(<span class="number">1</span>,<span class="number">1</span>,n,r)-<span class="built_in">findans</span>(<span class="number">1</span>,<span class="number">1</span>,n,l<span class="number">-1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="C"><a href="#C" class="headerlink" title="C"></a>C</h1><p>一个显然的事情，你考虑在折过一次的的纸上，去考虑接下来折纸产生的折痕，在这一次折纸展开后会变成什么样，可以发现：</p>
<script type="math/tex; mode=display">(M,V)=(\frac{M'+V'}{\sqrt{2}},\frac{M'+V'+4}{\sqrt{2}})</script><p>赛时唐了，以为要写矩阵，但实际上不用，直接推式子就行了。</p>
<p>最终 $\frac{M}{V}=1-\frac{2}{\sqrt{2}^{n+1}+\sqrt{2}^{n}-\sqrt{2}}$ ，直接算就行了。</p>
<p>题解说奇怪的模数是为了保证分母不为 $0$ ，说是不能让 $2$ 能够开根，我推测用上面的式子精细的讨论一下 $n$ 的奇偶，可能也能分析出来，但我懒得想了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> LL mod=<span class="number">999999893</span>,ni2=(mod+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    LL x,y;<span class="comment">//x+y*sqrt(2)</span></span><br><span class="line">&#125;;</span><br><span class="line">node <span class="keyword">operator</span>*(node x,node y)&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;(x.x*y.x+x.y*y.y*<span class="number">2</span>)%mod,(x.x*y.y+x.y*y.x)%mod&#125;;</span><br><span class="line">&#125;</span><br><span class="line">node <span class="keyword">operator</span>*(node x,LL y)&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;(x.x*y)%mod,(x.y*y)%mod&#125;;</span><br><span class="line">&#125;</span><br><span class="line">node <span class="keyword">operator</span>+(node x,node y)&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;(x.x+y.x)%mod,(x.y+y.y)%mod&#125;;</span><br><span class="line">&#125;</span><br><span class="line">node <span class="keyword">operator</span>-(node x,node y)&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;(x.x-y.x+mod)%mod,(x.y-y.y+mod)%mod&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">node <span class="title">ksm</span><span class="params">(node x,LL y)</span></span>&#123;</span><br><span class="line">    node ans=&#123;<span class="number">1ll</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">while</span>(y)&#123;</span><br><span class="line">        <span class="keyword">if</span>(y&amp;<span class="number">1</span>)ans=ans*x;</span><br><span class="line">        x=x*x;y&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">ksm</span><span class="params">(LL x,LL y)</span></span>&#123;</span><br><span class="line">    LL ans=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(y)&#123;</span><br><span class="line">        <span class="keyword">if</span>(y&amp;<span class="number">1</span>)ans=ans*x%mod;</span><br><span class="line">        x=x*x%mod;y&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> T;<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="type">int</span> n;<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">        node x=&#123;<span class="number">0ll</span>,<span class="number">1</span>&#125;;</span><br><span class="line">        node y=<span class="built_in">ksm</span>(x,n+<span class="number">1</span>)-node&#123;<span class="number">0ll</span>,<span class="number">1</span>&#125;+<span class="built_in">ksm</span>(x,n);</span><br><span class="line">        node z=node&#123;y.x,mod-y.y&#125;*<span class="built_in">ksm</span>( (y.x*y.x-y.y*y.y*<span class="number">2</span>%mod+mod)%mod ,mod<span class="number">-2</span>);</span><br><span class="line">        node ans=node&#123;<span class="number">1ll</span>,<span class="number">0ll</span>&#125;-z*<span class="number">2</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans.y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="D"><a href="#D" class="headerlink" title="D"></a>D</h1><p>唐了。</p>
<p>这道题目我一开始的思路是，一个显然的事情，最终序列一定是一堆合法括号序列，然后用 $)))((($ 插入到两个合法括号序列中间，然后就有了我最开始的做法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> LL mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e4</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> L=<span class="number">10000</span>;</span><br><span class="line">LL fc[N],nfc[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    fc[<span class="number">0</span>]=fc[<span class="number">1</span>]=nfc[<span class="number">0</span>]=nfc[<span class="number">1</span>]=<span class="number">1</span>;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=L;i++)nfc[i]=(mod-mod/i)*nfc[mod%i]%mod;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=L;i++)nfc[i]=nfc[i<span class="number">-1</span>]*nfc[i]%mod,fc[i]=fc[i<span class="number">-1</span>]*i%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">C</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;y || y&lt;<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0ll</span>;</span><br><span class="line">    <span class="keyword">return</span> fc[x]*nfc[y]%mod*nfc[x-y]%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">goal_fu</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> len)</span></span>&#123;</span><br><span class="line">    x--;len--;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;<span class="number">0</span>)x=-x;</span><br><span class="line">    <span class="keyword">if</span>(x&gt;len)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">assert</span>((len&amp;<span class="number">1</span>)==(x&amp;<span class="number">1</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">C</span>(len,(len-x)&gt;&gt;<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">goal</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">goal_fu</span>(x,len)-<span class="built_in">goal_fu</span>(-x,len)+mod)%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="type">int</span> T;<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="type">int</span> n,m,k;<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;k);</span><br><span class="line">        <span class="keyword">if</span>(n&lt;k || m&lt;k)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;0\n&quot;</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        n-=k;m-=k;</span><br><span class="line">        LL ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=k;i++)&#123;</span><br><span class="line">            LL now=<span class="built_in">goal</span>(i,k+k-i);</span><br><span class="line">            ans=(ans+now*<span class="built_in">C</span>(n+m+i,i))%mod;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但实际上可以直接用折线法得到最终答案。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> LL mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e4</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> L=<span class="number">10000</span>;</span><br><span class="line">LL fc[N],nfc[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    fc[<span class="number">0</span>]=fc[<span class="number">1</span>]=nfc[<span class="number">0</span>]=nfc[<span class="number">1</span>]=<span class="number">1</span>;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=L;i++)nfc[i]=(mod-mod/i)*nfc[mod%i]%mod;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=L;i++)nfc[i]=nfc[i<span class="number">-1</span>]*nfc[i]%mod,fc[i]=fc[i<span class="number">-1</span>]*i%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">C</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;<span class="keyword">return</span> fc[x]*nfc[y]%mod*nfc[x-y]%mod;&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="type">int</span> T;<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="type">int</span> n,m,k;<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;k);</span><br><span class="line">        <span class="keyword">if</span>(n&lt;k || m&lt;k)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;0\n&quot;</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,(<span class="built_in">C</span>(n+m,k)-<span class="built_in">C</span>(n+m,k<span class="number">-1</span>)+mod)%mod);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>显然两种做法后面一种更加优秀，而且也不算难。</p>
<p>但是赛时就是没想出来，警钟敲烂。</p>
<p>已将上面两种做法的最关键部分全部写入组合计数练习，引以为戒，警钟敲烂。</p>
<h1 id="E"><a href="#E" class="headerlink" title="E"></a>E</h1><p>做法已加入《组合计数练习》。</p>
<p>简单来说就是用排列考虑就行了。</p>
<p>时间复杂度：$O(n+m)$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> LL mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e6</span>+<span class="number">5</span>;</span><br><span class="line">LL nfc[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> L=<span class="number">2e6</span>+<span class="number">1</span>;</span><br><span class="line">    nfc[<span class="number">0</span>]=nfc[<span class="number">1</span>]=<span class="number">1</span>;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=L;i++)nfc[i]=(mod-mod/i)*nfc[mod%i]%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="type">int</span> T;<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        LL n,m,k;<span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld%lld&quot;</span>,&amp;n,&amp;m,&amp;k);k--;</span><br><span class="line">        <span class="keyword">if</span>(n*m&lt;=k)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;0\n&quot;</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        LL ans=<span class="number">1</span>;</span><br><span class="line">        &#123;</span><br><span class="line">            LL l=k/n+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=l;i&lt;m;i++)ans=(ans+nfc[n<span class="number">-1</span>+i])%mod;</span><br><span class="line">        &#125;</span><br><span class="line">        &#123;</span><br><span class="line">            LL l=k/m+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=l;i&lt;n;i++)ans=(ans+nfc[i+m<span class="number">-1</span>])%mod;</span><br><span class="line">        &#125;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">                LL l=k/i+<span class="number">1</span>,r=m<span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">if</span>(l&lt;=r)ans=(ans+<span class="number">2</span>*(nfc[i+l<span class="number">-1</span>]-nfc[i+r]+mod))%mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h2><p>在想这道题目的时候发现了一个具有意思的组合意义，可惜没法扩展。</p>
<p>考虑一个弱化版的问题：</p>
<p>令 $m=1$ ，问出现 $k*1$ 的纸张的概率。</p>
<p>这么考虑这个问题：</p>
<p>现在从 $n-1$ 开始考虑，考虑到 $x$ 时，有 $\frac{1}{x}$ 的概率选中他，不难发现这与原过程等价。</p>
<p>这样，问题转化为选中 $k$ 的概率，显然就是 $\frac{1}{k}$ 了。</p>
<h1 id="F"><a href="#F" class="headerlink" title="F"></a>F</h1><p>咕咕咕。</p>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title>ARC172 D. Distance Ranking</title>
    <url>/2024/03/18/ARC172-D-Distance-Ranking/</url>
    <content><![CDATA[<p>题目链接：<a href="https://atcoder.jp/contests/arc172/tasks/arc172_d">https://atcoder.jp/contests/arc172/tasks/arc172_d</a></p>
<p>题目大意：请你构造 $n$ 个 $n$ 维空间的整点，满足两点间距离的大小排序符合题目给的顺序。</p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>真TM人类智慧，根本想不到。</p>
<p>准确来说有想过先构造使得每条边都一样长，然后再微调，但是压根没想到微调的具体方法。</p>
<p>简单来说，设第 $i$ 个点的坐标是 $(a_{i,1},a_{i,2},…,a_{i,n})$ 。</p>
<p>先令 $a_{i,j}=[i=j]*K$ ，其中 $K$ 是一个很大的数字，显然，这样能使任意两点间的距离都等于 $\sqrt{2}K$ 。</p>
<p>现在的问题是怎么微调？我们假设给 $a_{i,1},a_{i,2},…,a_{i,n}$ 都加个相对于 $K$ 的小量，那么 $i$ 与别的点的距离会怎样变化呢?</p>
<p>将式子列出来可以发现，对于 $i,j$ 的距离的平方可以大致写成 $2K^2+c*K+O(1)$ ，其中 $c$ 与 $a_{i,i},a_{i,j}$ 有关，可以发现，这个式子的三个部分分别对应不同的量级。</p>
<p>对应任意两点的距离，都有 $2K^2$ 这一项，因此如果 $c*K$ 不一样，就可以用这一项控制相对大小了，显然此时 $O(1)$ 不影响相对大小。</p>
<p>接下来就很简单了，随便口胡一下就行了。</p>
<p>时间复杂度：$O(n^2)$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">30</span>;</span><br><span class="line"><span class="type">int</span> a[N][N];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)a[i][i]=<span class="number">1e6</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n*(n<span class="number">-1</span>)/<span class="number">2</span>;i++)&#123;</span><br><span class="line">        <span class="type">int</span> x,y;<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;x,&amp;y);</span><br><span class="line">        a[x][y]+=n*(n<span class="number">-1</span>)/<span class="number">2</span>-i+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,a[i][j]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>哎，菜就得多练了，根本想不到。</p>
<p>但多练真的有用吗？</p>
</div></details>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>构造</tag>
      </tags>
  </entry>
  <entry>
    <title>CCPC final 2023 L. Exchanging Kubic(最大子段和的深入分析)</title>
    <url>/2024/04/28/CCPC-final-2023-L-Exchanging-Kubic-%E6%9C%80%E5%A4%A7%E5%AD%90%E6%AE%B5%E5%92%8C%E7%9A%84%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>题目大意：</p>
<p>交互题，你可以询问一个区间的最大子段和，要求在 $2n$ 的询问次数内给出一个和原数组的最大子段和处处相等的数组。</p>
<details class="toggle" ><summary class="toggle-button" style="">我的做法</summary><div class="toggle-content"><p>首先第一步是花 $n$ 步的次数，问出所有点的正负，这样我们能知道所有的正值，和所有的非负值的位置。</p>
<p>现在要在 $n$ 的次数问出所有非负值的位置。</p>
<p>先把所有连通的正值放在一起，而连通的负值可以等价的认为只有一个，所以原问题可以转化为：+-+-…+，问所有负值的数值。</p>
<p>考虑这么一个询问：+-+ ，假如最终得到的结果等于左右两个 $+$ 值的其中一个，说明 $-$ 起码小于等于两个 $+$ 中最小值的负值。</p>
<p>又可以发现：如果 -+- 且 -+ 和 +- 的和都是 $\le 0$ 的，那么最大子段和一定要么同时包含 -+- ，要么不包含，因此可以将 -+- 合并起来。</p>
<p>因此做法就出来了：每次找到最小的 + ，然后询问其和临近 + 的最大子段和，如果有更大的最大子段和，将这个 + 和临近的 + 合并（此时能够确定中间的 - 值），否则和临近的 - 合并，这样至多两次少一个 + 。</p>
<p>当只剩下一个 + 时，得到的数组就是一个合法的答案，显然，询问次数不超过 $2n-1$ 次。</p>
<p>时间复杂度：$O(n^2)$ 。</p>
<p>可以优化到 $O(n\log{n})$ ，同时这也是这个做法的下界，因为这个做法要找最小值，可以构造：$a_1,-inf,a_2,…,a_m$ ，这样该做法等价于排序 $a_1,…,a_m$ ，因此这个做法的时间复杂度下界就是 $O(n\log{n})$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> LL inf = <span class="number">1e15</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e3</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="function">LL <span class="title">query</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    cnt++;</span><br><span class="line">    <span class="built_in">assert</span>(cnt &lt;= n + n);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;? &quot;</span> &lt;&lt; l &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; r &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="built_in">fflush</span>(stdout);</span><br><span class="line">    <span class="type">static</span> LL c;</span><br><span class="line">    cin &gt;&gt; c;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line">LL ans[N];</span><br><span class="line"><span class="type">bool</span> v[N];</span><br><span class="line"><span class="function">LL <span class="title">querysum</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    LL now = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = l; i &lt;= r; i++) now += ans[i];</span><br><span class="line">    <span class="keyword">return</span> now;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">findpos</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = l; i &lt;= r; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!v[i]) <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">assert</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, LL c, <span class="type">int</span> type)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    LL x = <span class="built_in">querysum</span>(l, r);</span><br><span class="line">    x = c - x;</span><br><span class="line">    <span class="keyword">if</span>(!type) x = <span class="built_in">min</span>(<span class="number">0ll</span>, x);</span><br><span class="line">    <span class="type">int</span> pos = <span class="built_in">findpos</span>(l, r);</span><br><span class="line">    ans[pos] += x;</span><br><span class="line">    <span class="keyword">if</span>(type)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = l; i &lt;= r; i++) v[i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    LL c;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        cin &gt;&gt; n;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) v[i] = <span class="number">0</span>, ans[i] = <span class="number">0ll</span>;</span><br><span class="line">        vector&lt;node&gt; a;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) a.<span class="built_in">push_back</span>(&#123;i, i - <span class="number">1</span>, <span class="number">0ll</span>&#125;);</span><br><span class="line">        a.<span class="built_in">push_back</span>(&#123;n + <span class="number">1</span>, n, <span class="number">0ll</span>&#125;);</span><br><span class="line">        <span class="keyword">while</span>(a.<span class="built_in">size</span>() &gt; <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="type">int</span> minpos = <span class="number">0</span>;</span><br><span class="line">            LL c = a[<span class="number">0</span>].c;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; a.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(a[i].c &lt; c)&#123;</span><br><span class="line">                    c = a[i].c;</span><br><span class="line">                    minpos = i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">auto</span> [l, r, tmp] = a[minpos];</span><br><span class="line">            <span class="keyword">if</span>(minpos)&#123;</span><br><span class="line">                <span class="keyword">auto</span>&amp; [ll, rr, cc] = a[minpos - <span class="number">1</span>];</span><br><span class="line">                LL val = <span class="built_in">query</span>(ll, r);</span><br><span class="line">                <span class="keyword">if</span>(val &lt;= cc) <span class="built_in">add</span>(rr + <span class="number">1</span>, l - <span class="number">1</span>, -c, <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    rr = r;</span><br><span class="line">                    <span class="built_in">add</span>(ll, rr, val, <span class="number">1</span>);</span><br><span class="line">                    cc = val;</span><br><span class="line">                    a.<span class="built_in">erase</span>(a.<span class="built_in">begin</span>() + minpos);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(minpos + <span class="number">1</span> &lt; a.<span class="built_in">size</span>())&#123;</span><br><span class="line">                <span class="keyword">auto</span>&amp; [ll, rr, cc] = a[minpos + <span class="number">1</span>];</span><br><span class="line">                LL val = <span class="built_in">query</span>(l, rr);</span><br><span class="line">                <span class="keyword">if</span>(val &lt;= cc) <span class="built_in">add</span>(r + <span class="number">1</span>, ll - <span class="number">1</span>, -c, <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    ll = l;</span><br><span class="line">                    <span class="built_in">add</span>(ll, rr, val, <span class="number">1</span>);</span><br><span class="line">                    cc = val;</span><br><span class="line">                    a.<span class="built_in">erase</span>(a.<span class="built_in">begin</span>() + minpos);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            a.<span class="built_in">erase</span>(a.<span class="built_in">begin</span>() + minpos);</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;!&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) cout &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; ans[i] ;</span><br><span class="line">        cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个做法的灵感是这样子的：</p>
<p>对于任意一个最大子段和，可以发现，一定存在一个前缀和一个后缀仍然是最大子段和。</p>
<p>也就是说，我们可以这么想象这么一个过程，就好像是一开始所有的 + 值都想要合并出最大的子段和，然后不断吞并中间的 - 值和周围的 + 值合并的过程，而上面就是一个比较良好的合并过程。</p>
<p>正确性分析：</p>
<p>可以发现，上面的过程都是选择相邻的三个数字，合并，或者是一开始相邻两个正数合并或者非负数合并。</p>
<p>因此只需要证明，一个合法的合并后的数组，在合并前也是合法的。</p>
<p>这个证明也不难，只需要小小讨论一下就行了，在此不再赘述。</p>
</div></details>
<details class="toggle" ><summary class="toggle-button" style="">更加正确的分析</summary><div class="toggle-content"><p>在看了题解后感受颇深，感觉自己之前的证明可能伪了，但后面看了下，确实可以这么证明，就没有删除原来的证明。</p>
<p>最后决定将这更加详细的证明新开一个板块，保留以前写的东西，同时这个板块我认为是更加重要的，新开一个板块来讲我认为很合适。</p>
<p>定义一个子段为可能最大子段和，当且仅当其大于其任何真子段和（不是自己的子段）。</p>
<p>充要条件：这个子段的任何前缀和后缀都 $&gt;0$ 。</p>
<p>性质 1 ：这个子段的任意一个前缀的最大子段和是其的前缀，这个子段的任意一个后缀的最大子段和是其后缀。</p>
<p>性质 2 ：对于可能最大子段和 $[l_1,r_1],[l_2,r_2]$ ，如果 $l_1\le l_2,r_1\le r_2,l_2\ge r_1$ ，那么 $[l_2,r_1]$ 也是可能最大子段和。</p>
<p>性质 3 ：如果知道了所有的最大子段和，显然能知道哪些段是可能的最大子段和。</p>
<p>性质 4 ：如果 $[l1,r1],[l2,r2]$ 是可能最大子段和，且满足：$l1\le l2 - 1\le r1\le r2$ ，那么 $[l1,r2]$ 也是可能最大子段和。</p>
<p>现在，回顾一下我之前的灵感中的最大子段和合并的过程，可以发现，里面提到的最大子段和就是可能最大子段和，当时提到了一个词：合并，但是这个合并到达是什么意思呢？</p>
<p>总不能就是感觉上的抽象的合并吧？就两个可能最大子段和合并成一个的过程吧？</p>
<p>接下来我将详细的、具体的描述这个过程：</p>
<p>假设我们知道了 $[l,r]$ 的和，且也有一了一个 $[l,r]$ 的数组满足 $[l,r]$ 内部要求的 $mss$ ，那么我们能不能将 $[l,r]$ 看成一个数字去研究接下来的问题呢？</p>
<p>可以发现，我的做法中，一开始合并两个正数，以及后面的 $+-+$ 的合并都属于这个类型。</p>
<p>这个问题可以这么说：假设我将 $[l,r]$ 看成一个数字，忽略与 $[l,r]$ 有交集但不包含的 $mss$ ，得到了一个合法的数组后，能够在将 $[l,r]$ 展开后，仍然满足所有的 $mss$ 。</p>
<p>又可以这么说：将 $[l,r]$ 看成一个数字，在忽略掉与 $[l,r]$ 有交集但不包含的 $mss$ ，能否唯一决定与 $[l,r]$ 有交集但不包含的 $mss$ 。</p>
<p>而事实上，如果 $[l,r]$ 的数组的得到过程只依赖于 $[l,r]$ 内部的 $mss$ 数组，那么这个问题又可以这么说：能否利用与 $[l,r]$ 有交集但不包含的 $mss$ 以外的 $mss$ 唯一决定这一部分的 $mss$ 。</p>
<p>现在给一个定理：如果 $[l,r]$ 是一个可能的最大子段和，那么上述问题成立。</p>
<p>证明：</p>
<p>考虑计算 $[l’,r’]$ 的 $mss$ ，不妨认为：$l’&lt;l,l\le l’\le r$ ，那么 $mss(l’,r’)=max(mss(l’,l-1),mss(l,r’),K)$ 。</p>
<p>其中 $K$ 表示什么，设最小的 $i$ 满足：$l’\le i &lt; l:[i,r]$ 是可能最大子段和。（没有则 $K=-\infty$）</p>
<p>则 $K=mss(i,r)-mss(l,r)+mss(l,r’)$ ，这一段成立的原因是，如果 $<a href="l\le y \le r">x,y</a>$ 是可能最大子段和，则 $[x,r]$ 也是。</p>
<p>然后显然最大贡献需要挑其中最大的，就是 $[i,r]$ ，然后考虑其的贡献一定是 $sum(i,l-1)$ 加上最大的前缀在 $[l,r’]$ ，显然这个就为 $mss(l,r’)$ 。</p>
<p>因此是可以计算的，证毕。</p>
<p>因此，$[l,r]$ 实际上可以看成一个数字，内部和外部分隔开来，忽略到多余的 $mss$ 不会影响整个 $mss$ 的合法性，我认为这就是上面说的那个合并过程的具体表述。</p>
<p>不过事实上从最终做法也可以看出，决定所有 $mss$ 所需要的 $mss$ 只需要 $O(n)$ 就行了。</p>
<p>区间包含单调性：$mss(l_1,r_1)\ge mss(l_2,r_2),l_1\le l_2,r_1\ge r_2$ 。</p>
<p>四边形不等式：$mss(l_1,r_1)+mss(l_2,r_2)\le mss(l_1,r_2)+mss(l_2,r_1)$ ，$l1\le l_2\le r_2\le r_1$ 。</p>
<p><details class="toggle" ><summary class="toggle-button" style="">证明</summary><div class="toggle-content"><p>只需要证明 $mss(l-1,r+1)-mss(l-1,r)\le mss(l,r+1)-mss(l,r)$ 。</p></p>
<p>考虑 $p(l,r)$ 表示 $\max\limits_{l\le i\le r} sum(i,r)$ ，显然如果 $mss(l,r+1)&gt;mss(l,r)$ ，那么 $mss(l,r+1)=a_{i}+p(l,r)$ ，因此只需要证明：$mss(l-1,r)-p(l-1,r)\ge mss(l,r)-p(l,r)$ 。</p>
<p>设 $[l_1,r_1]$ 为 $mss(l-1,r)$ 的区间， $[l_2,r]$ 为 $p(l-1,r)$ 的区间，$[l_3,r_3]$ 为 $mss(l,r)$ 的区间，$[l_4,r]$ 为 $p(l,r)$ 的区间。</p>
<p>那么显然可以有 $l_1\le l_2, l_3 \le l_4$ ，若有 $l_2\ge l-1$ ，则 $l_2=l_4$ ，则显然成立，所以不妨认为：$l_1 = l_2 = l - 1$ ，此时显然可以有 $r_1&lt;l_3$。</p>
<p>故 $mss(l_1,r)-p(l-1,r)-mss(l,r)+p(l,r)=-sum(r_1+1,l_4-1)\ge 0$ 。</p>
<p>证毕。</p>
</div></details>
<p>最大子段和还有很多其他性质，等待补充。</p>
<p>遇到一道疑似有关这个概念的题目，但是苦于没有提交链接，故先放在这里吃灰：</p>
<p>meta camp 2022 T5 最大子段和，出现链接：<a href="https://www.zhihu.com/question/546431239">https://www.zhihu.com/question/546431239</a> 。</p></div></details>
<details class="toggle" ><summary class="toggle-button" style="">官方题解</summary><div class="toggle-content"><p>看懂了做法，迷迷糊糊的明白了为什么是对的，但是感觉我不太能很好的说明其为什么是对的。（题解看的也不太懂）</p>
<p>我从我的角度去阐述这个做法：</p>
<p>还是跟之前做法一样，先全问一遍，然后合并，变成 $+-+-+-…$ 的形式。</p>
<p>考虑用增量法，即考虑维护一个正确的前缀。</p>
<p>注意到在假如在新添加字符后，我们肯定想知道哪个后缀成为了可能最大子段和。</p>
<p>假设前面的数字是 $a_1,…,a_{t-1}$ ，一个简单粗暴的想法是找到 $l$ ，满足：$mss(l,t) &gt; max(mss(l,t-1), mss(l+1,t))$ ，这样就可以将 $[t,l]$ 合并为一个数字，但是这样子要问 $O(n^2)$ 次，考虑优化。</p>
<p>注意到如果 $[l,t]$ 如果是可能最大子段和的话，那么 $mss(k,t) &gt; mss(k,t-1)(l\le k\le t-1)$ ，因此如果这一条不满足的话，就可以直接退出，但是这样子并没有优化最坏时间复杂度，悲。</p>
<p>接着思考，考虑如果 $mss(k,t)&gt;mss(k,t-1)$ 且 $mss(k,t)=mss(k+1,t)$ ，那究竟意味着什么？如果 $a_{k}\le 0$ 那么显然满足，但是如果 $a_{k}&gt;0$ 时呢？考虑一种简单情况，也就是：$+-+$ ，这个时候也就说明中间 $-$ 的绝对值大于左边的 $+$ 。</p>
<p>注意到，我们有可能永远不可能知道中间 $-$ 的值，因为我们要知道这个 $-$ 的充要条件是有一个可能最大子段和包含它且其余值我们都知道，但是前缀已经写成了 $+-+-+-$ 的形式，且 $-$ 值都不知道，因此这个充要条件感觉上不太可能成立。</p>
<p>这启示我们能不能贪心的给这个位置赋值，也就是给中间的 $-$ 赋值上左边正值的负数（能赋的值中的最大值，显然右边的 $+$ 大于左边的 $+$ 值）。</p>
<p>这样就能利用上每一次询问，根据这个想法，就可以得到题解的做法。</p>
<p>时间复杂度：$O(n)$ 。</p>
<p>具体过程感兴趣的话看代码吧，感觉不太能讲明白。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e3</span> + <span class="number">5</span>;</span><br><span class="line"><span class="function">std::mt19937 <span class="title">rnd</span><span class="params">(time(<span class="number">0</span>))</span></span>;</span><br><span class="line"><span class="type">int</span> n, cnt;</span><br><span class="line"><span class="function">LL <span class="title">mss</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;? &quot;</span> &lt;&lt; l &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; r &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="built_in">fflush</span>(stdout);</span><br><span class="line">    LL res;</span><br><span class="line">    cin &gt;&gt; res;</span><br><span class="line">    cnt++;</span><br><span class="line">    <span class="built_in">assert</span>(cnt &lt;= n + n &amp;&amp; l &gt;= <span class="number">1</span> &amp;&amp; r &lt;= n);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> l, r, p;</span><br><span class="line">    LL preval;</span><br><span class="line">&#125;sta[N]; <span class="type">int</span> top;</span><br><span class="line">LL a[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Seg</span>&#123;</span><br><span class="line">    <span class="type">int</span> l, mid, r;</span><br><span class="line">    LL sum = <span class="number">0ll</span>;</span><br><span class="line">&#125;s[N]; <span class="type">int</span> m;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">    <span class="comment">// while(1)&#123;</span></span><br><span class="line">        top = cnt = <span class="number">0</span>;</span><br><span class="line">        cin &gt;&gt; n;</span><br><span class="line">        <span class="comment">// generater();</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) a[i] = <span class="built_in">mss</span>(i, i);</span><br><span class="line">        <span class="comment">// for(int i = 1; i &lt;= n; i++) a[i] = mss(i, i, b);</span></span><br><span class="line">        m = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> l = <span class="number">1</span>; l &lt;= n; l++)&#123;</span><br><span class="line">            <span class="type">int</span> mid = l - <span class="number">1</span>;</span><br><span class="line">            LL sum = <span class="number">0ll</span>;</span><br><span class="line">            <span class="keyword">while</span>(mid &lt; n &amp;&amp; a[mid + <span class="number">1</span>] &gt; <span class="number">0</span>) mid++, sum += a[mid];</span><br><span class="line">            <span class="type">int</span> r = mid;</span><br><span class="line">            <span class="keyword">while</span>(r &lt; n &amp;&amp; a[r + <span class="number">1</span>] == <span class="number">0</span>) r++;</span><br><span class="line">            s[++m] = &#123;l, mid, r, sum&#125;;</span><br><span class="line">            l = r;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i].mid == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            LL val = s[i].sum;</span><br><span class="line">            <span class="type">int</span> p = s[i].l;</span><br><span class="line">            LL preval = s[i].sum;</span><br><span class="line">            <span class="keyword">while</span>(top)&#123;</span><br><span class="line">                val = <span class="built_in">mss</span>(sta[top].p, s[i].mid);</span><br><span class="line">                <span class="comment">// val = mss(sta[top].p, s[i].mid, b);</span></span><br><span class="line">                <span class="keyword">if</span>(val &gt; sta[top].preval)&#123;</span><br><span class="line">                    a[sta[top].r] = val - sta[top].preval - preval;</span><br><span class="line">                    <span class="keyword">if</span>(val &gt; preval) p = sta[top].p, preval = val;</span><br><span class="line">                    top--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> l = sta[top].l + <span class="number">1</span>;</span><br><span class="line">            sta[++top] = &#123;l, s[i].r, p, preval&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= top; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!a[sta[i].r]) a[sta[i].r] = <span class="number">-1e15</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;!&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) cout &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; a[i];</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>正确性可以感受一下，在每个 $-$ 值处放上能放的最大值，就可以在出现可能最大子段和的时候，使得放下的最后那个决定性的 $-$ 值是合法的，反之，如果在之前的 $-$ 值放下 $-inf$，那么在出现最大子段和时甚至可能在 $-$ 的位置放下正数，这显然是不合法的，这类似一种贪心思想。</p>
<p>再放一个东西：</p>
<p>对于一个 $+-+-+-…+$ 的序列 $a_1,..,a_n$ ，满足 $mss(1,n)=sum(1,n),mss(l,r)=\max\limits_{l\le i\le r}(0,a_{i})([l,r]\ne[1,n])$ ，则一定有以下结论：</p>
<p>$a_1,a_n$ 是 $a$ 序列中的最大值和次大值。</p>
<p>$mss(1,n)\le a_1+a_n-\max\limits_{2\le i \le n - 1}a_i$ 。</p>
<p><details class="toggle" ><summary class="toggle-button" style="">证明</summary><div class="toggle-content"><p>反证法：$\exists i: 2\le i \le n - 1:a_{i}&gt;a_1$（存在多个就找最小的 $i$ ），则 $mss(1,n)+mss(i,i)\le mss(1,i)+mss(i,n)$ ，推出：$mss(1,n)=mss(i,n)$ ，与定义矛盾，第一条证毕。</p></p>
<p>$mss(1,n)+mss(i,i)\le mss(1,i)+mss(i,n)=a_{1}+a_{n}$ ，整理一下可以得到第二条，证毕。</p>
</div></details>
<p>这个性质可以用于证明最后放下的那个负数的合法性。</p>
<p>但我感觉题解肯定不是这个意思，至少正确性应该不是这么丑陋的证明，肯定有更加高深的东西我没看懂，至于是啥，读者只能自行体会或者去看题解了，博主水平有限了。</p></div></details>]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>构造</tag>
        <tag>交互</tag>
      </tags>
  </entry>
  <entry>
    <title>Bridge Elimination</title>
    <url>/2024/02/02/Bridge-Elimination/</url>
    <content><![CDATA[<p>题目链接：<a href="https://qoj.ac/contest/1499/problem/8180">https://qoj.ac/contest/1499/problem/8180</a></p>
<p>题目大意：给定 $n$ 个点的点权，求 $n$ 个点的所有图的权值和，一个图的权值定义为：如果不连通，则为 $0$ ，联通则为所有边双的点权和的乘积。</p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>知道 Cayley 公式乱做。（但是我赛时不知道这个公式 QAQ ）</p>
<p>时间复杂度：$O(n^3)$ 。</p>
<p>解释一下代码：</p>
<p>$cn[i]$ 是 $i$ 个点的联通图的数量。</p>
<p>$dp[i][j]$ 表示有 $j$ 个点，恰好有 $i$ 个连通块的图的权值和（一个图的权值定义为每个连通块大小的乘积）</p>
<p>$bn[i]$ 表示 $i$ 个点的边双联通块数量。</p>
<p>$ff[i]$ 表示 $n$ 个点中，指定的 $i$ 个点各在一个边双，且联通，且恰有 $i$ 个边双的图的数量。</p>
<p>$ge[i]$ 表示从 $n$ 个点中选 $i$ 个点的点权乘积的和。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> LL mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">4e2</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n;LL a[N];</span><br><span class="line">LL fc[N],nfc[N];</span><br><span class="line"><span class="function">LL <span class="title">ksm</span><span class="params">(LL x,LL y)</span></span>&#123;</span><br><span class="line">    LL ans=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(y)&#123;</span><br><span class="line">        <span class="keyword">if</span>(y&amp;<span class="number">1</span>)ans=ans*x%mod;</span><br><span class="line">        x=x*x%mod;y&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    fc[<span class="number">0</span>]=fc[<span class="number">1</span>]=nfc[<span class="number">0</span>]=nfc[<span class="number">1</span>]=<span class="number">1</span>;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)nfc[i]=(mod-mod/i)*nfc[mod%i]%mod;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)nfc[i]=nfc[i<span class="number">-1</span>]*nfc[i]%mod,fc[i]=fc[i<span class="number">-1</span>]*i%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">C</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;<span class="keyword">return</span> fc[x]*nfc[y]%mod*nfc[x-y]%mod;&#125;</span><br><span class="line"><span class="keyword">namespace</span> Graph&#123;</span><br><span class="line">    LL cn[N],dp[N][N],bn[N];</span><br><span class="line">    LL f[N][N],ff[N];</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cn[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            cn[i]=<span class="built_in">ksm</span>(<span class="number">2</span>,i*(i<span class="number">-1</span>)/<span class="number">2</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;i;j++)cn[i]=(cn[i]-cn[j]*<span class="built_in">ksm</span>(<span class="number">2</span>,(i-j)*(i-j<span class="number">-1</span>)/<span class="number">2</span>)%mod*<span class="built_in">C</span>(i<span class="number">-1</span>,j<span class="number">-1</span>)%mod+mod)%mod;</span><br><span class="line">        &#125;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i;j&lt;=n;j++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;j;k++)&#123;<span class="comment">//pre size</span></span><br><span class="line">                    <span class="type">int</span> cnt=j-k;</span><br><span class="line">                    dp[i][j]=(dp[i][j]+dp[i<span class="number">-1</span>][k]*cn[cnt]%mod*<span class="built_in">C</span>(j<span class="number">-1</span>,cnt<span class="number">-1</span>)%mod*cnt)%mod;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            bn[i]=cn[i];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;i;j++)&#123;<span class="comment">//1&#x27;s size</span></span><br><span class="line">                LL now=<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=i-j;k++)&#123;</span><br><span class="line">                    now=now*j%mod;</span><br><span class="line">                    bn[i]=(bn[i]-bn[j]*<span class="built_in">C</span>(i<span class="number">-1</span>,j<span class="number">-1</span>)%mod*dp[k][i-j]%mod*now%mod+mod)%mod;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        f[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i;j&lt;=n;j++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;j;k++)&#123;</span><br><span class="line">                    <span class="type">int</span> cnt=j-k;</span><br><span class="line">                    f[i][j]=(f[i][j]+f[i<span class="number">-1</span>][k]*<span class="built_in">C</span>(j-i,cnt<span class="number">-1</span>)%mod*bn[cnt]%mod*cnt)%mod;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ff[<span class="number">1</span>]=bn[n];<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)ff[i]=f[i][n]*<span class="built_in">ksm</span>(n,i<span class="number">-2</span>)%mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">LL ge[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    Graph::<span class="built_in">init</span>();</span><br><span class="line">    ge[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;a[i]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i;j&gt;=<span class="number">1</span>;j--)ge[j]=(ge[j<span class="number">-1</span>]*a[i]+ge[j])%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    LL ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        ans=(ans+ge[i]*Graph::ff[i])%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></details>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>计数</tag>
        <tag>Prüfer序列</tag>
      </tags>
  </entry>
  <entry>
    <title>CF1526 E. Oolimry and Suffix Array(从后缀数组反推字符串)</title>
    <url>/2024/02/16/CF1526-E-Oolimry-and-Suffix-Array-%E4%BB%8E%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84%E5%8F%8D%E6%8E%A8%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<p>题目链接：<a href="https://codeforces.com/contest/1526/problem/E">https://codeforces.com/contest/1526/problem/E</a></p>
<p>题目大意：字符集大小为 $n$ ，询问有多少个字符串的后缀数组就是给定的后缀数组。</p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>其实我也不太清楚我是怎么想到这个做法的，反正就是想什么时候两个位置的字符能够相同，然后就知道怎么做了。</p>
<p>看到一个题解说的很有道理：<a href="https://www.luogu.com.cn/blog/namelessgugugu/solution-cf1526e">https://www.luogu.com.cn/blog/namelessgugugu/solution-cf1526e</a></p>
<p>这么说的：知道 $s[i,n]&lt;s[j,n]$ ，就知道 $s[i]\le s[j]$ ，问题是什么时候能够相等，显然是 $s[i+1,n]&lt;s[j+1,n]$ 的时候能够相等。</p>
<p>所以做法就出来了：显然后缀数组上每个位置的字符是非严格递增的，问题是相邻的位置字符能否相等，显然条件就是上面那个，假设我们已经知道了至少需要有 $now$ 个不同的字符，则答案为：</p>
<script type="math/tex; mode=display">\sum\limits_{i=0}^{\min(n,K)-now}\binom{K}{i+now}\binom{n-now}{i}</script><p>显然，这已经足以通过此题，但是还能再简化：</p>
<script type="math/tex; mode=display">
\begin{align*}
&\sum\limits_{i=0}^{\min(n,K)-now}\binom{K}{i+now}\binom{n-now}{i}\\
=& \sum\limits_{i=0}^{\min(n,K)-now}\binom{K}{i+now}\binom{n-now}{n-now-i}\\
=& \sum\limits_{i=0}^{n}\binom{K}{i}\binom{n-now}{n-i}\\
\end{align*}</script><p>最后一步是因为超出来的范围都因为组合数不合法所以值为 $0$ ，不会对结果产生影响。</p>
<p>所以显然，最终化简结果为：$\binom{K+n-now}{n}$ 。</p>
<p>时间复杂度：$O(n+K)$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> LL mod=<span class="number">998244353</span>;</span><br><span class="line">LL fc[N],nfc[N];</span><br><span class="line"><span class="type">int</span> n,K,sa[N],rk[N];</span><br><span class="line"><span class="function">LL <span class="title">C</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;<span class="keyword">return</span> fc[x]*nfc[y]%mod*nfc[x-y]%mod;&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;K);</span><br><span class="line">    fc[<span class="number">0</span>]=fc[<span class="number">1</span>]=nfc[<span class="number">0</span>]=nfc[<span class="number">1</span>]=<span class="number">1</span>;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=<span class="built_in">max</span>(n,K);i++)nfc[i]=(mod-mod/i)*nfc[mod%i]%mod;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=<span class="built_in">max</span>(n,K);i++)fc[i]=fc[i<span class="number">-1</span>]*i%mod,nfc[i]=nfc[i<span class="number">-1</span>]*nfc[i]%mod;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;sa[i]);</span><br><span class="line">        rk[sa[i]]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// rk[n+1]=0;</span></span><br><span class="line">    <span class="type">int</span> now=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(rk[sa[i<span class="number">-1</span>]+<span class="number">1</span>]&gt;rk[sa[i]+<span class="number">1</span>])&#123;</span><br><span class="line">            now++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    LL ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i+now&lt;=n &amp;&amp; i+now&lt;=K;i++)&#123;</span><br><span class="line">        ans=(ans+<span class="built_in">C</span>(K,i+now)*<span class="built_in">C</span>(n-now,i))%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></details>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>计数</tag>
        <tag>字符串</tag>
        <tag>后缀数组</tag>
      </tags>
  </entry>
  <entry>
    <title>Cola</title>
    <url>/2024/01/29/Cola/</url>
    <content><![CDATA[<p>题目链接：<a href="https://contest.ucup.ac/contest/1499/problem/8171">https://contest.ucup.ac/contest/1499/problem/8171</a></p>
<p>题目大意： $A$ 手里有个排列，$B$ 能问 $A$ 一个排列，如果排列完全匹配上，那就 $B$ 胜利，否则 $A$ 回答前 $x$ 个位置都是正确的，$x+1$ 的位置是错误的，如果 $m$ 次询问 $B$ 没有胜利就 $A$ 胜利。问 $B$ 在最优决策下， $A$ 随机拿到一个排列时 $B$ 的获胜概率。</p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>显然要对所有排列计数，而 $B$ 的最优策略就是变 $x+1$ 的位置，然后后面的位置从小到大排序（反正是随机拿一个排列，后面的部分随便一个都行，不会影响答案，从小到大好计数）。</p>
<p>所以问题等价于，有多少个 $n-1$ 的序列 $a$ ，满足：</p>
<p>$0\le a_i\le i,\sum\limits_{i=1}^{n-1}a_i\le m-1$ 。</p>
<p>那么等价于求：$[x^{m-1}]\frac{\prod\limits_{i=1}^{n-1}(1-x^i)}{(1-x)^{n+1}}$ ，但是注意到 $m\le n$ .</p>
<p>所以又等价于求： $[x^{m-1}]\frac{\prod\limits_{i=1}^{\infty}(1-x^i)}{(1-x)^{n+1}}$</p>
<p>分母是经典的高维前缀和，可以用组合意义快速计算 $x^i$ 的系数，分子是五边形数定理，直接算就行了。</p>
<p>时空复杂度：$O(n)$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> LL mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e7</span>+<span class="number">5</span>;</span><br><span class="line">LL fc[N],nfc[N];</span><br><span class="line"><span class="function">LL <span class="title">C</span><span class="params">(LL x,LL y)</span></span>&#123;<span class="keyword">return</span> fc[x]*nfc[y]%mod*nfc[x-y]%mod;&#125;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);n--;m--;</span><br><span class="line">    <span class="keyword">if</span>(!n)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;1\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    nfc[<span class="number">0</span>]=nfc[<span class="number">1</span>]=fc[<span class="number">0</span>]=fc[<span class="number">1</span>]=<span class="number">1</span>;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n+n+<span class="number">1</span>;i++)nfc[i]=(mod-mod/i)*nfc[mod%i]%mod;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n+n+<span class="number">1</span>;i++)nfc[i]=nfc[i<span class="number">-1</span>]*nfc[i]%mod,fc[i]=fc[i<span class="number">-1</span>]*i%mod;</span><br><span class="line">    LL ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="type">int</span> x=i*(<span class="number">3</span>*i<span class="number">-1</span>)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(x&gt;m)<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span>(i&amp;<span class="number">1</span>)ans=(ans+(mod<span class="number">-1</span>)*<span class="built_in">C</span>(n+<span class="number">1</span>+m-x,n+<span class="number">1</span>))%mod;</span><br><span class="line">        <span class="keyword">else</span> ans=(ans+<span class="built_in">C</span>(n+<span class="number">1</span>+m-x,n+<span class="number">1</span>))%mod;</span><br><span class="line">        x=i*(<span class="number">3</span>*i+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(x&gt;m || !i)<span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(i&amp;<span class="number">1</span>)ans=(ans+(mod<span class="number">-1</span>)*<span class="built_in">C</span>(n+<span class="number">1</span>+m-x,n+<span class="number">1</span>))%mod;</span><br><span class="line">        <span class="keyword">else</span> ans=(ans+<span class="built_in">C</span>(n+<span class="number">1</span>+m-x,n+<span class="number">1</span>))%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans*nfc[n+<span class="number">1</span>]%mod);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></details>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>组合意义</tag>
        <tag>五边形数定理</tag>
      </tags>
  </entry>
  <entry>
    <title>CF Round 940(Div 2) F2. Frequency Mismatch</title>
    <url>/2024/06/04/CF-Round-940-Div-2-F2-Frequency-Mismatch/</url>
    <content><![CDATA[<p>题目链接：<a href="https://codeforces.com/contest/1957/problem/F2">https://codeforces.com/contest/1957/problem/F2</a></p>
<p>题目链接：每次询问给你两条链，输出出现次数不同的颜色，至多只用输出 $k$ 个颜色。</p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>不是哥们，这都要分个 easy 和 hard 吗？</p>
<p>感觉没什么区别啊。</p>
<p>考虑多项式 Hash ，考虑 Hash 值为：$\sum\limits_{i=0}cnt_iBase^i$ ，其中 $i$ 是颜色编号。</p>
<p>直接线段树合并跑出到根节点路径上的 Hash 值，然后差分一下得到路径就行了。</p>
<p>有点卡常数，需要精细实现。</p>
<p>时间复杂度：$O((n+qk)\log{n})$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> SN = <span class="number">2e6</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M = <span class="number">1e5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> L = <span class="number">18</span>;</span><br><span class="line"><span class="type">const</span> LL M1 = <span class="number">1000000181ll</span>, A1 = <span class="number">1145141ll</span>;</span><br><span class="line"><span class="type">const</span> LL M2 = <span class="number">998244353ll</span>, A2 = <span class="number">1145141ll</span>;</span><br><span class="line">LL f1[N], f2[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    f1[<span class="number">0</span>] = f1[<span class="number">1</span>] = f2[<span class="number">0</span>] = f2[<span class="number">1</span>] = <span class="number">1ll</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= M; i++) f1[i] = f1[i - <span class="number">1</span>] * A1 % M1, f2[i] = f2[i - <span class="number">1</span>] * A2 % M2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">upd1</span><span class="params">(LL x)</span></span>&#123;<span class="keyword">return</span> x &gt;= M1 ? x - M1 : x;&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">upd2</span><span class="params">(LL x)</span></span>&#123;<span class="keyword">return</span> x &gt;= M2 ? x - M2 : x;&#125;</span><br><span class="line">PII <span class="keyword">operator</span> + (PII x, PII y)&#123;<span class="keyword">return</span> &#123;<span class="built_in">upd1</span>(x.first + y.first), <span class="built_in">upd2</span>(x.second + y. second)&#125;;&#125;</span><br><span class="line">PII <span class="keyword">operator</span> - (PII x, PII y)&#123;<span class="keyword">return</span> &#123;<span class="built_in">upd1</span>(x.first - y.first + M1), <span class="built_in">upd2</span>(x.second - y. second + M2)&#125;;&#125;</span><br><span class="line">PII <span class="keyword">operator</span> * (PII x, <span class="type">int</span> y)&#123;<span class="keyword">return</span> &#123;x.first * (M1 + y) % M1, x.second * (M2 + y) % M2&#125;;&#125;</span><br><span class="line">PII <span class="keyword">operator</span> * (<span class="type">int</span> x, PII y)&#123;<span class="keyword">return</span> y * x;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> lc, rc;</span><br><span class="line">    PII val;</span><br><span class="line">&#125;tr[SN]; <span class="type">int</span> cnt, rt[N];</span><br><span class="line"><span class="type">int</span> n, q;</span><br><span class="line"><span class="type">int</span> col[N];</span><br><span class="line"><span class="comment">// void update(int x)&#123;tr[x].val = tr[tr[x].lc].val + tr[tr[x].rc].val; tr[x].cnt = tr[tr[x].lc].cnt + tr[tr[x].rc].cnt;&#125;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">link</span><span class="params">(<span class="type">int</span> &amp;x, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> p)</span></span>&#123;</span><br><span class="line">    tr[++cnt] = tr[x];</span><br><span class="line">    x = cnt;</span><br><span class="line">    tr[x].val = tr[x].val + PII&#123;f1[p], f2[p]&#125;;</span><br><span class="line">    <span class="keyword">if</span>(l == r) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="type">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(p &lt;= mid) <span class="built_in">link</span>(tr[x].lc, l, mid, p);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">link</span>(tr[x].rc, mid + <span class="number">1</span>, r, p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">PII <span class="title">calc</span><span class="params">(<span class="type">const</span> vector&lt;PII&gt; &amp;x)</span></span>&#123;</span><br><span class="line">    PII ans = &#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> [p, type] : x)&#123;</span><br><span class="line">        ans = ans + tr[p].val * type;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">vector&lt;PII&gt; <span class="title">gleft</span><span class="params">(vector&lt;PII&gt; x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; [p, type] : x) p = tr[p].lc;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">vector&lt;PII&gt; <span class="title">gright</span><span class="params">(vector&lt;PII&gt; x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; [p, type] : x) p = tr[p].rc;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">findans</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> limit, vector&lt;PII&gt; x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(limit &gt; r || <span class="built_in">calc</span>(x) == PII&#123;<span class="number">0</span>, <span class="number">0</span>&#125;) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(l == r) <span class="keyword">return</span> l;</span><br><span class="line">    <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(limit &lt;= mid) ans = <span class="built_in">findans</span>(l, mid, limit, <span class="built_in">gleft</span>(x));</span><br><span class="line">    <span class="keyword">if</span>(ans == <span class="number">-1</span>) ans = <span class="built_in">findans</span>(mid + <span class="number">1</span>, r, limit, <span class="built_in">gright</span>(x));</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span>&#123;</span><br><span class="line">    <span class="type">int</span> y, next;</span><br><span class="line">&#125;a[N * <span class="number">2</span>]; <span class="type">int</span> len, las[N];</span><br><span class="line"><span class="type">int</span> fa[N][L], dep[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ins</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>&#123;a[++len] = &#123;y, las[x]&#125;; las[x] = len;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; L; i++) fa[x][i] = fa[fa[x][i - <span class="number">1</span>]][i - <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">link</span>(rt[x], <span class="number">1</span>, M, col[x]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k = las[x]; k; k = a[k].next)&#123;</span><br><span class="line">        <span class="type">int</span> y = a[k].y;</span><br><span class="line">        <span class="keyword">if</span>(y == fa[x][<span class="number">0</span>]) <span class="keyword">continue</span>;</span><br><span class="line">        rt[y] = rt[x];</span><br><span class="line">        fa[y][<span class="number">0</span>] = x;</span><br><span class="line">        dep[y] = dep[x] + <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">findlca</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(dep[x] &lt; dep[y]) <span class="built_in">swap</span>(x, y);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = L - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(dep[x] - dep[y] &gt;= (<span class="number">1</span> &lt;&lt; i)) x = fa[x][i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(x == y) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = L - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(fa[x][i] != fa[y][i]) x = fa[x][i], y = fa[y][i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fa[x][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin.<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) cin &gt;&gt; col[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="type">int</span> x, y;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        <span class="built_in">ins</span>(x, y);</span><br><span class="line">        <span class="built_in">ins</span>(y, x);</span><br><span class="line">    &#125;</span><br><span class="line">    dep[<span class="number">1</span>] = <span class="number">1</span>; <span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">    cin &gt;&gt; q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= q; i++)&#123;</span><br><span class="line">        <span class="type">int</span> x1, y1, x2, y2, cnt;</span><br><span class="line">        cin &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2 &gt;&gt; cnt;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">        vector&lt;PII&gt; t;</span><br><span class="line">        t.<span class="built_in">resize</span>(<span class="number">8</span>);</span><br><span class="line">        <span class="type">int</span> lca = <span class="built_in">findlca</span>(x1, y1);</span><br><span class="line">        t[<span class="number">0</span>]=&#123;rt[x1], <span class="number">1</span>&#125;;</span><br><span class="line">        t[<span class="number">1</span>]=&#123;rt[y1], <span class="number">1</span>&#125;;</span><br><span class="line">        t[<span class="number">2</span>]=&#123;rt[lca], <span class="number">-1</span>&#125;;</span><br><span class="line">        t[<span class="number">3</span>]=&#123;rt[fa[lca][<span class="number">0</span>]], <span class="number">-1</span>&#125;;</span><br><span class="line">        lca = <span class="built_in">findlca</span>(x2, y2);</span><br><span class="line">        t[<span class="number">4</span>]=&#123;rt[x2], <span class="number">-1</span>&#125;;</span><br><span class="line">        t[<span class="number">5</span>]=&#123;rt[y2], <span class="number">-1</span>&#125;;</span><br><span class="line">        t[<span class="number">6</span>]=&#123;rt[lca], <span class="number">1</span>&#125;;</span><br><span class="line">        t[<span class="number">7</span>]=&#123;rt[fa[lca][<span class="number">0</span>]], <span class="number">1</span>&#125;;</span><br><span class="line">        <span class="type">int</span> pre = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= cnt; j++)&#123;</span><br><span class="line">            pre = <span class="built_in">findans</span>(<span class="number">1</span>, M, pre + <span class="number">1</span>, t);</span><br><span class="line">            <span class="keyword">if</span>(pre == <span class="number">-1</span>) <span class="keyword">break</span>;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(pre);</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; ans.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> x : ans) cout &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; x;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看了下题解，题解说的有道理，给每个权值随一个随机数也可以。</p>
<p>总之只要 Hash 支持可加就行了。</p>
</div></details>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>Hash</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title>ECNU 2023.8 C. Kaleidoscope</title>
    <url>/2023/09/02/ECNU-2023-8-C-Kaleidoscope/</url>
    <content><![CDATA[<p>题目链接：<a href="https://acm.ecnu.edu.cn/contest/695/problem/C/">https://acm.ecnu.edu.cn/contest/695/problem/C/</a></p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>我是状压 DP 做的，不难发现，我们可以把这一行被上一行占用的位置保存下来，然后转移。</p>
<p>显然如果 $x$ 转移到 $y$ ，那么 $x\And y=0$ ，而这是一个经典的 trick ，这样子转移的复杂度是 $O(3^m)$ 的，所以最终时间复杂度就是：$O(n3^m)$ 。</p>
<p>不过看题解说其实有效转移 $&lt;6000$ ？</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 310</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> M 160</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">26</span>],len,fa;</span><br><span class="line">&#125;tr[N];<span class="type">int</span> tot,last;</span><br><span class="line"><span class="type">char</span> st[M];<span class="type">int</span> n;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> c)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> p=last;<span class="type">int</span> np=last=++tot;</span><br><span class="line">    tr[np].len=tr[p].len+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(;p &amp;&amp; !tr[p].a[c];p=tr[p].fa)tr[p].a[c]=np;</span><br><span class="line">    <span class="keyword">if</span>(!p)tr[np].fa=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="type">int</span> q=tr[p].a[c];</span><br><span class="line">        <span class="keyword">if</span>(tr[q].len==tr[p].len+<span class="number">1</span>)tr[np].fa=q;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="type">int</span> nq=++tot;</span><br><span class="line">            tr[nq].fa=tr[q].fa;tr[q].fa=nq;</span><br><span class="line">            tr[nq].len=tr[p].len+<span class="number">1</span>;<span class="built_in">memcpy</span>(tr[nq].a,tr[q].a,<span class="built_in">sizeof</span>(tr[q].a));</span><br><span class="line">            tr[np].fa=nq;</span><br><span class="line">            <span class="keyword">for</span>(;p &amp;&amp; tr[p].a[c]==q;p=tr[p].fa)tr[p].a[c]=nq;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool</span> dp[N][M][M];</span><br><span class="line"><span class="type">int</span> m,X;<span class="type">char</span> ans[M];<span class="type">int</span> fuck;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getval</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> fucklen)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> cnt=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=fucklen;i&gt;=<span class="number">1</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(tr[x].a[ans[i]-<span class="string">&#x27;a&#x27;</span>])x=tr[x].a[ans[i]-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        <span class="keyword">else</span> x=tr[<span class="number">1</span>].a[ans[i]-<span class="string">&#x27;a&#x27;</span>],cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool</span> v[<span class="number">40</span>];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">work</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(fuck!=m)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=tot;i++)&#123;</span><br><span class="line">            <span class="type">int</span> x=<span class="built_in">getval</span>(i,fuck);</span><br><span class="line">            <span class="keyword">if</span>(x&lt;=X &amp;&amp; dp[i][m-fuck][X-x+<span class="number">1</span>])<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">getval</span>(tr[<span class="number">1</span>].a[ans[m]-<span class="string">&#x27;a&#x27;</span>],m<span class="number">-1</span>)==X;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> T;<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;X);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,st+<span class="number">1</span>);</span><br><span class="line">        tot=last=<span class="number">1</span>;<span class="built_in">memset</span>(tr,<span class="number">0</span>,<span class="built_in">sizeof</span>(tr));<span class="built_in">memset</span>(v,<span class="number">0</span>,<span class="built_in">sizeof</span>(v));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i+i&lt;=n;i++)<span class="built_in">swap</span>(st[i],st[n-i+<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="built_in">add</span>(st[i]-<span class="string">&#x27;a&#x27;</span>),v[st[i]-<span class="string">&#x27;a&#x27;</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="comment">// for(int i=1;i&lt;=tot;i++)&#123;</span></span><br><span class="line">        <span class="comment">//     printf(&quot;%d %d\n&quot;,tr[i].fa,tr[i].len);</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">25</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(tr[<span class="number">1</span>].a[i])dp[tr[<span class="number">1</span>].a[i]][<span class="number">1</span>][<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;m;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">2</span>;j&lt;=tot;j++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> t=<span class="number">1</span>;t&lt;=i &amp;&amp; t&lt;=X;t++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(!dp[j][i][t])<span class="keyword">continue</span>;</span><br><span class="line">                    <span class="comment">// if(i==1 &amp;&amp; j==5 &amp;&amp; t==1)printf(&quot;OK\n&quot;);</span></span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;=<span class="number">25</span>;k++)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(tr[j].a[k])dp[tr[j].a[k]][i+<span class="number">1</span>][t]=<span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span>(tr[<span class="number">1</span>].a[k] &amp;&amp; t&lt;X)dp[tr[<span class="number">1</span>].a[k]][i+<span class="number">1</span>][t+<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// for(int i=1;i&lt;=tot;i++)printf(&quot;%d:%d %d\n&quot;,i,tr[i].len,tr[i].fa);</span></span><br><span class="line">        <span class="comment">// printf(&quot;%d %d %d\n&quot;,dp[4][2][1],tr[5].a[0],dp[5][1][1]);</span></span><br><span class="line">        <span class="type">bool</span> bk=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=tot;i++)bk|=dp[i][m][X];</span><br><span class="line">        <span class="keyword">if</span>(!bk)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=tot;i++)<span class="built_in">memset</span>(dp[i],<span class="number">0</span>,<span class="built_in">sizeof</span>(dp[i]));</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;-1\n&quot;</span>);<span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ans[1]=ans[2]=&#x27;a&#x27;;printf(&quot;%d\n&quot;,getval(5,2));</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">            fuck=i;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=<span class="number">25</span>;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!v[j])<span class="keyword">continue</span>;</span><br><span class="line">                ans[i]=j+<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">work</span>()==<span class="number">1</span>)<span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans[m+<span class="number">1</span>]=<span class="string">&#x27;\0&#x27;</span>;<span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,ans+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=tot;i++)<span class="built_in">memset</span>(dp[i],<span class="number">0</span>,<span class="built_in">sizeof</span>(dp[i]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>官方做法：</p>
<p>可以发现 $(i,j)$ 至多从 $(i-1,j-1)$ 转移过来，所以可以直接轮廓线 DP ，保存所有需要位置的状态就行了。</p>
<p>时间复杂度：$O(nm2^m)$ 。</p>
</div></details>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>经典trick</tag>
        <tag>状压</tag>
        <tag>轮廓线</tag>
      </tags>
  </entry>
  <entry>
    <title>CF1987 赛后总结</title>
    <url>/2024/07/04/CF1987-%E8%B5%9B%E5%90%8E%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>比赛链接：<a href="https://codeforces.com/contest/1987">https://codeforces.com/contest/1987</a></p>
<h1 id="A-Upload-More-RAM"><a href="#A-Upload-More-RAM" class="headerlink" title="A. Upload More RAM"></a>A. Upload More RAM</h1><p>题目链接：<a href="https://codeforces.com/contest/1987/problem/A">https://codeforces.com/contest/1987/problem/A</a></p>
<p>题目大意：略。</p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>答案是 ：$(n-1)k+1$ 。</p>
</div></details>
<h1 id="B-K-Sort"><a href="#B-K-Sort" class="headerlink" title="B.K-Sort"></a>B.K-Sort</h1><p>题目链接：<a href="https://codeforces.com/contest/1987/problem/B">https://codeforces.com/contest/1987/problem/B</a></p>
<p>题目大意：略。</p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>显然每个数字最多变到前缀 max 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> a[N], n;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="type">int</span> pre = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> val = <span class="number">0</span>;</span><br><span class="line">    LL ans = <span class="number">0ll</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">        pre = <span class="built_in">max</span>(pre, a[i]);</span><br><span class="line">        a[i] = pre - a[i];</span><br><span class="line">        ans += a[i];</span><br><span class="line">        val = <span class="built_in">max</span>(val, a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    ans += val;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></details>
<h1 id="C-Basil’s-Garden"><a href="#C-Basil’s-Garden" class="headerlink" title="C. Basil’s Garden"></a>C. Basil’s Garden</h1><p>题目链接：<a href="https://codeforces.com/contest/1987/problem/C">https://codeforces.com/contest/1987/problem/C</a></p>
<p>题目大意：略。</p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>倒着做，答案要么是他自己，要么是后面的答案加一。</p>
</div></details>
<h1 id="D-World-is-Mine"><a href="#D-World-is-Mine" class="headerlink" title="D. World is Mine"></a>D. World is Mine</h1><p>题目链接：<a href="https://codeforces.com/contest/1987/problem/D">https://codeforces.com/contest/1987/problem/D</a></p>
<p>题目大意：略。</p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>首先，基于后手一个不改变答案的选项：不吃。</p>
<p>然后决定好哪些蛋糕是要吃的，且吃了某种蛋糕就一定要全部吃完，显然一定可以按照从左到右的顺序吃（不可以就说明这个方案不优）。</p>
<p>然后可以发现，任意一个前缀，只关心两个值：剩下的蛋糕的种类数，需要吃的蛋糕数，只要任意前缀前者大于等于后者，这个方案就是合法方案。</p>
<p>注意到，现在是三元组：前缀、剩余蛋糕种类数、需要吃的蛋糕数。</p>
<p>因此不妨考虑，在需要吃的蛋糕数相同的情况下，只维护最小的剩余蛋糕种类数。</p>
<p>原因是：假设只有需要吃的蛋糕数不同的情况下，假设 X 方案 &gt; Y 方案的。</p>
<p>假设 X 在后面能到 Z 方案，把 X 方案后面需要吃的 $X-Y$ 种蛋糕全部不吃，并且前面换成 Y 方案，可以发现，这仍然是一个合法方案，而且需要吃的蛋糕数更少，也就是更优，所以 X 所能到的方案严格劣于 Y 能到的方案。</p>
<p>至于严谨证明，可以从前缀开始，每次把一定不可能产生答案的三元组扔掉，答案一定产生于剩下的三元组中，然后前缀从左往右扫就可以证明了。</p>
<p>时间复杂度：$O(n^2)$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">5e3</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">1e9</span>;</span><br><span class="line"><span class="type">int</span> n, dp[N][N];</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(a + <span class="number">1</span>, a + n + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= n; j++) dp[i][j] = -inf;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> l = <span class="number">1</span>; l &lt;= n; l++)&#123;</span><br><span class="line">        cnt++;</span><br><span class="line">        <span class="type">int</span> r = l;</span><br><span class="line">        <span class="keyword">while</span>(r &lt; n &amp;&amp; a[r + <span class="number">1</span>] == a[l]) r++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; l; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dp[l - <span class="number">1</span>][j] == -inf) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="type">int</span> x = dp[l - <span class="number">1</span>][j];</span><br><span class="line">            dp[r][j] = <span class="built_in">max</span>(dp[r][j], x);</span><br><span class="line">            <span class="keyword">if</span>(cnt - (x + <span class="number">1</span>) &gt;= j + r - l + <span class="number">1</span>)&#123;</span><br><span class="line">                dp[r][j + r - l + <span class="number">1</span>] = <span class="built_in">max</span>(dp[r][j + r - l + <span class="number">1</span>], x + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        l = r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans = cnt;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i++) ans = <span class="built_in">min</span>(ans, cnt - dp[n][i]);</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></details>
<p>没怎么看官方题解，官方题解也是类似的 $n^2$ dp ，估计区别不大。</p>
<details class="toggle" ><summary class="toggle-button" style="">别的做法</summary><div class="toggle-content"><p>看题解说能 $n\log{n}$ ，先自己想了一个。</p>
<p>首先注意到，我们可以把颜色数记录成一个数组，排序，然后全体 $+1$ 。</p>
<p>这样问题就变成了，你可以选择一些颜色，满足前 $i$ 种颜色选择的数字和 $\le i$ 对于所有的 $i$ 都满足。</p>
<p>那么显然，按数量从小到大考虑每一种颜色是对的，不难证明，不再赘述。</p>
<p>下面是用 $O(n^2)$ 实现的版本，可以用线段树做到 $O(n\log{n})$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">5e3</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> a[N], n, m, id[N], b[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        m = <span class="number">0</span>;</span><br><span class="line">        cin &gt;&gt; n;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            cin &gt;&gt; a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(a + <span class="number">1</span>, a + n + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> l = <span class="number">1</span>; l &lt;= n; l++)&#123;</span><br><span class="line">            <span class="type">int</span> r = l;</span><br><span class="line">            <span class="keyword">while</span>(r &lt; n &amp;&amp; a[r + <span class="number">1</span>] == a[r]) r++;</span><br><span class="line">            a[++m] = r - l + <span class="number">2</span>;</span><br><span class="line">            l = r;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) id[i] = i, b[i] = i;</span><br><span class="line">        <span class="built_in">sort</span>(id + <span class="number">1</span>, id + m + <span class="number">1</span>, [](<span class="type">int</span> x, <span class="type">int</span> y)&#123;<span class="keyword">return</span> a[x] &lt; a[y];&#125;);</span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">            <span class="type">int</span> x = id[i];</span><br><span class="line">            <span class="type">bool</span> bk = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = x; j &lt;= m; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(b[j] &lt; a[x]) &#123;bk = <span class="number">0</span>; <span class="keyword">break</span>;&#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!bk) <span class="keyword">continue</span>;</span><br><span class="line">            cnt++;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = x; j &lt;= m; j++) b[j] -= a[x];</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; m - cnt &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后一翻 CF 评论区，发现有一种比我这好写的多的单 log 做法。</p>
<p>就是从左到右，直接贪心，每次尝试直接吃完这个颜色，不能吃完就尝试替换之前吃过的颜色。</p>
<p>用一个堆就可以做到 $O(n\log{n})$ ，非常的好写。</p>
<p>这乍一看很对，但是怎么证明呢？</p>
<p>我们需要证明一个引理：</p>
<p>设吃了 $k$ 种颜色的最优方案，则 $k-1$ 种颜色的最优方案就是 $k$ 种颜色最优方案的子集，（证明采用上面那个模型）</p>
<p>考虑 $k$ 种颜色的最优方案和 $k-1$ 种颜色的最优方案，消去相同的选择。</p>
<p>得到：$\{x_1,x_2,x_3,…,x_{m+1}\},\{y_1,y_2,…,y_{m}\}$ （递增排列）</p>
<p>如果存在一个 $L,t$ 满足 $x_{t},y_{t}\le L, x_{t+1},y_{t+1}&gt;L$ 吗，下标不存在认为是 $\infty$ 。</p>
<p>那么这两者一定可以交换且不影响双方的值，因为最优，所以消掉，下面认为不存在这种情况。</p>
<p>则一定有 $y_{1}&gt;x_{2}$ ，考虑对于任意 $i$ ，即 $X$ 集合的贡献为： $\sum\limits_{\forall 2\le j \le m+1,x_j\le i}cnt_{x_j}$ ，同理，$Y$ 集合有：$\sum\limits_{\forall 1\le j \le m,y_j\le i}cnt_{y_j}$ ，根据前面的说法，$X$ 合法的 $j$ 的个数 $\ge$ $Y$ 集合的，而且知道 $X$ 集合的贡献 $\ge$ $Y$ 集合的，否则交换可以使 $Y$ 集合个数不减的同时更优。</p>
<p>综上，最后，我们可以交换 $\{x_{2},…,x_{m+1}\}$ 和 $\{y_1,y_2,…,y_{m}\}$ ，得到不劣的 $X$ ，但又最优，则两者和相等，证毕。（注：上面过程之所以这么繁琐是为了交换完后仍然合法）</p>
<p>因此，我们只需要时时刻刻维护以选择颜色数为第一权重，要吃掉的食物为第二权重的最优方案就行了，也就是上面那个做法。即上面那个做法可以归纳的证明，其每次得到的方案就是方才说的最优方案。</p>
<p>这样正确性就证明完毕了。</p>
<p>这里贴一份别人的代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//https://codeforces.com/contest/1987/submission/268356662</span></span><br><span class="line"><span class="comment">// Problem: D. World is Mine</span></span><br><span class="line"><span class="comment">// Contest: Codeforces - EPIC Institute of Technology Round Summer 2024 (Div. 1 + Div. 2)</span></span><br><span class="line"><span class="comment">// URL: https://codeforces.com/contest/1987/problem/D</span></span><br><span class="line"><span class="comment">// Memory Limit: 256 MB</span></span><br><span class="line"><span class="comment">// Time Limit: 2000 ms</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AC ios::sync_with_stdio(0); cin.tie(0);</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(<span class="string">&quot;Ofast&quot;</span>)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//suppose b should eat 2 1 to let a - 2</span></span><br><span class="line"><span class="comment">//but in the gready approach, b will eat 1 first and can&#x27;t eat 2</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	AC;</span><br><span class="line">	<span class="type">int</span> t; cin &gt;&gt; t;</span><br><span class="line">	<span class="keyword">while</span> (t--) &#123;</span><br><span class="line">		<span class="type">int</span> n; cin &gt;&gt; n;</span><br><span class="line">		map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; ma;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">			<span class="type">int</span> temp; cin &gt;&gt; temp;</span><br><span class="line">			ma[temp]++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">		<span class="type">int</span> skip = <span class="number">0</span>;</span><br><span class="line">		priority_queue&lt;<span class="type">int</span>&gt; pque;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> &amp;[i, j] : ma) &#123;</span><br><span class="line">			<span class="keyword">if</span> (skip &gt;= j) &#123;</span><br><span class="line">				skip -= j;</span><br><span class="line">				pque.<span class="built_in">push</span>(j);</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (!pque.<span class="built_in">empty</span>() &amp;&amp; pque.<span class="built_in">top</span>() &gt; j) &#123; <span class="comment">//check if current one costs less skip points</span></span><br><span class="line">				<span class="comment">//if so, reverse the prevoius operation where b stops a</span></span><br><span class="line">				skip += pque.<span class="built_in">top</span>() + <span class="number">1</span>;</span><br><span class="line">				pque.<span class="built_in">pop</span>();</span><br><span class="line">				ans++;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (skip &gt;= j) &#123; <span class="comment">//let b stops a in the better scenario, which costs least skip points</span></span><br><span class="line">				skip -= j;</span><br><span class="line">				pque.<span class="built_in">push</span>(j);</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			ans++;</span><br><span class="line">			skip++;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></details>
<h1 id="E-Wonderful-Tree"><a href="#E-Wonderful-Tree" class="headerlink" title="E. Wonderful Tree!"></a>E. Wonderful Tree!</h1><p>题目链接：<a href="https://codeforces.com/contest/1987/problem/E">https://codeforces.com/contest/1987/problem/E</a></p>
<p>题目大意：略。</p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>感觉有点简单了，但是有趣。</p>
<p>注意到 $dp[x][i]$ 表示 $x$ 值为 $i$ 的时候的最小代价。</p>
<p>可以发现这是凸性的，而且斜率范围在 $[0,size]$ ，所以直接转移就行了。</p>
<p>当然这也有实际意义，差分一下，表示用代价 $k$ 让 $x$ 增加 $1$ 的操作至多能进行多少次，按照这个思路 dp 转移式就很容易列出来了。（想到这个意义并且证明这是对的还是花了我一定的时间）</p>
<p>时间复杂度：$O(n^2)$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">5e3</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">1e9</span>;</span><br><span class="line"><span class="type">int</span> n, p[N], siz[N], a[N];</span><br><span class="line">LL f[N][N], dp[N], sum[N];</span><br><span class="line"><span class="comment">// vector&lt;int&gt; son[N];</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">        siz[i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        cin &gt;&gt; p[i];</span><br><span class="line">        <span class="comment">// son[p[i]].push_back(i);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = n; i &gt;= <span class="number">1</span>; i--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(siz[i] == <span class="number">1</span>) sum[i] = inf;</span><br><span class="line">        LL res = a[i] - sum[i];</span><br><span class="line">        <span class="keyword">if</span>(res &lt; <span class="number">0</span>) f[i][<span class="number">1</span>] = -res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n &amp;&amp; res &gt; <span class="number">0</span>; j++)&#123;</span><br><span class="line">            LL s = <span class="built_in">min</span>(res, f[i][j]);</span><br><span class="line">            res -= s;</span><br><span class="line">            f[i][j] -= s;</span><br><span class="line">            dp[i] += (j - <span class="number">1</span>) * s;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i == <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">        siz[p[i]] += siz[i];</span><br><span class="line">        sum[p[i]] += a[i];</span><br><span class="line">        dp[p[i]] += dp[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt; n; j++) f[p[i]][j + <span class="number">1</span>] += f[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; dp[<span class="number">1</span>] &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="comment">// son[i].clear();</span></span><br><span class="line">        dp[i] = sum[i] = <span class="number">0ll</span>;</span><br><span class="line">        <span class="built_in">memset</span>(f[i], <span class="number">0</span>, <span class="built_in">sizeof</span>(f[i]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></details>
<details class="toggle" ><summary class="toggle-button" style="">官方做法</summary><div class="toggle-content"><p>你是真的笨啊，都长成父亲和儿子权值和的比较了，还想不到差分吗？那我只能说你是真 FW 啊。</p>
<p>总之，看了题解后，我觉得我这道题目只是根据见识硬做出来的，其实我根本就没有真正会这道题目。我有个可以过的做法，但是我并未真正触及其本质。</p>
<p>注意到这个不等式可以写成：</p>
<script type="math/tex; mode=display">a_{v}-\sum\limits_{u\in son_{v}}a_{u}\le 0</script><p>其中，如果没有儿子，就认为左式为 $-\infty$ 。</p>
<p>那么这个时候就很显然了，每次操作会把一个点 $+1$ ，父亲 $-1$ 。</p>
<p>要求用最少的步数把所有点变成 $\le 0$ 的。</p>
<p>注意到如果把每次操作，让这个点的父亲向其连一条边，表示父亲的一个 $1$ 流向了这个点，那么操作完后的图一定可以把所有边分成若干条路径，满足不存在一条路径的终点和另外一条路径的起点相同，可以看到，每条路径反映了一个 $1$ 的流向，起点包含了所有正点，终点一定是负点，贡献就是路径长度。</p>
<p>注意到最优方案中，只有正点可能作为起点，且作为起点的次数一定是其的值。（答案一定出在这个集合中）</p>
<p>那么问题可以等价的转化成求这个问题的最优解：每次将一个正点和子树内一个负电匹配，代价是距离，然后把正点 $-1$ ，负电 $+1$ ，直到没有正点为止。</p>
<p>这显然是一个费用流，所以在 CF 评论区和 luogu 都看到了赛时写费用流过题的佬。</p>
<p>当然，因为这个匹配非常简单，显然可以模拟，也不用写费用流。</p>
<p>先回看我上面的做法，实际上是在维护离当前点距离为 $d$ 的负数点能提供多少个匹配，这样就一目了然了。</p>
<p>当然，题解提供了种更好写的做法：每个点 BFS 一遍。</p>
<p>优化一下复杂度，做到 $O(n\log{n})$ 不难，把上面的数组合并写成可并堆的形式就行了。（能不能数组用启发式合并呢？不行，因为还有一个时间复杂度瓶颈是在做单点匹配的时候，需要弹出当前的最小值，数组用遍历的话复杂度仍然是 $O(n^2)$ 的）</p>
<p>能不能再快点？</p>
<p>在原图上，按深度从浅到深遍历每一个负数点，然后并查集维护到祖先的正数点，时间复杂度：$O(n\alpha(n))$ 。</p>
<p>能不能再快点？</p>
<p>可以，长链剖分，每个点用链表维护，合并的时候，两个链表至多弹出短链长度个，所以合并是 $O(n)$ 的，由于链表中的点数至多 $O(n)$ 个，所以弹出最小值也是 $O(n)$ 的。（之所以这样子归并复杂度不是两个数组长度和，是因为我实际上限制了值域范围，而不是限制了弹出个数。归并是两个数组长度和是因为短数组的最大值可能大过长数组的）</p>
<p>综上，时间复杂度为：$O(n)$ 。</p>
<p>最后说个幽默的事情，我在赛后说能启发式合并优化到 $n\log{n}$ ，因为我首先没想到弹出最小值的事情，其次我以为数组长度是和 $size$ 相关，后面问了人才发现，原来是和深度相关的。</p>
<p>很有意思。</p>
</div></details>
<h1 id="F-Interesting-Problem-Hard-Version"><a href="#F-Interesting-Problem-Hard-Version" class="headerlink" title="F. Interesting Problem (Hard Version)"></a>F. Interesting Problem (Hard Version)</h1><p>直接上 Hard Version 吧，我两个一起做的。</p>
<p>题目链接：<a href="https://codeforces.com/contest/1987/problem/F2">https://codeforces.com/contest/1987/problem/F2</a></p>
<p>题目大意：略。</p>
<details class="toggle" ><summary class="toggle-button" style="">我的做法</summary><div class="toggle-content"><p>这里，我采用复盘的形式写出我的做法，因为我觉得看懂最终做法不难，但是明白中间犯了什么错是至关重要的，以及怎么避免犯同样的错误。</p>
<p>首先可以注意到，如果在一开始就规定某些数字是作为 $a[i]=i$ 的位置被删除的，那么可以类似括号匹配一样，找到和其一起被删除的位置。</p>
<p>那么我一开始就想，会不会只要在一个位置前面能被删除的数字个数是 $\frac{i-a[i]}{2}$ ，这个位置就一定能被删除，所有都满足就合法吧。</p>
<p>当时的逻辑是，假设每次都有能删除的数字，每次选择最右边的数字删除，一定不会影响左边，而且还能贡献给右边的数字，让他们也能删除，而且最左边的数字一定能被删除。</p>
<p>然后喜提 WA ，原因：可能删除了两个左括号。</p>
<p>然后我就开始想，也就是说括号嵌套的时候，不能让内层括号的消除时间晚于外层括号，怎么办到呢？</p>
<p>显然从左往右 dp 是办不到的，不可能记录这么多信息，但是发现这是括号序列啊，这不直接区间 dp 。</p>
<p>但“晚于”这个词有点过于模糊不清了，有没有具体点的说法？</p>
<p>当时提出了一种想法，$f[l][r]$ 表示前面需要额外删多少个数字这个区间才可以完整消完（维护最小可能的解，至于为什么，写博客的时候感觉并不是很显然，但是当时很自然的就这么想了，也没质疑，反正都红了。但其实正确性也并不难，只要知道了括号序列合并和嵌套的充要条件，就可以发现维护最小值在任何时候都是最优的，所以直接维护最小值就行了，但前提是充要条件是对的），嵌套的要求一定要求外层的括号所需要删除的数字一定严格大于等于内层的。（但是具体怎么想的也忘了，太红了，但是反正差不多）</p>
<p>就关于 $f$ 的维护我就写了好几种逆天的东西，包括当不限于：找于 l 同奇偶的位置的 a 的最小值、必须要求外层有嵌套等，反正很逆天就是了，感觉就是纯红。</p>
<p>后面发现可以这么维护，区间合并的时候，前一个区间可以对后一个区间产生贡献就行了（至于为什么，也没细想），反正此时终于走上正轨了。</p>
<p>在正确的实现完这个做法后就过了。</p>
<p>时间复杂度：$O(n^3)$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">8e2</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">1e9</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">calc</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>((x &amp; <span class="number">1</span>) != (a[x] &amp; <span class="number">1</span>)) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(a[x] &gt; x) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">return</span> (x - a[x]) / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> v[N][N];</span><br><span class="line"><span class="type">int</span> dp[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) cin &gt;&gt; a[i];</span><br><span class="line">    <span class="built_in">memset</span>(v, <span class="number">20</span>, <span class="built_in">sizeof</span>(v));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) v[i][i - <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> len = <span class="number">2</span>; len &lt;= n; len += <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> l = <span class="number">1</span>; l + len - <span class="number">1</span> &lt;= n; l++)&#123;</span><br><span class="line">            <span class="type">int</span> r = l + len - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> mid = l; mid &lt; r; mid++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(v[l][mid] &gt; n &amp;&amp; v[mid + <span class="number">1</span>][r] &gt; n) <span class="keyword">continue</span>;</span><br><span class="line">                v[l][r] = <span class="built_in">min</span>(<span class="built_in">max</span>(v[l][mid], v[mid + <span class="number">1</span>][r] - (mid - l + <span class="number">1</span>) / <span class="number">2</span>), v[l][r]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> val = <span class="built_in">calc</span>(l);</span><br><span class="line">            <span class="keyword">if</span>(val == <span class="number">-1</span> || v[l + <span class="number">1</span>][r - <span class="number">1</span>] &gt; n) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(val &gt;= v[l + <span class="number">1</span>][r - <span class="number">1</span>]) v[l][r] = <span class="built_in">min</span>(val, v[l][r]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        dp[i] = dp[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(v[j + <span class="number">1</span>][i] &gt; n) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(dp[j] &gt;= v[j + <span class="number">1</span>][i]) dp[i] = <span class="built_in">max</span>(dp[i], dp[j] + (i - j) / <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        cout &lt;&lt; <span class="built_in">solve</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>回忆一下，我当时几乎证明了这个做法是对的，但当时非常的红温，现在来看，确实这个做法是对的，而且证明起来并不困难，但反正当时就是红温，好想只证明了嵌套和合并的条件是当下充要的，并没有考虑后效性什么的，也就是零零散散的给了些部分的证明，并没有串在一起，给一个整体的、完整的证明，当因为在比赛，这也能理解，毕竟 WA 了再想也不迟。虽然但是，我觉得这不是并不证明的借口，我认为比赛时尤其是模拟赛，该证明的东西就应该证明，先不提不会假这种显性收益，不依赖比赛反馈做题的这种习惯是可以带来很多隐形收益的，包括对自己实力的提升和心态的考验。</p>
<p>你要说这场比赛我证明了吗？几乎所有做法我都在写之前给了些零散的证明，但有用吗？没有用，该 WA 还是得 WA ，为什么？首先证明是会假的，但我认为赛时给出正确而不假的证明也是实力的一部分。其次，其实这场比赛很多时候我都知道，我给的证明并不足以称为证明，即很多时候我只给出了局部的正确性，或者是可能能证明的一个方向，我并没有给出具体的，完整的，不容易出现瑕疵的证明，这场的 D,F,G 都是这样，D,G 都可以理解，简单题和时间不够，但是 F 在这一场，就是因为这个问题 WA 了一遍又一遍，但凡我当时多动点脑子，也不至于出现这种情况。将这种碎片化的证明当成证明，等于没有证明，在赛时给出一个正确的证明，我认为这也是比赛考验我们的东西，为了 rating 而舍弃掉证明，靠比赛反馈做题，依赖应试技巧，这和高考有什么区别，抛开这些不谈，我认为过度依赖这种应试技巧，终究会被反噬，所得到的分数，不过也是虚假的分数，不足以反映真正的实力。</p>
<p>但是这又出现了一个问题，为什么队长没证明，却几乎每次都能给出一个不会假的做法。首先队长赛时不证明很久了，因此自然也有规避错误的方法，这个方法是什么呢？我觉得就是想一些极端例子，在这些极端例子下是 well done 的，这相比相信一个不完整的证明，并且没有尝试证伪好多了。简单来说，队长多了个证伪的过程，而且队长证伪能力很强（相应的，他构造水平很高），证伪也是一种能力，至少比纯猜靠反馈要好的多。但你要说这也是种应试技巧，那也算是。但是很多时候极端证伪的过程和证明几乎也没有区别了，所以自然几乎次次都能证伪的话，证明的能力自然也不会差，在比赛时不失为一种策略，虽然我仍然不觉得这是赛时能够考验自己真正实力的习惯。但是队长真正实力也确实很厉害，那我只能认为队长每次的证伪其实和证明已经没有区别了，也就是换个说法的问题。（事实也是每次和他一起打比赛，让他给证明的时候他也能给出证明，队长厉害，无需多言）</p>
<p>所以我认为，比赛时该证明的时候，就要给出一个好的证明，不要过度关注那些排名和 rating 啥的，导致忽略了真正的修行。</p>
<p><strong>回归正题</strong>，怎么证明这个 dp 是充要的呢？</p>
<p>首先明确给出 dp[l][r] 的定义，最小的数 $x$ 满足前面在删除 $2x$ 个数字后，区间 [l,r] 内的数字可以全部删除。</p>
<p>根据前面的说法来看，我们只需要证明采用以下方案可以删除完整个序列就行了。</p>
<p>每次删除最右边的合法括号，这对括号满足：a[i]=i ，内层为空。</p>
<p>这完全等价于什么呢？设任意一个括号序列，对于任意一对括号，其的可删除括号为，所有 () 满足 () 都在其的左括号左边，可删除左括号个数 * 2 $\ge i-a[i]$ 。</p>
<p>用这个性质证明 dp 就显然了。</p>
<p>以下皆是吹水。</p>
<p>你要说我当时知道这么证明纯属狗屁，首先这个性质是在我写博客的时候才想到的，其次我当时只证明了两个括号序列合并，两个括号序列嵌套，那个条件似乎足够充要，但是实际上，为什么要设最小的次数，为什么满足就一定有解呢？当时我是一定没想的。即使现在，我也想不太明白，因为如果纯从局部去证明整体，我很难去说明为什么局部满足这个条件，整体就一定满足，难道归纳吗？拿这又是一个很屎的过程，因为一定会用到优先删右边这个性质，很不巧，这是个整体性质，把整体性质用在局部的归纳法就是一坨屎，就只能说隐隐感觉这样子看非常的正确，但实际书写书写不出来。</p>
<p>一般发生这种情况是因为，我们在想这个问题的时候，默认的使用了某些性质，比如这里就默认使用了能删优先删右边，所以即使左边删多了也不要紧这个性质。但是默认使用的这个性质，在我们并不知情的情况下，是对的吗？用对了没？我们都不知道，所以你要说隐隐感觉对就是对的，我觉得纯放屁，到时候正式赛假了就直接寄了，痛哭流涕。</p>
<p>那如果要从整体去证明，我觉得就不能叫从这个 dp 的角度去证明了，两者的关系大概率是整体证明了一个性质，然后用 dp 维护，这里 dp 就只是维护工具，并不作为证明的载体，但我当时肯定不是这么想的，我是直接想的 dp ，并没有说先找到性质，然后再想办法用 dp 维护这么一个思考过程。</p>
<p>反正我觉得，有些 dp ，先想到一个感觉正确的 dp ，再从这个 dp 去证明做法正确性就是耍流氓。</p>
<p>我个人觉得做大部分 dp ，正确的流程就应该是，我先想到这个题目的一些充要的性质啥的，然后再尝试用 dp 去维护这些充要的性质。</p>
<p>即不是从 dp 本身去证明 dp 的正确性，而是先把 dp 要维护的东西证明了，这样使用 dp 维护就完全正确了。</p>
<p>所以我认为，这道题目正确的、自然的思考过程大体上应该是这样：</p>
<ol>
<li><p>以任意路线发现充要条件：可以采用后面这个方案删除完整个序列：每次删除最右边的合法括号，这对括号满足：a[i]=i ，内层为空。</p>
</li>
<li><p>然后再发现一个等价的充要条件：对于一个括号序列，对于任意一对括号，其的可删除括号为，所有 () 满足 () 都在其的左括号左边，可删除左括号个数 * 2 $\ge i-a[i]$ （或者是等效的可以方便导出 dp 方程的充要条件）。</p>
</li>
<li><p>使用 dp 维护这个过程，取得 AC 。</p>
</li>
</ol>
<p>总之我认为，做一个 dp 题目肯定是先提出充要条件，再维护，而不是先提出 dp ，再证明。</p>
</div></details>
<p>和官方做法没啥区别。</p>
<h1 id="G-Spinning-Round"><a href="#G-Spinning-Round" class="headerlink" title="G. Spinning Round"></a>G. Spinning Round</h1><h2 id="Easy-Version"><a href="#Easy-Version" class="headerlink" title="Easy Version"></a>Easy Version</h2><p>题目链接：<a href="https://codeforces.com/contest/1987/problem/G1">https://codeforces.com/contest/1987/problem/G1</a></p>
<p>题目大意：给你一个排列，每个点可以向左边最近的比它大的点连边，或者向右边，问得到的联通图的直径的最大值是多少。</p>
<details class="toggle" ><summary class="toggle-button" style="">我的做法</summary><div class="toggle-content"><p>首先在笛卡尔树上考虑，发现每个点只可能连向自己的祖先，而且根节点一定是自环，可以知道连通的充要条件是除了根节点外的所有点不自环，而且最终一定是一棵树。</p>
<p>所以可以知道求直径等价于求新树中的直径，这样就好求多了。</p>
<p>我们考虑每条路径在这条路径的 LCA 处考虑。</p>
<p>有两种情况：</p>
<ol>
<li>来自不同的儿子。</li>
<li>来自相同的儿子。</li>
</ol>
<p>情况 $1$ 是简单的，重点是情况下，可以发现，他们都一定来自于：</p>
<p>左儿子-右儿子-右儿子-右儿子-右儿子… 这条链，或者反过来。（下面假设就在这条链上处理，反过来同理）</p>
<p>直接在这条链上找就行了，只要一条链能线性处理，则时间复杂度是 ：$O(n)$ 的。</p>
<p>注意到在这条链上选择了一深一浅两个点，浅的点一定会沿着这条链到达 LCA ，然后深的点直接连向 LCA 。（注意，这里浅的点会选择其所在路径与链交集的最深的点，深的点会选择最浅的点，下同）</p>
<p>难点在于发现这个过程可以嵌套，距离来说，如果在链上选择的两个点是相邻的，则下面的路径有可能同时来自于浅的点的子树，导致嵌套。</p>
<p><img src="1.png" alt=""></p>
<p>上面是一个例子，蓝色是新树，当然，这个例子新树的构建不止这一种，这里只是给出上面那种嵌套情况会发生的新树，显然存在以这种情况为唯一最优的树。</p>
<p>用 dp 额外维护就行了，dp[x] 表示现在有两条链，一条连向 $x$ ，一条连向 $x$ 的父亲的长度和。</p>
<p>时间复杂度：$O(n)$ 。</p>
<p>当然，你可能会问，这种讨论题你怎么保证自己能讨论对的，我经常漏情况，要怎么处理？</p>
<p>虽然我主观上认为，讨论的难度反比于你的实力，你的实力越高，你在一开始就越容易找到方便讨论的角度和做法。但是实际上我完全不知道怎么保证自己能讨论对，因为：</p>
<p><img src="2.png" alt=""></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">4e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_char_array</span><span class="params">(<span class="type">char</span> *s)</span></span>&#123;</span><br><span class="line">    <span class="type">char</span> ss[N];</span><br><span class="line">    cin &gt;&gt; ss;</span><br><span class="line">    <span class="built_in">memcpy</span>(s + <span class="number">1</span>, ss, <span class="built_in">sizeof</span>(<span class="type">char</span>) * (<span class="built_in">strlen</span>(ss) + <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n, sta[N], top, p[N];</span><br><span class="line"><span class="type">int</span> son[N][<span class="number">2</span>];</span><br><span class="line"><span class="type">char</span> ss[N];</span><br><span class="line"><span class="type">int</span> d[N], ans;</span><br><span class="line"><span class="type">int</span> dp[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">work</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> t)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> y = son[x][t];</span><br><span class="line">    <span class="type">int</span> now = son[x][t], cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> base = d[son[now][t]] + <span class="number">1</span> + cnt;</span><br><span class="line">    <span class="keyword">while</span>(son[now][t ^ <span class="number">1</span>])&#123;</span><br><span class="line">        dp[y] = <span class="built_in">max</span>(dp[y], base + d[son[now][t ^ <span class="number">1</span>]] + <span class="number">1</span>);</span><br><span class="line">        dp[y] = <span class="built_in">max</span>(dp[y], dp[son[now][t ^ <span class="number">1</span>]] + cnt + <span class="number">1</span>);</span><br><span class="line">        now = son[now][t ^ <span class="number">1</span>];</span><br><span class="line">        cnt++;</span><br><span class="line">        base = <span class="built_in">max</span>(base, d[son[now][t]] + <span class="number">1</span> + cnt);</span><br><span class="line">    &#125;</span><br><span class="line">    ans = <span class="built_in">max</span>(ans, dp[y] + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(son[x][<span class="number">0</span>]) <span class="built_in">dfs</span>(son[x][<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">if</span>(son[x][<span class="number">1</span>]) <span class="built_in">dfs</span>(son[x][<span class="number">1</span>]);</span><br><span class="line">    d[x] = <span class="built_in">max</span>(d[son[x][<span class="number">0</span>]] + <span class="number">1</span>, d[son[x][<span class="number">1</span>]] + <span class="number">1</span>);</span><br><span class="line">    ans = <span class="built_in">max</span>(ans, d[son[x][<span class="number">0</span>]] + d[son[x][<span class="number">1</span>]] + <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span>(son[x][<span class="number">0</span>]) <span class="built_in">work</span>(x, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(son[x][<span class="number">1</span>]) <span class="built_in">work</span>(x, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    ans = <span class="number">0</span>;</span><br><span class="line">    top = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        cin &gt;&gt; p[i];</span><br><span class="line">        son[i][<span class="number">0</span>] = son[i][<span class="number">1</span>] = d[i] = dp[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">get_char_array</span>(ss);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="type">int</span> pre = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(top &amp;&amp; p[sta[top]] &lt; p[i])&#123;</span><br><span class="line">            <span class="keyword">if</span>(pre) son[sta[top]][<span class="number">1</span>] = pre;</span><br><span class="line">            pre = sta[top--];</span><br><span class="line">        &#125;</span><br><span class="line">        son[i][<span class="number">0</span>] = pre;</span><br><span class="line">        sta[++top] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = top - <span class="number">1</span>; i &gt;= <span class="number">1</span>; i--) son[sta[i]][<span class="number">1</span>] = sta[i + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">dfs</span>(sta[<span class="number">1</span>]);</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    d[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>错误回顾：</p>
<p> WA 的主要原因：</p>
<ol>
<li>没有发现嵌套的情况。</li>
<li>代码写错了。</li>
</ol>
</div></details>
<h2 id="Hard-Version"><a href="#Hard-Version" class="headerlink" title="Hard Version"></a>Hard Version</h2><p>题目链接：<a href="https://codeforces.com/contest/1987/problem/G2">https://codeforces.com/contest/1987/problem/G2</a></p>
<p>题目大意：有些点会固定连向左边或者右边。</p>
<details class="toggle" ><summary class="toggle-button" style="">我的做法</summary><div class="toggle-content"><p>书接上回，证明合不合法简单的。</p>
<p>问题在于，当某些点的方向固定后，很多原来可以扔掉的劣的情况，就必须重新考虑了。</p>
<p>首先大的情况还是那么几种（依旧认为是左儿子-右儿子-右儿子-右儿子-右儿子… 这条链）：</p>
<ol>
<li>来自不同子树，不同在于，来自一个子树的最长路不一定来自儿子。</li>
<li><p>来自相同子树。</p>
<p>一样的，我们还是在链上考虑，先假设枚举一深一浅的两个点不相邻，但是有两点不同。</p>
<ol>
<li>浅的点不一定会沿着链到 LCA 。</li>
<li>浅的点所在的路径的下方不一定来自其左儿子。</li>
</ol>
<p><img src="3.png" alt=""></p>
<p>其中 1 好解决，2 不好解决，这需要我们在每个点额外维护一个东西，从这个子树出发向外连边是 L 或者是 R 的最长路径，这样就能维护不相邻的情况。</p>
<p>相邻呢？</p>
<p>还是一样，维护 dp ，而这与上面出现了相同的两个问题，用相同的办法解决就行了。</p>
</li>
</ol>
<p>时间复杂度：$O(n)$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">4e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">1e9</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_char_array</span><span class="params">(<span class="type">char</span> *s)</span></span>&#123;</span><br><span class="line">    <span class="type">char</span> ss[N];</span><br><span class="line">    cin &gt;&gt; ss;</span><br><span class="line">    <span class="built_in">memcpy</span>(s + <span class="number">1</span>, ss, <span class="built_in">sizeof</span>(<span class="type">char</span>) * (<span class="built_in">strlen</span>(ss) + <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n, sta[N], top, p[N];</span><br><span class="line"><span class="type">int</span> son[N][<span class="number">2</span>];</span><br><span class="line"><span class="type">char</span> ss[N];</span><br><span class="line"><span class="type">int</span> d[N][<span class="number">2</span>], g[N][<span class="number">2</span>], ans;</span><br><span class="line"><span class="type">int</span> dp[N];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">pd</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!t) <span class="keyword">return</span> ss[x] == <span class="string">&#x27;?&#x27;</span> || ss[x] == <span class="string">&#x27;R&#x27;</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> ss[x] == <span class="string">&#x27;?&#x27;</span> || ss[x] == <span class="string">&#x27;L&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">work</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> t)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> y = son[x][t];</span><br><span class="line">    d[x][t] = g[y][t];</span><br><span class="line">    g[x][t ^ <span class="number">1</span>] = <span class="built_in">max</span>(g[x][t ^ <span class="number">1</span>], g[y][t ^ <span class="number">1</span>]);</span><br><span class="line">    dp[y] = <span class="built_in">max</span>(d[y][<span class="number">0</span>], d[y][<span class="number">1</span>]);</span><br><span class="line">    <span class="type">int</span> now = y, cnt = <span class="number">0</span>, ncnt = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/*distance between top/or now_top*/</span></span><br><span class="line">    <span class="type">int</span> pre = d[y][t] + <span class="number">1</span>, npre = d[y][t];</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">pd</span>(y, t)) cnt = -inf, pre = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(son[now][t ^ <span class="number">1</span>])&#123;</span><br><span class="line">        now = son[now][t ^ <span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> pre1 = g[son[now][t]][t ^ <span class="number">1</span>] + <span class="number">1</span> + cnt;</span><br><span class="line">        <span class="type">int</span> npre1 = g[son[now][t]][t ^ <span class="number">1</span>] + ncnt;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">pd</span>(now, t))&#123;</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, dp[now] + cnt + <span class="number">2</span>);</span><br><span class="line">            dp[y] = <span class="built_in">max</span>(dp[y], dp[now] + ncnt + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">pd</span>(now, t ^ <span class="number">1</span>)) cnt = <span class="number">0</span>, ncnt = -inf;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(!<span class="built_in">pd</span>(now, t)) cnt ++;</span><br><span class="line">        <span class="keyword">else</span> cnt = <span class="built_in">max</span>(cnt + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        ncnt++;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">pd</span>(now, t))&#123;</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, <span class="built_in">max</span>(d[now][<span class="number">0</span>], d[now][<span class="number">1</span>]) + <span class="number">1</span> + pre);</span><br><span class="line">            dp[y] = <span class="built_in">max</span>(dp[y], <span class="built_in">max</span>(d[now][<span class="number">0</span>], d[now][<span class="number">1</span>]) + <span class="number">1</span> + npre);</span><br><span class="line">        &#125;</span><br><span class="line">        pre = <span class="built_in">max</span>(pre, d[now][t] + <span class="number">1</span> + cnt);</span><br><span class="line">        pre = <span class="built_in">max</span>(pre, pre1);</span><br><span class="line">        npre = <span class="built_in">max</span>(npre, d[now][t] + ncnt);</span><br><span class="line">        npre = <span class="built_in">max</span>(npre, npre1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> state)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(state == <span class="number">1</span> &amp;&amp; !<span class="built_in">pd</span>(x, <span class="number">0</span>)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(state == <span class="number">2</span> &amp;&amp; !<span class="built_in">pd</span>(x, <span class="number">1</span>)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(son[x][<span class="number">0</span>])&#123;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">dfs</span>(son[x][<span class="number">0</span>], state | <span class="number">1</span>)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">work</span>(x, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(son[x][<span class="number">1</span>])&#123;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">dfs</span>(son[x][<span class="number">1</span>], state | <span class="number">2</span>)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">work</span>(x, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">pd</span>(x, <span class="number">0</span>)) g[x][<span class="number">0</span>] = <span class="built_in">max</span>(g[x][<span class="number">0</span>], <span class="built_in">max</span>(d[x][<span class="number">0</span>], d[x][<span class="number">1</span>]) + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">pd</span>(x, <span class="number">1</span>)) g[x][<span class="number">1</span>] = <span class="built_in">max</span>(g[x][<span class="number">1</span>], <span class="built_in">max</span>(d[x][<span class="number">0</span>], d[x][<span class="number">1</span>]) + <span class="number">1</span>);</span><br><span class="line">    ans = <span class="built_in">max</span>(ans, d[x][<span class="number">0</span>] + d[x][<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    ans = <span class="number">0</span>;</span><br><span class="line">    top = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        cin &gt;&gt; p[i];</span><br><span class="line">        son[i][<span class="number">0</span>] = son[i][<span class="number">1</span>] = d[i][<span class="number">0</span>] = d[i][<span class="number">1</span>] = g[i][<span class="number">0</span>] = g[i][<span class="number">1</span>] = dp[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">get_char_array</span>(ss);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="type">int</span> pre = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(top &amp;&amp; p[sta[top]] &lt; p[i])&#123;</span><br><span class="line">            <span class="keyword">if</span>(pre) son[sta[top]][<span class="number">1</span>] = pre;</span><br><span class="line">            pre = sta[top--];</span><br><span class="line">        &#125;</span><br><span class="line">        son[i][<span class="number">0</span>] = pre;</span><br><span class="line">        sta[++top] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = top - <span class="number">1</span>; i &gt;= <span class="number">1</span>; i--) son[sta[i]][<span class="number">1</span>] = sta[i + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">dfs</span>(sta[<span class="number">1</span>], <span class="number">0</span>)) cout &lt;&lt; <span class="string">&quot;-1\n&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>犯错记录：</p>
<ol>
<li>代码写错了。</li>
<li>发现忘记浅点的路径可以来自其右儿子的左二子。</li>
<li>发现但是用了错误的方法解决，后面新维护了一个 dp 解决了这个问题，最后 AC 了。</li>
</ol>
<p>感觉这种题目就是很屎，很需要讨论，很看你的讨论功底的题目。</p>
</div></details>
<h2 id="别的做法"><a href="#别的做法" class="headerlink" title="别的做法"></a>别的做法</h2><details class="toggle" ><summary class="toggle-button" style="">在提交中找到的一份做法</summary><div class="toggle-content"><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//https://codeforces.com/contest/1987/submission/268586570</span></span><br><span class="line"><span class="comment">// LUOGU_RID: 163845250</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> a[<span class="number">400005</span>];</span><br><span class="line"><span class="type">char</span> s[<span class="number">400005</span>];</span><br><span class="line"><span class="type">int</span> st[<span class="number">400005</span>],top;</span><br><span class="line"><span class="type">int</span> ch[<span class="number">400005</span>][<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> dp[<span class="number">400005</span>][<span class="number">3</span>],ans;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ch[x][<span class="number">0</span>])<span class="built_in">dfs</span>(ch[x][<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">if</span>(ch[x][<span class="number">1</span>])<span class="built_in">dfs</span>(ch[x][<span class="number">1</span>]);</span><br><span class="line">    dp[x][<span class="number">0</span>]=dp[ch[x][<span class="number">0</span>]][<span class="number">0</span>];</span><br><span class="line">    dp[x][<span class="number">1</span>]=dp[ch[x][<span class="number">1</span>]][<span class="number">1</span>];</span><br><span class="line">    dp[x][<span class="number">2</span>]=dp[ch[x][<span class="number">0</span>]][<span class="number">0</span>]+dp[ch[x][<span class="number">1</span>]][<span class="number">1</span>];</span><br><span class="line">    ans=<span class="built_in">max</span>(ans,dp[ch[x][<span class="number">0</span>]][<span class="number">1</span>]+dp[ch[x][<span class="number">1</span>]][<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">if</span>(s[x]!=<span class="string">&#x27;R&#x27;</span>)&#123;</span><br><span class="line">        dp[x][<span class="number">0</span>]=<span class="built_in">max</span>(&#123;dp[x][<span class="number">0</span>],dp[ch[x][<span class="number">0</span>]][<span class="number">1</span>]+<span class="number">1</span>,dp[ch[x][<span class="number">1</span>]][<span class="number">0</span>]+<span class="number">1</span>&#125;);</span><br><span class="line">        dp[x][<span class="number">2</span>]=<span class="built_in">max</span>(&#123;dp[x][<span class="number">2</span>],dp[ch[x][<span class="number">0</span>]][<span class="number">1</span>]+dp[ch[x][<span class="number">1</span>]][<span class="number">1</span>]+<span class="number">1</span>,dp[ch[x][<span class="number">1</span>]][<span class="number">2</span>]+<span class="number">1</span>&#125;);</span><br><span class="line">        <span class="keyword">if</span>(a[x]&lt;n)ans=<span class="built_in">max</span>(&#123;ans,dp[ch[x][<span class="number">0</span>]][<span class="number">0</span>]+dp[ch[x][<span class="number">1</span>]][<span class="number">0</span>]+<span class="number">1</span>,dp[ch[x][<span class="number">0</span>]][<span class="number">2</span>]+<span class="number">1</span>&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(s[x]!=<span class="string">&#x27;L&#x27;</span>)&#123;</span><br><span class="line">        dp[x][<span class="number">1</span>]=<span class="built_in">max</span>(&#123;dp[x][<span class="number">1</span>],dp[ch[x][<span class="number">0</span>]][<span class="number">1</span>]+<span class="number">1</span>,dp[ch[x][<span class="number">1</span>]][<span class="number">0</span>]+<span class="number">1</span>&#125;);</span><br><span class="line">        dp[x][<span class="number">2</span>]=<span class="built_in">max</span>(&#123;dp[x][<span class="number">2</span>],dp[ch[x][<span class="number">0</span>]][<span class="number">0</span>]+dp[ch[x][<span class="number">1</span>]][<span class="number">0</span>]+<span class="number">1</span>,dp[ch[x][<span class="number">0</span>]][<span class="number">2</span>]+<span class="number">1</span>&#125;);</span><br><span class="line">        <span class="keyword">if</span>(a[x]&lt;n)ans=<span class="built_in">max</span>(&#123;ans,dp[ch[x][<span class="number">0</span>]][<span class="number">1</span>]+dp[ch[x][<span class="number">1</span>]][<span class="number">1</span>]+<span class="number">1</span>,dp[ch[x][<span class="number">1</span>]][<span class="number">2</span>]+<span class="number">1</span>&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,mx=<span class="number">0</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">if</span>(a[i]&gt;mx)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i]&lt;n)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s[i]==<span class="string">&#x27;L&#x27;</span>)<span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>),<span class="built_in">void</span>();</span><br><span class="line">                s[i]=<span class="string">&#x27;R&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            mx=a[i];</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=n,mx=<span class="number">0</span>;i&gt;=<span class="number">1</span>;i--)</span><br><span class="line">        <span class="keyword">if</span>(a[i]&gt;mx)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i]&lt;n)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s[i]==<span class="string">&#x27;R&#x27;</span>)<span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>),<span class="built_in">void</span>();</span><br><span class="line">                s[i]=<span class="string">&#x27;L&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            mx=a[i];</span><br><span class="line">        &#125;</span><br><span class="line">    top=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)ch[i][<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="type">int</span> lst=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(top&amp;&amp;a[st[top]]&lt;a[i])lst=st[top--];</span><br><span class="line">        ch[st[top]][<span class="number">1</span>]=i;</span><br><span class="line">        ch[i][<span class="number">0</span>]=lst;</span><br><span class="line">        st[++top]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    ans=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">dfs</span>(ch[<span class="number">0</span>][<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> _;<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;_);</span><br><span class="line">    <span class="keyword">while</span>(_--)<span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>思考一个事情，我的做法相当于是直接在路径的 LCA 上考虑，这样考虑的好处是：</p>
<ol>
<li>直观，很容易想到这个做法，而且明确知道自己只需要讨论什么东西就足以完成此题。</li>
<li>可实现，在讨论完后所需要维护的东西一般都是可以简单维护的。</li>
</ol>
<p>但是坏处也是显然的：</p>
<p>讨论以后得到的每个部分相对独立，很难整合起来，因此码量比较大。</p>
<p>但是如果我们换个角度看，从下往上考虑，即考虑两条路径什么时候交到一起。</p>
<p>依旧是两种情况：</p>
<ol>
<li>两条路径，一条往左，一条往右，交到一个点上。</li>
<li>两条往同个方向，交到一个点上。</li>
</ol>
<p>注意到这个路径往左往右，也就是这个子树往外的第一条边往左往右，在我的做法中也有类似的定义：$g[x][0/1]$ 表示 $x$ 子树内往外的第一条边是什么方向。</p>
<p>顺着这个思路想，那怎么维护 $2$ 呢？注意到，肯定会有一个时间点，这两条路径一定会从 $x$ 子树的左儿子和右儿子内出来，其中左儿子往左，右儿子往右，所以维护 $g[x][2]$ 表示子树内有两条不相交的路径，一条往左，一条往右的长度。</p>
<p>因此就得到了上面那个做法 ，$g$ 也就是上面的 $dp$ 。</p>
<p>实际上，这个做法所维护的 $g[x][2]$，放到我那个做法中，就是把来自同一子树的两条链在较浅的那个点中产生并一路维护上来，相当于直接在遍历树的过程完成了转移，而不是单独再开一个部分计算答案。同时这个单条链的维护的过程和嵌套转移的过程是一样的，可以直接用一个转移过程，所以就可以少处理很多东西了。</p>
<p>这个思路相较于我的思路，明显的优势就是考虑主体变少了，从一条条链变成了一个个点，自然要好写好想（这里的好想指的是在初始方向正确的情况下，后面的细节都很简单，不是说这个思路好想）。</p>
<p>反思一下，虽然说做法是同构的，但是从这个做法想出那个做法，我感觉要难于直接换个角度考虑。就像很多题目直接考虑考虑不出来，但是换个角度就能考虑出来，做法本质就在那，都是一样的，但是换个角度难度就能大幅减少。</p>
<p>因此，考虑简化做法的时候不要只寄希望于优化当前的做法，因为将其直接优化到更加简洁的做法或许难度很大，有时候可以尝试换个角度观察这个做法，或许能很轻松的得到一个简洁得多的做法。</p>
</div></details>
<p>官方做法没看懂，感觉思考起来不太自然，而且看起来实现也很麻烦，咕了。不过能不在笛卡尔树上完成这道题目确实厉害，我只能说。</p>
<h1 id="比赛小结"><a href="#比赛小结" class="headerlink" title="比赛小结"></a>比赛小结</h1><p>评价一下，打的一坨，还好最后 G1 撞对了，否则坠机了。</p>
<p>比赛小结已经写在了 $F$ 的做法中。</p>
<p>总结下来就一句话 ：</p>
<p><strong>模拟赛</strong>时的题目该证明的就要给出完整的证明，不要搞一些自欺欺人的事情，不要过度的关注排名和 rating 。（当然时间不够的时候猜猜结论也是可以的，猜结论也是能力的一环，但是时间充足的时候或者中期的题目就别猜了，要给出完整的证明）</p>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
  </entry>
  <entry>
    <title>ECNU 2023.8 B. Bare Minimum Difference</title>
    <url>/2023/09/02/ECNU-2023-8-B-Bare-Minimum-Difference/</url>
    <content><![CDATA[<p>题目链接：<a href="https://acm.ecnu.edu.cn/contest/695/problem/B/">https://acm.ecnu.edu.cn/contest/695/problem/B/</a></p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>题弱智但我也弱智，看错题了，以为要求方案数，乐，而且还以为会有负数。</p>
<p>我的做法是枚举 $n^2$ 个下界，然后 DP 维护最小上界，时间复杂度：$O(n^4)$。</p>
<p>然而看了题解后发现如果二分上界的话实际上可以配合滑动窗口之类的东西做到 $O(n)$ check 。</p>
<p>所以最优秀的时间复杂度是：$o(n^3\log{n})$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 110</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf=<span class="number">999999999</span>;</span><br><span class="line"><span class="type">int</span> a[N],n,dp[N],b[N],m;</span><br><span class="line"><span class="type">int</span> ans=inf;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> type=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> limit)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)b[i]+=b[i<span class="number">-1</span>];</span><br><span class="line">    <span class="built_in">memset</span>(dp,<span class="number">20</span>,<span class="built_in">sizeof</span>(dp));</span><br><span class="line">    dp[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">            <span class="comment">// if(type)printf(&quot;OK %d\n&quot;,limit);</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;i;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(b[i]-b[j]&lt;limit)<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span>(dp[i]&gt;<span class="built_in">max</span>(dp[j],b[i]-b[j]))dp[i]=<span class="built_in">max</span>(b[i]-b[j],dp[j]);</span><br><span class="line">            <span class="comment">// if(type==1 &amp;&amp; i==3 &amp;&amp; j==0)printf(&quot;%d\n&quot;,dp[i]);</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// if(type==1)printf(&quot;%d\n&quot;,dp[m]);</span></span><br><span class="line">    <span class="keyword">return</span> dp[m];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i;j&lt;=n;j++)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// type=0;</span></span><br><span class="line"></span><br><span class="line">            sum+=a[j];<span class="keyword">if</span>(i==<span class="number">1</span> &amp;&amp; j==n)<span class="keyword">continue</span>;</span><br><span class="line">            m=i<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;i;k++)b[k]=a[k];</span><br><span class="line">            <span class="type">int</span> now=<span class="built_in">solve</span>(sum);</span><br><span class="line">            m=n-j;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=j+<span class="number">1</span>;k&lt;=n;k++)b[k-j]=a[k];</span><br><span class="line"></span><br><span class="line">            <span class="comment">// if(i==1 &amp;&amp; j==3)type=1;</span></span><br><span class="line">            <span class="comment">// else type=0;</span></span><br><span class="line"></span><br><span class="line">            now=<span class="built_in">max</span>(<span class="built_in">solve</span>(sum),now);</span><br><span class="line">            <span class="comment">// if(i==1 &amp;&amp; j==3)printf(&quot;%d\n&quot;,now);</span></span><br><span class="line">            ans=<span class="built_in">min</span>(now-sum,ans);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></details>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title>Game of Connect(Shannon&#39;s Switching Game)</title>
    <url>/2024/01/31/Game-of-Connect-Shannon-s-Switching-Game/</url>
    <content><![CDATA[<p>题目链接：<a href="https://onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=3792">https://onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=3792</a></p>
<p>题目大意：给一张图，先手先选定两个不同的点 $A,B$ ，然后开始游戏，每轮先手指定一个未固定的边删掉，后手指定一个没被固定的边固定，如果 $A,B$ 最后联通，则后手获胜，否则先手获胜，问后手是否必胜。</p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>这道题目非常经典，又叫：Shannon’s Switching Game。</p>
<p>又有个变体问题：没有指定 $A,B$ 了，后手的目的是最后要是个联通图。</p>
<p>这两个问题的后手必胜的充要条件是：图中有两个交集为 $0$ 的生成树。</p>
<p>对于变体问题的充分性是比较好证明的，采用归纳+缩边的方法就行，详情请看：<a href="https://zhuanlan.zhihu.com/p/33862629">https://zhuanlan.zhihu.com/p/33862629</a> 。</p>
<p>也可以用拟阵中的基进行证明，这里不再赘述。</p>
<p>但是必要性我不会证明，所以这道题目在此留一个坑，就此作罢。</p>
<h6 id="坑"><a href="#坑" class="headerlink" title="坑"></a>坑</h6><p>学会 Shannon’s Switching Game 。</p>
<p>知道这个判定条件后后面就好搞了，怎么判定呢？</p>
<p>要有个生成树，且在这个生成树外还有一个生成树，前者是图拟阵，后者是图拟阵的对偶拟阵，所以就是图拟阵与图拟阵的对偶拟阵的拟阵交。</p>
<p>时间复杂度：$O(Tm^3)$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">没有，不会证明，懒得写代码了。</span><br></pre></td></tr></table></figure>
</div></details>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>拟阵</tag>
      </tags>
  </entry>
  <entry>
    <title>Exact Subsequences</title>
    <url>/2024/06/26/Exact-Subsequences/</url>
    <content><![CDATA[<p>题目链接：<a href="https://qoj.ac/problem/6351">https://qoj.ac/problem/6351</a></p>
<p>题目大意：问你内恰有 $n$ 个本质不同子序列的且字典序排名为 $k$ 的 $01$ 串是啥。</p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>非常 amazing 的一道题目。</p>
<p>首先想想对于一个 $01$ 串怎么求本质不同的 $01$ 串个数，因为我记得之前队友做过一道这样的题目，做法是万能欧几里得。</p>
<p>设 $f_0$ 表示添加 $0$ 后变成新的子序列的串，$f_1$ 同理。</p>
<p>初始时 $f_0=f_1=1$ ，可以发现，转移就是：</p>
<p>$f_0=f_0+f_1$ （添加 $1$）</p>
<p>$f_1=f_0+f_1$ （添加 $0$）</p>
<p>而子序列个数恰好等于 $f_0+f_1-2$ 。</p>
<p>可以发现，这个过程是 gcd 的逆过程（把取模的过程看成一个个减的过程），因此顺过来看，$f_0$ 必须满足和 $n+2$ 互质，即任意一个本质不同字串个数等于 $n+2$ 的串对应一个与 $n+2$ 互素的数字，而 $01$ 串其实就是其 gcd 的过程。（因此无解就是 $&gt;\phi(n+2)$）</p>
<p>因此现在就是要找过程字典序第 $k$ 小的与 $n+2$ 互素的 $x$ 。</p>
<p>这怎么找呢？设数字为 $(x,y=n-x)$ （为了方便，后面都认为 $n=n+2$ ），不妨考虑逆着求本质不同子序列个数，这样来做一一对应，其过程就等价于这样的字符串：</p>
<p>从左到右，出现 $0$ 就 ：$y-x$ ，出现 $1$ 就 $x-y$ ，做完后 $x=y=1$ 。</p>
<p>注：这同时也证明了，对于一个 $01$ 串，拿着 $(1,1)$ 正着跑和倒着跑最后得到的 $x+y$ 的值是一样的。同时，在后面会频繁出现拿着 $(x,y)$ 跑一遍字符串这种话，一般情况下，如果 $x,y\le 1$ ，做的是加法的那种跑，否则是减法的那种跑。</p>
<p>这样就可以二分了，由于我们知道 $gcd$ 的过程中，$01$ 转化不会超过 $O(\log)$ 次，所以总时间复杂度为 $O(\log^2)$ 的。</p>
<p>由于具体过程中并不知道二分的上界，我选择倍增。</p>
<p>倍增是这样子倍增：$x’=ax-bn,y’=-cx+dn$ ，其中要求 $x’\ge 0, y’ \ge 0,x\ge 1$ ，从而得到初值 $x$ 的上界和下界，然后上界等于下界时，得到最终答案 $x$ 。</p>
<p>当我们想要确定 $0$ 的数量时，我们就设 $y’’=y’-kx’$ ，可以发现如果 $(x’,y’)$ 对应的区间为 $[l,r]$ ，那么 $(x’,y’’)$ 对应的区间为 $[l,r’]$ ，只要确保其中的数字够 $k$ 就行了。</p>
<p>$1$ 的数量类似，不过我们需要先计算出其是这个区间中字典序排名第几大的，相当于取个反。</p>
<p>感觉还是蛮有细节需要证明的，有些东西不会证明就直接判掉了。</p>
<p>细节 1 ：$\exist x\in[l,r]:gcd(x,n)=1,$ 且 $(x,n-x)$ 进行当前跑出来的 $01$ 串能够变成 $(1,0)/(0,1)/(1,1)$ 的必要条件是 $l=r$ 或者 $l=n-1,r=n$ 。</p>
<p><details class="toggle" ><summary class="toggle-button" style="">证明</summary><div class="toggle-content"><p>$(1,1)$ ：</p></p>
<p>$ax-bn\ge0, -cx+dn\ge0$ 在取到特解 $x’$ 时满足：$ax-bn=1, -cx+dn=1$ 。</p>
<p>可以发现，上界 $\ge x’$ 。</p>
<p>$-c(x’+1)+dn=1-c$ ，当 $c&gt;1$ 时上界 $=x’$ ，否则此时 $c=1$，意味着 $d=1$ ，所以上界为 $n$ ，$x’=n-1$ ，又 $n\ge 3$ ，所以至少有一个 $1$ ，由下面的讨论知道 $l=n-1,r=n$ 。</p>
<p>$a(x’-1)-bn=1-a$ ，当 $a&gt;1$ 时下界 $&gt;x’-1$ 。</p>
<p>$a=1$ 意味着 $b=0$ ，所以过程是 $00000…$ ，这个时候可以发现下界为 $0$ ，故 $x’=1$ ，但又有额外要求：$x\ge 1$ ，所以此时区间中只有一个数字。</p>
<p>剩下的两个状态一定会经过 $(1,1)$ ，证毕。</p>
</div></details>
<p>细节 2 ：过程中的 $a,b,c,d$ 会不会爆 long long （一旦区间中只有一个数字就退出）。</p>
<details class="toggle" ><summary class="toggle-button" style="">证明</summary><div class="toggle-content"><p>不难发现，我们可以将倍增过程中的减号全部变成加号，状态改成 $(ax+bn,cx+dn)$ ，不会影响 $a,b,c,d$ ，这样我们只要拿着 $(1,1)/(1,0)$ 倒着跑一遍就可以得到 $a,b,c,d$ 的精确值。</p>
<p>首先倍增过程中一致保持着 $[l,r]$ 中是有合法解的，因此区间中一旦只有两个数字，分为两种情况讨论：</p>
<ol>
<li>此时这个唯一的合法解超过 $(1,1)$ ，即恰好或者还没到，因此绝对 $\ge (1,1)$ 。注 ：我们认为 $(a,b)\ge(c,d)$ 等价于 $a\ge c,b\ge d$ ，直接拿着 $(1,1)$ 倒着跑，就可以得到范围 $\le n$ ，不会爆。</li>
<li><p>$(0,1)/(1,0)$ ，以 $(1,0)$ 举例，初始区间为 $[1,n]$ ，因此过程是非空的，又由于是区间长度一为 $1$ 我们就退出，我们先假设上一步中的区间不是 $[n-1,n]$ ，那么过程最后一个字符一定为 $0$ ，扔掉这个字符后的结果为 $(1,1)$ ，因此我们从左边拿着 $(1,1)$ 走完这个字符串得到的结果 $\le 2n$ 。</p>
<p>如果是 $[n-1,n]$，那么 $a=n,b=n-1,c=1,d=1$ ，在倍增一次后变成：$a=n,b=n-1,c=n+1,d=n$ ，直接退出，因此，范围还是在 $O(n)$ 的。</p>
</li>
</ol>
<p>综上，范围是在 $O(n)$ 的，不会爆 long long 。</p>
</div></details>
<p>其余小的细节就不再赘述了。</p>
<p>最终时间复杂度：$O(T\sqrt{n}\log^2n)$ 。（还要算区间中与 $n$ 互素的数字个数）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;LL, LL&gt; PLL;</span><br><span class="line">PLL <span class="keyword">operator</span>+(PLL x, PLL y)&#123;<span class="keyword">return</span> &#123;x.first + y.first, x.second + y.second&#125;;&#125;</span><br><span class="line">PLL <span class="keyword">operator</span>-(PLL x, PLL y)&#123;<span class="keyword">return</span> &#123;x.first - y.first, x.second - y.second&#125;;&#125;</span><br><span class="line">PLL <span class="keyword">operator</span>*(PLL x, LL y)&#123;<span class="keyword">return</span> &#123;x.first * y, x.second * y&#125;;&#125;</span><br><span class="line">PLL <span class="keyword">operator</span>*(LL x, PLL y)&#123;<span class="keyword">return</span> y * x;&#125;</span><br><span class="line"><span class="comment">//x.first * t + y.second * n</span></span><br><span class="line">LL n, K;</span><br><span class="line"><span class="function">PLL <span class="title">getrange</span><span class="params">(PLL l, PLL r)</span></span>&#123;<span class="keyword">return</span> &#123;<span class="built_in">max</span>((l.first - <span class="number">1</span> - l.second * n) / l.first, <span class="number">1ll</span>), - r.second * n / r.first&#125;;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printans</span><span class="params">(LL x)</span></span>&#123;</span><br><span class="line">    vector&lt;PLL&gt; ans;</span><br><span class="line">    LL y = n - x;</span><br><span class="line">    <span class="keyword">while</span>(x &gt; <span class="number">1</span> || y &gt; <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">assert</span>(x &amp;&amp; y);</span><br><span class="line">        <span class="keyword">if</span>(x &gt; y)&#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(&#123;<span class="number">1ll</span>, x / y&#125;);</span><br><span class="line">            x %= y;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(&#123;<span class="number">0ll</span>, y / x&#125;);</span><br><span class="line">            y %= x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ans.<span class="built_in">back</span>().second--;</span><br><span class="line">    cout &lt;&lt; ans.<span class="built_in">size</span>() &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; (*ans.<span class="built_in">begin</span>()).first &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> [d, cnt] : ans) cout &lt;&lt; cnt &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">vector&lt;LL&gt; p;</span><br><span class="line">vector&lt;LL&gt; fac;</span><br><span class="line"><span class="function">LL <span class="title">query</span><span class="params">(LL x)</span></span>&#123;</span><br><span class="line">    LL ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; fac.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(__builtin_popcount(i) &amp; <span class="number">1</span>) ans -= x / fac[i];</span><br><span class="line">        <span class="keyword">else</span> ans += x / fac[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">query</span><span class="params">(LL l, LL r)</span></span>&#123;<span class="keyword">return</span> <span class="built_in">query</span>(r) - <span class="built_in">query</span>(l - <span class="number">1</span>);&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    p.<span class="built_in">clear</span>();</span><br><span class="line">    fac.<span class="built_in">clear</span>();</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; K;</span><br><span class="line">    n += <span class="number">2</span>;</span><br><span class="line">    &#123;</span><br><span class="line">        LL now = n;</span><br><span class="line">        <span class="keyword">for</span>(LL i = <span class="number">2</span>; i * i &lt;= now; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(now % i != <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            p.<span class="built_in">push_back</span>(i);</span><br><span class="line">            <span class="keyword">while</span>(now % i == <span class="number">0</span>) now /= i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(now &gt; <span class="number">1ll</span>) p.<span class="built_in">push_back</span>(now);</span><br><span class="line">        fac.<span class="built_in">push_back</span>(<span class="number">1ll</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> x : p)&#123;</span><br><span class="line">            <span class="type">int</span> pre = fac.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; pre; i++) fac.<span class="built_in">push_back</span>(fac[i] * x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">query</span>(<span class="number">1</span>, n) &lt; K)&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;-1\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    PLL left, right;</span><br><span class="line">    left = &#123;<span class="number">1ll</span>, <span class="number">0ll</span>&#125;;</span><br><span class="line">    right = &#123;<span class="number">-1ll</span>, <span class="number">1ll</span>&#125;;</span><br><span class="line">    <span class="type">int</span> type = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">auto</span> [l1, r1] = <span class="built_in">getrange</span>(left, right);</span><br><span class="line">        <span class="keyword">if</span>(l1 == r1) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span>(!type)&#123;<span class="comment">//determine 0 cnt</span></span><br><span class="line">            LL k;</span><br><span class="line">            <span class="keyword">for</span>(LL k = <span class="number">1ll</span>;;k *= <span class="number">2</span>)&#123;</span><br><span class="line">                PLL nex = right - left * k;</span><br><span class="line">                <span class="keyword">auto</span> [l2, r2] = <span class="built_in">getrange</span>(left, nex);</span><br><span class="line">                <span class="keyword">if</span>(l2 &gt; r2 || <span class="built_in">query</span>(l1, r2) &lt; K) <span class="keyword">break</span>;</span><br><span class="line">                right = nex;</span><br><span class="line">                <span class="keyword">if</span>(l2 == r2) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(; k; k /= <span class="number">2</span>)&#123;</span><br><span class="line">                PLL nex = right - left * k;</span><br><span class="line">                <span class="keyword">auto</span> [l2, r2] = <span class="built_in">getrange</span>(left, nex);</span><br><span class="line">                <span class="keyword">if</span>(l2 &gt; r2 || <span class="built_in">query</span>(l1, r2) &lt; K) <span class="keyword">continue</span>;</span><br><span class="line">                right = nex;</span><br><span class="line">                <span class="keyword">if</span>(l2 == r2) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            LL k;</span><br><span class="line">            <span class="keyword">for</span>(k = <span class="number">1ll</span>;;k *= <span class="number">2</span>)&#123;</span><br><span class="line">                PLL nex = left - right * k;</span><br><span class="line">                <span class="keyword">auto</span> [l2, r2] = <span class="built_in">getrange</span>(nex, right);</span><br><span class="line">                <span class="keyword">if</span>(l2 &gt; r2 || <span class="built_in">query</span>(l2, r1) &lt; K) <span class="keyword">break</span>;</span><br><span class="line">                left = nex;</span><br><span class="line">                <span class="keyword">if</span>(l2 == r2) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(; k; k /= <span class="number">2</span>)&#123;</span><br><span class="line">                PLL nex = left - right * k;</span><br><span class="line">                <span class="keyword">auto</span> [l2, r2] = <span class="built_in">getrange</span>(nex, right);</span><br><span class="line">                <span class="keyword">if</span>(l2 &gt; r2 || <span class="built_in">query</span>(l2, r1) &lt; K) <span class="keyword">continue</span>;</span><br><span class="line">                left = nex;</span><br><span class="line">                <span class="keyword">if</span>(l2 == r2) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">auto</span> [l2, r2] = <span class="built_in">getrange</span>(left, right);</span><br><span class="line">        K = <span class="built_in">query</span>(l2, r2) - K + <span class="number">1</span>;</span><br><span class="line">        type ^= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printans</span>(<span class="built_in">getrange</span>(left, right).first);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>感觉我的做法有点麻烦了，看看正解。</p></div></details>
<details class="toggle" ><summary class="toggle-button" style="">官方做法</summary><div class="toggle-content"><p>在除了实现以外的部分基本一样，但最后还是唐了，终究逃不出唐的魔爪。</p>
<p>注意到一个事情，我们在二分 $0$ 的个数的时候，上界向下，这启示我们 $x$ 越小字典序越小。</p>
<p>$1$ 的个数的时候，下界网上，这启示我们 $x$ 越大字典序越大。</p>
<p>这两件事综合起来就可以证明：$x$ 的大小等价于字典序的大小。</p>
<p>事实上，也可以直接去证明，对于 $(x_1,y_1)/(x_2,y_2)\to (1,1)$ 的过程，如果 $x_1<x_2,y_1>y_2$ ，可以用归纳法加一些小讨论证明前者的过程要 $&lt;$ 后者的过程。（注意：$gcd(x_1,y_1)=1,gcd(x_2,y_2)=1$ ）</p>
<p>然后直接二分就行了。</p>
<p>完了，感觉自己唐完了。我记得我有过这个想法，但是在发现二分 $1$ 的时候 $1$ 下界是往上走时就觉得错完了，但是忘记下界往上走对应 $1$ 的个数更多，对应字典序越大，实际上是对完了，结果就是我唐完了。</p>
<p>真是艹了，这样确实好写多了，不过我也懒得再写一遍了。</p>
<p>时间复杂度 ：$O(T\sqrt{n}\log{n})$ 。</p>
</div></details>]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>gcd</tag>
      </tags>
  </entry>
  <entry>
    <title>Graffiti</title>
    <url>/2024/02/05/Graffiti/</url>
    <content><![CDATA[<p>题目链接：<a href="https://contest.ucup.ac/contest/1511/problem/8213">https://contest.ucup.ac/contest/1511/problem/8213</a></p>
<p>题目大意：</p>
<p>给一个树，给一个长度不超过 $3$ 的串，然后问：每个点填一个字母，最大化满足经过的点构成的字符串等于给定串的有向路径数量，输出数量。</p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>显然只有长度为 $3$ 的串需要思考，当只有两个不同的字母的时候，会发现如果使用 $dp[x][0/1]$ 的 dp 方式，会无法处理从 $x$ 的儿子的儿子，到 $x$ 的路径，所以我们需要再多添加一维，表示父亲填的字母，相当于提前知道了父亲填的字母，然后父亲在转移的时候直接调用就行了。</p>
<p>但是会发现我们仍然无法处理三个字母都不同的情况，因为儿子有三种选择。</p>
<p>但是注意到第一个字母和第三个字母并没有本质区别，将一个子树的第一个字母和第三个字母全部颠倒不会影响这个子树的贡献，所以也就只需要知道儿子应该选一/三字母或者第二个字母就行，排个序枚举一下就行了。</p>
<p>时间复杂度：$O(n\log{n})$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="keyword">typedef</span> vector&lt;<span class="type">int</span>&gt; VI;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">3e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> NN=<span class="number">6e5</span>+<span class="number">5</span>;</span><br><span class="line">LL dp[N][<span class="number">4</span>][<span class="number">4</span>];</span><br><span class="line"><span class="type">int</span> ss[<span class="number">4</span>],n,m,C;<span class="type">char</span> st[<span class="number">10</span>];</span><br><span class="line"><span class="type">int</span> vis[<span class="number">300</span>];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> y,next;</span><br><span class="line">&#125;a[NN];<span class="type">int</span> len,las[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ins</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;a[++len]=&#123;y,las[x]&#125;;las[x]=len;&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">pd</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(m==<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> (x==ss[<span class="number">1</span>] &amp;&amp; y==ss[<span class="number">2</span>]) || (x==ss[<span class="number">2</span>] &amp;&amp; y==ss[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">pd</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> z)</span></span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(m==<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">return</span> (x==ss[<span class="number">1</span>] &amp;&amp; y==ss[<span class="number">2</span>] &amp;&amp; z==ss[<span class="number">3</span>]) || (x==ss[<span class="number">3</span>] &amp;&amp; y==ss[<span class="number">2</span>] &amp;&amp; z==ss[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">count</span><span class="params">(LL c1,LL c2,<span class="type">int</span> fc)</span></span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(C&gt;<span class="number">1</span>);</span><br><span class="line">    LL tmp=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(C==<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">pd</span>(<span class="number">1</span>,ss[<span class="number">2</span>],<span class="number">1</span>)==<span class="number">1</span>)tmp+=c1*(c1<span class="number">-1</span>)/<span class="number">2</span>;</span><br><span class="line">        <span class="comment">// if(pd(2,ss[2],2)==1)tmp+=c2*(c2-1)/2; impossible</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">pd</span>(<span class="number">1</span>,ss[<span class="number">2</span>],<span class="number">2</span>)==<span class="number">1</span>)tmp+=c1*c2;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">pd</span>(<span class="number">1</span>,ss[<span class="number">2</span>],fc)==<span class="number">1</span>)tmp+=c1;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">pd</span>(<span class="number">2</span>,ss[<span class="number">2</span>],fc))tmp+=c2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(fc==<span class="number">1</span> || fc==<span class="number">3</span>)&#123;</span><br><span class="line">            LL c3=(c1+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">            tmp+=c3*(c1-c3)+c3;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            LL c3=c1/<span class="number">2</span>;</span><br><span class="line">            tmp+=c3*(c1-c3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line">LL sta[N];<span class="type">int</span> top;</span><br><span class="line">VI son[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> fa)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=las[x];k;k=a[k].next)&#123;</span><br><span class="line">        <span class="type">int</span> y=a[k].y;<span class="keyword">if</span>(y==fa)<span class="keyword">continue</span>;</span><br><span class="line">        son[x].<span class="built_in">push_back</span>(y);</span><br><span class="line">        <span class="built_in">dfs</span>(y,x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(m==<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=C;i++)&#123;</span><br><span class="line">            LL now=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> y:son[x])&#123;</span><br><span class="line">                LL tmp=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=C;j++)&#123;</span><br><span class="line">                    tmp=<span class="built_in">max</span>(dp[y][i][j],tmp);</span><br><span class="line">                &#125;</span><br><span class="line">                now+=tmp;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> fc=<span class="number">1</span>;fc&lt;=C;fc++)&#123;<span class="comment">//father color</span></span><br><span class="line">                <span class="keyword">if</span>(x!=<span class="number">1</span> &amp;&amp; <span class="built_in">pd</span>(i,fc))dp[x][fc][i]=now+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> dp[x][fc][i]=now;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;<span class="comment">//m=3</span></span><br><span class="line">        <span class="built_in">assert</span>(m==<span class="number">3</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=C;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i!=ss[<span class="number">2</span>])&#123;<span class="comment">//only up</span></span><br><span class="line">                LL now=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">auto</span> y:son[x])&#123;</span><br><span class="line">                    LL tmp=<span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=C;j++)&#123;</span><br><span class="line">                        tmp=<span class="built_in">max</span>(tmp,dp[y][i][j]);</span><br><span class="line">                    &#125;</span><br><span class="line">                    now+=tmp;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> fc=<span class="number">1</span>;fc&lt;=C;fc++)&#123;<span class="comment">//father color</span></span><br><span class="line">                    dp[x][fc][i]=now;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(C==<span class="number">1</span>)&#123;</span><br><span class="line">                LL siz=son[x].<span class="built_in">size</span>();</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">auto</span> y:son[x]) dp[x][<span class="number">1</span>][<span class="number">1</span>]+=dp[y][<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">                dp[x][<span class="number">1</span>][<span class="number">1</span>]+=siz*(siz<span class="number">-1</span>)/<span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span>(x!=<span class="number">1</span>)dp[x][<span class="number">1</span>][<span class="number">1</span>]+=siz;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                top=<span class="number">0</span>;</span><br><span class="line">                LL ini=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">auto</span> y:son[x])&#123;</span><br><span class="line">                    sta[++top]=dp[y][i][<span class="number">2</span>]-dp[y][i][<span class="number">1</span>];</span><br><span class="line">                    <span class="built_in">assert</span>(C!=<span class="number">3</span> || dp[y][i][<span class="number">1</span>]==dp[y][i][<span class="number">3</span>]);</span><br><span class="line">                    ini+=dp[y][i][<span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">sort</span>(sta+<span class="number">1</span>,sta+top+<span class="number">1</span>,[](LL x,LL y)&#123;<span class="keyword">return</span> x&gt;y;&#125;);</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> fc=<span class="number">1</span>;fc&lt;=C;fc++)&#123;</span><br><span class="line">                    LL now=<span class="number">0</span>,tmp=ini;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=top;j++)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(x!=<span class="number">1</span>)now=<span class="built_in">max</span>( now , tmp+<span class="built_in">count</span>(top-j,j,fc) );</span><br><span class="line">                        <span class="keyword">else</span> now=<span class="built_in">max</span>( now , tmp+<span class="built_in">count</span>(top-j,j,<span class="number">0</span>) );</span><br><span class="line">                        <span class="keyword">if</span>(j!=top) tmp+=sta[j+<span class="number">1</span>];</span><br><span class="line">                    &#125;</span><br><span class="line">                    dp[x][fc][i]=now;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">work</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,st+<span class="number">1</span>);m=<span class="built_in">strlen</span>(st+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="type">int</span> x,y;<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;x,&amp;y);</span><br><span class="line">        <span class="built_in">ins</span>(x,y);<span class="built_in">ins</span>(y,x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!vis[st[i]])vis[st[i]]=++C;</span><br><span class="line">        ss[i]=vis[st[i]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(m==<span class="number">1</span>)<span class="keyword">return</span> n;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    LL ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=C;i++)ans=<span class="built_in">max</span>(ans,dp[<span class="number">1</span>][<span class="number">1</span>][i]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ss[<span class="number">1</span>]==ss[m])ans*=<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,<span class="built_in">work</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>题外话：<br>其实这个 dp 设计非常有意思。</p>
<ol>
<li><p>从树的角度考虑，我们其实有另外一种设计思路是，多添加几维表示这个节点的每个颜色的儿子选了多少个，但是可以发现这种设计是显然会超时的。</p>
<p>这是因为一个节点的儿子数量可以很多，而父亲至多一个，因此，我们更希望通过父亲解决问题，而不是通过儿子。</p>
<p>一个类似的例子是：一个数据结构题目，每次能够给一个点周围的所有点的点权加上 $c$ ，做法为：父亲的点权直接加上，儿子的点权加在自己身上，等查询一个点点权的时候让他自己来问父亲。</p>
<p>当然，上面那个例子还有个单 log 做法，就是利用 BFS 序+线段树，因为 BFS 序上儿子的编号是连续的。</p>
</li>
<li><p>从预知未来的角度考虑：</p>
<p>每个点先预知未来的一些信息，在这道题目上的作用是，让我们能够处理了一些本来无法处理的信息。</p>
<p>当然也可以有其他作用，举个减少时间复杂度的例子（某一年提高组初赛的题目，忘记是哪一年了）：</p>
<h6 id="坑"><a href="#坑" class="headerlink" title="坑"></a>坑</h6><p>这道题目到底是哪一年的。</p>
<p>求长度恰好为 $k$ 且相邻数字的异或的和最大的子序列，输出最大的和，值域 $2^{8}-1$。</p>
<p>做法为 $dp[i][x][y]$ ，$i$ 是已经有几个数字，$x$ 表示子序列目前最后一个数字的上 $4$ 位，$y$ 表示我们期望下一个数字的下 $4$ 位是多少。</p>
<p>这样就能在 $O(n^2*2^4)$ 的复杂度处理这个问题，相较于 $dp[i][x]$ 少了 $2^4$ 。</p>
</li>
</ol>
</div></details>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>树形DP</tag>
      </tags>
  </entry>
  <entry>
    <title>ECNU 2023.8 D. Mutton string</title>
    <url>/2023/09/02/ECNU-2023-8-D-Mutton-string/</url>
    <content><![CDATA[<p>题目链接：<a href="https://acm.ecnu.edu.cn/contest/695/problem/D/">https://acm.ecnu.edu.cn/contest/695/problem/D/</a></p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>引理 $1$ ：优先加入符合要求的最长子串。（把后一个子串的前缀拿过来显然不劣）</p>
<p>到这里其实就差不多了，子串显然能够想到那个算法：SAM 。</p>
<p>如果给你一个字符串，怎么求出其的最小操作数呢？显然是拉上 SAM 上跑一遍，现在要我们确定一个最小操作数为 $x$ 的字符串，显然也是在 SAM 上 DP 一下就行了。</p>
<p>如果没有字典序的约束，这道题目就是：$dp[i][j]<a href="bool">k</a>$ 表示是否存在一个方案满足终止位置 SAM 上的第 $i$ 个节点，目前长度为 $j$ ，已经有了 $k$ 段，然后直接转移就行了。</p>
<p>但是因为我赛时分析错了复杂度，以为是四次方的，就没有往下接着想了，但实际上是三次方的。</p>
<p>显然时间复杂度是：$O(26nmx)$ ，而且如果实现的足够精妙能够到达 $O(nmx)$ ，因为考虑固定 $j,k$ ，这样对于 $i$ 的转移分两种，跑存在的边（ SAM 边的数量级是 $O(n)$ 的），跑不存在的边（可以状压，也可以调整搜索顺序，优先跑 $26$ ，然后去找可行且不能到达的状态（因此需要提前把可行的状态记录一下））。</p>
<p>但是如果要求字典序最小的字符串呢？</p>
<p>显然，我们必须要查询对于一个前缀，是否存在满足要求的答案，为此，我们不妨考虑整个字符串是倒着加子串的，然后把 $A$ 翻转，反着跑一遍 $DP$ ，然后枚举刚好跑到前缀时位于哪个点，然后继续扔到后缀数组上跑，看看能否凑出一个 $X$ 段出来。</p>
<p>时间复杂度：$O(26nmx)$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 310</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> M 160</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">26</span>],len,fa;</span><br><span class="line">&#125;tr[N];<span class="type">int</span> tot,last;</span><br><span class="line"><span class="type">char</span> st[M];<span class="type">int</span> n;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> c)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> p=last;<span class="type">int</span> np=last=++tot;</span><br><span class="line">    tr[np].len=tr[p].len+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(;p &amp;&amp; !tr[p].a[c];p=tr[p].fa)tr[p].a[c]=np;</span><br><span class="line">    <span class="keyword">if</span>(!p)tr[np].fa=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="type">int</span> q=tr[p].a[c];</span><br><span class="line">        <span class="keyword">if</span>(tr[q].len==tr[p].len+<span class="number">1</span>)tr[np].fa=q;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="type">int</span> nq=++tot;</span><br><span class="line">            tr[nq].fa=tr[q].fa;tr[q].fa=nq;</span><br><span class="line">            tr[nq].len=tr[p].len+<span class="number">1</span>;<span class="built_in">memcpy</span>(tr[nq].a,tr[q].a,<span class="built_in">sizeof</span>(tr[q].a));</span><br><span class="line">            tr[np].fa=nq;</span><br><span class="line">            <span class="keyword">for</span>(;p &amp;&amp; tr[p].a[c]==q;p=tr[p].fa)tr[p].a[c]=nq;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool</span> dp[N][M][M];</span><br><span class="line"><span class="type">int</span> m,X;<span class="type">char</span> ans[M];<span class="type">int</span> fuck;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getval</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> fucklen)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> cnt=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=fucklen;i&gt;=<span class="number">1</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(tr[x].a[ans[i]-<span class="string">&#x27;a&#x27;</span>])x=tr[x].a[ans[i]-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        <span class="keyword">else</span> x=tr[<span class="number">1</span>].a[ans[i]-<span class="string">&#x27;a&#x27;</span>],cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool</span> v[<span class="number">40</span>];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">work</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(fuck!=m)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=tot;i++)&#123;</span><br><span class="line">            <span class="type">int</span> x=<span class="built_in">getval</span>(i,fuck);</span><br><span class="line">            <span class="keyword">if</span>(x&lt;=X &amp;&amp; dp[i][m-fuck][X-x+<span class="number">1</span>])<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">getval</span>(tr[<span class="number">1</span>].a[ans[m]-<span class="string">&#x27;a&#x27;</span>],m<span class="number">-1</span>)==X;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> T;<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;X);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,st+<span class="number">1</span>);</span><br><span class="line">        tot=last=<span class="number">1</span>;<span class="built_in">memset</span>(tr,<span class="number">0</span>,<span class="built_in">sizeof</span>(tr));<span class="built_in">memset</span>(v,<span class="number">0</span>,<span class="built_in">sizeof</span>(v));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i+i&lt;=n;i++)<span class="built_in">swap</span>(st[i],st[n-i+<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="built_in">add</span>(st[i]-<span class="string">&#x27;a&#x27;</span>),v[st[i]-<span class="string">&#x27;a&#x27;</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="comment">// for(int i=1;i&lt;=tot;i++)&#123;</span></span><br><span class="line">        <span class="comment">//     printf(&quot;%d %d\n&quot;,tr[i].fa,tr[i].len);</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">25</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(tr[<span class="number">1</span>].a[i])dp[tr[<span class="number">1</span>].a[i]][<span class="number">1</span>][<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;m;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">2</span>;j&lt;=tot;j++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> t=<span class="number">1</span>;t&lt;=i &amp;&amp; t&lt;=X;t++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(!dp[j][i][t])<span class="keyword">continue</span>;</span><br><span class="line">                    <span class="comment">// if(i==1 &amp;&amp; j==5 &amp;&amp; t==1)printf(&quot;OK\n&quot;);</span></span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;=<span class="number">25</span>;k++)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(tr[j].a[k])dp[tr[j].a[k]][i+<span class="number">1</span>][t]=<span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span>(tr[<span class="number">1</span>].a[k] &amp;&amp; t&lt;X)dp[tr[<span class="number">1</span>].a[k]][i+<span class="number">1</span>][t+<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// for(int i=1;i&lt;=tot;i++)printf(&quot;%d:%d %d\n&quot;,i,tr[i].len,tr[i].fa);</span></span><br><span class="line">        <span class="comment">// printf(&quot;%d %d %d\n&quot;,dp[4][2][1],tr[5].a[0],dp[5][1][1]);</span></span><br><span class="line">        <span class="type">bool</span> bk=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=tot;i++)bk|=dp[i][m][X];</span><br><span class="line">        <span class="keyword">if</span>(!bk)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=tot;i++)<span class="built_in">memset</span>(dp[i],<span class="number">0</span>,<span class="built_in">sizeof</span>(dp[i]));</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;-1\n&quot;</span>);<span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ans[1]=ans[2]=&#x27;a&#x27;;printf(&quot;%d\n&quot;,getval(5,2));</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">            fuck=i;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=<span class="number">25</span>;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!v[j])<span class="keyword">continue</span>;</span><br><span class="line">                ans[i]=j+<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">work</span>()==<span class="number">1</span>)<span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans[m+<span class="number">1</span>]=<span class="string">&#x27;\0&#x27;</span>;<span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,ans+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=tot;i++)<span class="built_in">memset</span>(dp[i],<span class="number">0</span>,<span class="built_in">sizeof</span>(dp[i]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>官方做法：</p>
<p>不得不说这应该是经典 trick 但是我忘了，在遇到 DP + 字符串 + 字典序最小就应该马上意识过来才对。</p>
<p>简单来说，用 BFS 更新 DP 状态，这样只要更新出了最终状态那么这条更新路径就是答案，而且不止最终状态，准确来说对于每个状态其的更新路径都是字典序最小的路径。（那这样是不是 DFS 也可以啊，只要加个记忆化就行了，本质应该是一样的）</p>
<p>原因：队列中对于两个长度相等的状态，一定满足更新路径字典序小的在前面，大的在后面，同时只要前面符合这种情况，后面也一定符合这种情况，想想就知道了，挺有意思的，</p>
<hr>
<p>队友的做法：</p>
<p>赛后讨论了一下，他的做法是正着做，反过来标记每个状态如果要到达最终状态的最优决策是什么（实际上只要处理出能否到达最终状态就行了），然后在正着处理出答案。</p>
<p><del>然而，我突然发现，实际上倒着跑就可以只跑两遍了，先倒着跑一遍 DP ，处理出每个位置的最优，然后正着跑出结果就行了。</del> (错误原因：一个点可能有多个点走同一个字符的边转移过来，因此无法在常数的时间判断出来哪个是最优决策)</p>
<hr>
<p>同机房同学的做法：</p>
<p>非常的有意思，我只能说不愧是他，A不了，但是可以看一下。</p>
<p>观察发现实际上会出问题当且仅当某个子串的下一个位置和下一个子串的首位置相等，所以一个操作次数 $≥2$ 的子串的某个前缀一定是由一个子串+某个字符构成的（且这个前缀不是一个子串），不妨考虑处理出所有这样的字符串（最多 $26n^2$ 个），然后排序，可以发现，这样的字符串具有一个性质，不存在一个字符串是另外一个字符串的前缀，这个性质后面有用。</p>
<p>然后设 $f[i][j][k]$ 表示长度为 $j$ ，首字母为 $i$ ，最小操作次数为 $k$ 的最小字典序的字符串（其实也不需要保留字符串，保留转移就行了）。</p>
<p>这样，转移的时候只需要从小到达遍历前面那个字符串，能转移就转移，不难发现这就是最优的决策。</p>
<p>但是仔细计算一下复杂度是 $O(26^2nmx)$ ，非常遗憾不能通过此题，但是我个人感觉这个思想非常的有意思，所以就把它给记录下来了，而且也很有启示意义，就是很多时候可以尝试一下脱离算法思考，可以发现这个方法并不依赖任何字符串算法，却得到了一个非常有意思的方法（这个老哥就是这个想法的忠实拥护者，不怎么学算法，坚信大部分题目都是可以用思维解决，所以他的思维就非常的厉害）。</p>
<hr>
<p>听说同机房还有基于字典树和 bitset 优化的四方做法过了，厉害厉害。</p>
</div></details>]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>经典trick</tag>
        <tag>字符串</tag>
        <tag>字典序</tag>
        <tag>SAM</tag>
      </tags>
  </entry>
  <entry>
    <title>Milk Candy</title>
    <url>/2024/01/31/Milk-Candy/</url>
    <content><![CDATA[<p>题目链接：<a href="https://qoj.ac/contest/1386/problem/7580">https://qoj.ac/contest/1386/problem/7580</a></p>
<p>题目大意：</p>
<p>有 $n$ 个未知数字，有 $m$ 个商人，每个商人有 $c_i$ 个的线索，每个线索有个价格，同时线索内容为 $[l,r]$ 的数字的和，你可以向每个商人买线索，但是每个商人必须恰好买 $k_i$ 个线索，问最少需要多少钱才能知道所有未知数字。</p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>虽然赛时队长神力秒了，但是我来编一个比较自然的思考路线：前缀和。</p>
<p>设 $s$ 为前缀和数组，所以实际上就是要知道所有 $s_i-s_0$ 。</p>
<p>考虑每个线索实际上提供了 $s_r-s_{l-1}$ ，又 $(s_a-s_b)+(s_b-s_c)=(s_a-s_c)$ ，所以实际上就是 $r$ 与 $l-1$ 连边，最后问所有点是不是与 $0$ 联通，也就是 $n+1$ 个点的生成树。</p>
<p>问题等价于 $n+1$ 个点，然后有一些边，问符合要求的最小权连通图。</p>
<ol>
<li>第一个拟阵 ，图拟阵的对偶拟阵。</li>
<li>第二个拟阵 ，每个商人去掉的线索数量不超过 $c_i-k_i$ 。</li>
</ol>
<p>带权拟阵交。</p>
<p>时间复杂度：$O((n\sum c_i)^2)$ 。</p>
<p>记得特判图一开始是不是联通的，因为如果一开始就不联通，那么 $\emptyset\notin \mathcal{I}$ ，这与拟阵交一开始默认 $\emptyset \in \mathcal{I}$ 冲突。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf=<span class="number">1e9</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e2</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M=<span class="number">2e4</span>+<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m,K,ans,ned;</span><br><span class="line"><span class="type">int</span> bel[N],cnt[N],lim[N];</span><br><span class="line">PII e[N];<span class="type">int</span> pri[N];</span><br><span class="line"><span class="type">bool</span> in[N];</span><br><span class="line"><span class="keyword">namespace</span> Union&#123;</span><br><span class="line">    <span class="type">int</span> fa[N];</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findfa</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="keyword">return</span> fa[x]==x?x:fa[x]=<span class="built_in">findfa</span>(fa[x]);&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mer</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">        x=<span class="built_in">findfa</span>(x);y=<span class="built_in">findfa</span>(y);</span><br><span class="line">        <span class="keyword">if</span>(x!=y)fa[x]=y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">pd</span><span class="params">(<span class="type">int</span> mov,<span class="type">int</span> add)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;i++)fa[i]=i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=K;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i==mov)<span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(i!=add &amp;&amp; in[i])<span class="keyword">continue</span>;</span><br><span class="line">            <span class="built_in">mer</span>(e[i].first,e[i].second);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">findfa</span>(i)!=<span class="built_in">findfa</span>(<span class="number">0</span>))<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> Union::pd;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> y,next;</span><br><span class="line">&#125;a[M];<span class="type">int</span> len,las[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ins</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;a[++len]=&#123;y,las[x]&#125;;las[x]=len;&#125;</span><br><span class="line"><span class="type">int</span> val[N],typ[N];PII d[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    len=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(las+<span class="number">1</span>,<span class="number">0</span>,<span class="built_in">sizeof</span>(<span class="type">int</span>)*K);</span><br><span class="line">    <span class="built_in">memset</span>(typ+<span class="number">1</span>,<span class="number">0</span>,<span class="built_in">sizeof</span>(<span class="type">int</span>)*K);</span><br><span class="line">&#125;</span><br><span class="line">queue&lt;<span class="type">int</span>&gt; q;<span class="type">bool</span> v[N];</span><br><span class="line"><span class="type">int</span> pre[N];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=K;i++)d[i]=&#123;-inf,-inf&#125;;</span><br><span class="line">    <span class="built_in">assert</span>(q.<span class="built_in">empty</span>());</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=K;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(typ[i]&amp;<span class="number">1</span>)&#123;</span><br><span class="line">            d[i]=&#123;val[i],<span class="number">0</span>&#125;;</span><br><span class="line">            v[i]=<span class="number">1</span>;</span><br><span class="line">            pre[i]=<span class="number">0</span>;</span><br><span class="line">            q.<span class="built_in">push</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="type">int</span> x=q.<span class="built_in">front</span>();q.<span class="built_in">pop</span>();</span><br><span class="line">        v[x]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k=las[x];k;k=a[k].next)&#123;</span><br><span class="line">            <span class="type">int</span> y=a[k].y;</span><br><span class="line">            <span class="keyword">if</span>(PII&#123;d[x].first+val[y],d[x].second<span class="number">-1</span>&#125;&gt;d[y])&#123;</span><br><span class="line">                d[y]=PII&#123;d[x].first+val[y],d[x].second<span class="number">-1</span>&#125;;</span><br><span class="line">                pre[y]=x;</span><br><span class="line">                <span class="keyword">if</span>(!v[y])&#123;</span><br><span class="line">                    v[y]=<span class="number">1</span>;</span><br><span class="line">                    q.<span class="built_in">push</span>(y);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    PII maxval=&#123;-inf,-inf&#125;;</span><br><span class="line">    <span class="type">int</span> endpoint=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=K;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>((typ[i]&amp;<span class="number">2</span>) &amp;&amp; d[i]&gt;maxval)&#123;</span><br><span class="line">            maxval=d[i];</span><br><span class="line">            endpoint=i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!endpoint)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    ans-=maxval.first;ned--;</span><br><span class="line">    <span class="type">int</span> now=endpoint;</span><br><span class="line">    <span class="keyword">while</span>(now)&#123;</span><br><span class="line">        <span class="keyword">if</span>(in[now])cnt[bel[now]]--;</span><br><span class="line">        <span class="keyword">else</span> cnt[bel[now]]++;</span><br><span class="line">        in[now]^=<span class="number">1</span>;</span><br><span class="line">        now=pre[now];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=K;i++)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!in[i])val[i]=pri[i];</span><br><span class="line">        <span class="keyword">else</span> val[i]=-pri[i];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(in[i])&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=K;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(in[j])<span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">pd</span>(j,i))<span class="built_in">ins</span>(i,j);</span><br><span class="line">                <span class="keyword">if</span>(cnt[bel[j]]&lt;lim[bel[j]] || bel[i]==bel[j])<span class="built_in">ins</span>(j,i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">pd</span>(i,<span class="number">-1</span>))typ[i]|=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(cnt[bel[i]]&lt;lim[bel[i]])typ[i]|=<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> T;<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        ans=ned=K=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(cnt,<span class="number">0</span>,<span class="built_in">sizeof</span>(cnt));</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">            <span class="type">int</span> x;<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;x,&amp;lim[i]);</span><br><span class="line">            lim[i]=x-lim[i];</span><br><span class="line">            ned+=lim[i];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=x;j++)&#123;</span><br><span class="line">                ++K;bel[K]=i;in[K]=<span class="number">0</span>;</span><br><span class="line">                <span class="type">int</span> l,r;<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;l,&amp;r,&amp;pri[K]);</span><br><span class="line">                l--;</span><br><span class="line">                e[K]=&#123;l,r&#125;;</span><br><span class="line">                ans+=pri[K];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">pd</span>(<span class="number">-1</span>,<span class="number">-1</span>))&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;-1\n&quot;</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            <span class="built_in">build</span>();</span><br><span class="line">        &#125;<span class="keyword">while</span>(<span class="built_in">solve</span>());</span><br><span class="line">        <span class="keyword">if</span>(ned)ans=<span class="number">-1</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></details>]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>拟阵</tag>
      </tags>
  </entry>
  <entry>
    <title>NCPC 2020 L. Languages</title>
    <url>/2024/07/01/NCPC-2020-L-Languages/</url>
    <content><![CDATA[<p>题目链接：<a href="https://qoj.ac/contest/531/problem/886">https://qoj.ac/contest/531/problem/886</a></p>
<p>题目大意：给你一个矩阵，每个位置为 $1/2$ ，分别表示恰有一种颜色，和 $\ge 2$ 种颜色。</p>
<p>要求给出三种颜色的染色方案，满足符合上面的矩形，且单个染色是联通的。</p>
<details class="toggle" ><summary class="toggle-button" style="">我的做法</summary><div class="toggle-content"><p>说来话长，特判掉没有 $2$ ，$n=1$ 和 $m=1$ 的情况。</p>
<p>然后假设每行都有一个 $2$ ，那么两种颜色就够了，奇偶行分别主要染不同的颜色，次要染不同的颜色。（表示 $1/2$ 分别染什么颜色，$1$ 染主要颜色 ，$2$ 主要次要都染）</p>
<p>假设有一个行没有 $2$ ，很自然的想把这一行作为枢纽，用来连接所有的 $0$ ，然后上面主要为 $1$ ，下面主要为 $2$ 。</p>
<p>具体来说，不妨只看单侧，即假设这一行为最后一行：</p>
<p>一种自然的想法是，如果这一列有 $2$ ，那么整一列主要染 $0$ ，次要染 $1$ ，但是这样如果相邻列都有 $2$ ，$1$ 就不连通了，因此会想这种情况下就让下一列主要染 $1$ ，次要染 $0$ 就行了。</p>
<p>综上得到做法，若某列有 $2$ ，先把这一列全部先染个 $0$ ，同时如果下一列相邻格子也有 $2$ ，就把这个格子也染成 $2$ ，然后跳过下一列，染完后，如果一个格子为 $2$ 或者没染过色，就染 $1$ ，对两边分别做一次就行了。</p>
<p>时间复杂度：$O(nm)$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e2</span> + <span class="number">5</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_char_array</span><span class="params">(<span class="type">char</span> *s)</span></span>&#123;</span><br><span class="line">	<span class="type">static</span> <span class="type">char</span> ss[N];</span><br><span class="line">	cin &gt;&gt; ss;</span><br><span class="line">	<span class="built_in">memcpy</span>(s + <span class="number">1</span>, ss, <span class="built_in">sizeof</span>(<span class="type">char</span>) * (<span class="built_in">strlen</span>(ss) + <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> type;</span><br><span class="line"><span class="type">char</span> st[N];</span><br><span class="line"><span class="type">int</span> a[N][N], tmp[N][N];</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">bool</span> be[<span class="number">3</span>][N][N];</span><br><span class="line"><span class="type">bool</span> vr[N], vc[N];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">work1</span><span class="params">()</span></span>&#123;</span><br><span class="line">	vector&lt;PII&gt; seg;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> l = <span class="number">1</span>; l &lt;= m; l++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(a[<span class="number">1</span>][l] == <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="type">int</span> r = l;</span><br><span class="line">		<span class="keyword">while</span>(r &lt; m &amp;&amp; a[<span class="number">1</span>][r + <span class="number">1</span>] == <span class="number">2</span>) r++;</span><br><span class="line">		seg.<span class="built_in">push_back</span>(&#123;l, r&#125;);</span><br><span class="line">		l = r;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(seg.<span class="built_in">size</span>() &gt;= <span class="number">3</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> j = seg[<span class="number">0</span>].first; j &lt;= seg[<span class="number">0</span>].second; j++) be[<span class="number">2</span>][<span class="number">1</span>][j] = <span class="number">1</span>;</span><br><span class="line">	<span class="type">int</span> t = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(seg.<span class="built_in">size</span>() == <span class="number">1</span>) t = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= seg[t].second; j++) be[<span class="number">0</span>][<span class="number">1</span>][j] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> j = seg[t].first; j &lt;= m; j++) be[<span class="number">1</span>][<span class="number">1</span>][j] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">putone</span><span class="params">(<span class="type">int</span> t)</span></span>&#123;</span><br><span class="line">	<span class="type">bool</span> bk = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(a[i][j] == <span class="number">2</span>)&#123;be[t][i][j] = <span class="number">1</span>; bk = <span class="number">1</span>; <span class="keyword">break</span>;&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(bk) <span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">work2</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">putone</span>(<span class="number">2</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(a[i][j] == <span class="number">2</span>) be[<span class="number">0</span>][i][j] = be[<span class="number">1</span>][i][j] = <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">else</span> be[i &amp; <span class="number">1</span>][i][j] = <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">auto</span> f)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++) tmp[j][i] = f[i][j];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) f[i][j] = tmp[i][j];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> sta[N], top;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	<span class="type">bool</span> b2 = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">		<span class="built_in">get_char_array</span>(st);</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++)&#123;</span><br><span class="line">			a[i][j] = st[j] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">			<span class="keyword">if</span>(a[i][j] == <span class="number">2</span>)&#123;</span><br><span class="line">				vr[i] = vc[j] = <span class="number">1</span>;</span><br><span class="line">				b2 = <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(!b2)&#123;</span><br><span class="line">		<span class="keyword">if</span>(n * m &lt;= <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		<span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++) be[<span class="built_in">min</span>(cnt, <span class="number">2</span>)][i][j] = <span class="number">1</span>, cnt++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(n == <span class="number">1</span>) <span class="keyword">return</span> <span class="built_in">work1</span>();</span><br><span class="line">	<span class="keyword">if</span>(m == <span class="number">1</span>)&#123;</span><br><span class="line">		type = <span class="number">1</span>;</span><br><span class="line">		<span class="built_in">rotate</span>(a);</span><br><span class="line">		<span class="built_in">swap</span>(n, m);</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">work1</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> posi = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(!vr[i])&#123;posi = i; <span class="keyword">break</span>;&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(!posi) <span class="keyword">return</span> <span class="built_in">work2</span>();</span><br><span class="line">    <span class="keyword">if</span>(posi == <span class="number">1</span>) <span class="built_in">putone</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(posi == n) <span class="built_in">putone</span>(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++) be[<span class="number">0</span>][posi][j] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++)&#123;</span><br><span class="line">        <span class="type">bool</span> bk = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; posi; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i][j] == <span class="number">2</span>) bk = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(bk)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; posi; i++)&#123;</span><br><span class="line">                be[<span class="number">0</span>][i][j] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(j &lt; m &amp;&amp; a[i][j + <span class="number">1</span>] == <span class="number">2</span>) be[<span class="number">0</span>][i][j + <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++)&#123;</span><br><span class="line">        <span class="type">bool</span> bk = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = posi + <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i][j] == <span class="number">2</span>) bk = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(bk)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = posi + <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">                be[<span class="number">0</span>][i][j] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(j &lt; m &amp;&amp; a[i][j + <span class="number">1</span>] == <span class="number">2</span>) be[<span class="number">0</span>][i][j + <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i][j] == <span class="number">2</span> || !be[<span class="number">0</span>][i][j])&#123;</span><br><span class="line">                <span class="keyword">if</span>(i &lt; posi) be[<span class="number">1</span>][i][j] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> be[<span class="number">2</span>][i][j] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(!<span class="built_in">solve</span>()) cout &lt;&lt; <span class="string">&quot;impossible\n&quot;</span>;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(type)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> t = <span class="number">0</span>; t &lt;= <span class="number">2</span>; t++) <span class="built_in">rotate</span>(be[t]);</span><br><span class="line">			<span class="built_in">swap</span>(n, m);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> t = <span class="number">0</span>; t &lt;= <span class="number">2</span>; t++)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">				<span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++)&#123;</span><br><span class="line">					<span class="keyword">if</span>(be[t][i][j]) st[j] = t + <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">					<span class="keyword">else</span> st[j] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				cout &lt;&lt; st + <span class="number">1</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></details>
<details class="toggle" ><summary class="toggle-button" style="">官方做法</summary><div class="toggle-content"><p>蚌埠住了，我太菜了，看到第一句话的那一刻起，我感觉赛时构造了一两个小时还没构造出来的我像个小丑一样，构造题真难啊。</p>
<p>注意到，如果我们能给这个矩阵划分成三个独立的连通块，且满足每个点四联通附近都有一个别的连通块的点，那么就显然做完了。</p>
<p>以下是一种可能的方案：</p>
<p><img src="1.png" alt=""></p>
<p>在 $n,m$ 小的时候这种方案可能用不了，特判一下就行了，在此不再赘述。（<del>其实是因为我没细想</del>，因为我觉得最关键的就是上面那句话，以及一种可能的方案，在完成这些后，后面的细节处理就只是时间问题了）</p>
</div></details>]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>构造</tag>
      </tags>
  </entry>
  <entry>
    <title>MEXimum Spanning Tree</title>
    <url>/2024/01/30/MEXimum-Spanning-Tree/</url>
    <content><![CDATA[<p>题目链接：<a href="https://qoj.ac/contest/1221/problem/6402">https://qoj.ac/contest/1221/problem/6402</a></p>
<p>题目大意：求 $mex$ 最大的生成树。</p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>一个显然的事情，这道题目是拟阵交，第一个拟阵无环，第二个拟阵要求每条数字的边至多一条。</p>
<p>这个时候可以二分+拟阵交，也可以从小到达考虑 $\le c$ 的边的拟阵交，因为拟阵交的算法保证了，只要给一个交集中的元素（一般默认空集），就一定可以增广出最大的元素。</p>
<p>接下来默认用从小到大考虑的方法，因为少个 $log$ 。</p>
<p>以下时间复杂度默认点数与边数同阶。</p>
<p>暴力建图的话是 $O(n^3)$ ，虽然能过，但是能不能更加优秀？</p>
<p>这个时候有几个优化方向：</p>
<ol>
<li>bitset ，在翻代码的时候看到的，虽然没看具体怎么优化的，反正是有人这么干的。</li>
<li>等到遍历到在加入边，显然，我们没必要一开始就把图建出来，而是跑到一个点再把这个点的所有出边找到，发现由于是 BFS，所以每个点至多走一次，所以这个优化只快不慢，同时注意到图拟阵那边的出边是难的，可以采用并查集优化的方式，在 $O(n^2\alpha(n))$ 的时间解决这个特殊的拟阵交问题。</li>
<li>题解说可以 $O(n^2\sqrt{n})$ ，没懂具体咋搞的，但肯定不是一开始就把图建出来。后面经过询问，似乎是说最短路的总长度有个 bound ，又说和 Hopcroft Karp 的分析类似，但 Hopcroft Karp 我没有学过，这个方法先咕了，等以后再说吧。</li>
</ol>
<p>但我写的是最暴力的三方做法，还要乘并查集的 $\alpha(n)$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e3</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M=<span class="number">2e6</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span>&#123;</span><br><span class="line">    <span class="type">int</span> x,y,c;</span><br><span class="line">&#125;e[N];<span class="type">int</span> pf[N];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(Edge x,Edge y)</span></span>&#123;<span class="keyword">return</span> x.c&lt;y.c;&#125;</span><br><span class="line"><span class="type">bool</span> in[N],col[N];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> fa[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">findfa</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="keyword">return</span> fa[x]==x?x:fa[x]=<span class="built_in">findfa</span>(fa[x]);&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mer</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    x=<span class="built_in">findfa</span>(x);y=<span class="built_in">findfa</span>(y);</span><br><span class="line">    <span class="keyword">if</span>(x!=y)fa[x]=y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">pd</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;<span class="keyword">return</span> <span class="built_in">findfa</span>(x)==<span class="built_in">findfa</span>(y);&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">uinit</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)fa[i]=i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> y,next;</span><br><span class="line">&#125;a[M];<span class="type">int</span> len,las[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ins</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;a[++len]=&#123;y,las[x]&#125;;las[x]=len;&#125;</span><br><span class="line"><span class="type">int</span> typ[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> lim)</span></span>&#123;</span><br><span class="line">    len=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(las+<span class="number">1</span>,<span class="number">0</span>,<span class="built_in">sizeof</span>(<span class="type">int</span>)*lim);</span><br><span class="line">    <span class="built_in">memset</span>(typ+<span class="number">1</span>,<span class="number">0</span>,<span class="built_in">sizeof</span>(<span class="type">int</span>)*lim);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=lim;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!in[i])<span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">uinit</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=lim;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i!=j &amp;&amp; in[j])<span class="built_in">mer</span>(e[j].x,e[j].y);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=lim;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(in[j])<span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(!<span class="built_in">pd</span>(e[j].x,e[j].y))<span class="built_in">ins</span>(i,j);</span><br><span class="line">            <span class="keyword">if</span>(e[i].c==e[j].c || !col[e[j].c])<span class="built_in">ins</span>(j,i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">uinit</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=lim;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(in[i])<span class="built_in">mer</span>(e[i].x,e[i].y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=lim;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(in[i])<span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">pd</span>(e[i].x,e[i].y))typ[i]|=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(!col[e[i].c])typ[i]|=<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"><span class="type">int</span> pre[N];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> lim)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=lim;i++)pre[i]=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=lim;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(typ[i]&amp;<span class="number">1</span>)&#123;</span><br><span class="line">            pre[i]=<span class="number">0</span>;</span><br><span class="line">            q.<span class="built_in">push</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="type">int</span> x=q.<span class="built_in">front</span>();q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(typ[x]&amp;<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">while</span>(x)&#123;</span><br><span class="line">                col[e[x].c]^=<span class="number">1</span>;</span><br><span class="line">                in[x]^=<span class="number">1</span>;</span><br><span class="line">                x=pre[x];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k=las[x];k;k=a[k].next)&#123;</span><br><span class="line">            <span class="type">int</span> y=a[k].y;</span><br><span class="line">            <span class="keyword">if</span>(pre[y]==<span class="number">-1</span>)&#123;</span><br><span class="line">                pre[y]=x;</span><br><span class="line">                q.<span class="built_in">push</span>(y);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;e[i].x,&amp;e[i].y,&amp;e[i].c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(e+<span class="number">1</span>,e+m+<span class="number">1</span>,[](Edge x,Edge y)&#123;</span><br><span class="line">        <span class="keyword">return</span> x.c&lt;y.c;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)pf[e[i].c]=i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)pf[i]=<span class="built_in">max</span>(pf[i],pf[i<span class="number">-1</span>]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">build</span>(pf[i]);</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">solve</span>(pf[i]))&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,i);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="坑"><a href="#坑" class="headerlink" title="坑"></a>坑</h6><p>根号做法是啥。</p>
</div></details>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>拟阵</tag>
      </tags>
  </entry>
  <entry>
    <title>Pick Your Own Nim</title>
    <url>/2024/01/31/Pick-Your-Own-Nim/</url>
    <content><![CDATA[<p>题目链接：<a href="https://codeforces.com/gym/102156/problem/D">https://codeforces.com/gym/102156/problem/D</a></p>
<p>题目大意：</p>
<p>给你 $n$ 个数字，再给你 $m$ 组数字，你要在每一组里面选一个数字，使得选出来的数字和那 $n$ 个数字，关于异或运算线性无关，如果可以，给一组方案。</p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>有限大小的线性空间本身就是拟阵，这样就很显然了。</p>
<ol>
<li>拟阵 $1$ 是线性无关。（算上那 $n$ 个数字）</li>
<li>拟阵 $2$ 是每组数字至多一个。</li>
</ol>
<p>时间复杂度：$O(60^2\sum\limits k_i)$ 。</p>
<p>记得特判一开始的 $n$ 个数字是否线性无关，否则还是老生常谈的问题：$\emptyset\notin \mathcal{I}$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N1=<span class="number">65</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N2=<span class="number">5e3</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M=<span class="number">6e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n,m,K;</span><br><span class="line">LL va[N2];<span class="type">int</span> bel[N2];</span><br><span class="line"><span class="type">bool</span> col[N1],in[N2];</span><br><span class="line"></span><br><span class="line">LL sta[N1];</span><br><span class="line"><span class="type">int</span> pos[N1],top;</span><br><span class="line">LL lin[N1],fac[N1];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">add</span><span class="params">(LL x,<span class="type">int</span> id)</span></span>&#123;</span><br><span class="line">    LL now=(<span class="number">1ll</span>&lt;&lt;(id<span class="number">-1</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">59</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">if</span>((x&gt;&gt;i)&amp;<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!lin[i])&#123;</span><br><span class="line">                lin[i]=x;</span><br><span class="line">                fac[i]=now;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> x^=lin[i],now^=fac[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">build_liner</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(lin,<span class="number">0</span>,<span class="built_in">sizeof</span>(lin));</span><br><span class="line">    <span class="built_in">memset</span>(fac,<span class="number">0</span>,<span class="built_in">sizeof</span>(fac));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=top;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">add</span>(sta[i],i))<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">findfac</span><span class="params">(LL x)</span></span>&#123;</span><br><span class="line">    LL now=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">59</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">if</span>((x&gt;&gt;i)&amp;<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!lin[i])<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">else</span> x^=lin[i],now^=fac[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> now;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> y,next;</span><br><span class="line">&#125;a[M];<span class="type">int</span> len,las[N2];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ins</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;a[++len]=&#123;y,las[x]&#125;;las[x]=len;&#125;</span><br><span class="line"><span class="type">int</span> typ[N2];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getliner</span><span class="params">()</span></span>&#123;</span><br><span class="line">    top=n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=K;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(in[i])sta[++top]=va[i],pos[top]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">assert</span>(<span class="built_in">build_liner</span>());</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">()</span></span>&#123;</span><br><span class="line">    len=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(las+<span class="number">1</span>,<span class="number">0</span>,<span class="built_in">sizeof</span>(<span class="type">int</span>)*K);</span><br><span class="line">    <span class="built_in">memset</span>(typ+<span class="number">1</span>,<span class="number">0</span>,<span class="built_in">sizeof</span>(<span class="type">int</span>)*K);</span><br><span class="line">    <span class="built_in">getliner</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> now=n+<span class="number">1</span>,i=pos[now];now&lt;=top;now++,i=pos[now])&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=K;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(in[j])<span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(bel[i]==bel[j] || !col[bel[j]])<span class="built_in">ins</span>(j,i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=K;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(in[i])<span class="keyword">continue</span>;</span><br><span class="line">        LL x=<span class="built_in">findfac</span>(va[i]);</span><br><span class="line">        <span class="keyword">if</span>(x==<span class="number">-1</span>)&#123;</span><br><span class="line">            typ[i]|=<span class="number">1</span>;</span><br><span class="line">            x=(<span class="number">1ll</span>&lt;&lt;top)<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> now=n+<span class="number">1</span>;now&lt;=top;now++)&#123;</span><br><span class="line">            <span class="keyword">if</span>((x&gt;&gt;(now<span class="number">-1</span>))&amp;<span class="number">1</span>)<span class="built_in">ins</span>(pos[now],i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!col[bel[i]])typ[i]|=<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"><span class="type">int</span> pre[N2];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=K;i++)pre[i]=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=K;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(typ[i]&amp;<span class="number">1</span>)&#123;</span><br><span class="line">            pre[i]=<span class="number">0</span>;</span><br><span class="line">            q.<span class="built_in">push</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="type">int</span> x=q.<span class="built_in">front</span>();q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(typ[x]&amp;<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">while</span>(x)&#123;</span><br><span class="line">                col[bel[x]]^=<span class="number">1</span>;</span><br><span class="line">                in[x]^=<span class="number">1</span>;</span><br><span class="line">                x=pre[x];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k=las[x];k;k=a[k].next)&#123;</span><br><span class="line">            <span class="type">int</span> y=a[k].y;</span><br><span class="line">            <span class="keyword">if</span>(pre[y]==<span class="number">-1</span>)&#123;</span><br><span class="line">                pre[y]=x;</span><br><span class="line">                q.<span class="built_in">push</span>(y);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);top=n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;sta[i]);</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">build_liner</span>())&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;-1\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="type">int</span> cnt;<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;cnt);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=cnt;j++)&#123;</span><br><span class="line">            ++K;bel[K]=i;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;va[K]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="built_in">build</span>();</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">solve</span>())&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;-1\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=K;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(in[i])<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,va[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></details>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
  </entry>
  <entry>
    <title>Strange Keyboard</title>
    <url>/2024/02/11/Strange-Keyboard/</url>
    <content><![CDATA[<p>题目链接：Strange Keyboard</p>
<p>题目大意：$Q$ 组数据，给 $n$ 个串 $S_i$ 和一个 $K$ ，还有一个空串和目标串 $T$ ，你可以对空串依次做下面两个操作的其中一个，问最少几步变成目标串。</p>
<ol>
<li>如果串长 $\ge K$ ，就删除最后 $K$ 个字符。</li>
<li>在串尾加入 $n$ 个串的其中一个。</li>
</ol>
<p>数据范围：$Q\le 100$ ，所有数据的 $\sum |S_i|\le 10^6$ ，所有数据的 $\sum |K|\le 5000$ ，$K\le 5000$ 。</p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>循序渐进的考虑这道题目怎么做：</p>
<p>考虑一种特殊情况：$T=aaa…$ ，然后只有一个串是 $abc…$ 的结构（首字母为 $a$ ，后面全都不是 $a$ ），然后其余一堆没有 $a$ 的垃圾串，那么这显然引导我们先要解决一个同余最短路的问题，即需要至少多少次数能够消掉一个长度为 $len$ 的后缀？</p>
<p>注意到，在这个问题中，我们并不关心字符串的内容是什么，我们只关心长度，不同的长度只有至多 $O(\sqrt{\sum |S_i|})$ 种。</p>
<p>设 $f_i$ 表示需要最少多少次才能让字符串恰好有 $i$ 个字符，$f_0=0$ ，这个时候发现，跑同余最短路会超时，多个 log ，怎么办呢？</p>
<p>如果你足够聪慧，就会发现，导致出现权值从而让我们不得不跑最短路的原因是我们直接做了取余操作，事实上，我们根本没必要一次性把取余操作做完，详细的说就是：</p>
<script type="math/tex; mode=display">
\begin{align*}
    f_{i-K}&=\min(f_{i-K},f_{i}+1),i\ge K\\
    f_{i+a_j}&=\min(f_{i+a_j},f_{i}+1),i<K\\
\end{align*}</script><p>这样，权值就都是 $1$ 了，直接跑 $BFS$ 即可。</p>
<p>当然，我不够聪慧，我的解决方法是直接开值域个队列，不难证明 $f$ 的最大值不超过 $\max(S_i)+K$ 。</p>
<p>上述两种方法的时空复杂度都一样，单组数据下：</p>
<p>时间复杂度：$O(max(S_i)+K\sqrt{\sum |S_i|})$</p>
<p>空间复杂度：$O(\sum |S_i|+K)$</p>
<p>后面就简单了，考虑一个事情，假如我们现在已经填了 $T$ 的一个前缀，然后现在我们要填一个字符串，并且要删掉字符串的一个后缀，那么代价可以很方便的用 $f$ 计算。</p>
<p>设 $dp[i]$ 表示填下 $T$ 的长度为 $i$ 的前缀的最小操作次数。</p>
<p>那么 $dp[i]\to dp[j]$ 的转移就是所有前缀能对上 $T[i+1\to j]$ 的 $S$ 串的转移代价的最小值，这里有个匹配前缀的要求，显然用 Trie 就行了。</p>
<p>因此这道题目就做完了：先同余最短路算 $f$ ，然后建 $Trie$ ，最后 $dp$ 转移即可。</p>
<p>单组数据下：</p>
<p>时间复杂度：$O(26\sum S_i+K\sqrt{\sum |S_i|}+T^2)$</p>
<p>空间复杂度：$O(26\sum S_i+K+T)$</p>
<p>虽然有 $100$ 组数据，但是算一下发现这个复杂度已经足以通过此题。（注意 $S$ 是所有数据的长度总和不超过 $10^6$ ，不是单组数据的）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> LL inf=<span class="number">1e15</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e6</span>+<span class="number">5e3</span>+<span class="number">105</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M=<span class="number">5e3</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n,K;</span><br><span class="line">string ss[N];<span class="type">char</span> st[N];</span><br><span class="line"><span class="type">bool</span> v[N];<span class="type">int</span> stk[N],top;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!v[x])stk[++top]=x;</span><br><span class="line">    v[x]=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> h[N];</span><br><span class="line"><span class="function">LL <span class="title">calc</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> y=x%K;</span><br><span class="line">    <span class="keyword">if</span>(!y)<span class="keyword">return</span> x/K;</span><br><span class="line">    <span class="keyword">if</span>(!h[K-y])<span class="keyword">return</span> inf;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> h[K-y]+x/K;</span><br><span class="line">&#125;</span><br><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;</span><br><span class="line">    h[<span class="number">0</span>]=<span class="number">1</span>;q.<span class="built_in">push</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="type">int</span> x=q.<span class="built_in">front</span>();q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(x&gt;=K)&#123;</span><br><span class="line">            <span class="type">int</span> y=x-K;</span><br><span class="line">            <span class="keyword">if</span>(!h[y])&#123;</span><br><span class="line">                h[y]=h[x]+<span class="number">1</span>;</span><br><span class="line">                q.<span class="built_in">push</span>(y);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=top;i++)&#123;</span><br><span class="line">                <span class="type">int</span> y=x+stk[i];</span><br><span class="line">                <span class="keyword">if</span>(!h[y])&#123;</span><br><span class="line">                    h[y]=h[x]+<span class="number">1</span>;</span><br><span class="line">                    q.<span class="built_in">push</span>(y);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Trie</span>&#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">26</span>];LL val;</span><br><span class="line">    <span class="type">int</span>&amp; <span class="keyword">operator</span>[](<span class="type">int</span> x)&#123;<span class="keyword">return</span> a[x];&#125;</span><br><span class="line">&#125;tr[N];<span class="type">int</span> tcnt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">cl</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(tr[x].a,<span class="number">0</span>,<span class="built_in">sizeof</span>(tr[x].a));</span><br><span class="line">    tr[x].val=inf;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> mxlen=<span class="number">0</span>;</span><br><span class="line">    top=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        v[ss[i].<span class="built_in">length</span>()]=<span class="number">0</span>;</span><br><span class="line">        mxlen=<span class="built_in">max</span>(mxlen,(<span class="type">int</span>)ss[i].<span class="built_in">length</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    mxlen+=K;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(h,<span class="number">0</span>,<span class="built_in">sizeof</span>(<span class="type">int</span>)*mxlen);</span><br><span class="line"></span><br><span class="line">    tcnt=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">cl</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(string &amp;s)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> len=s.<span class="built_in">length</span>();</span><br><span class="line">    <span class="type">int</span> now=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=len;i++)&#123;</span><br><span class="line">        <span class="type">int</span> x=s[i<span class="number">-1</span>]-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span>(!tr[now][x])&#123;</span><br><span class="line">            tr[now][x]=++tcnt;</span><br><span class="line">            <span class="built_in">cl</span>(tcnt);</span><br><span class="line">        &#125;</span><br><span class="line">        now=tr[now][x];</span><br><span class="line">        tr[now].val=<span class="built_in">min</span>(tr[now].val,<span class="built_in">calc</span>(len-i));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LL dp[M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> T;<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;K);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,st+<span class="number">1</span>);</span><br><span class="line">            ss[i]=st+<span class="number">1</span>;</span><br><span class="line">            <span class="built_in">add</span>(ss[i].<span class="built_in">length</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">bfs</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="built_in">add</span>(ss[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,st+<span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> m=<span class="built_in">strlen</span>(st+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)dp[i]=inf;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">            <span class="type">int</span> now=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">                now=tr[now][st[j]-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">                <span class="keyword">if</span>(!now)<span class="keyword">break</span>;</span><br><span class="line">                dp[j]=<span class="built_in">min</span>(dp[j],dp[i]+tr[now].val+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">assert</span>(dp[m]&lt;=inf);</span><br><span class="line">        <span class="keyword">if</span>(dp[m]==inf)dp[m]=<span class="number">-1</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,dp[m]);</span><br><span class="line">        <span class="built_in">init</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></details>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>Trie</tag>
        <tag>字符串</tag>
        <tag>同余最短路</tag>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title>NCPC-2020 with some BAPC/UKIEPC 2020 赛后小结</title>
    <url>/2024/07/03/NCPC-2020-with-some-BAPC-UKIEPC-2020-%E8%B5%9B%E5%90%8E%E5%B0%8F%E7%BB%93/</url>
    <content><![CDATA[<p>比赛链接：NCPC-2020 with some BAPC/UKIEPC 2020</p>
<p>前期，B,G 队友秒了，K 不难，但是我和队友交流了一会，得出了必须写高精度的结论，上去写，写完后发现结论有点问题，下来改了又上去写，然后才过了。</p>
<p>感觉最大的问题在于结论错了一次，其余没有犯什么大的罪。</p>
<p>但是呢，在看了最短的代码，发现我实际上实现糟糕了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//https://qoj.ac/submission/191620</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n,v,x,m,b,A[<span class="number">1</span>&lt;&lt;<span class="number">20</span>],k;</span><br><span class="line">string s,t;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	cin&gt;&gt;s&gt;&gt;t;</span><br><span class="line">	<span class="keyword">if</span>(s.<span class="built_in">size</span>()&lt;t.<span class="built_in">size</span>())</span><br><span class="line">		<span class="built_in">swap</span>(s,t);</span><br><span class="line">	<span class="built_in">reverse</span>(s.<span class="built_in">begin</span>(),s.<span class="built_in">end</span>()),<span class="built_in">reverse</span>(t.<span class="built_in">begin</span>(),t.<span class="built_in">end</span>()),n=s.<span class="built_in">size</span>(),s=<span class="string">&#x27; &#x27;</span>+s,t=<span class="string">&#x27; &#x27;</span>+t+<span class="built_in">string</span>(n-t.<span class="built_in">size</span>(),<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		x+=s[i]-<span class="string">&#x27;0&#x27;</span>+t[i]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">		<span class="keyword">if</span>(x&gt;<span class="number">9</span>)</span><br><span class="line">			m=i;</span><br><span class="line">		x/=<span class="number">10</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">		<span class="keyword">if</span>(s[i]&gt;t[i])</span><br><span class="line">			v=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(s[i]&lt;t[i])</span><br><span class="line">			v=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(!v)</span><br><span class="line">		<span class="built_in">swap</span>(s,t);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">		A[i]=(b-s[i]+<span class="string">&#x27;0&#x27;</span>)%<span class="number">10</span>;</span><br><span class="line">		<span class="keyword">if</span>(A[i]&lt;<span class="number">0</span>)</span><br><span class="line">			b=<span class="number">-1</span>,A[i]+=<span class="number">10</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">		<span class="keyword">if</span>(A[i])</span><br><span class="line">			k=i;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=k;i;i--)</span><br><span class="line">		cout&lt;&lt;A[i]; </span><br><span class="line">	<span class="keyword">if</span>(!k)</span><br><span class="line">		cout&lt;&lt;<span class="number">0</span>;</span><br><span class="line">	cout&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意到就是找到最大的符合条件的 $k$ ，然后求出：$10^{k}-(a\mod 10^k)$ ，或者是 $b$ ，而这个位置我们是用 $a,b$ 分别与 $a+b$ 比较去找的，但实际上这个位置就是 $a+b$ 最后一次发生进位的位置。</p>
<p>为啥呢，设 $a=a_n…a_5a_4a_3a_2a_1a_0,b=b_n…b_5b_4b_3b_2b_1b_0$ ，从低位到高位。</p>
<p>如果第 $i$ 位进位了，说明 $a_{i}…a_{0}+b_{i}…b_{0}\ge 10^{i+1}$ ，所以操作的时候不让 $a$ 或者 $b$ 在第 $i$ 位进位，$a+b$ 就一定会在第 $i$ 位进位，所以直接操作 $a,b$ 中的一个让其进位就行了，而且由于 $a_{i}…a_{0}+b_{i}…b_{0}\ge 10^{i+1}$ ，所以另外一个不会退位，所以这一定是合法的，因此这是最优的，就做完了。</p>
<p>但你要说这是我们策略上的问题吗？我觉得不是，只是我们菜了。</p>
<p>C,D 队友秒了，但是这个时候队长上 I 了，我觉得比赛时可以炸，但是中期开炸我觉得很不合理，队长记大过一次，虽然最后过了，但是这个决策确实浪费了很多时间。</p>
<p>反正我觉得很多时候卡题了不如直接跳，逻辑是什么呢？首先红了以后效率会降低，其次可能会错失一些其余机会，比如某个题你很擅长，在干完其余事后头脑清醒了，再回来调试或许效率会更高点。</p>
<p>或者这么说，我个人认为，激进一点就是直接跳，赌跳的收益会比调的收益高，稳健点就调试，都已经会了，只要做法假了，期望的调的时间不会很长，当然，至于两种策略谁激进谁稳健，最终都要根据实际情况来定，不能一概而论。</p>
<p> J 板子，抄了个板子过了。</p>
<p> F 队长神力，将前面的犯罪都弥补了，E 队友神力，队长还秒了个 H 。</p>
<p>那 fw 的我在干嘛呢？我在构造 L ，然后提出一个做法假一个做法，在最后都没有过。</p>
<p>最后来看，总体上而言，过不了 A,L 是实力问题，大的决策问题只有队长的 I 。</p>
<p>但实际上呢？我前期啥事没干，后期构造了半个比赛。</p>
<p>首先，我认为那个构造时间长还没做出来是实力问题，但是前期我其实在偷偷犯罪，我看到 A 的第一眼，我就觉得这是道好题，就很想把他做出来，在想了半天后，发现其不是 dp 而是模拟后，就已经意识到最后的代码可能很难写了。</p>
<p>后面的大部分时间，我一直都在想 A 怎么快速的判断一个方案是合法的，到我开始拿起 L 的时候都没搞出来。</p>
<p>最后在赛后做出来 A 后回头来看，A 或许不难，但也绝对没有这么简单，更别提我当时方向错了，这道题目得先猜出答案再做，而我当时一直在想怎么快速判断一个方案是合法的。</p>
<p>首先，榜上大部分情况下就是可以反映实际的难度，我深刻检讨，或许是在之前的比赛做出来了几道少人的题目，让我以为我在某些题目特别擅长，超过了我自己的平均水平，导致这场比赛直接莽 A 了，但结合所以比赛来看，前面几场就是意外，实际比赛中基本不会发生这种情况，就得一步一个脚印。</p>
<p>其次，我当时还有点私心，我觉得这个题目非常的好，很想自己做出来，但 ACM 是个团队比赛，除非你有超人的能力，否则纯凭个人力量是没法打出好的名次的，团队赛要注重的是配合，如果我那么想独立做题，就应该平时自己多加训，而不是赛时直接去莽题。深刻检讨我自己，希望以后不要在比赛时犯这种错误，多和队友合作交流。</p>
<p>再回头来看 A ，我当时实际上并没有发现答案的一个下界，也没有发现答案就是下界，也没有想出快速模拟的方法，而是一直在想只知道每个区间操作了多少次能否快速判断，这很 ATcoder ，ATcoder 中很多 1000 的题目就是这么做的，所以赛时我没有做出来。</p>
<p>回头来看，这道题目实际就是找下界，证明是下界，然后模拟，如果要快点，就用数据结构加速模拟。不是特别难，是能做的题目，但是我当时的思维就限制在 ATcoder 类型的题目上面，导致根本没有想到，这启示我要多开阔思维，不要把思维局限在某一类方法上。</p>
<p>还记得 NOI D1T2 我就是因为这个原因寄掉的，希望未来不会出现重蹈覆辙的情况，ATcoder 上的题目终究只是一类题目，不能代表所有题目，要想思维开阔要广刷题，多刷题，不能只刷 ATcoder 的题目，我也不能呆在舒适圈里，要多去做些别的题库的题，感受不一样的风格，这样才能变强。</p>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
  </entry>
  <entry>
    <title>Prüfer序列学习笔记</title>
    <url>/2024/02/02/Prufer%E5%BA%8F%E5%88%97%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p> Prüfer 序列是真好用啊。</p>
<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>对于一棵 $n(n\ge 2)$ 个点的树，每次我们选择一个编号最小的叶子节点删掉，然后将其相邻节点的编号加入到序列中，直到剩下两个点为止，这样构成的序列，就叫这棵树的 Prüfer 序列。</p>
<h1 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h1><p>Prüfer 序列构建了一个有标号无根树到序列的双射，后面会讲如何通过另方求另一方。</p>
<p>而且任意一个值域为 $n$ 长度为 $n-2$ 的序列都对应了一棵生成树，这让 Prüfer 序列在解决无根树相关的计数问题非常好用。</p>
<p>从度数的角度看 Prüfer 序列，可以发现，Prüfer 序列中的点实际上表现的是度数 $-1$ 的过程。</p>
<p>例如 ：Prüfer 序列是 $1,2,3$ ，那么表示在删除第一个叶子时，$1$ 号点度数减 $1$ ，接下来同理。</p>
<p>最后，所有度数为 $1$ 的点被删除，只剩下了 $n$ 和另外一个度数为 $1$ 的点。</p>
<p>综上，我们可以得到下面这个结论。</p>
<p><strong>结论 1</strong> ：每个点在 Prüfer 序列中的出现次数为度数$-1$ 。</p>
<h1 id="转化"><a href="#转化" class="headerlink" title="转化"></a>转化</h1><h2 id="无根树转-Prufer-序列"><a href="#无根树转-Prufer-序列" class="headerlink" title="无根树转 Prüfer 序列"></a>无根树转 Prüfer 序列</h2><p>从小到大搜索每一个点，直到 Prüfer 序列中已经有 $n-2$ 个数字，设搜索到 $p$ 号点：</p>
<ol>
<li>假如 $p$ 号点不是叶子，继续搜。</li>
<li>假如 $p$ 号点是叶子，删除，如果新增了一个叶子节点且编号小于 $p$ ，显然这个叶子节点编号最小，接着删，直到删了 $n-2$ 个点或者编号 $&gt;p$ 。</li>
</ol>
<p>时间复杂度：$O(n)$ 。</p>
<h2 id="Prufer-序列转无根树"><a href="#Prufer-序列转无根树" class="headerlink" title="Prüfer 序列转无根树"></a>Prüfer 序列转无根树</h2><p>首先，根据 Prüfer 序列可以算出每个点的度数，然后按照 Prüfer 序列，每次取出编号最小的叶子节点和 Prüfer 序列当前位置连边，然后给 Prüfer 序列当前位置度数 $-1$ ，不断重复，直到最后，就只会剩两个度数为 $1$ 的节点，连起来即可。</p>
<p>时间复杂度：$O(n\log{n})$ 。</p>
<h1 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h1><ol>
<li>$n$ 个点的有标号无根树有多少个：$n^{n-2}$ 个。</li>
<li>假设每个点的度数已知，设为 $d_i$ ，求满足这个度数限制的有标号无根树的数量：$\binom{n-2}{d_1-1,d_2-1,…,d_n-1}$ 。</li>
<li><p>Cayley 公式：给定 $m(m\ge 2)$ 个连通块，每个连通块的大小是 $s_i$ ，且 $\sum\limits_{i=1}^m=n$ ，那么用 $m-1$ 条边把这 $m$ 个联通块联通起来的方案数为 $(\prod\limits_{i=1}^m s_i)n^{m-2}$ 。</p>
<details class="toggle" ><summary class="toggle-button" style="">证明</summary><div class="toggle-content"><p>证明 1 ：考虑 $m$ 个点的树的 $Prüfer$ 序列，不妨设为 $p$ 序列，由于 $Prüfer$ 序列实际上代表了一种连边方式，所以我们只需要计算 $n-1$ 条边能够有多少种连法就行了，那么对于这个 $Prüfer$ 序列能够代表的方案数，通过计算为：$(\prod_{i=1}^m s_i)<em>(\prod_{i=1}^{m-2} s_{p_i})$ 。又 Prüfer 序列 $m-2$ 个位置都可以填 $1-m$ ，所以显然，总方案数为 $(\prod\limits_{i=1}^m s_i)</em>n^{m-2}$ 。</p>
<p>证明 2 ：代数证明（来自oiwiki）</p>
<p>考虑每个连通块的度数为 $d_i$ ，显然，只要 $d_i&gt;0,\sum\limits_{i=1}^md_i=2m-2$ ，就能算是一个合法的度数序列。</p>
<p>所以这样子的方案数为：$\binom{m-2}{d_1-1,d_2-1,…,d_m-1}\prod{s_i^{d_i}}$ 。</p>
<p>由多元二项式定理：$(x_1+x_2+…+x_p)^k=\sum\limits_{a_1,a_2,…,a_p\ge 0,a_1+a_2+…+a_p=k}\binom{k}{a_1,a_2,…,a_p}\prod\limits_{i=1}^px_i^{a_i}$ 。</p>
<p>那么 $\sum\limits_{d_i&gt;0,d_1+…+d_m=2m-2}\binom{m-2}{d_1-1,d_2-1,…,d_m-1}\prod\limits_{i=1}^m{s_i^{d_i}}$ ，令 $e_i=d_i-1$ 可以得到：$\sum\limits_{e_i\ge 0,e_1+…+e_m=m-2}\binom{m-2}{e_1,e_2,…,e_m}\prod\limits_{i=1}^m{s_i^{e_i+1}}=n^{m-2}\prod\limits_{i=1}^ms_i$</p>
<p>证毕。</p>
</div></details></li>
</ol>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>计数</tag>
        <tag>Prüfer序列</tag>
      </tags>
  </entry>
  <entry>
    <title>The 2nd Ucup Stage 2: SPb M. Hardcore String Counting</title>
    <url>/2024/05/30/The-2nd-Ucup-Stage-2-SPb-M-Hardcore-String-Counting/</url>
    <content><![CDATA[<p>题目链接：<a href="https://contest.ucup.ac/contest/1356/problem/7187">https://contest.ucup.ac/contest/1356/problem/7187</a></p>
<p>题目大意：给一个长度为 $n$ 的字符串 $S$，问有多少个长度为 $m$ 的字符串满足所有真前缀没有子串等于 $S$ ，但整个串有。</p>
<details class="toggle" ><summary class="toggle-button" style="">做法 + 反思</summary><div class="toggle-content"><p>看复杂度，应该是 $n\log$ 之类的东西，不大可能在 AC 自动机上跑，因此比较有可能的就是列一个线性递推式，然后常系数齐次线性递推。</p>
<p>我当时想到这一步了，可惜并没有列出线性递推式。</p>
<p>我当时的思路是，设 $g(m)$ 表示长度为 $m$ 的字符串且没有子串等于 $S$ ，然后在 $g(m-1)$ 放一个字符，容斥减去 $g(m-n)$ ，但 $g(m-n)$ 不一定满足前 $m-1$ 前缀没有子串等于 $S$ ，所以还得容斥，当时我的思路就是接着找 border ，不断下去，但是发现这个过程好想是无穷的。</p>
<p>例如 $S=aa$ 时，则按照这个思路可以得到：$g(m)=26g(m-1)-\sum\limits_{i=2}^{m}(-1)^ig(m-i)$ 。</p>
<p>下面的代码可以验证：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> LL mod = <span class="number">998244353</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line">LL f1[N][<span class="number">2</span>], f2[N];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    f1[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1ll</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        f1[i][<span class="number">0</span>] = (f1[i - <span class="number">1</span>][<span class="number">0</span>] + f1[i - <span class="number">1</span>][<span class="number">1</span>]) * <span class="number">25ll</span> % mod;</span><br><span class="line">        f1[i][<span class="number">1</span>] = f1[i - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">        cout &lt;&lt; (f1[i][<span class="number">0</span>] + f1[i][<span class="number">1</span>]) % mod &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    f2[<span class="number">0</span>] = <span class="number">1ll</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        f2[i] = f2[i - <span class="number">1</span>] * <span class="number">26</span> % mod;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">2</span>, type = <span class="number">-1ll</span>; j &lt;= i; j++, type = -type) f2[i] = (f2[i] + f2[i - j] * type + mod) % mod; </span><br><span class="line">        cout &lt;&lt; f2[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>然后我就觉得这个思路是错的，虽然上面的 $g(m)$ 可以加上 $g(m-1)$ ，这样就可以变成有限项求和，但是这只是针对 $S=aa$ 的情况，对于更加一般的情况，就不一定能这么干了，而且我也想不太明白一般情况下 $g$ 的递推式。（这个思路我感觉确实比较绕，比较难想）</p>
<p>但是如果换个角度来看：我们设 $f(m)$ 就表示答案，显然：$f(m)=26g(m-1)-g(m)$ ，上面的式子中，我们需要容斥掉不一定满足前 $m-1$ 前缀没有子串等于 $S$ 但是前 $m-n$ 的前缀满足的字符串，显然这就是 $\sum\limits_{Border}f(m-n+Border)$ 。</p>
<p>所以这显然就是 $\sum\limits_{Border}26g(m-n+Border-1)-g(m-n+Border)$ ，那么就得到了有限项的递推式。</p>
<p>然后直接加速一下，就可以在 $O(n\log{n}\log{k})$ 的时间解决这个问题了。</p>
<p>反思一下我为什么没做出来：我没找到有限项递推 ≠ 没有，我找到无限项递推 ≠ 没有有限项。</p>
<p>再回头看我那个思考方向，我不认为能想出来，从结果来看，有限项的递推式中一堆 $26$ ，因此可以知道那个无穷递推式的结果肯定很难看，更别说要看出怎样线性组合可以把那个无穷递推式变成有限项，反正我不认为那个角度可以想出来。</p>
<p>所以当推不出递推式的时候，先别着急的认为不存在递推式，或许换个方式去推就能很快推出来了。虽然做题的时候，做不出来换个方向考虑是正常的，但对于这种不同的推式子方法难度天差地别的方向，多换不同的方法推式子也是必要的。同理，组合题也是。</p>
<h6 id="坑"><a href="#坑" class="headerlink" title="坑"></a>坑</h6><p>代码？博主不会多项式算法，咕了，以后会了再回来补上。</p>
</div></details>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>计数</tag>
        <tag>字符串</tag>
        <tag>常系数齐次线性递推</tag>
      </tags>
  </entry>
  <entry>
    <title>Rainbow Graph</title>
    <url>/2024/01/31/Rainbow-Graph/</url>
    <content><![CDATA[<p>题目链接：<a href="https://open.kattis.com/problems/rainbowgraph">https://open.kattis.com/problems/rainbowgraph</a></p>
<p>题目大意：</p>
<p>一张无向图，每条边有红绿蓝三种颜色，请选一个最小权值和的边集，使得：不看红色边图是联通的，不看蓝色边图也是联通的。</p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>两个对偶拟阵一交就做完了，需要注意的是，带权拟阵交每次增广出来的集合，都是与他同大小的权值和最大的集合，所以一遍带权拟阵交就能处理出所有的答案。</p>
<p>记得特判图一开始是不是联通的，因为如果一开始就不联通，那么 $\emptyset\notin \mathcal{I}$ ，这与拟阵交一开始默认 $\emptyset \in \mathcal{I}$ 冲突。</p>
<p>时间复杂度：$O(m^4)$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf=<span class="number">1e9</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e2</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M=<span class="number">2e4</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n,m,zans;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span>&#123;</span><br><span class="line">    <span class="type">int</span> x,y,c,typ;</span><br><span class="line">&#125;e[N];</span><br><span class="line"><span class="type">bool</span> in[N];</span><br><span class="line"><span class="keyword">namespace</span> Union&#123;</span><br><span class="line">    <span class="type">int</span> fa[N];</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findfa</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="keyword">return</span> fa[x]==x?x:fa[x]=<span class="built_in">findfa</span>(fa[x]);&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mer</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">        x=<span class="built_in">findfa</span>(x);y=<span class="built_in">findfa</span>(y);</span><br><span class="line">        <span class="keyword">if</span>(x!=y)fa[x]=y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">pd</span><span class="params">(<span class="type">int</span> ban,<span class="type">int</span> mov,<span class="type">int</span> add)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)fa[i]=i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(e[i].typ==ban || i==mov)<span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(i!=add &amp;&amp; in[i])<span class="keyword">continue</span>;</span><br><span class="line">            <span class="built_in">mer</span>(e[i].x,e[i].y);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">findfa</span>(i)!=<span class="built_in">findfa</span>(<span class="number">1</span>))<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> Union::pd;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> y,next;</span><br><span class="line">&#125;a[M];<span class="type">int</span> len,las[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ins</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;a[++len]=&#123;y,las[x]&#125;;las[x]=len;&#125;</span><br><span class="line"><span class="type">int</span> pri[N],typ[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">()</span></span>&#123;</span><br><span class="line">    len=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(las+<span class="number">1</span>,<span class="number">0</span>,<span class="built_in">sizeof</span>(<span class="type">int</span>)*m);</span><br><span class="line">    <span class="built_in">memset</span>(typ+<span class="number">1</span>,<span class="number">0</span>,<span class="built_in">sizeof</span>(<span class="type">int</span>)*m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(in[i])&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(in[j])<span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">pd</span>(<span class="number">0</span>,j,i))<span class="built_in">ins</span>(i,j);</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">pd</span>(<span class="number">2</span>,j,i))<span class="built_in">ins</span>(j,i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">pd</span>(<span class="number">0</span>,i,<span class="number">-1</span>))typ[i]|=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">pd</span>(<span class="number">2</span>,i,<span class="number">-1</span>))typ[i]|=<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!in[i])pri[i]=e[i].c;</span><br><span class="line">        <span class="keyword">else</span> pri[i]=-e[i].c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> pre[N];PII d[N];</span><br><span class="line"><span class="type">bool</span> v[N];</span><br><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(q.<span class="built_in">empty</span>());</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)d[i]=&#123;-inf,-inf&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(typ[i]&amp;<span class="number">1</span>)&#123;</span><br><span class="line">            q.<span class="built_in">push</span>(i);</span><br><span class="line">            v[i]=<span class="number">1</span>;</span><br><span class="line">            d[i]=&#123;pri[i],<span class="number">0</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="type">int</span> x=q.<span class="built_in">front</span>();q.<span class="built_in">pop</span>();</span><br><span class="line">        v[x]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k=las[x];k;k=a[k].next)&#123;</span><br><span class="line">            <span class="type">int</span> y=a[k].y;</span><br><span class="line">            <span class="keyword">if</span>(PII&#123;d[x].first+pri[y],d[x].second<span class="number">-1</span>&#125;&gt;d[y])&#123;</span><br><span class="line">                d[y]=PII&#123;d[x].first+pri[y],d[x].second<span class="number">-1</span>&#125;;</span><br><span class="line">                pre[y]=x;</span><br><span class="line">                <span class="keyword">if</span>(!v[y])&#123;</span><br><span class="line">                    v[y]=<span class="number">1</span>;</span><br><span class="line">                    q.<span class="built_in">push</span>(y);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    PII maxval=&#123;-inf,-inf&#125;;<span class="type">int</span> mp=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>((typ[i]&amp;<span class="number">2</span>) &amp;&amp; d[i]&gt;maxval)&#123;</span><br><span class="line">            maxval=d[i];</span><br><span class="line">            mp=i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!mp)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    zans-=maxval.first;</span><br><span class="line">    <span class="type">int</span> now=mp;</span><br><span class="line">    <span class="keyword">while</span>(now)&#123;</span><br><span class="line">        in[now]^=<span class="number">1</span>;</span><br><span class="line">        now=pre[now];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">char</span> ss[<span class="number">10</span>];</span><br><span class="line"><span class="type">int</span> ans[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="type">int</span> x,y,w,t;<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%s&quot;</span>,&amp;x,&amp;y,&amp;w,ss+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(ss[<span class="number">1</span>]==<span class="string">&#x27;R&#x27;</span>)t=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(ss[<span class="number">1</span>]==<span class="string">&#x27;G&#x27;</span>)t=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> t=<span class="number">2</span>;</span><br><span class="line">        e[i]=&#123;x,y,w,t&#125;;</span><br><span class="line">        zans+=w;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)ans[i]=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">pd</span>(<span class="number">0</span>,<span class="number">-1</span>,<span class="number">-1</span>) &amp;&amp; <span class="built_in">pd</span>(<span class="number">2</span>,<span class="number">-1</span>,<span class="number">-1</span>))&#123;</span><br><span class="line">        ans[m]=zans;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=m<span class="number">-1</span>;i&gt;=<span class="number">1</span>;i--)&#123;</span><br><span class="line">            <span class="built_in">build</span>();</span><br><span class="line">            <span class="keyword">if</span>(!<span class="built_in">solve</span>())<span class="keyword">break</span>;</span><br><span class="line">            ans[i]=zans;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></details>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>拟阵</tag>
      </tags>
  </entry>
  <entry>
    <title>Treelection</title>
    <url>/2024/02/11/Treelection/</url>
    <content><![CDATA[<p>题目链接：<a href="https://qoj.ac/contest/1259/problem/6638">https://qoj.ac/contest/1259/problem/6638</a></p>
<p>题目大意：给一棵以 $1$ 为根的树，举办一场投票，每个人只能向祖先投票，问每个点存不存在一种情况使得这个点的得票数严格大于其他点的得票数。（根不投票）</p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>考虑一个事情，一个子树大小为 $x$ 的点可以当选，那么显然一个子树大小 $y&gt;x$ 的点也一定可以当选，但是 $y=x$ 呢？</p>
<p>显然如果子树大小为 $x$ 的点的形状不是菊花就行，如果是菊花的话就还得另外考虑。</p>
<p>于是我们就发现，答案结构应该是存在一个 $limit$ ，$siz&gt;limit$ 一定可以，$siz=limit$ 得看情况（且必要条件是子树得是个菊花），考虑怎么找这个 limit ，显然得二分，但是怎么判断 $&gt;mid$ 的子树全都可以呢？</p>
<p>观察上述结论的证明过程，发现关键在于对于一个点 $x$ ，子树大小为 $siz$ ，要求每个点的得票数 $&lt;siz-1$ 时，这个子树能内部消化自己的得票数（也就是不是菊花），也就是说，存在一种情况使得整棵树的得票数的最大值 $&lt;siz-1$ ，因此做法就出来了。</p>
<p>如果存在一个情况，使得整棵树的得票数最大值 $\le mid-1$ ，那么 $limit \le mid$ ，显然树形DP即可。</p>
<p>在找到 $limit$ 后，考虑处理 $siz=limit$ 的点，用树形 DP 跑一遍每个点的最大容量只有 $limit-2$ 的情况，显然，只有当根节点得票数为 $limit-1$ 且这个点的 $siz=limit$ 且这个点到根节点这条路径上一直存在 $dp$ 值的有效转移时，这个点才是可以当选的点，否则不符合这种情况。（显然，能符合上述要求的点，子树一定是个菊花，这也符合上面的讨论）</p>
<p>时间复杂度：$O(n\log{n})$ </p>
<p>注：代码的实现思路和上面说的略有不同。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e6</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> p[N],siz[N],n;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="built_in">memset</span>(siz+<span class="number">1</span>,<span class="number">0</span>,<span class="built_in">sizeof</span>(<span class="type">int</span>)*n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;p[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=n;i&gt;=<span class="number">1</span>;i--)&#123;</span><br><span class="line">        siz[i]+=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(i!=<span class="number">1</span>)siz[p[i]]+=siz[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> f[N];<span class="type">bool</span> v[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">check</span><span class="params">(<span class="type">int</span> U)</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(f+<span class="number">1</span>,<span class="number">0</span>,<span class="built_in">sizeof</span>(<span class="type">int</span>)*n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=n;i&gt;=<span class="number">2</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(f[i]&lt;=U)v[i]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> v[i]=<span class="number">1</span>;</span><br><span class="line">        f[p[i]]+=<span class="built_in">max</span>(f[i]-U,<span class="number">0</span>)+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f[<span class="number">1</span>]-U;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">char</span> ac[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;1\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> l=<span class="number">3</span>,r=n+<span class="number">1</span>,mid,ans;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;=r)&#123;</span><br><span class="line">        mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">check</span>(mid<span class="number">-2</span>)&lt;=<span class="number">0</span>)r=mid<span class="number">-1</span>,ans=mid;</span><br><span class="line">        <span class="keyword">else</span> l=mid+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(siz[i]&gt;=ans)ac[i]=<span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">        <span class="keyword">else</span> ac[i]=<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ac[<span class="number">1</span>]=<span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">    <span class="keyword">if</span>(ans!=<span class="number">2</span> &amp;&amp; <span class="built_in">check</span>(ans<span class="number">-3</span>)==<span class="number">1</span>)&#123;</span><br><span class="line">        v[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(v[p[i]] &amp;&amp; v[i])v[i]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> v[i]=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(v[i] &amp;&amp; siz[i]==ans<span class="number">-1</span>)ac[i]=<span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ac[n+<span class="number">1</span>]=<span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,ac+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> T;<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></details>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>二分</tag>
        <tag>树形DP</tag>
      </tags>
  </entry>
  <entry>
    <title>The 2nd Universal Cup Semifinals L. Slay the Spire</title>
    <url>/2024/07/06/The-2nd-Universal-Cup-Semifinals-L-Slay-the-Spire/</url>
    <content><![CDATA[<p>题目链接：<a href="https://contest.ucup.ac/contest/1708/problem/8824">https://contest.ucup.ac/contest/1708/problem/8824</a></p>
<p>题目大意：给你 $n$ 张卡，卡的效果为将你变成 $c_i$ 状态，同时如果之前你处于 $a_{i}$ 状态，那么你对敌人造成 $b_{i}$ 点攻击，还有 $k$ 瓶药，效果是直接变成 $x_{i}$ 状态，然后给你初始状态，问你能造成的最大伤害。</p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>显然卡牌和药全用完最优，然后我们可以变成，构建一条欧拉路径，使得权值和最大，权值定义为，能把卡片效果用出来的边，即如果一张卡牌是 $x\to y$ ，而我们也确实让这张卡牌这么干了。</p>
<p>又可以注意到，我们可以把终点和起点连起来，变成欧拉回路，即我们添加一瓶能到初始状态的药，然后要求最终回到初始状态，这两个问题显然是等价的。</p>
<p>这样，每个点的总入度是知道的，现在问题在于，我们能保留多少张卡牌的效果。</p>
<p>一个显然的事情是：一个点有多少入度，我们就会保留等量的从大到小的以这个点为起始点的卡牌。</p>
<p>但有一个问题，这样不一定连通。</p>
<p>我们不妨统计选的边所贡献的入度和出度，显然一个点的出度小于等于这个点的总入度。</p>
<p>可以发现，这个选法有效当且仅当，将单向边当成双向边后，一个连通块的总入度和 $&gt;$ 出度和。</p>
<p>思考一下什么时候等于，一个连通块的出度和等于入度和，入度 $\le$ 总入度，即总入度等于入度，所以这个连通块中所选择的边就是这个连通块所有的入边，即这个连通块没有块外的边连进来，同时因为入度等于总入读等于出度，所以这个连通块还是个欧拉图（单向边的情况下）。</p>
<p>现在要尝试花最小的代价使得其合法化，不妨猜一下，要么删除一条边，或者删除一条边，加入一条同起点的连向块外的边。</p>
<p>首先这一定是合法的，由于原来是欧拉图，所以一定强连通，所以连通块内仍连通，同时连通块的入度和等于总入度和等价于其中每个点都等于，而删除或者替换都会使原连通块不满足后者，所以新的连通块一定不满足。</p>
<p>问题是这为什么是最优的呢？</p>
<p>首先如果一开始没有孤立的团，那么显然是对的，假设有，假设有 $k$ 个，将点集分成 $k+1$ 部分，$X_1,X_2,…,X_{k+1}$ ，其中最后一个为补集。</p>
<p>尝试用局部最优的方法证明上面的那种选法就是上界，考虑每个集合中的点选出边，显然都会优先选最优的，但是任何方案都不可能包含 $X_{i}(i\le m)$ 的最优选法，所以每个方案至多包含 $X_{i}$ 的次优方案，所以每个方案的权值和 $\le$ $X_{1},…,X_{k}$ 的次优方案和 $X_{k+1}$ 的最优方案，而这个上界是能达到的，也就是上面那个东西，证毕。</p>
<p>时间复杂度：$O((n+k)\log{n+k}+m\log_{m})$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">1e9</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">5e2</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M = <span class="number">2e3</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n, m, K, st, in[N];</span><br><span class="line">vector&lt;PII&gt; e[N];</span><br><span class="line"><span class="type">int</span> fa[N], inc[N], outc[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">findfa</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="keyword">return</span> fa[x] == x ? x : fa[x] = <span class="built_in">findfa</span>(fa[x]);&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mer</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    x = <span class="built_in">findfa</span>(x);</span><br><span class="line">    y = <span class="built_in">findfa</span>(y);</span><br><span class="line">    <span class="keyword">if</span>(x != y)&#123;</span><br><span class="line">        fa[x] = y;</span><br><span class="line">        inc[y] += inc[x];</span><br><span class="line">        outc[y] += outc[x];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; u[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="built_in">memset</span>(in, <span class="number">0</span>, <span class="built_in">sizeof</span>(in));</span><br><span class="line">        cin &gt;&gt; n &gt;&gt; m &gt;&gt; K &gt;&gt; st;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) e[i].<span class="built_in">clear</span>(), u[i].<span class="built_in">clear</span>();</span><br><span class="line">        in[st]++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="type">int</span> x, c, y;</span><br><span class="line">            cin &gt;&gt; x &gt;&gt; c &gt;&gt; y;</span><br><span class="line">            e[x].<span class="built_in">push_back</span>(&#123;c, y&#125;);</span><br><span class="line">            in[y]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= K; i++)&#123;</span><br><span class="line">            <span class="type">int</span> x;</span><br><span class="line">            cin &gt;&gt; x;</span><br><span class="line">            in[x]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">            fa[i] = i;</span><br><span class="line">            inc[i] = in[i];</span><br><span class="line">            outc[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        LL ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">            <span class="built_in">sort</span>(e[i].<span class="built_in">begin</span>(), e[i].<span class="built_in">end</span>(), [](PII x, PII y)&#123;<span class="keyword">return</span> x.first &gt; y.first;&#125;);</span><br><span class="line">            <span class="type">int</span> cnt = in[i];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> [c, y] : e[i])&#123;</span><br><span class="line">                <span class="keyword">if</span>(!cnt) <span class="keyword">break</span>;</span><br><span class="line">                cnt--;</span><br><span class="line">                ans += c;</span><br><span class="line">                <span class="built_in">mer</span>(i, y);</span><br><span class="line">                outc[<span class="built_in">findfa</span>(i)]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) u[<span class="built_in">findfa</span>(i)].<span class="built_in">push_back</span>(i);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(fa[i] == i &amp;&amp; inc[i] == outc[i] &amp;&amp; inc[i])&#123;</span><br><span class="line">                <span class="type">int</span> tmp = <span class="number">1e9</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">auto</span> x : u[i])&#123;</span><br><span class="line">                    <span class="built_in">assert</span>(in[x]);</span><br><span class="line">                    <span class="keyword">if</span>(e[x].<span class="built_in">size</span>() &gt; in[x]) tmp = <span class="built_in">min</span>(tmp, e[x][in[x] - <span class="number">1</span>].first - e[x][in[x]].first);</span><br><span class="line">                    <span class="keyword">else</span> tmp = <span class="built_in">min</span>(e[x].<span class="built_in">back</span>().first, tmp);</span><br><span class="line">                &#125;</span><br><span class="line">                ans -= tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以为什么才开到 $5000$ ，这么能诈骗，要是 $200000$ 我赛时就做这题了。</p>
<p>和官方题解基本一致，不过我是从保留的角度考虑的，题解是从删除的角度考虑的，本质是一样的。</p>
</div></details>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
  </entry>
  <entry>
    <title>The 3rd Ucup Stage 2: M. Balance of Permutation</title>
    <url>/2024/06/27/The-3rd-Ucup-Stage-2-M-Balance-of-Permutation/</url>
    <content><![CDATA[<p>题目链接：<a href="https://contest.ucup.ac/contest/1699/problem/8529">https://contest.ucup.ac/contest/1699/problem/8529</a></p>
<p>题目大意：求长度为 $n$ 字典序排名为 $k$ 的满足 $\sum\limits_{|p_i-i|}=b$ 的排列。</p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>一开始看到数据范围这么小，下意识觉得可能是某种非常 interesting 的 meet in middle ，然后再优化了大半天状态以后发现好像可以直接多项式 $dp$ ，真是闹麻了。</p>
<p>注意到一个事情，如果观察 $\ge k$ 的数字和位置，可以发现有两种状态：空着和已经填上了，而且数字和位置同一状态的数量是一样的。</p>
<p>可以注意到，空着的数字或者位置总是要填的，而由于我们是按顺序枚举的，所以其的贡献已经可以算了，他们在绝对值中一定是大减小中的大者，按照这个思路直接 $dp$ 就行了。</p>
<p>单次枚举的时间复杂度是 ：$O(n^4)$ ，然后填数是 $O(n^2)$ 的，不过填数是从左到右的，方便起见，枚举也可以从小到大枚举。</p>
<p>这样就是 $O(n^6)$ 的。</p>
<p>代码也不难写。</p>
<p>但是呢，队长说题解的复杂度好像是 $O(n^5)$ 的，于是我接着想。（虽然后面看了题解发现是 $O(n^6)$ 的）</p>
<p>注意到一个事情，什么 $n$ 是可以被优化掉的，就是枚举这个位置放什么，我们可以锁住这个位置，不让这个位置放东西，然后前缀 $dp$ 一遍，后缀 $dp$ 一遍，当我要放 $val$ 的时候，就把 $val-1$ 的前缀和 $val+1$ 的后缀拿出来求出这个的贡献，就能优化掉一个 $n$ 。</p>
<p>原理类似于本来 $dp$ 合并是一个卷积，但是如果只用求特定项的系数，就可以线性求出。</p>
<p>最终时间复杂度：$O(n^5)$ 。</p>
<p>然后我就喜提 5.4k 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="keyword">typedef</span> __int128 IT;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">35</span>;</span><br><span class="line"><span class="comment">// &gt;=  and  &lt;</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getz</span><span class="params">(T &amp;x)</span></span>&#123;</span><br><span class="line">    x = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(c &gt; <span class="string">&#x27;9&#x27;</span> || c &lt; <span class="string">&#x27;0&#x27;</span>) c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(c &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;9&#x27;</span>) x = (x &lt;&lt; <span class="number">3</span>) + (x &lt;&lt; <span class="number">1</span>) + (c - <span class="string">&#x27;0&#x27;</span>), c = <span class="built_in">getchar</span>();</span><br><span class="line">&#125;</span><br><span class="line">IT fl[N * <span class="number">2</span>][N][N * N * <span class="number">2</span>], fr[N * <span class="number">2</span>][N][N * N * <span class="number">2</span>], fc[N];</span><br><span class="line"><span class="type">int</span> v0[N], v1[N];</span><br><span class="line"><span class="type">int</span> vsl0[N][N], vsl1[N][N]; <span class="comment">//&lt;=</span></span><br><span class="line"><span class="type">int</span> vsr0[N][N], vsr1[N][N]; <span class="comment">//&gt;=</span></span><br><span class="line"><span class="type">int</span> n, S, a[N], Sb;</span><br><span class="line">IT K;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> ban)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> l = <span class="number">1</span>; l &lt;= n; l++)&#123;<span class="comment">//limit</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            vsl0[l][i] = vsl0[l][i - <span class="number">1</span>] + ((i == ban) || (v0[i] &amp;&amp; v0[i] &gt;= l));</span><br><span class="line">            vsl1[l][i] = vsl1[l][i - <span class="number">1</span>] + (v1[i] &amp;&amp; v1[i] &gt;= l);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = n; i &gt;= <span class="number">1</span>; i--)&#123;</span><br><span class="line">            vsr0[l][i] = vsr0[l][i + <span class="number">1</span>] + ((i == ban) || (v0[i] &amp;&amp; v0[i] &lt;= l));</span><br><span class="line">            vsr1[l][i] = vsr1[l][i + <span class="number">1</span>] + (v1[i] &amp;&amp; v1[i] &lt;= l);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addposleft</span><span class="params">(<span class="type">int</span> t, <span class="type">int</span> id, <span class="type">int</span> ban)</span></span>&#123;<span class="comment">//id - 1 -&gt; id;</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n / <span class="number">2</span> + <span class="number">1</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> s = <span class="number">0</span>; s &lt;= Sb + Sb + Sb; s++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!fl[id - <span class="number">1</span>][i][s]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(t == ban || v0[t])&#123;</span><br><span class="line">                <span class="keyword">if</span>(t == ban || v0[t] &gt;= t) <span class="comment">/*-*/</span> fl[id][i + <span class="number">1</span>][s - t] += fl[id - <span class="number">1</span>][i][s];</span><br><span class="line">                <span class="keyword">else</span> <span class="comment">/*+*/</span> fl[id][i][s + t] += fl[id - <span class="number">1</span>][i][s];</span><br><span class="line">                    </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                fl[id][i + <span class="number">1</span>][s - t] += fl[id - <span class="number">1</span>][i][s];<span class="comment">//-</span></span><br><span class="line">                <span class="keyword">if</span>(i) fl[id][i][s + t] += fl[id - <span class="number">1</span>][i][s] * (i - vsl1[t][t - <span class="number">1</span>]);<span class="comment">//+</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addnumleft</span><span class="params">(<span class="type">int</span> t, <span class="type">int</span> id)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n / <span class="number">2</span> + <span class="number">1</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> s = <span class="number">0</span>; s &lt;= Sb + Sb + Sb; s++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!fl[id - <span class="number">1</span>][i][s]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(v1[t])&#123;</span><br><span class="line">                <span class="keyword">if</span>(v1[t] &gt; t) <span class="comment">/*-*/</span> fl[id][i][s - t] += fl[id - <span class="number">1</span>][i][s];</span><br><span class="line">                <span class="keyword">else</span> <span class="comment">/*+*/</span> fl[id][i - <span class="number">1</span>][s + t] += fl[id - <span class="number">1</span>][i][s];</span><br><span class="line">                    </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                fl[id][i][s - t] += fl[id - <span class="number">1</span>][i][s];<span class="comment">//-</span></span><br><span class="line">                <span class="keyword">if</span>(i) fl[id][i - <span class="number">1</span>][s + t] += fl[id - <span class="number">1</span>][i][s] * (i - vsl0[t][t]);<span class="comment">//+</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addnumright</span><span class="params">(<span class="type">int</span> t, <span class="type">int</span> id)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n / <span class="number">2</span> + <span class="number">1</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> s = <span class="number">0</span>; s &lt;= Sb + Sb + Sb; s++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!fr[id + <span class="number">1</span>][i][s]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(v1[t])&#123;</span><br><span class="line">                <span class="keyword">if</span>(v1[t] &lt;= t) <span class="comment">/*+*/</span> fr[id][i + <span class="number">1</span>][s + t] += fr[id + <span class="number">1</span>][i][s];</span><br><span class="line">                <span class="keyword">else</span> <span class="comment">/*-*/</span> fr[id][i][s - t] += fr[id + <span class="number">1</span>][i][s];</span><br><span class="line">                    </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                fr[id][i + <span class="number">1</span>][s + t] += fr[id + <span class="number">1</span>][i][s]; <span class="comment">//+</span></span><br><span class="line">                <span class="keyword">if</span>(i) fr[id][i][s - t] += fr[id + <span class="number">1</span>][i][s] * (i - vsr0[t][t + <span class="number">1</span>]); <span class="comment">//-</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addposright</span><span class="params">(<span class="type">int</span> t, <span class="type">int</span> id, <span class="type">int</span> ban)</span></span>&#123;<span class="comment">//id + 1 -&gt; id;</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n / <span class="number">2</span> + <span class="number">1</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> s = <span class="number">0</span>; s &lt;= Sb + Sb + Sb; s++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!fr[id + <span class="number">1</span>][i][s]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(t == ban || v0[t])&#123;</span><br><span class="line">                <span class="keyword">if</span>(t == ban || v0[t] &lt; t) <span class="comment">/*+*/</span> fr[id][i][s + t] += fr[id + <span class="number">1</span>][i][s];</span><br><span class="line">                <span class="keyword">else</span> <span class="comment">/*-*/</span> fr[id][i - <span class="number">1</span>][s - t] += fr[id + <span class="number">1</span>][i][s];</span><br><span class="line">                    </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                fr[id][i][s + t] += fr[id + <span class="number">1</span>][i][s]; <span class="comment">//+</span></span><br><span class="line">                <span class="keyword">if</span>(i) fr[id][i - <span class="number">1</span>][s - t] += fr[id + <span class="number">1</span>][i][s] * (i - vsr1[t][t]); <span class="comment">//-</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin.<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">getz</span>(n); Sb = n * (n + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">getz</span>(S);</span><br><span class="line">    <span class="built_in">getz</span>(K);</span><br><span class="line">    fc[<span class="number">0</span>] = <span class="number">1</span>; <span class="keyword">for</span>(<span class="type">int</span> t = <span class="number">1</span>; t &lt;= n; t++) fc[t] = fc[t - <span class="number">1</span>] * t;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> t = <span class="number">1</span>; t &lt;= n; t++)&#123;</span><br><span class="line">        <span class="built_in">memset</span>(fl, <span class="number">0</span>, <span class="built_in">sizeof</span>(fl));</span><br><span class="line">        <span class="built_in">memset</span>(fr, <span class="number">0</span>, <span class="built_in">sizeof</span>(fr));</span><br><span class="line">        fl[<span class="number">0</span>][<span class="number">0</span>][Sb] = <span class="number">1</span>;</span><br><span class="line">        fr[n + n + <span class="number">1</span>][<span class="number">0</span>][Sb] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        v0[t] = <span class="number">-1</span>;</span><br><span class="line">        <span class="built_in">init</span>(t);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="built_in">addposleft</span>(i, i * <span class="number">2</span> - <span class="number">1</span>, t);</span><br><span class="line">            <span class="built_in">addnumleft</span>(i, i * <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = n; i &gt;= <span class="number">1</span>; i--)&#123;</span><br><span class="line">            <span class="built_in">addnumright</span>(i, i * <span class="number">2</span>);</span><br><span class="line">            <span class="built_in">addposright</span>(i, i * <span class="number">2</span> - <span class="number">1</span>, t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(v1[i]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="type">int</span> l = i * <span class="number">2</span> - <span class="number">1</span>, r = i * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">            IT now = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> jl = <span class="number">1</span>; jl &lt;= n / <span class="number">2</span> + <span class="number">1</span>; jl++)&#123;</span><br><span class="line">                IT k;</span><br><span class="line">                <span class="type">int</span> jr, c;</span><br><span class="line">                <span class="keyword">if</span>(i &lt; t)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(jl - vsl0[i][i] &lt; <span class="number">0</span> || jl - <span class="number">1</span> - vsl1[i + <span class="number">1</span>][i - <span class="number">1</span>] &lt; <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">                    jr = jl;</span><br><span class="line">                    k = fc[jl - vsl0[i][i]] * fc[jl - <span class="number">1</span> - vsl1[i + <span class="number">1</span>][i - <span class="number">1</span>]];</span><br><span class="line">                    c = -i;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(jl - <span class="number">1</span> - vsr0[i][i + <span class="number">1</span>] &lt; <span class="number">0</span> || jl - <span class="number">1</span> - vsr1[i][i + <span class="number">1</span>] &lt; <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">                    jr = jl - <span class="number">1</span>;</span><br><span class="line">                    k = fc[jl - <span class="number">1</span> - vsr0[i][i + <span class="number">1</span>]] * fc[jl - <span class="number">1</span> - vsr1[i][i + <span class="number">1</span>]];</span><br><span class="line">                    c = i;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> sl = <span class="number">0</span>; sl &lt;= Sb + Sb + Sb; sl++)&#123;</span><br><span class="line">                    <span class="type">int</span> sr = Sb + Sb + S - (sl + c);</span><br><span class="line">                    <span class="keyword">if</span>(sr &gt; Sb + Sb + Sb || sr &lt; <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">if</span>(fl[l][jl][sl] &amp;&amp; fr[r][jr][sr])&#123;</span><br><span class="line">                        now += fl[l][jl][sl] * fr[r][jr][sr] * k;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(now &lt; K) K -= now;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                v0[t] = i;</span><br><span class="line">                v1[i] = t;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        cout &lt;&lt; v0[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不过会长的最主要原因是有 $4$ 个长的几乎一样但是又不能合并的函数。</p>
<p>真是艹了。</p>
<p>官方题解和 $n^6$ 的做法基本一样，在此不再赘述。</p>
<p>但是有个问题，$n^6$ 我会写多长呢？</p>
<p>答案是 2.2k 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> __int128 IT;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">35</span>;</span><br><span class="line">IT dp[<span class="number">2</span>][N][N * N * <span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sw</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">swap</span>(dp[<span class="number">0</span>], dp[<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">memset</span>(dp[<span class="number">0</span>], <span class="number">0</span>, <span class="built_in">sizeof</span>(dp[<span class="number">0</span>]));</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> base;</span><br><span class="line"><span class="type">int</span> n, B;</span><br><span class="line">IT K;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getz</span><span class="params">(<span class="keyword">auto</span> &amp;x)</span></span>&#123;</span><br><span class="line">    x = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(c &lt; <span class="string">&#x27;0&#x27;</span> || c &gt; <span class="string">&#x27;9&#x27;</span>) c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(c &lt;= <span class="string">&#x27;9&#x27;</span> &amp;&amp; c &gt;= <span class="string">&#x27;0&#x27;</span>) x = (x &lt;&lt; <span class="number">3</span>) + (x &lt;&lt; <span class="number">1</span>) + (c - <span class="string">&#x27;0&#x27;</span>), c = <span class="built_in">getchar</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> m1[N], m2[N];<span class="comment">// 1 : seat , 2 : number</span></span><br><span class="line"><span class="type">int</span> c1[N], c2[N];</span><br><span class="line"><span class="function">IT <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        c1[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= i; j++) c1[i] += (m1[j] &amp;&amp; m1[j] &gt;= i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        c2[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt; i; j++) c2[i] += (m2[j] &amp;&amp; m2[j] &gt;= i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sw</span>();</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>][base] = <span class="number">1ll</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="built_in">sw</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; j++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt;= base * <span class="number">3</span>; k++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!dp[<span class="number">1</span>][j][k]) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(!(m1[i] &amp;&amp; m1[i] &lt; i) &amp;&amp; k &gt;= i) dp[<span class="number">0</span>][j + <span class="number">1</span>][k - i] += dp[<span class="number">1</span>][j][k]; <span class="comment">//-</span></span><br><span class="line">                <span class="keyword">if</span>(!(m1[i] &amp;&amp; m1[i] &gt;= i))&#123;</span><br><span class="line">                    <span class="keyword">if</span>(m1[i]) dp[<span class="number">0</span>][j][k + i] += dp[<span class="number">1</span>][j][k];</span><br><span class="line">                    <span class="keyword">else</span> dp[<span class="number">0</span>][j][k + i] += dp[<span class="number">1</span>][j][k] * (j - c2[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sw</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= i; j++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt;= base * <span class="number">3</span>; k++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!dp[<span class="number">1</span>][j][k]) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(!(m2[i] &amp;&amp; m2[i] &lt;= i) &amp;&amp; k &gt;= i) dp[<span class="number">0</span>][j][k - i] += dp[<span class="number">1</span>][j][k];</span><br><span class="line">                <span class="keyword">if</span>(!(m2[i] &amp;&amp; m2[i] &gt; i))&#123;</span><br><span class="line">                    <span class="keyword">if</span>(m2[i]) dp[<span class="number">0</span>][j - <span class="number">1</span>][k + i] += dp[<span class="number">1</span>][j][k];</span><br><span class="line">                    <span class="keyword">else</span> dp[<span class="number">0</span>][j - <span class="number">1</span>][k + i] += dp[<span class="number">1</span>][j][k] * (j - c1[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>][<span class="number">0</span>][base + B];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">getz</span>(n); <span class="built_in">getz</span>(B); <span class="built_in">getz</span>(K);</span><br><span class="line">    base = n * (n + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(m2[j]) <span class="keyword">continue</span>;</span><br><span class="line">            m1[i] = j;</span><br><span class="line">            m2[j] = i;</span><br><span class="line">            IT rk = <span class="built_in">solve</span>();</span><br><span class="line">            <span class="keyword">if</span>(rk &lt; K) K -= rk;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">            m1[i] = <span class="number">0</span>;</span><br><span class="line">            m2[j] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) cout &lt;&lt; m1[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>短了一半，好写多了，真是艹了。</p>
<p>但是还是有点长，学习一下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//https://contest.ucup.ac/submission/442419</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> i128=__int128;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">31</span>;</span><br><span class="line"><span class="type">int</span> n,b,g[N],p[N];</span><br><span class="line">i128 f[N][N][N*N];</span><br><span class="line">string K;</span><br><span class="line"><span class="function">i128 <span class="title">val</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(f,<span class="number">0</span>,<span class="keyword">sizeof</span> f);</span><br><span class="line">	<span class="type">int</span> cnt=<span class="number">0</span>,m=n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="keyword">if</span>(p[i]) cnt+=<span class="built_in">abs</span>(i-p[i]),m--;</span><br><span class="line">	f[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		<span class="type">int</span> c0=<span class="number">0</span>,c1=<span class="number">0</span>,t0=<span class="number">0</span>,t1=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;i;j++) c0+=!p[j],c1+=!g[j];</span><br><span class="line">		t0+=c0+(!p[i]);t1+=c1+(!g[i]);</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=<span class="built_in">min</span>(t0,t1);j++) <span class="keyword">for</span>(<span class="type">int</span> t=t0+t1-j*<span class="number">2</span>,k=t;k&lt;=b-cnt;k++)&#123;</span><br><span class="line">			f[i][j][k]=f[i<span class="number">-1</span>][j][k-t];</span><br><span class="line">			<span class="keyword">if</span>(!g[i]&amp;&amp;j) f[i][j][k]+=(c0-j+<span class="number">1</span>)*f[i<span class="number">-1</span>][j<span class="number">-1</span>][k-t];</span><br><span class="line">			<span class="keyword">if</span>(!p[i]&amp;&amp;j) f[i][j][k]+=(c1-j+<span class="number">1</span>)*f[i<span class="number">-1</span>][j<span class="number">-1</span>][k-t];</span><br><span class="line">			<span class="keyword">if</span>(!g[i]&amp;&amp;!p[i]&amp;&amp;j) f[i][j][k]+=f[i<span class="number">-1</span>][j<span class="number">-1</span>][k-t];</span><br><span class="line">			<span class="keyword">if</span>(!g[i]&amp;&amp;!p[i]&amp;&amp;j&gt;<span class="number">1</span>) f[i][j][k]+=(c0-j+<span class="number">2</span>)*(c1-j+<span class="number">2</span>)*f[i<span class="number">-1</span>][j<span class="number">-2</span>][k-t];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> f[n][m][b-cnt];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	cin.<span class="built_in">tie</span>(<span class="number">0</span>)-&gt;<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;b&gt;&gt;K;</span><br><span class="line">	i128 k=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> x:K) k=k*<span class="number">10</span>+x-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++) <span class="keyword">if</span>(!g[j])&#123;</span><br><span class="line">		g[j]=i;p[i]=j;</span><br><span class="line">		i128 cnt=<span class="built_in">val</span>();</span><br><span class="line">		<span class="keyword">if</span>(cnt&gt;=k)&#123;</span><br><span class="line">			cout&lt;&lt;j&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		k-=cnt;g[j]=<span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>$dp$ 外的部分没什么区别，但是 $dp$ 内的部分有很大区别，区别主要有 $3$ 个。</p>
<ol>
<li><p>我第二维记录的是还没成对的位置和数字，这有一个问题，虽然这两个数量确实相等，但是由于未成对里面可能有已经成对但是还没添加进来的数字或位置，这就导致在后面计算乘的系数的时候比较麻烦。</p>
<p>而他记录的是已经成了多少对（忽略外面成对的数字），这样遇到已经在外面成对的数字或者位置可以直接跳过，甚至后面计算系数也好算。</p>
</li>
<li>第三维，我记录的是每个数字的贡献，因此基础下标是 $\frac{n(n+1)}{2}$ ，但是他的贡献是实时算的，什么意思呢，就是如果我有 $k$ 个数字或位置在下面，每次往上移动一格，贡献为 $k$ ，而且忽略了外面成对数字的贡献，好处就是成对的数字或者位置可以直接跳过，而且 $dp$ 范围非常的自然。</li>
<li><p>我添加数字或者位置写了两个循环，但是他是合并了，至于这个，我觉得没有优劣之分。</p>
<p>主要是这两个添加时的判断都很少，所以合并起来也少。但是如果两个添加时有很多判断，合并起来实现复杂度是乘一起的。相比之下，虽然我的做法多了一层循环，但是条理更加清晰，犯错概率更低，所以我的代码之所以比他长，我觉得主要原因是前两条，而不是这一条，我觉得这一条各有优劣，没有对错之分。</p>
</li>
</ol>
<p>还是实现麻烦了，还得学，还得多练。</p>
</div></details>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>计数</tag>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>UR1 缩进优化</title>
    <url>/2023/08/22/UR1-%E7%BC%A9%E8%BF%9B%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<p>题目链接：<a href="https://uoj.ac/contest/3/problem/21">https://uoj.ac/contest/3/problem/21</a></p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
</div></details>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>调和级数</tag>
      </tags>
  </entry>
  <entry>
    <title>UR1 外星人</title>
    <url>/2023/08/22/UR1-%E5%A4%96%E6%98%9F%E4%BA%BA/</url>
    <content><![CDATA[<p>题目链接：<a href="https://uoj.ac/problem/22">https://uoj.ac/problem/22</a></p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>经典 trick 。</p>
<p>简单来说，对于 $x$ 个有标号的数字，让指定的数字站在开头的概率是多少？</p>
<p>答案：$\frac{1}{x}$ 。</p>
<p>证法：</p>
<ol>
<li>从随机性的角度考虑，第一个位置是某个数字的概率为 $\frac{1}{x}$ 。</li>
<li>从式子的角度分析：$\frac{(x-1)!}{x!}=\frac{1}{x}$ 。</li>
</ol>
<p>现在规定有 $y$ 个数字必须在某些数字前面，且对于第 $i$ 个数字，其必须在前面的数字包括其自己所构成的集合为 $S_i$ 。</p>
<p>如果满足：$S_{i}\subseteq S_{i-1}$ 。</p>
<p>那么概率的计算公式为：$\prod \frac{1}{|S_{i}|}$ 。</p>
<p>证法：</p>
<p>我们顺序考虑，假如第一个数字是 $x$ ，$S_1/x$ 的元素都要在其后面，那么为 $\frac{1}{S_1}$ ，显然剩下元素仍然是随机的，现在把 $S_1/S_2$ 的元素删掉，考虑 $S_2$ 的元素，其仍然是随机的，且不受前面影响，完全是一个子问题，那么直接乘就行了。</p>
<p>证毕。</p>
<p>这是一个很经典的概率 trick ，但是一定要谨记其的使用范围。</p>
<p>比如我稍微改变一下上面的条件，让 $S_i$ 不包含 $x$ 就已经错了。</p>
<p>例如：$1,2$ 都要在 $3$ 前面，那么：$\frac{1}{4}$ ，显然是错的。</p>
<p>为什么？原因是接下来的序列并不是一个完全的子问题，原因是：</p>
<p>例如 $13$ ，这个时候放 $2$ ，$23$ 的情况有两种：$213,123$ ，而 $32$ 的情况只有一种：$132$ ，所以并不满足不受前面影响这句话。</p>
<p>当然，也可以采用式子严谨证明：</p>
<p>显然，结果为：</p>
<p>定义 $|S_0|=n+1$ 。</p>
<p>公式为：$(\prod\limits_{i=1}^{m} C_{|S_{i-1}|-1}^{|S_i|}<em>(|S_{i-1}|-1-|S_{i}|)!)</em>\frac{(S_{m}-1)!}{S_{m}!}$ 。</p>
<p>展开可以发现就是结论中的式子。而上面的反例显然就是不满足这条计算公式，所以也就不能使用结论中的计算式进行计算。</p>
<p>利用这个 trick ，这道题目就随便做了，做法就不详写了，自己想想。</p>
<p>UPD：看了官方题解突然发现，貌似这道题目不用这个 trick 也能做，本质上是把官方题解的式子优化了一下。</p>
</div></details>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>经典trick</tag>
        <tag>概率</tag>
      </tags>
  </entry>
  <entry>
    <title>UR3-铀仓库</title>
    <url>/2023/08/25/UR3-%E9%93%80%E4%BB%93%E5%BA%93/</url>
    <content><![CDATA[<p>题目链接：<a href="https://uoj.ac/contest/5/problem/49">https://uoj.ac/contest/5/problem/49</a></p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>CNM，血压高了，一直卡在官方题解中的算法 2 ，根本就没有想到是二分答案，悲。</p>
<p>首先，一个十分显然的事情，这题有两种不同的二分方法：</p>
<ol>
<li>如果指定左右两边最远的到达距离，你可以在 $O(n)$ 的时间内对所有位置处理出其对应的区间，但是由于二分最远到达距离只能作用在一个数上，所以时间复杂度是： $O(n\log{n}\log_{X})$ ，也就是算法二。</li>
<li>既然答案要求箱子数，就二分箱子数 $K$ ，同理，可以在 $O(n)$ 的时间处理出对应的区间，然后算一下最小代价就行了，时间复杂度：$O(n\log{X})$ ，这就是题解的做法。</li>
</ol>
<p>为什么啊，纯二分题没有做出来，你真的是越来越菜了QAQ。</p>
<p>处理细节：考虑处理出包含 $x$ 的最长的区间，满足两个要求：</p>
<ol>
<li>区间内的箱子数和 $&lt;K$。</li>
<li>区间为这个位置搬箱子最优方案的一种。</li>
</ol>
<p>什么叫搬箱子的最优方案，显然：优先搬最近的。</p>
<p>所以每次把最近的不在区间中的位置加入区间所得到的任意一个方案都是最优方案。</p>
<p>可以证明，这个区间的左右端点会随着位置右移而非严格递增。</p>
<p>然后直接写就行了。</p>
<p>时间复杂度：$O(n\log{X})$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 510000</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line">LL a[N],fa[N],ff[N],b[N],sum,T;</span><br><span class="line">LL limit;</span><br><span class="line"><span class="type">int</span> n,left,right;</span><br><span class="line"><span class="function">LL <span class="title">dis</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;<span class="keyword">return</span> b[y]-b[x];&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve1</span><span class="params">(<span class="type">int</span> i)</span></span>&#123;<span class="keyword">while</span>(<span class="built_in">dis</span>(left,i)&gt;<span class="built_in">dis</span>(i,right) &amp;&amp; sum&gt;limit)sum-=a[left++];&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">()</span></span>&#123;</span><br><span class="line">    sum=<span class="number">0</span>;left=<span class="number">1</span>;right=<span class="number">0</span>;</span><br><span class="line">    LL mincost=T+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(right&lt;i)right++,sum+=a[right];</span><br><span class="line">        <span class="built_in">solve1</span>(i);</span><br><span class="line">        <span class="keyword">while</span>(right&lt;n &amp;&amp; (left==<span class="number">1</span> || <span class="built_in">dis</span>(left<span class="number">-1</span>,i)&gt;<span class="built_in">dis</span>(i,right+<span class="number">1</span>)) &amp;&amp; sum&lt;=limit)&#123;</span><br><span class="line">            right++,sum+=a[right];</span><br><span class="line">            <span class="built_in">solve1</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(sum&gt;limit)sum-=a[right--];</span><br><span class="line">        LL now=ff[right]-ff[i]-b[i]*(fa[right]-fa[i])+b[i]*(fa[i<span class="number">-1</span>]-fa[left<span class="number">-1</span>])-(ff[i<span class="number">-1</span>]-ff[left<span class="number">-1</span>]);</span><br><span class="line">        LL fnow=T+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(left&gt;<span class="number">1</span>)fnow=<span class="built_in">min</span>(<span class="built_in">dis</span>(left<span class="number">-1</span>,i)*(limit-sum),fnow);</span><br><span class="line">        <span class="keyword">if</span>(right&lt;n)fnow=<span class="built_in">min</span>(<span class="built_in">dis</span>(i,right+<span class="number">1</span>)*(limit-sum),fnow);</span><br><span class="line">        <span class="keyword">if</span>(left==<span class="number">1</span> &amp;&amp; right==n)fnow=<span class="number">0</span>;</span><br><span class="line">        mincost=<span class="built_in">min</span>(mincost,now+fnow);</span><br><span class="line">        <span class="comment">// printf(&quot;%d:%d %d %lld %lld %lld %lld\n&quot;,i,left,right,sum,mincost,now,fnow);</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mincost*<span class="number">2</span>&lt;=T;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// freopen(&quot;std.in&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%lld&quot;</span>,&amp;n,&amp;T);</span><br><span class="line">    LL l=<span class="number">0</span>,r=<span class="number">0</span>,ans;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;b[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;<span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;a[i]);l=<span class="built_in">max</span>(a[i],l);r+=a[i];fa[i]=fa[i<span class="number">-1</span>]+a[i];&#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)ff[i]=ff[i<span class="number">-1</span>]+b[i]*a[i];</span><br><span class="line">    <span class="comment">// printf(&quot;%lld %lld\n&quot;,l,r);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// limit=11;printf(&quot;%d\n&quot;,check());</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(l&lt;=r)&#123;</span><br><span class="line">        limit=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">check</span>())ans=limit,l=limit+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> r=limit<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></details>]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title>UKIEPC 2020 A. Arrange The Piranhas</title>
    <url>/2024/07/03/UKIEPC-2020-A-Arrange-The-Piranhas/</url>
    <content><![CDATA[<p>题目链接：<a href="https://qoj.ac/contest/531/problem/875">https://qoj.ac/contest/531/problem/875</a></p>
<p>题目大意： $n$ 个格子，有 $k$ 条食人鱼，每个格子只有至多一条食人鱼，每秒你可以把手指放到一个没有食人鱼的格子里，然后左右两边离你手指最近的食人鱼会朝你游动一格，要求移动后和你手指不在同一格里面，问最少需要多少秒才能变成目标状态。</p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>相当于把 $n$ 个格子切成 $k+1$ 份，每次操作可以将一个区间 $-2$ ，两边区间 $+1$ ，要求操作后的区间长度 $\ge 2$。（也就是差分，但需要注意的是两边的区间略有区别）</p>
<p>可以发现，根据目标状态可以列出 $k$ 个方程，设 $f_i$ 表示操作区间 $i$ 多少次。</p>
<p>那么有：$f_{i+1}-f_{i}=d_{i}-p_i$ ，可以把所有的 $f$ 用 $f_1$ 表示，显然所有 $f$ 都是非负的。</p>
<p>找到最小的 $f_1$ 使得所有 $f$ 非空，不妨猜测此时的 $f$ 的和就是答案。</p>
<p>这样就只需要验证是否可行就行了，显然 $f$ 的和是 $O(nk^2)$ 的（ $f_i$ 是 $O(nk)$ 的），直接验证就行了，时间复杂度：$O(nk^2)$ 。（题解做法）</p>
<p>什么叫直接验证呢？就是注意到一个区间如果能操作，那么不操作他他一直都处于能操作的状态，所以先后顺序无所谓，直接操作就行了，或者更准确的说，如果不操作一个区间，随着别的区间的操作，这个区间的可操作性是单调不降的，所以以任意顺序操作可操作的区间就是对的。</p>
<p>但是有没有更加快速的搞法呢？（毕竟正常人哪会想到，$n,k,1000$ 最终复杂度是 $O(nk^2)$ 的）</p>
<p>有，我们可以对一个前缀先操作到不能操作位置，然后找到最长的还需要操作的后缀，观察其每个区间的长度，一定是每个区间的长度 $\le 2$ （特殊的，对于第一个区间，我们给其 $+1$ ），然后可以发现，每次前缀外输送进来一个 $1$ ，会引发后缀一串连续的 $2$ 各操作一次（即操作一段连续的区间）。具体可以自己手模一下这个过程，就知道了。</p>
<p>因此，我们从左到右维护前缀，采用增量法的方式进行操作，这样给前缀输送 $1$ 的次数是多少次呢？注意到如果 $i≠k+1$ ，每次操作 $i$ ，不仅像 $i-1$ 这个前缀输送 $1$ ，也会像后输送 $1$ ，所以至多 $n$ 次，即 $nk$ 次，当 $i=k+1$ 时，其的操作次数是 $O(nk)$ 的，所以也至多输送 $O(nk)$ 次，综上，输送 $1$ 的次数是 $O(nk)$ 次的，</p>
<p>发现往前缀输送 $1$ 所引起的变化的这个过程是可以线段树维护的，于是就做完了，时间复杂度：$O(nk\log{k})$ 。</p>
<p>注：可以注意到，在同一个前缀下，不断给这个前缀的最后一个位置添加 $1$ ，后缀最长的连续的 $2$ 的长度，在没有位置操作次数达到的情况下，至多减少 $1$ ，而操作次数到的时候会把这个位置 $ban$ 掉，但至多 ban $k+1$ 次，而且，前缀变化也至多 $k+1$ 次，所以综上，后缀最长的连续的 $2$ 的长度至多变化 $O(nk)$ ，所以可以直接维护。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e3</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">1e9</span>;</span><br><span class="line"><span class="comment">// struct node&#123;</span></span><br><span class="line"><span class="comment">//     int lc, rc;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> a[N], b[N], c[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Tree</span>&#123;</span><br><span class="line">    <span class="type">int</span> lc, rc;</span><br><span class="line">    <span class="type">int</span> val, lazy;</span><br><span class="line">&#125;tr[N * <span class="number">2</span>]; <span class="type">int</span> cnt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushlazy</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">    tr[x].val += k;</span><br><span class="line">    tr[x].lazy += k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tr[x].lazy)&#123;</span><br><span class="line">        <span class="built_in">pushlazy</span>(tr[x].lc, tr[x].lazy);</span><br><span class="line">        <span class="built_in">pushlazy</span>(tr[x].rc, tr[x].lazy);</span><br><span class="line">        tr[x].lazy = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;tr[x].val = <span class="built_in">min</span>(tr[tr[x].lc].val, tr[tr[x].rc].val);&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bt</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> x = ++cnt;</span><br><span class="line">    tr[x].val = inf;</span><br><span class="line">    <span class="keyword">if</span>(l &lt; r)&#123;</span><br><span class="line">        <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        tr[x].lc = <span class="built_in">bt</span>(l, mid);</span><br><span class="line">        tr[x].rc = <span class="built_in">bt</span>(mid + <span class="number">1</span>, r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">findpos</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> l, <span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tr[x].val &gt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(l == r) <span class="keyword">return</span> l;</span><br><span class="line">    <span class="built_in">pushdown</span>(x);</span><br><span class="line">    <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> ans = <span class="built_in">findpos</span>(tr[x].rc, mid + <span class="number">1</span>, r);</span><br><span class="line">    <span class="keyword">if</span>(!ans) ans = <span class="built_in">findpos</span>(tr[x].lc, l, mid);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">change</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> ll, <span class="type">int</span> rr, <span class="type">int</span> k, <span class="type">int</span> type)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(r &lt; ll || l &gt; rr || ll &gt; rr) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">if</span>(l &gt;= ll &amp;&amp; r &lt;= rr)&#123;</span><br><span class="line">        <span class="keyword">if</span>(type == <span class="number">0</span>) <span class="built_in">pushlazy</span>(x, k);</span><br><span class="line">        <span class="keyword">else</span> tr[x].val = k, tr[x].lazy = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pushdown</span>(x);</span><br><span class="line">    <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">change</span>(tr[x].lc, l, mid, ll, rr, k, type);</span><br><span class="line">    <span class="built_in">change</span>(tr[x].rc, mid + <span class="number">1</span>, r, ll, rr, k, type);</span><br><span class="line">    <span class="built_in">update</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> now;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">change</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> s)</span></span>&#123;</span><br><span class="line">    a[x] = s;</span><br><span class="line">    <span class="keyword">if</span>(s != <span class="number">2</span>) now = <span class="built_in">max</span>(x + <span class="number">1</span>, now);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">maintain</span><span class="params">(<span class="type">int</span> f)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(now &lt;= f &amp;&amp; a[now] != <span class="number">2</span>) now++;</span><br><span class="line">    <span class="keyword">while</span>(now &gt; <span class="number">1</span> &amp;&amp; a[now - <span class="number">1</span>] == <span class="number">2</span>) now--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">oper</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x == <span class="number">1</span>) a[x] --, a[x + <span class="number">1</span>] ++;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(x == m) a[x] --;</span><br><span class="line">    <span class="keyword">else</span> a[x] -= <span class="number">2</span>, a[x + <span class="number">1</span>] ++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) cin &gt;&gt; a[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) cin &gt;&gt; b[i];</span><br><span class="line">    <span class="type">int</span> base = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">        c[i + <span class="number">1</span>] = c[i] + b[i] - a[i];</span><br><span class="line">        base = <span class="built_in">min</span>(base, c[i + <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//r[i] - l[i] = b[i] - a[i]</span></span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m + <span class="number">1</span>; i++) c[i] -= base, ans += c[i];</span><br><span class="line">    m++;</span><br><span class="line">    <span class="built_in">bt</span>(<span class="number">1</span>, m);</span><br><span class="line"></span><br><span class="line">    a[m] = n + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = m; i &gt;= <span class="number">1</span>; i--) a[i] = a[i] - a[i - <span class="number">1</span>] - <span class="number">1</span>;</span><br><span class="line">    a[<span class="number">1</span>]++; a[m]++;</span><br><span class="line"></span><br><span class="line">    now = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(c[i] &amp;&amp; a[i] &gt;= <span class="number">3</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(now &lt;= i - <span class="number">1</span>) a[i]++;</span><br><span class="line">            <span class="built_in">change</span>(<span class="number">1</span>, <span class="number">1</span>, m, now, i - <span class="number">1</span>, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span>(now != <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="type">int</span> pre = now;</span><br><span class="line">                <span class="keyword">if</span>(pre != i) <span class="built_in">change</span>(pre, <span class="number">1</span>);</span><br><span class="line">                <span class="built_in">change</span>(pre - <span class="number">1</span>, a[pre - <span class="number">1</span>] == <span class="number">-1</span> ? <span class="number">-1</span> : a[pre - <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">                <span class="built_in">maintain</span>(i - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(tr[<span class="number">1</span>].val == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="type">int</span> pos = <span class="built_in">findpos</span>(<span class="number">1</span>, <span class="number">1</span>, m);</span><br><span class="line">                <span class="built_in">change</span>(<span class="number">1</span>, <span class="number">1</span>, m, pos, pos, inf, <span class="number">1</span>);</span><br><span class="line">                <span class="built_in">change</span>(pos, <span class="number">-1</span>);</span><br><span class="line">                <span class="comment">// maintain(i - 1);</span></span><br><span class="line">            &#125;</span><br><span class="line">            c[i]--;</span><br><span class="line">            <span class="built_in">oper</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!c[i]) <span class="built_in">change</span>(i, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">assert</span>(a[i] &lt;= <span class="number">2</span>);</span><br><span class="line">            <span class="built_in">change</span>(i, a[i]);</span><br><span class="line">            <span class="built_in">change</span>(<span class="number">1</span>, <span class="number">1</span>, m, i, i, c[i], <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// maintain(i);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(tr[<span class="number">1</span>].val &lt;= n * n) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        cout &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">solve</span>()) cout &lt;&lt; <span class="string">&quot;impossible\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><details class="toggle" ><summary class="toggle-button" style="">证明</summary><div class="toggle-content"><p>假设现在有一个合法方案：$g_1,g_2,…,g_{k+1}(g_i&gt;0)$ ，现在证明 $g_1-1,g_2-1,…,g_{k+1}-1$ 也是合法的。</p></p>
<p>反证法，假设不行，我们先一直操作到不能操作为止。</p>
<p>这样，需要操作但是不能操作的区间又连续的构成一些区间，我们把其中一个区间拉出来。</p>
<p>显然，在合法方案 $g_{1},g_{2},…,g_{k+1}$ 下按照同样的顺序操作到这一步，这个区间也没办法全部操作两次及以上。（讨论一下就行了，至多一次）</p>
<p>所以矛盾，证毕。</p>
</div></details>
<p>还能更快吗？</p>
<p>其实是可以 $O(nk)$ 的。</p>
<p>注意到线段树维护的次数是一个后缀减，后缀查是否 $&lt;0$ ，而这我们可以维护一个严格递增的单调栈（即维护目前所有的后缀最小值），栈用链表维护，两个元素之间维护差值，同时维护链头的值，每次后缀减相当于在链表的某个位置减，但是代码前的注释可以知道，后缀连续 $2$ 的长度变化为 $O(nk)$ ，即后缀减长度变化至多 $O(nk)$ ，所以可以直接暴力在链表上跳。</p>
<p>但是这样我们并没有实际性的维护操作次数，最后怎么验证合法呢？</p>
<p>两个方法：</p>
<ol>
<li>每次把区间减在外面差分操作一下，最后前缀和算一下是否都等于 $0$ 。</li>
<li>至于算操作次数是否对上了，因为我们不会让一个位置的实际操作次数 $&gt;$ 需要的操作次数。</li>
</ol>
<p>这样，就能在 $O(nk)$ 的时间解决此题。</p>
<p>因为代码太难写了，所以没有代码。<del>摆了</del></p></div></details>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
  </entry>
  <entry>
    <title>The 3rd Ucup Stage 2: E. Pattern Search II</title>
    <url>/2024/06/27/The-3rd-Ucup-Stage-2-E-Pattern-Search-II/</url>
    <content><![CDATA[<p>题目链接：<a href="https://contest.ucup.ac/contest/1699/problem/8521">https://contest.ucup.ac/contest/1699/problem/8521</a></p>
<p>题目大意：略。</p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>很有意思的 dp ，如果一开始想对了方向就会很简单，但是一旦一开始想错了方向，就会花很多时间了。</p>
<p>$fl[i][j]/fr[i][j]$ 表示的是从 $S_{i}$ 左边往右边/右边往左边匹配 $T$ 的从 $j$ 开始的前缀/后缀能匹配都多少，如果能完整匹配就记录所需的最短长度。</p>
<p>转移是显然的，记录答案的时候需要注意，由于 $fl,fr$ 只能记录 $S$ 前缀或者后缀的最小值，而如果我们想要知道 $S$ 内部的答案，就需要枚举。</p>
<p>注意到若答案在 $S_i$ 内部，我们先把 $S_i$ 用 $S_{i-1},S_{i-2}$ 表示，答案要么还在里面，要么横跨两个串，即不断下去，答案一定可以跨过：$S_{i}S_{j}(|i-j|\le 1)$ ，或者答案的长度为 $1$ 。</p>
<p>但问题来了，我们要枚举 $i$ 到什么地步为止？</p>
<p>我们设 $t$ 表示最小的 $t$ 满足 $S_{t}\ge 3n$ （不难证明，不会有连续三个 $a$ ，连续两个 $b$，所以当 $S_{t}\ge 3n$ 时，$T$ 一定是其子序列）</p>
<p>因此如果把字符串表示成 $S_{t},S_{t+1}$ 的组合，答案一定不会跨过三个字符串，所以 $i\le t+1$ 就行了。</p>
<p>时间复杂度：$O(n\log{n})$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> L = <span class="number">40</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_char_array</span><span class="params">(<span class="type">char</span> *s)</span></span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">char</span> ss[N];</span><br><span class="line">    cin &gt;&gt; ss;</span><br><span class="line">    <span class="built_in">memcpy</span>(s + <span class="number">1</span>, ss, <span class="built_in">strlen</span>(ss) + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// left to right</span></span><br><span class="line"><span class="comment">// right to left</span></span><br><span class="line"><span class="type">int</span> dp[L][<span class="number">2</span>][N];<span class="comment">//&gt;=0 num &lt;0 len</span></span><br><span class="line"><span class="type">char</span> st[N];</span><br><span class="line"><span class="type">int</span> n, f[L];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">get_char_array</span>(st);</span><br><span class="line">    n = <span class="built_in">strlen</span>(st + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>)&#123;</span><br><span class="line">        cout &lt;&lt; <span class="number">1</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">2</span> &amp;&amp; st[<span class="number">1</span>] == <span class="string">&#x27;a&#x27;</span> &amp;&amp; st[<span class="number">2</span>] == <span class="string">&#x27;b&#x27;</span>)&#123;</span><br><span class="line">        cout &lt;&lt; <span class="number">2</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    只要第一次满足匹配的 t &gt;= 3 就可以在下面求出答案，所以对 t=0,1,2 特判。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(st[i] == <span class="string">&#x27;a&#x27;</span>) dp[<span class="number">1</span>][<span class="number">0</span>][i] = dp[<span class="number">1</span>][<span class="number">1</span>][i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(st[i] == <span class="string">&#x27;b&#x27;</span>) dp[<span class="number">0</span>][<span class="number">0</span>][i] = dp[<span class="number">0</span>][<span class="number">1</span>][i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> t = <span class="number">0</span>; t &lt;= <span class="number">1</span>; t++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i + dp[t][<span class="number">0</span>][i] == n + <span class="number">1</span>) dp[t][<span class="number">0</span>][i] = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">if</span>(i - dp[t][<span class="number">1</span>][i] == <span class="number">0</span>) dp[t][<span class="number">1</span>][i] = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    f[<span class="number">0</span>] = f[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">-1e9</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> t = <span class="number">2</span>; ; t++)&#123;</span><br><span class="line">        f[t] = f[t - <span class="number">1</span>] + f[t - <span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dp[t - <span class="number">1</span>][<span class="number">0</span>][i] &lt; <span class="number">0</span>) dp[t][<span class="number">0</span>][i] = dp[t - <span class="number">1</span>][<span class="number">0</span>][i];</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="type">int</span> j = i + dp[t - <span class="number">1</span>][<span class="number">0</span>][i];</span><br><span class="line">                <span class="keyword">if</span>(dp[t - <span class="number">2</span>][<span class="number">0</span>][j] &lt; <span class="number">0</span>) dp[t][<span class="number">0</span>][i] = dp[t - <span class="number">2</span>][<span class="number">0</span>][j] - f[t - <span class="number">1</span>];</span><br><span class="line">                <span class="keyword">else</span> dp[t][<span class="number">0</span>][i] = dp[t - <span class="number">2</span>][<span class="number">0</span>][j] + dp[t - <span class="number">1</span>][<span class="number">0</span>][i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(dp[t - <span class="number">2</span>][<span class="number">1</span>][i] &lt; <span class="number">0</span>) dp[t][<span class="number">1</span>][i] = dp[t - <span class="number">2</span>][<span class="number">1</span>][i];</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="type">int</span> j = i - dp[t - <span class="number">2</span>][<span class="number">1</span>][i];</span><br><span class="line">                <span class="keyword">if</span>(dp[t - <span class="number">1</span>][<span class="number">1</span>][j] &lt; <span class="number">0</span>) dp[t][<span class="number">1</span>][i] = dp[t - <span class="number">1</span>][<span class="number">1</span>][j] - f[t - <span class="number">2</span>];</span><br><span class="line">                <span class="keyword">else</span> dp[t][<span class="number">1</span>][i] = dp[t - <span class="number">1</span>][<span class="number">1</span>][j] + dp[t - <span class="number">2</span>][<span class="number">1</span>][i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dp[t][<span class="number">1</span>][i] &lt; <span class="number">0</span> &amp;&amp; dp[t - <span class="number">1</span>][<span class="number">0</span>][i + <span class="number">1</span>] &lt; <span class="number">0</span>) ans = <span class="built_in">max</span>(ans, dp[t][<span class="number">1</span>][i] + dp[t - <span class="number">1</span>][<span class="number">0</span>][i + <span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">if</span>(dp[t][<span class="number">1</span>][i] &lt; <span class="number">0</span> &amp;&amp; dp[t][<span class="number">0</span>][i + <span class="number">1</span>] &lt; <span class="number">0</span>) ans = <span class="built_in">max</span>(ans, dp[t][<span class="number">1</span>][i] + dp[t][<span class="number">0</span>][i + <span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">if</span>(dp[t - <span class="number">1</span>][<span class="number">1</span>][i] &lt; <span class="number">0</span> &amp;&amp; dp[t][<span class="number">0</span>][i + <span class="number">1</span>] &lt; <span class="number">0</span>) ans = <span class="built_in">max</span>(ans, dp[t - <span class="number">1</span>][<span class="number">1</span>][i] + dp[t][<span class="number">0</span>][i + <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(f[t - <span class="number">1</span>] &gt;= n * <span class="number">3</span>)&#123;</span><br><span class="line">            <span class="built_in">assert</span>(dp[t - <span class="number">1</span>][<span class="number">0</span>][<span class="number">1</span>] &lt; <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; -ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><details class="toggle" ><summary class="toggle-button" style="">当时想题时记录的一些性质</summary><div class="toggle-content"><p>注意放 $a(0)$ 还是 $b(1)$ 可以用下面的方法生成：</p></p>
<p>初始有个全 $0$ 的串，每次在最左边放 $1$ ，然后没有相邻两个 $1$ ，就删掉向右边进 $1$ ，即每个 $1$ 分别表示：$1,2,3,5,…$ 。</p>
<p>然后第一个是 $0/1$ 代表了是放 $a$ 还是 $b$ 。</p>
<ol>
<li><p>1…. 后面一定是 b。</p>
</li>
<li><p>不会有aaa…. ，与下面同理，1… 的结构在两次 aa 后一定会生成</p>
</li>
<li><p>不会有连续三个 aa ：</p>
</li>
</ol>
<p>0100000000….   b<br>0010000000….   a<br>1010000000….   a<br>0001000000….   b<br>1001000000….   a<br>0101000000….   b</p>
<p>0000100000….   b<br>0000100000….   a<br>1000100000….   a<br>0100100000….   b<br>0010100000….   a<br>1010100000….   a<br>0000010000….   b<br>1000010000….   a<br>0100010000….   b</p>
<p>0101010000….   b<br>0000001000….   a<br>1000001000….   a<br>0100001000….   b<br>0010001000….   a<br>1010001000….   a<br>0001001000….   b<br>1000001000….   a<br>0100001000….   b</p>
<p>逻辑，当 001 这种结构生成的时候，接下来一定会是：abab 的形式。</p>
<p>而这种结构两次一定会生成成功。</p>
<ol>
<li><p>不会有连续三个 ab ，同样的逻辑，当 01 生成时，接下来一定是：aa，同理一定会生成。</p>
</li>
<li><p>综上，任何一个前缀在两次经过后一定会生成。</p>
</li>
<li><p>一定不会有连续两个 ab ，逻辑：研究 babab 的结构，发现一开始必须是 001 ，矛盾。</p>
</li>
</ol>
</div></details>
<p>感觉这个 $dp$ 非常的有意思，用 $dp$ 来完成了匹配，感觉以前没有见过。</p>
<p>和官方做法基本一致，在此不再赘述。</p></div></details>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>UR4 元旦激光炮</title>
    <url>/2023/08/24/UR4-%E5%85%83%E6%97%A6%E6%BF%80%E5%85%89%E7%82%AE/</url>
    <content><![CDATA[<p>题目链接：<a href="https://uoj.ac/problem/52">https://uoj.ac/problem/52</a></p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>题解做法不难想到，每次把 $K$ 均摊到三个数组，查询三次，最小的那个数字显然一定在 $\le K$  的范围内。</p>
<p>操作次数：$n\log_{\frac{n}{n-1}}{K}$ 左右。</p>
<p>但是这个做法存在优化的空间：</p>
<ol>
<li>我们每次查询三个数组位置的和为 $K$ ，这个限制太强了，可以考虑放宽这个限制。</li>
<li>我们只利用到了最小的数字一定在 $\le K$ 的性质，没有利用到 最大的数字一定在 $\ge K$ 的性质。（但是上面那个做法每个数组查询的位置非严格单调递减，所以上面那个算法无法利用该性质进行优化。）</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;kth.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> cnt[<span class="number">3</span>],ff[<span class="number">3</span>],fucknow[<span class="number">3</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getans</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> type)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(type==<span class="number">0</span>)<span class="keyword">return</span> <span class="built_in">get_a</span>(x);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(type==<span class="number">1</span>)<span class="keyword">return</span> <span class="built_in">get_b</span>(x);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">get_c</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> lastans=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">solve1</span><span class="params">(<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(k)&#123;</span><br><span class="line">        <span class="type">int</span> pre=<span class="number">-1</span>,preval=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">2</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cnt[i]&lt;ff[i])&#123;</span><br><span class="line">                <span class="type">int</span> now=<span class="built_in">getans</span>(cnt[i],i);</span><br><span class="line">                <span class="keyword">if</span>(pre==<span class="number">-1</span> || <span class="built_in">now</span>&lt;preval)preval=now,pre=i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cnt[pre]++;k--;</span><br><span class="line">        lastans=preval;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> lastans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> id[<span class="number">10</span>];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;<span class="keyword">return</span> (ff[x]-cnt[x])&gt;(ff[y]-cnt[y]);&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">solve2</span><span class="params">(<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">2</span>;i++)id[i]=i;</span><br><span class="line">    <span class="keyword">while</span>(k&gt;<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="type">int</span> now=k;</span><br><span class="line">        <span class="built_in">sort</span>(id,id+<span class="number">3</span>,cmp);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="type">int</span> x=id[i],s=<span class="built_in">min</span>(ff[x]-cnt[x],now/(i+<span class="number">1</span>));</span><br><span class="line">            now-=s;fucknow[x]=cnt[x]+s;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> pre=<span class="number">-1</span>,preval=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">2</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cnt[i]==ff[i])<span class="keyword">continue</span>;</span><br><span class="line">            <span class="type">int</span> now=<span class="built_in">getans</span>(fucknow[i]<span class="number">-1</span>,i);</span><br><span class="line">            <span class="keyword">if</span>(pre==<span class="number">-1</span> || preval&gt;now)preval=now,pre=i;</span><br><span class="line">        &#125;</span><br><span class="line">        k-=fucknow[pre]-cnt[pre];cnt[pre]=fucknow[pre];</span><br><span class="line">        lastans=preval;</span><br><span class="line">        <span class="comment">// printf(&quot;%d\n&quot;,k);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">solve1</span>(k);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query_kth</span><span class="params">(<span class="type">int</span> n_a, <span class="type">int</span> n_b, <span class="type">int</span> n_c, <span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">    ff[<span class="number">0</span>]=n_a;ff[<span class="number">1</span>]=n_b;ff[<span class="number">2</span>]=n_c;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">solve2</span>(k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>基于二分的做法：</p>
<p>接下来阐释做法时默认数字不同，相同的情况加个浮动可以转化为不同的情况。</p>
<p>每个数组都有个 $[L,R]$ ,考虑查询每个数组的 $mid$ ，$mid$ 总和为 $sum$ ， $sum\ge sum$ ，那么最大的数字一定在 $\ge sum$ 的位置。</p>
<p>$&lt;sum$ ，那么最小的位置一定在 $&lt;sum$ 的位置。</p>
<p>然后二分就行了。</p>
<p>最后把所有 $\ge K$ 的数字拉出来跑个最小值就行了。（不用搜索次数，之前自动记录）</p>
<p>至于为什么是对的？</p>
<p>证明：</p>
<p>首先，最后每个数字都会分为两类 $&lt;K,\ge K$ ，那么显然 $\ge K$ 的数字中最小的那个就是 $=K$ 的数字，证毕。</p>
<p>注：准确来说，$\ge K$ 又分为 $\ge K$ 和 $\ge K+1$ ，同时，根据过程和定义，显然 $&lt;K$ 里面有恰好 $K-1$ 个数字。</p>
<p>操作次数：$n\log_{2}{K}$ 左右，显然，这个做法完全优于上面的做法。</p>
<p>还没有明白怎么做的可以直接看代码，很好看懂的，我讲的确实有点抽象。</p>
<p>代码来自：<a href="https://uoj.ac/submission/243331">https://uoj.ac/submission/243331</a> 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kth.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">   </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i,s,t) for(int i=(s),_t=(t);i&lt;_t;++i)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> per(i,s,t) for(int i=(t)-1,_s=(s);i&gt;=_s;--i)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> bug(x) cerr&lt;&lt;#x&lt;&lt;<span class="string">&quot; = &quot;</span>&lt;&lt;(x)&lt;&lt;<span class="string">&quot; &quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug(x) cerr&lt;&lt;#x&lt;&lt;<span class="string">&quot; = &quot;</span>&lt;&lt;(x)&lt;&lt;<span class="string">&quot;\n&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">double</span> db;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; pii;</span><br><span class="line">   </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;<span class="function"><span class="type">void</span> <span class="title">rd</span><span class="params">(T &amp;x)</span></span>&#123;</span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> f;<span class="type">static</span> <span class="type">char</span> c;</span><br><span class="line">	f=<span class="number">1</span>;x=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(c=<span class="built_in">getchar</span>(),c&lt;<span class="number">48</span>)<span class="keyword">if</span>(c==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">do</span> x=x*<span class="number">10</span>+(c&amp;<span class="number">15</span>);</span><br><span class="line">	<span class="keyword">while</span>(c=<span class="built_in">getchar</span>(),c&gt;<span class="number">47</span>);</span><br><span class="line">	x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;<span class="function"><span class="type">void</span> <span class="title">prin</span><span class="params">(T x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x&lt;<span class="number">0</span>)<span class="built_in">putchar</span>(<span class="string">&#x27;-&#x27;</span>),x=-x;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(!x)&#123;<span class="built_in">putchar</span>(<span class="string">&#x27;0&#x27;</span>);<span class="keyword">return</span> ;&#125;</span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> stk[<span class="number">100</span>],tp;</span><br><span class="line">	<span class="keyword">while</span>(x)stk[tp++]=x%<span class="number">10</span>,x/=<span class="number">10</span>;</span><br><span class="line">	<span class="keyword">while</span>(tp)<span class="built_in">putchar</span>(stk[--tp]^<span class="number">48</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;<span class="function"><span class="type">void</span> <span class="title">ptk</span><span class="params">(T x)</span></span>&#123;<span class="built_in">prin</span>(x);<span class="built_in">putchar</span>(<span class="string">&#x27; &#x27;</span>);&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;<span class="function"><span class="type">void</span> <span class="title">ptn</span><span class="params">(T x)</span></span>&#123;<span class="built_in">prin</span>(x);<span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;<span class="function"><span class="type">void</span> <span class="title">Min</span><span class="params">(T &amp;a,T b)</span></span>&#123;<span class="keyword">if</span>(b&lt;a)a=b;&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;<span class="function"><span class="type">void</span> <span class="title">Max</span><span class="params">(T &amp;a,T b)</span></span>&#123;<span class="keyword">if</span>(a&lt;b)a=b;&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=(<span class="type">int</span>)<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> A[N],B[N],C[N];</span><br><span class="line"><span class="comment">//int get_a(int x);</span></span><br><span class="line"><span class="comment">//int get_b(int x);</span></span><br><span class="line"><span class="comment">//int get_c(int x);</span></span><br><span class="line"><span class="comment">//int get_a(int x)&#123;</span></span><br><span class="line"><span class="comment">//	return 1;</span></span><br><span class="line"><span class="comment">//	</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//int get_b(int x)&#123;</span></span><br><span class="line"><span class="comment">//	return 1;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//int get_c(int x)&#123;</span></span><br><span class="line"><span class="comment">//	return 1;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Find_a</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(A[x])<span class="keyword">return</span> A[x];</span><br><span class="line">	<span class="keyword">return</span> A[x]=<span class="built_in">get_a</span>(x<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Find_b</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(B[x])<span class="keyword">return</span> B[x];</span><br><span class="line">	<span class="keyword">return</span> B[x]=<span class="built_in">get_b</span>(x<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Find_c</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(C[x])<span class="keyword">return</span> C[x];</span><br><span class="line">	<span class="keyword">return</span> C[x]=<span class="built_in">get_c</span>(x<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query_kth</span><span class="params">(<span class="type">int</span> na, <span class="type">int</span> nb, <span class="type">int</span> nc, <span class="type">int</span> K)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> L[<span class="number">3</span>]=&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,R[<span class="number">3</span>]=&#123;na,nb,nc&#125;,mid[<span class="number">3</span>],could[<span class="number">3</span>];</span><br><span class="line">	<span class="type">int</span> ans=(<span class="type">int</span>)<span class="number">1e9</span>;pii arr[<span class="number">3</span>];</span><br><span class="line">	<span class="keyword">while</span>(L[<span class="number">0</span>]&lt;=R[<span class="number">0</span>]||L[<span class="number">1</span>]&lt;=R[<span class="number">1</span>]||L[<span class="number">2</span>]&lt;=R[<span class="number">2</span>])&#123;</span><br><span class="line">		<span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">		<span class="built_in">rep</span>(i,<span class="number">0</span>,<span class="number">3</span>)&#123;</span><br><span class="line">			<span class="keyword">if</span>(L[i]&lt;=R[i])mid[i]=(L[i]+R[i])&gt;&gt;<span class="number">1</span>;</span><br><span class="line">			<span class="keyword">else</span> mid[i]=could[i];</span><br><span class="line">			sum+=mid[i];</span><br><span class="line">		&#125;</span><br><span class="line">		arr[<span class="number">0</span>]=<span class="built_in">pii</span>(<span class="built_in">Find_a</span>(mid[<span class="number">0</span>]),<span class="number">0</span>);</span><br><span class="line">		arr[<span class="number">1</span>]=<span class="built_in">pii</span>(<span class="built_in">Find_b</span>(mid[<span class="number">1</span>]),<span class="number">1</span>);</span><br><span class="line">		arr[<span class="number">2</span>]=<span class="built_in">pii</span>(<span class="built_in">Find_c</span>(mid[<span class="number">2</span>]),<span class="number">2</span>);</span><br><span class="line">		<span class="built_in">sort</span>(arr,arr+<span class="number">3</span>);</span><br><span class="line">		<span class="keyword">if</span>(sum&gt;=K)&#123;<span class="comment">//找最大的 </span></span><br><span class="line">			<span class="built_in">Min</span>(ans,arr[<span class="number">2</span>].fi);</span><br><span class="line">			<span class="built_in">per</span>(i,<span class="number">0</span>,<span class="number">3</span>)&#123;</span><br><span class="line">				<span class="keyword">if</span>(L[arr[i].se]&lt;=R[arr[i].se])&#123;</span><br><span class="line">					R[arr[i].se]=mid[arr[i].se]<span class="number">-1</span>;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;<span class="comment">//找最小的 </span></span><br><span class="line">			<span class="built_in">rep</span>(i,<span class="number">0</span>,<span class="number">3</span>)&#123;</span><br><span class="line">				<span class="keyword">if</span>(L[arr[i].se]&lt;=R[arr[i].se])&#123;</span><br><span class="line">					could[arr[i].se]=mid[arr[i].se];</span><br><span class="line">					L[arr[i].se]=mid[arr[i].se]+<span class="number">1</span>;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></details>]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>交互</tag>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title>Vizing 定理学习笔记</title>
    <url>/2024/05/28/Vizing-%E5%AE%9A%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>本来想一直咕咕咕的，结果没想到最近比赛用到了，这下不能咕了。</p>
<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>对于一个边染色，如果一个点有一条 $c$ 颜色的边，我们称 $c$ 在这个点上表现。</p>
<p>简单图：无重边和自环的无向图。（事实上有自环不影响 Vizing 定理的正确性，自环性质太好了，直接染上这个点没有表现的颜色就行了）</p>
<p>一个点的度数为 $d(x)$ ，其中 $\Delta = \max\limits_{x\in V}d(x)$ ，即最大度数。</p>
<p>对于一个边染色 $c$ ，一个点的表现颜色数为 $c(x)$ ，边的颜色为 $c(x,y)$ ，称一个边染色合法当且仅当对于每个点：$d(x)=c(x)$ ，即一个颜色不会在一个点重复出现两次，同时称此时的颜色数是合法的。</p>
<p>称一个染色方案 $c^{\prime}$ 为另一个染色方案 $c$ 的优化，当且仅当 ：$\forall c^{\prime}_{x}\ge c_{x}$ ，且存在 $x$ 是 $&gt;$ 号。</p>
<p>一个染色方案称为最优当且仅当其不能被优化，显然一个颜色数合法当且仅当其的其中一个最优染色方案合法。</p>
<p>称：$\chi$ 为最小的合法颜色数，显然的有：$\chi\ge \Delta$ 。</p>
<h1 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h1><p>引理 1 ：对于一个不是奇圈的连通图，存在一种两种颜色边染色（不一定合法）满足 ：$\forall x\in V,d(x)\ge 2 : c(x)\ge 2$ </p>
<details class="toggle" ><summary class="toggle-button" style="">证明</summary><div class="toggle-content"><p>假设图是一个欧拉图，即所有点度数为偶数，那么如果度数都为 $2$ ，就是一个环，显然必须得是偶环。</p>
<p>否则存在度数 $\ge 4$ 的点 $x$ ，以该点为起点做欧拉回路 ：$x-e_1-x_{1}-e_{2}-…-x$ ，那么每个点都一定在中间出现过一次，所以 $\forall x\in V, c(x)\ge 2$ 。（奇数和偶数的边为不同的颜色）</p>
<p>假设不是欧拉图，此时不可能是奇环，直接新建一个点 $t$ ，把所有奇点连向他，构成一个欧拉图，然后以 $t$ 为起点跑回路，显然这符合要求。</p>
</div></details>
<p>引理 2 ：一个方案最优的必要条件：若 $i_1$ 在 $x$ 处不表现，$i_2$ 表现两次，则 $E_{i_1}\cup E_{i_2}$ 中 $x$ 所在的连通块是个奇环。</p>
<details class="toggle" ><summary class="toggle-button" style="">证明</summary><div class="toggle-content"><p>显然，不是个奇环就存在两种颜色的染色，根据那种染色重新染上 $i_1,i_2$ ，则一定优化了，证毕。</p>
<p>本来想用增广路证明的，但是发现只能证明从 $x$ 出发的 $i_2-i_1-…$ 的增广路一定是个奇环，离证明连通块是个奇环还有点距离，遂放弃。</p>
</div></details>
<p>Vizing 定理：对于简单图，$\Delta \le \chi \le \Delta + 1$ </p>
<details class="toggle" ><summary class="toggle-button" style="">证明</summary><div class="toggle-content"><p>反证法，假设 $\chi &gt; \Delta+1$</p>
<p>我们假设一种 $\Delta + 1$ 的最优染色方案。</p>
<p>存在 $u:c(u)&lt;d(u)$ ，那么 $i_{0}$ 在 $x$ 上不表现，$i_{1}$ 表现两次，假设 $c(v_{1},u)=i_1$ ，$i_2$ 不在 $v_{1}$ 上表现，那么一定存在 $v_{2}$ ：$c(v_{2},u)=i_2$ ，否则能优化。</p>
<p>优化：$i_{l+1}$ 不在 $u$ 表示，那么给 $(u,v_{i})$ 染色 $i_{i+1}$ 色就可以优化了。</p>
<p>一直这样下去，直到：$\exist k:i_{k}=i_{l+1}$ （显然 $v$ 序列是不重复的），其中显然 $l\ge 2,k&lt;l$，也就是下面的 $a$ 图。</p>
<p><img src="1.png" alt=""></p>
<p>上面的图片截自参考资料中的视频，来源是 bondy 图论，很老的一个教材。</p>
<p>优化染色，若 $k&gt;1$ ，那么：</p>
<p>给 $\forall 1\le i &lt;k,c^{\prime}(u,v_{i})=i_{i+1}$ ，其余与 $c$ 一样。</p>
<p>和上面的 $b$ 图一样，这样 $E_{i_{0}}\cup E_{i_{k}}$ 中 $u$ 所在的连通块是一个奇环。</p>
<p>然后再基于 $c^{\prime}$ 构造一个新的染色：$\forall k\le i\le l,c^{\prime\prime}(u,v_{i})=i_{l+1}$ ，也就是上面的 $c$ 图，那么此时原来的奇环中，只有 $(u,v_{k})$ 消失了，则剩下的一定不是奇环，相对于 $c^{\prime\prime}$ 可以优化，可以验证，$c^{\prime\prime}$ 不劣于 $c$ ，所以这就构造了一个优化的方案，矛盾。</p>
<p>如果 $k=1$ 那么存在 $v≠v_{1}:c(u,v)=i_{1}$ ，则 $v,v_{1}$ 在奇环中，$\forall 1\le i\le l,c^{\prime}(u,v_{i})=i_{i+1}$ ，那么类似的，奇环断成链，可以优化，矛盾，证毕。</p>
<p>那么重边会导致什么问题呢？可能会导致 $v$ 序列有重复，注意到我们上面重新染色的时候，$c^{\prime}(u,v_{i})=i_{i+1}$ ，这个染色严格不劣的原因是 $i_{i+1}$ 在 $v_{i}$ 上不表现，但是如果 $v$ 序列有重复，就可能把 $v_{i}$ 的两个颜色染成 $i_{i+1}$ ，这样就可能导致更劣的结果，导致我们并没有得到更优的方案，证明不再成立。</p>
<p>一个简单的例子：三角形，但每条边重复两次，手模一下就知道我说的是什么意思了。</p>
</div></details>
<h1 id="补充结论"><a href="#补充结论" class="headerlink" title="补充结论"></a>补充结论</h1><ol>
<li><p>偶图一定是：$\chi = \Delta$ 。（证明：偶图没有奇环）</p>
</li>
<li><p>非简单图中，设 $u$ 是一条边重复次数的最大值，那么 $\chi\le \Delta + u$ ，我不会证明，这里放个讲解证明的视频：<a href="https://www.bilibili.com/video/BV1984y1V7Rx/?vd_source=5dd17c0f68b735f1a16d0353c08bcc7a">https://www.bilibili.com/video/BV1984y1V7Rx/?vd_source=5dd17c0f68b735f1a16d0353c08bcc7a</a> 。</p>
</li>
</ol>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p><a href="https://www.bilibili.com/video/BV1oT411j7Q8/?spm_id_from=333.788&amp;vd_source=5dd17c0f68b735f1a16d0353c08bcc7a">https://www.bilibili.com/video/BV1oT411j7Q8/?spm_id_from=333.788&amp;vd_source=5dd17c0f68b735f1a16d0353c08bcc7a</a></p>
<p><a href="https://www.bilibili.com/video/BV1984y1V7Rx/?vd_source=5dd17c0f68b735f1a16d0353c08bcc7a">https://www.bilibili.com/video/BV1984y1V7Rx/?vd_source=5dd17c0f68b735f1a16d0353c08bcc7a</a></p>
<p>这下 B 站真是学习网站了。</p>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>Vizing 定理</tag>
      </tags>
  </entry>
  <entry>
    <title>WC2016 论战捆竹竿</title>
    <url>/2024/03/18/WC2016-%E8%AE%BA%E6%88%98%E6%8D%86%E7%AB%B9%E7%AB%BF/</url>
    <content><![CDATA[<p>题目链接：<a href="https://www.luogu.com.cn/problem/P4156">https://www.luogu.com.cn/problem/P4156</a></p>
<p>题目大意：每一开始你有一个字符串 $s$ ，然后你可以在字符串末尾加入 $s$ 并删除末尾一个 $s$ 的 Border ，问你最终能得到多少个不超过 $w$ 的不同长度。</p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>首先，如何计数？观察到我们只要知道对于 $\forall k\in \{0,1,…,n-1\}$ ，最小的长度 $len_k$ 满足：$len_k\equiv k\mod{n}$ 。</p>
<p>这样就能够在 $O(n)$ 的时间内计算答案了。</p>
<p>这时一个很暴力的想法是求出所有的 Border 然后做同余最短路，时间复杂度 $O(n^2)$ 。</p>
<p>这个时候就要利用 Border 的性质做一些优化了，Border 有一个性质：能够把所有 Border 划分成恰好 $\log$ 段等差数列。</p>
<p>不妨将长度设为 $l,l+d,l+2d,…,l+(s-1)d$ 。</p>
<p>这时候还要观察到一个事情：如果把这个问题想象成背包，这个背包的体积和价值是一样的，这能够产生一个什么性质呢？不妨认为 $len_k\equiv t\mod{l}$ ，我们只要先在$\mod{l}$ 意义下跑出最小的 $len’_t$ ，然后再用 $len’_t$ 去更新 $len_k$ 即可。</p>
<p>前一部分可以用单调队列，后一部分连单调队列都不用。</p>
<p>时间复杂度：$O(Tn\log{n})$ 。</p>
<p>空间复杂度：$O(n)$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">5e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> NN=<span class="number">1e6</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> LL inf=<span class="number">1e18</span>+<span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;<span class="keyword">return</span> !x?y:<span class="built_in">gcd</span>(y%x,x);&#125;</span><br><span class="line"><span class="type">int</span> fail[N],n;LL m,dp[N],tmp[N];</span><br><span class="line"><span class="type">char</span> st[N];</span><br><span class="line">PII lis[NN];</span><br><span class="line"><span class="type">int</span> head,tail;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> s,<span class="type">int</span> d)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;l;i++)tmp[i]=inf+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)tmp[dp[i]%l]=<span class="built_in">min</span>(tmp[dp[i]%l],dp[i]);</span><br><span class="line">    <span class="type">int</span> g=<span class="built_in">gcd</span>(l,d);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;g;i++)&#123;</span><br><span class="line">        head=<span class="number">1</span>;tail=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> now=i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> lim=l/g*<span class="number">2</span>,ti=<span class="number">0</span>;lim;lim--,ti++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(head&lt;=tail &amp;&amp; ti-lis[head].second+<span class="number">1</span>&gt;s)head++;</span><br><span class="line">            <span class="keyword">if</span>(head&lt;=tail)tmp[now]=<span class="built_in">min</span>(tmp[now],tmp[lis[head].first]+<span class="number">1ll</span>*(ti-lis[head].second)*d+l);</span><br><span class="line">            <span class="keyword">while</span>(head&lt;=tail &amp;&amp; tmp[lis[tail].first]+(ti-lis[tail].second)*d&gt;tmp[now])tail--;</span><br><span class="line">            lis[++tail]=&#123;now,ti&#125;;</span><br><span class="line">            now=(now+d)%l;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;l;i++)&#123;</span><br><span class="line">        dp[tmp[i]%n]=<span class="built_in">min</span>(dp[tmp[i]%n],tmp[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    g=<span class="built_in">gcd</span>(l,n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;g;i++)&#123;</span><br><span class="line">        <span class="type">int</span> now=i;LL mi=inf;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> lim=n/g*<span class="number">2</span>;lim;lim--)&#123;</span><br><span class="line">            dp[now]=<span class="built_in">min</span>(dp[now],mi);</span><br><span class="line">            mi=<span class="built_in">min</span>(mi,dp[now])+l;</span><br><span class="line">            now=(now+l)%n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> T;<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%lld&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,st+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(m&lt;n)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;0\n&quot;</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        m-=n;</span><br><span class="line">        fail[<span class="number">0</span>]=<span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> now=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(now!=<span class="number">-1</span> &amp;&amp; st[now+<span class="number">1</span>]!=st[i])now=fail[now];</span><br><span class="line">            fail[i]=++now;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)dp[i]=inf+<span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        now=fail[n];</span><br><span class="line">        <span class="keyword">while</span>(now)&#123;</span><br><span class="line">            <span class="type">int</span> nex=fail[now];</span><br><span class="line">            <span class="keyword">if</span>(nex+nex&lt;now)<span class="built_in">solve</span>(n-now,<span class="number">1</span>,<span class="number">1</span>),now=nex;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="type">int</span> p=now-nex;</span><br><span class="line">                <span class="type">int</span> l=now%p+p;</span><br><span class="line">                <span class="built_in">solve</span>(n-now,(now-l)/p+<span class="number">1</span>,p);</span><br><span class="line">                now=l;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        LL ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dp[i]&lt;=m)ans+=(m-dp[i])/n+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我没做出来，我的评价是：菜就多练。</p>
<p>训，狠狠地训。</p>
</div></details>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>Border</tag>
        <tag>同余最短路</tag>
        <tag>单调队列</tag>
      </tags>
  </entry>
  <entry>
    <title>UR4-元旦三侠的游戏</title>
    <url>/2023/08/25/UR4-%E5%85%83%E6%97%A6%E4%B8%89%E4%BE%A0%E7%9A%84%E6%B8%B8%E6%88%8F/</url>
    <content><![CDATA[<p>题目链接：<a href="https://uoj.ac/problem/51">https://uoj.ac/problem/51</a></p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>这道题目主要涉及到了一个转化的问题。</p>
<p> SG 函数一般是使用在了没得走的时候为必败态，但是如果题目是走到了某个状态就输了要怎么转化呢？</p>
<p>答案是，我们认为玩家绝顶聪明，那显然不会去走那些输了的状态，也就是状态树中只会去走那些不会立即输的状态。（对应在本题中就是走后一定要 $a^b\le n$） </p>
<p>那么显然，当一个点没的走的时候，其是不是就一定输了，因为其下一步必定要走到判定为输的局面，这样我们就转化为了 $SG$ 的常见模型：没得走的状态为必败态。</p>
<p>这道题目也是同理，经过这种转化后，就是一个非常裸的 SG 函数了。</p>
<p>可以直接按题解写的做：$O(\sqrt{n}\log{n})$ ，但是感觉也存在更加优秀的做法。</p>
<p>就是观察发现状态只有 $0,1,2$ 三种，而且 $2$ 不会相邻，观察不难发现，同一个 $b$ 至多一个 $2$ ，记录一下 $2$ 的位置以及同一个 $b$ 的 SG 函数的一些参数，应该是可以做到 $O(\text{预处理}+m\log{n})$ 的时间做出来这道题目的。</p>
<p>但是感觉上就非常难写，以及有很多细节，有兴趣的读者可以自行尝试，我就不尝试了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 110000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> M 40</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n,m,a[M][N];</span><br><span class="line"><span class="type">int</span> b[M],top;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ksm</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> now=n;</span><br><span class="line">    <span class="keyword">while</span>(y)&#123;</span><br><span class="line">        <span class="keyword">if</span>(y&amp;<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(now&lt;x)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            now/=x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(y!=<span class="number">1</span> &amp;&amp; now/x&lt;x)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        x=x*x;y&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(y==<span class="number">1</span> &amp;&amp; x&gt;b[<span class="number">2</span>])<span class="keyword">return</span> (n-x)&amp;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> a[y][x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">findans</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> now=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(now==x || now==y)now++;</span><br><span class="line">    <span class="keyword">return</span> now;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// printf(&quot;%d\n&quot;,ksm(2,31));</span></span><br><span class="line"></span><br><span class="line">    b[top=<span class="number">1</span>]=n;</span><br><span class="line">    <span class="keyword">while</span>(b[top]&gt;<span class="number">1</span>)&#123;</span><br><span class="line">        b[++top]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">ksm</span>(b[top]+<span class="number">1</span>,top))b[top]++;</span><br><span class="line">    &#125;</span><br><span class="line">    top--;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=top;i&gt;=<span class="number">1</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="built_in">min</span>(b[i],b[<span class="number">2</span>]);j&gt;=<span class="number">2</span>;j--)&#123;</span><br><span class="line">            <span class="type">int</span> x=<span class="number">-1</span>,y=<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">if</span>(!(i==top || j&gt;b[i+<span class="number">1</span>]))x=a[i+<span class="number">1</span>][j];</span><br><span class="line">            <span class="keyword">if</span>(j!=b[i] &amp;&amp; !(i==<span class="number">1</span> &amp;&amp; j&gt;b[<span class="number">2</span>]))y=a[i][j+<span class="number">1</span>];</span><br><span class="line">            a[i][j]=<span class="built_in">findans</span>(x,y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// for(int i=1;i&lt;=top;i++)&#123;</span></span><br><span class="line">    <span class="comment">//     printf(&quot;%d %d: &quot;,i,b[i]);</span></span><br><span class="line">    <span class="comment">//     for(int j=2;j&lt;=b[i];j++)printf(&quot;%d &quot;,a[i][j]);</span></span><br><span class="line">    <span class="comment">//     printf(&quot;\n&quot;);</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="type">int</span> a,b;<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a,&amp;b);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">solve</span>(a,b))<span class="built_in">printf</span>(<span class="string">&quot;Yes\n&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;No\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></details>]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>SG</tag>
        <tag>博弈</tag>
        <tag>经典模型转化</tag>
      </tags>
  </entry>
  <entry>
    <title>UR5 怎样提高智商</title>
    <url>/2023/08/29/UR5-%E6%80%8E%E6%A0%B7%E6%8F%90%E9%AB%98%E6%99%BA%E5%95%86/</url>
    <content><![CDATA[<p><a href="https://uoj.ac/contest/7/problem/60">https://uoj.ac/contest/7/problem/60</a></p>
<span id="more"></span>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>非常有意思的一道题目，结论不难猜，但是非常难证。</p>
<p>首先，答案为 $4*3^{n-1}$ ，达到上界也非常的简单，搞一堆 ‘A 0 0 0 0’ 就行了。</p>
<p>时间复杂度：$O(n)$ 。</p>
<details class="toggle" ><summary class="toggle-button" style="">证明</summary><div class="toggle-content"><p>我们认为如果一道题目的四个答案都是一样的，我们称其为 SB 题。</p>
<p>假设最早出现的 SB 题在第 $i$ 道。</p>
<p>那么显然。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> LL mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    LL ans=<span class="number">4</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)ans=ans*<span class="number">3</span>%mod;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="built_in">printf</span>(<span class="string">&quot;A 0 0 0 0\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></details></div></details>]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>构造</tag>
        <tag>思维</tag>
      </tags>
  </entry>
  <entry>
    <title>World Final 2015 K. Tours</title>
    <url>/2024/07/01/World-Final-2015-K-Tours/</url>
    <content><![CDATA[<p>题目链接：<a href="https://qoj.ac/contest/280/problem/4686">https://qoj.ac/contest/280/problem/4686</a></p>
<p>题目大意：给每个点染色，问有多少种染色数满足存在一种染色方案使得：</p>
<ol>
<li>每个颜色至少被染了一次，每个点都被染了一种颜色。</li>
<li>任意一个简单环上每种颜色的数量一样。</li>
</ol>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>注意到一个事情，两个环像个 $8$ 一样的相交，那么中间的那条路径也满足每种颜色的数量一样。</p>
<p>这启示我们或许可以把第二条当成方程一样，解一下方程。想到方程就想到了向量空间。<del>虽然这一步是队长想的，并不是我想的，也许这并不自然</del></p>
<p>设一个 $n$ 维的向量空间，定义其中一个子空间 $S$ 满足：</p>
<p>其为 $span\{L_i\}$ ，其中 $L_i$ 为第 $i$ 个环所生成的向量，即 $L_{i,x}=1$ 当且仅当 $x$ 在环上，否则为 $0$ 。</p>
<p>可以看到，对于任意一个合法的染色方案：元素 $(a_1,a_2,….,a_n)\in S$ 满足每种颜色的加权和相等，其中加权和表示如果 $x$ 染色某种颜色，其对这个颜色的贡献为 $a_x$ 。</p>
<p>由于我们实际上只是用方程多生成了一些线性无关的方程，所以这与前面第二条是相互充要的，即一个方案是合法的当且仅当其在 $S$ 内任意一个元素下的颜色加权和相等。</p>
<p>这意外着如果我们能找到 $S$ 的另外一组基，就可以把问题变成求这组基下的合法染色方案。</p>
<p>不妨猜基中每个分量要么 $0$ 要么 $1$ ，且每个分量最多在一个元素中不为 $0$，由此可以发现，两个分量在一个元素中同时为 $1$ 等价于这两个元素在任何方程中的值都相等且存在一个方程中，其系数不为 $0$ 。</p>
<p>因此基实际上可以等价的看成，把每条边按照其所在的环的集合作为标准划分等价类（空集的点扔掉）。</p>
<p>而这又可以等价于按照其所在的 DFS 环的集合作为标准划分等价类（DFS 环指的是做一遍 DFS 后，由恰好一条非树边构成的环），原因是根据异或路径那个结论，每个环都可以当成若干个 DFS 环在异或意义下的线性表示，所以 DFS 环划分的等价类和所有环划分的等价类是一样的。</p>
<p>这样的话题目就好做了，答案就是每条链的长度的最大公约数，就做完了。</p>
<p>时间复杂度：$O(nm)$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e3</span> + <span class="number">5</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>&#123;<span class="keyword">return</span> !x ? y : <span class="built_in">gcd</span>(y % x, x);&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">	<span class="type">int</span> y, next;</span><br><span class="line">&#125;a[N * <span class="number">2</span>]; <span class="type">int</span> len = <span class="number">1</span>, las[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ins</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>&#123;a[++len] = &#123;y, las[x]&#125;; las[x] = len;&#125;</span><br><span class="line"><span class="type">int</span> col[N], tmp[N], fa[N];</span><br><span class="line"><span class="type">bool</span> v[N];</span><br><span class="line"><span class="type">int</span> rk[N][<span class="number">2</span>], cnt;</span><br><span class="line"><span class="type">int</span> dfn[N], ti;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(vector&lt;<span class="type">int</span>&gt; x)</span></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(v, <span class="number">0</span>, <span class="built_in">sizeof</span>(v));</span><br><span class="line">	<span class="built_in">swap</span>(col, tmp);</span><br><span class="line">	<span class="built_in">memset</span>(rk, <span class="number">0</span>, <span class="built_in">sizeof</span>(rk));</span><br><span class="line">	rk[<span class="number">1</span>][<span class="number">0</span>] = cnt = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> y : x) v[y] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(!rk[tmp[i]][v[i]]) rk[tmp[i]][v[i]] = ++cnt;</span><br><span class="line">		col[i] = rk[tmp[i]][v[i]];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">	dfn[x] = ++ti;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> k = las[x]; k; k = a[k].next)&#123;</span><br><span class="line">		<span class="type">int</span> y = a[k].y;</span><br><span class="line">		<span class="keyword">if</span>(!dfn[y])&#123;</span><br><span class="line">			fa[y] = k ^ <span class="number">1</span>;</span><br><span class="line">			<span class="built_in">dfs</span>(y);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(dfn[y] &lt; dfn[x] &amp;&amp; k != fa[x])&#123;</span><br><span class="line">			vector&lt;<span class="type">int</span>&gt; now;</span><br><span class="line">			now.<span class="built_in">push_back</span>(k / <span class="number">2</span>);</span><br><span class="line">			<span class="type">int</span> z = x;</span><br><span class="line">			<span class="keyword">while</span>(z != y)&#123;</span><br><span class="line">				now.<span class="built_in">push_back</span>(fa[z] / <span class="number">2</span>);</span><br><span class="line">				z = a[fa[z]].y;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">add</span>(now);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> sum[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	cnt = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">		<span class="type">int</span> x, y;</span><br><span class="line">		cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">		<span class="built_in">ins</span>(x, y);</span><br><span class="line">		<span class="built_in">ins</span>(y, x);</span><br><span class="line">		col[i] = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(!dfn[i]) <span class="built_in">dfs</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">		sum[col[i]]++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> d = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= cnt; i++)&#123;</span><br><span class="line">		d = <span class="built_in">gcd</span>(d, sum[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(d % i == <span class="number">0</span>)&#123;</span><br><span class="line">			cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是怎么证明呢？</p>
<p><details class="toggle" ><summary class="toggle-button" style="">证明</summary><div class="toggle-content"><p>首先，一个容易犯的误区是：等价类可以用 DFS 环划分，但是不代表 $S$ 就是可以只有 DFS 环所构成的元素生成。<del>因为我当时犯了这个错误</del></p></p>
<p>所以问题关键就是如何利用所有环进行线性组合，组合出那组基来。（显然 $S$ 是那组基的子空间，现在只要证明这组基能够被生成就行了）</p>
<p>设每个环都是异或意义下 DFS 环的线性组合（这是唯一的，我之前另外一篇博客有介绍）：$L=\{L_{x_1}\oplus L_{x_2}…\oplus L_{x_{k}}\}$ ，而 $L$ 的方程也是由 $L_{x_1},…,L_{x_{k}}$ 的方程异或出来的。</p>
<p>设 $L_y\notin L$ ，考察环 $\{L_y\}\cup L$ ，可以发现，就是对 $L_{y}$ 中的所有元素取个反，设 $f(L)$ 表示 $L$ 代表的元素。</p>
<p>考察 $f(\{L_y\}\cup L)-f(L)$ ，可以得到其在 $L_y$ 上的每个点的分量是 $±2$ 。</p>
<p>现在证明，每个基都可以求出来。</p>
<p>对于等价类 $L=\{L_1,L_2,…,L_k\}$ ，假设其补集为 $L’=\{L’_1,L’_2,…,L’_t\}$ ，那么我们这么计算：</p>
<script type="math/tex; mode=display">\sum\limits_{l\subset L,l'\subset L'}(-1)^{|L|-|l|}f(l\cup l')</script><p>这个值是多少呢？</p>
<p>假设对于一个点 $x$，其的等价类 $\cap L’≠\emptyset$ （设交集为 $A$），那么其的系数可以用下面这个式子证明为 $0$ ：</p>
<p>$f(S\cup a)+f(S)$ 在 $x$ 处的分量为 $0$，其中 $a\notin S$ ，即可证明。</p>
<p>假设为 $\emptyset$ ，但是等价类为 $L$ 的一个真子集，假设 $a\in L$ 不在里面。</p>
<p>那么有 $f(S\cup a)-f(S)$ 在 $x$ 处的分量为 $0$，其中 $a\notin S$ ，即可证明。</p>
<p>可以证明，等价类在恰好等于 $L\cup L_1$ 的点的分量为 $±2^{|L|+|L’|}≠ 0$ ，其中正负号一致。</p>
<p>证毕。</p>
</div></details>
<p>高中的时候，我知道了那个异或环的性质，但是不会证明，然后在今年会证了，这个结论在去年知道了，今年也会证了，感叹时光的流逝，在我会证明这些结论的时候，也是我即将退役的时候，哎。</p></div></details>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>ZJOI2017 字符串</title>
    <url>/2024/02/18/ZJOI2017-%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<p>题目链接：<a href="https://loj.ac/p/2572">https://loj.ac/p/2572</a></p>
<p>题目大意：</p>
<p>一个长度为 $n$ ，字符集大小为 $10^9$ 的字符串，要求完成 $m$ 次操作。</p>
<p>两种操作：</p>
<ol>
<li>区间 $+d$ ，$d$ 可以为负。</li>
<li>求区间的字典序最小的后缀。</li>
</ol>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>太唐了，都已经知道了 Significant Suffixes 都还不会，感觉自从高三回归课内搞了一年后，我信息学的许多基本功都下降了好多，悲。</p>
<p>首先，一个显然的事情，我们得先处理子串比较的问题，这个显然可以 二分+线段树+Hash 解决，时间复杂度：$O(n\log^2{n})$ 。（修改复杂度：$O(n\log{n})$）</p>
<p>其次，我们可以在线段树上维护每个区间的 Significant Suffixes 的集合，但是问题是怎么求 Significant Suffixes？</p>
<p>其实压根没有必要保证集合里面都是 Significant Suffixes，只需要保证 Significant Suffixes 一定在集合里面就行了，同时保证集合大小在 $O(\log)$ 即可。（当确定一个东西是什么十分困难时，不妨尝试确定一个东西不是什么）</p>
<p>根据 Significant Suffixes 的相关证明以及线段树的性质，不难发现，线段树上合并节点时，左节点只会贡献一个可能是 Significant Suffixes 的后缀。</p>
<p>而找到这个后缀的方法就是：在左节点的集合中找一种奇怪字典序最小的后缀，这种字典序最小是认为空字符大于所有字符，即如果 $A$ 是 $B$ 的真前缀且 $A$，则 $B&lt;A$ 。</p>
<p>但是可以发现，一次修改的时间复杂度高达：$O(\log^4)$ ，但如果你足够聪慧，你可以发现，Hash 修改的时间开销很小，但是查询的时间开销很大，所以我们希望牺牲一下修改复杂度，从而降低查询复杂度，不难想到分块，分块+Hash 修改复杂度 $O(\sqrt{n})$ ，查询复杂度 $O(1)$ ，这样修改的最终复杂度就能优化到：$O(\log^3{n}+\sqrt{n})$ 。</p>
<p>那查询咋整，如果和修改一样合并节点，就没法保证左右节点长度几乎相等的性质，那个做法就不能用了，虽然也能补救，就是从右往左合并，如果左边的长度大于右边的长度+1，那么就把左边那个节点变成这个节点的左儿子和又儿子再进行合并，显然这样的时间复杂度是 $O(\log^3)$ 的，但是比较麻烦，有没有简单点的方法。</p>
<p>变换思路，不合并了，反正就 $O(\log)$ 个节点，则集合的并的大小也就 $O(\log^2)$ 大小，直接比较大小就行了，时间复杂度：$O(\log^3)$ 。</p>
<p>所以，最终复杂度就出来：$O(n\log^2{n}+m(\sqrt{n}+\log^3{n}))$</p>
<p>空间复杂度：$O(n\log{n})$ </p>
<p>什么时候我能自己独立做出来一道这么牛逼的字符串题啊。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;LL,<span class="type">int</span>&gt; PLI;</span><br><span class="line"><span class="type">const</span> LL mod=<span class="number">2000000239</span>;</span><br><span class="line"><span class="type">const</span> LL A=<span class="number">2000000137</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> NN=<span class="number">4e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> B=<span class="number">950</span>;</span><br><span class="line"><span class="type">int</span> n,q;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getz</span><span class="params">(<span class="type">int</span> &amp;x)</span></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">int</span> f=<span class="number">1</span>;<span class="type">char</span> c=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(c&gt;<span class="string">&#x27;9&#x27;</span> || c&lt;<span class="string">&#x27;0&#x27;</span>)c==<span class="string">&#x27;-&#x27;</span>?f=<span class="number">-1</span>:<span class="number">1</span>,c=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(c&lt;=<span class="string">&#x27;9&#x27;</span> &amp;&amp; c&gt;=<span class="string">&#x27;0&#x27;</span>)x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+c-<span class="string">&#x27;0&#x27;</span>,c=<span class="built_in">getchar</span>();</span><br><span class="line">    x=x*f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">mt</span><span class="params">(LL x)</span></span>&#123;<span class="keyword">return</span> x&gt;=mod?x-mod:(x&lt;<span class="number">0</span>?x+mod:x);&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Hash</span>&#123;</span><br><span class="line">    LL fb[N],ff[N];</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">        fb[<span class="number">0</span>]=<span class="number">1</span>;fb[<span class="number">1</span>]=A;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)fb[i]=fb[i<span class="number">-1</span>]*A%mod;</span><br><span class="line">        ff[<span class="number">0</span>]=<span class="number">1</span>;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)ff[i]=<span class="built_in">mt</span>(ff[i<span class="number">-1</span>]+fb[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;has;</span><br><span class="line">PLI <span class="keyword">operator</span>+(PLI x,PLI y)&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;(x.first*has.fb[y.second]+y.first)%mod,x.second+y.second&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> bel[N],lazy[N],ll[N],rr[N],val[N];</span><br><span class="line">PLI fl[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">maintain</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=ll[x];i&lt;=rr[x];i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i==ll[x])fl[i]=PLI&#123;val[i],<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">else</span> fl[i]=fl[i<span class="number">-1</span>]+PLI&#123;val[i],<span class="number">1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">change</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> d)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=ll[x];i&lt;=rr[x];i++)&#123;</span><br><span class="line">        val[i]+=lazy[x];</span><br><span class="line">        <span class="keyword">if</span>(i&gt;=l &amp;&amp; i&lt;=r)val[i]+=d;</span><br><span class="line">    &#125;</span><br><span class="line">    lazy[x]=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">maintain</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">change</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> d)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(bel[l]==bel[r])<span class="built_in">change</span>(bel[l],l,r,d);</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">change</span>(bel[l],l,r,d);</span><br><span class="line">        <span class="built_in">change</span>(bel[r],l,r,d);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=bel[l]+<span class="number">1</span>;i&lt;bel[r];i++)lazy[i]+=d;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">PLI <span class="title">queryhash_nl</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l==ll[bel[l]])<span class="keyword">return</span> fl[r];</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> &#123;<span class="built_in">mt</span>(fl[r].first-fl[l<span class="number">-1</span>].first*has.fb[ r-l+<span class="number">1</span> ]%mod),r-l+<span class="number">1</span>&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">PLI <span class="title">hashplus</span><span class="params">(PLI x,LL d)</span></span>&#123;<span class="keyword">return</span> &#123;<span class="built_in">mt</span>(x.first+has.ff[x.second<span class="number">-1</span>]*d%mod),x.second&#125;;&#125;<span class="comment">/*x+dval*/</span></span><br><span class="line"><span class="function">PLI <span class="title">queryhash_l</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;<span class="keyword">return</span> <span class="built_in">hashplus</span>(<span class="built_in">queryhash_nl</span>(l,r),lazy[bel[l]]);&#125;</span><br><span class="line"><span class="function">PLI <span class="title">queryhas</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    PLI ans=&#123;<span class="number">0ll</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=bel[l];i&lt;=bel[r];i++)&#123;</span><br><span class="line">        ans=ans+<span class="built_in">queryhash_l</span>(<span class="built_in">max</span>(l,ll[i]),<span class="built_in">min</span>(rr[i],r));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> lim,<span class="type">int</span> typ=<span class="number">0</span>)</span></span>&#123;<span class="comment">//return x&lt;y</span></span><br><span class="line">    <span class="type">int</span> l=<span class="number">1</span>,r=lim-<span class="built_in">max</span>(x,y)+<span class="number">1</span>,mid,ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;=r)&#123;</span><br><span class="line">        mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">queryhas</span>(x,x+mid<span class="number">-1</span>)!=<span class="built_in">queryhas</span>(y,y+mid<span class="number">-1</span>))r=mid<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">else</span> l=mid+<span class="number">1</span>,ans=mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(ans==lim-<span class="built_in">max</span>(x,y)+<span class="number">1</span>)<span class="keyword">return</span> typ?x&lt;y:x&gt;y;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> val[x+ans]+lazy[bel[x+ans]]&lt;val[y+ans]+lazy[bel[y+ans]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Segment</span>&#123;</span><br><span class="line">    <span class="type">int</span> lc,rc;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; sign;</span><br><span class="line">&#125;tr[NN];<span class="type">int</span> cnt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">updata</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="comment">// tr[x].sign.clear();</span></span><br><span class="line">    tr[x].sign=tr[tr[x].rc].sign;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> y:tr[tr[x].lc].sign)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!ans || <span class="built_in">cmp</span>(y,ans,r,<span class="number">1</span>))ans=y;</span><br><span class="line">    &#125;</span><br><span class="line">    tr[x].sign.<span class="built_in">push_back</span>(ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bt</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> x=++cnt;</span><br><span class="line">    <span class="keyword">if</span>(l==r)tr[x].sign.<span class="built_in">push_back</span>(l);</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        tr[x].lc=<span class="built_in">bt</span>(l,mid);</span><br><span class="line">        tr[x].rc=<span class="built_in">bt</span>(mid+<span class="number">1</span>,r);</span><br><span class="line">        <span class="built_in">updata</span>(x,r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">change</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> ll,<span class="type">int</span> rr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ll&gt;rr || rr&lt;l || ll&gt;r || (l&gt;=ll &amp;&amp; r&lt;=rr))<span class="keyword">return</span> ;</span><br><span class="line">    <span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">change</span>(tr[x].lc,l,mid,ll,rr);</span><br><span class="line">    <span class="built_in">change</span>(tr[x].rc,mid+<span class="number">1</span>,r,ll,rr);</span><br><span class="line">    <span class="built_in">updata</span>(x,r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> zans;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">query</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> ll,<span class="type">int</span> rr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ll&gt;rr || rr&lt;l || ll&gt;r)<span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">if</span>(l&gt;=ll &amp;&amp; r&lt;=rr)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> y:tr[x].sign)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!zans || <span class="built_in">cmp</span>(y,zans,rr))zans=y;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">query</span>(tr[x].lc,l,mid,ll,rr);</span><br><span class="line">    <span class="built_in">query</span>(tr[x].rc,mid+<span class="number">1</span>,r,ll,rr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">getz</span>(n);<span class="built_in">getz</span>(q);</span><br><span class="line">    has.<span class="built_in">init</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">getz</span>(val[i]);</span><br><span class="line">        val[i]+=<span class="number">1000000001</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        bel[i]=i/B+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(!ll[bel[i]])ll[bel[i]]=i;</span><br><span class="line">        rr[bel[i]]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=bel[n];i++)<span class="built_in">maintain</span>(i);</span><br><span class="line">    <span class="built_in">bt</span>(<span class="number">1</span>,n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=q;i++)&#123;</span><br><span class="line">        <span class="type">int</span> typ;<span class="built_in">getz</span>(typ);</span><br><span class="line">        <span class="keyword">if</span>(typ==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="type">int</span> l,r,d;<span class="built_in">getz</span>(l);<span class="built_in">getz</span>(r);<span class="built_in">getz</span>(d);</span><br><span class="line">            <span class="built_in">change</span>(l,r,d);</span><br><span class="line">            <span class="built_in">change</span>(<span class="number">1</span>,<span class="number">1</span>,n,l,r);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="type">int</span> l,r;<span class="built_in">getz</span>(l);<span class="built_in">getz</span>(r);</span><br><span class="line">            zans=<span class="number">0</span>;</span><br><span class="line">            <span class="built_in">query</span>(<span class="number">1</span>,<span class="number">1</span>,n,l,r);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,zans);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个题目有点卡常，这里说一下我是怎么卡常的：</p>
<ol>
<li>模数等量改成常数，同时将一些取模改成判断和加减的组合。</li>
<li>调调块长，在 $2\sqrt{n}$ 左右会快很多。</li>
<li>加快读。</li>
</ol>
</div></details>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>Hash</tag>
        <tag>线段树</tag>
        <tag>数据结构</tag>
        <tag>分块</tag>
        <tag>Significant Suffixes</tag>
      </tags>
  </entry>
  <entry>
    <title>sgu543 Cafe</title>
    <url>/2024/04/29/sgu543-Cafe/</url>
    <content><![CDATA[<p>题目链接：<a href="https://codeforces.com/problemsets/acmsguru/problem/99999/543">https://codeforces.com/problemsets/acmsguru/problem/99999/543</a></p>
<p>题目大意：有 $n$ 个团体，每张桌子有 $r$ 个位置，问最小多少张桌子能让所有人上桌，要求：一个桌子上不会出现一个团体只有一个人在这张桌子上。</p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>注意到一个事情：任何一个 $&gt;1$ 的正整数可以被拆分成若干 $2,3$ 的和，但问题是，我们不知道每个团体的人要被拆成多少个 $2,3$ （显然，知道有多少个 $2,3$ ，就可以在足够优秀的时间复杂度内得到最少的桌子数量）。</p>
<p>但是又注意到一个事情：一个桌子上有两个 $3$ 和一个团体被拆分成两个 $3$ 这两件事不会同时发生，因为发生这种情况时可以交换，然后把两个 $3$ 拆成 $3$ 个 $2$ 。</p>
<p>因此我们只要分成两种情况讨论就行了：</p>
<ol>
<li>每个团体至多拆出一个 $3$ 。</li>
<li>每个桌子至多放置一个 $3$ 。</li>
</ol>
<p>然后讨论一下就做完了，我采用了二分，所以时间复杂度是：$O(n\log{V})$ 的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e3</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n, R, a[N];</span><br><span class="line"><span class="keyword">namespace</span> Solve1&#123;<span class="comment">//any team only one    </span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">evenpd</span><span class="params">(<span class="type">int</span> res, <span class="type">int</span> cnt, <span class="type">int</span> num2, <span class="type">int</span> num3)</span></span>&#123;</span><br><span class="line">        <span class="built_in">assert</span>(res % <span class="number">2</span> == <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(<span class="number">1ll</span> * res * cnt &lt; num2 * <span class="number">2</span> + num3 * <span class="number">3</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="number">1ll</span> * res / <span class="number">6</span> * <span class="number">2</span> * cnt &gt;= num3) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> tmp = res % <span class="number">6</span>;</span><br><span class="line">        <span class="keyword">if</span>(tmp &lt; <span class="number">3</span>) <span class="keyword">return</span> <span class="number">0ll</span>;</span><br><span class="line">        num3 -= <span class="number">1ll</span> * res / <span class="number">6</span> * <span class="number">2</span> * cnt;</span><br><span class="line">        <span class="keyword">return</span> tmp * cnt &gt;= num3 * <span class="number">4</span> + num2 * <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">pd</span><span class="params">(<span class="type">int</span> cnt, <span class="type">int</span> num2, <span class="type">int</span> num3)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!(R &amp; <span class="number">1</span>)) <span class="keyword">return</span> <span class="built_in">evenpd</span>(R, cnt, num2, num3);</span><br><span class="line">        <span class="keyword">if</span>(num3 &lt;= cnt) <span class="keyword">return</span> <span class="number">1ll</span> * (R - <span class="number">1</span>) * cnt &gt;= (num2 + num3) * <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">evenpd</span>(R - <span class="number">3</span>, cnt, num2, num3 - cnt);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> num2 = <span class="number">0</span>, num3 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i] &amp; <span class="number">1</span>) num3 ++, num2 --;</span><br><span class="line">            num2 += a[i] / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">1</span>, r = <span class="number">2000</span> * n, mid, ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt;= r)&#123;</span><br><span class="line">            mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">pd</span>(mid, num2, num3)) ans = mid, r = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">assert</span>(ans);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> Solve2&#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">pd</span><span class="params">(<span class="type">int</span> cnt, <span class="type">int</span> num2, <span class="type">int</span> num3, <span class="type">int</span> num6)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(num3 &gt; cnt) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> use = num3 + <span class="built_in">min</span>((cnt - num3) / <span class="number">2</span> * <span class="number">2</span>, num6 * <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">return</span> (num3 * <span class="number">3</span> + num2 * <span class="number">2</span> + num6 * <span class="number">6</span> + (cnt - use)) &lt;= <span class="number">1ll</span> * cnt * R;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!(R &amp; <span class="number">1</span>)) <span class="keyword">return</span> <span class="number">1e9</span>;</span><br><span class="line">        <span class="type">int</span> num2 = <span class="number">0</span>, num3 = <span class="number">0</span>, num6 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="type">int</span> tmp = a[i];</span><br><span class="line">            <span class="keyword">if</span>(a[i] &amp; <span class="number">1</span>) num3 ++, tmp -= <span class="number">3</span>;</span><br><span class="line">            num6 += tmp / <span class="number">6</span>;</span><br><span class="line">            tmp %= <span class="number">6</span>;</span><br><span class="line">            num2 += tmp / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">1</span>, r = <span class="number">2000</span> * n, mid, ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt;= r)&#123;</span><br><span class="line">            mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">pd</span>(mid, num2, num3 ,num6)) ans = mid, r = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">assert</span>(ans);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; R;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">min</span>(Solve1::<span class="built_in">solve</span>(), Solve2::<span class="built_in">solve</span>()) &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还有个问题，如果知道了有多少个 $2,3$ ，可以多快知道有多少个桌子数，显然 $O(\log)$ 可以，但是可以线性吗？</p>
<p>我们不妨设 $f(x)$ 表示有 $x$ 张桌子的情况下，将 $3$ 的桌子放进去，最多还能放入多少的 $2$ ，而 $f$ 显然能写成 $O(1)$ 个分段函数相加，且边界可以在 $O(1)$ 的时间处理完，所以一定可以在 $O(1)$ 的时间解决，具体讨论不再赘述。</p>
<p>因此，每个团队至多一个 $3$ 的情况可以在 $O(1)$ 的时间内解决。</p>
<p>同理，每张桌子至多一个 $3$ 的情况，显然此时可以认为 $r$ 为奇数，$r$ 为偶数的情况这种情况肯定不如另一种情况优。</p>
<p>可以先把原来的团队分成：$0/1$ 个 $3$ ，最多的 $6$ 和剩下的 $2$。</p>
<p>设 $f(x)$ 表示有 $x$ 张桌子的话至多能放多少个人，其中 $x\ge 3$ 的个数，因此 $f(x)$ 关于 $x$ 是偶数和奇数分别是分段函数，因此类似上面的，只要肯讨论，也可以在 $O(1)$ 内解决。</p>
<p>综上，该问题可以在 $O(n)$ 时间内解决。</p>
</div></details>]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title>tag说明</title>
    <url>/2023/09/04/tag%E8%AF%B4%E6%98%8E/</url>
    <content><![CDATA[<p>帮助更好的使用本网站的 tag 找到你想找到的内容。</p>
<details class="toggle" ><summary class="toggle-button" style="">字典序</summary><div class="toggle-content"><p>这里你会看到各种处理题目中最小字典序要求的做法，例如 DP 题要求最小字典序，字符串要求最小字典序等等。</p>
</div></details>
<details class="toggle" ><summary class="toggle-button" style="">感觉</summary><div class="toggle-content"><p>依赖感觉的题目，难以证明。</p>
</div></details>]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>ACM杂类</tag>
      </tags>
  </entry>
  <entry>
    <title>lzqy_ の Strings Round 赛后总结</title>
    <url>/2024/03/21/lzqy-%E3%81%AE-Strings-Round-%E8%B5%9B%E5%90%8E%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="A-好奇心宝宝"><a href="#A-好奇心宝宝" class="headerlink" title="A 好奇心宝宝"></a>A 好奇心宝宝</h1><p><a href="https://www.luogu.com.cn/problem/P10270?contestId=155684">https://www.luogu.com.cn/problem/P10270?contestId=155684</a></p>
<p>题目大意：给一个网格，求两条从左上到右下的路径满足最长公共前缀最短，输出最短公共前缀长度。</p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>显然等价于找 $\{(x,y)|x+y=t\}$ 中最小的 $t$ 满足这个集合中的点的字符集大小 $&gt;1$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e3</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">char</span> st[N][N];</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,st[i]+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n<span class="number">-1</span>+m<span class="number">-1</span>;i++)&#123;</span><br><span class="line">        <span class="type">int</span> pre=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> x=<span class="number">1</span>;x&lt;=i+<span class="number">1</span>;x++)&#123;</span><br><span class="line">            <span class="type">int</span> y=i-(x<span class="number">-1</span>)+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(x&gt;=<span class="number">1</span> &amp;&amp; y&gt;=<span class="number">1</span> &amp;&amp; x&lt;=n &amp;&amp; y&lt;=m)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!pre)pre=st[x][y];</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(pre!=st[x][y])&#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,i);</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,n+m<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></details>
<h1 id="B-漫长悄悄话"><a href="#B-漫长悄悄话" class="headerlink" title="B 漫长悄悄话"></a>B 漫长悄悄话</h1><p><a href="https://www.luogu.com.cn/problem/P10270?contestId=155684">https://www.luogu.com.cn/problem/P10270?contestId=155684</a></p>
<p>题目大意：对于 $i,j$ ，贡献为 $i,j$ 前缀的翻转和后缀的 $LCP$ （四个串的 LCP ），求最大贡献。</p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>等价于找最长的奇数长度回文串满足出现了至少两次。</p>
<p>接下来各显神通了，可以马拉车+Hash，可以回文自动机，也可以Hash+二分。</p>
<p>我用了回文自动机。</p>
<p>Hash+二分的做法详见官方题解：<a href="https://www.luogu.com/article/sfxeve97。（需要用到本质不同的回文串只有至多">https://www.luogu.com/article/sfxeve97。（需要用到本质不同的回文串只有至多</a> $n$ 个的性质）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e3</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">char</span> st[N][N];</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,st[i]+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n<span class="number">-1</span>+m<span class="number">-1</span>;i++)&#123;</span><br><span class="line">        <span class="type">int</span> pre=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> x=<span class="number">1</span>;x&lt;=i+<span class="number">1</span>;x++)&#123;</span><br><span class="line">            <span class="type">int</span> y=i-(x<span class="number">-1</span>)+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(x&gt;=<span class="number">1</span> &amp;&amp; y&gt;=<span class="number">1</span> &amp;&amp; x&lt;=n &amp;&amp; y&lt;=m)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!pre)pre=st[x][y];</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(pre!=st[x][y])&#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,i);</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,n+m<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></details>
<h1 id="C-在四方城外"><a href="#C-在四方城外" class="headerlink" title="C 在四方城外"></a>C 在四方城外</h1><p><a href="https://www.luogu.com.cn/problem/P10272?contestId=155684">https://www.luogu.com.cn/problem/P10272?contestId=155684</a></p>
<p>题目大意：每次操作在 $S$ 后面添加 $S$ 的 mxBd ，求第 $L$ 次操作和第 $R$ 次操作之间所有操作后的字符串长度之和。</p>
<details class="toggle" ><summary class="toggle-button" style="">我的做法</summary><div class="toggle-content"><p>引理 1 ：若 $ST=TS$ ，则 $S,T$ 有相同的整周期。</p>
<p><details class="toggle" ><summary class="toggle-button" style="">情况1：无Bd</summary><div class="toggle-content"><p>若原串的 $mxBd=0$ ，则答案为 $|S|*(r-l+1)$ 。</p>
</div></details></p>
<p><details class="toggle" ><summary class="toggle-button" style="">情况2：有整周期</summary><div class="toggle-content"><p>若原串有最小整周期 $p$ ，那么每次添加的长度必然是：$|S|-p$ ，否则一定会出现下面的情况：</p></p>
<p><img src="1.png" alt=""></p>
<p>那么根据引理，原串存在更小的整周期，矛盾，证毕。</p>
</div></details>
<details class="toggle" ><summary class="toggle-button" style="">情况3：无整周期但有Bd</summary><div class="toggle-content"><p>这里给一些例子：abababababcab 、aaaaaaaba 。</p>
<p>为了方便下面叙述，我们设 $S_m$ 表示第 $m$ 操作后的字符串，$S_0=S$ ，然后设 $T_m=S_m-S,T_m’=(mxBd(S)+T_m)$ ，字符串 $S-T$ 定义为 $S$ 删去 $LCP(S,T)$ 。</p>
<p>显然，$|T_{m+1}|-|T_{m}|=|T’_{m+1}|-|T’_{m}|$ ，$|T_{m+1}|-|T_{m}|\le |T_{m+2}|-|T_{m+1}|$ </p>
<p>接下来先说结论，整个增长过程可以分成两个部分，先是 $|T’_{m+1}|=2|T’_m|$ ，然后 $|T_{m+1}|-|T_m|$ 恒定。</p>
<p>定理 1 ：$|mxBd(T_{m})|\le |T’_{m}|$ 。（显然，归纳一下就行了）</p>
<p>因此，$|T’_{m+1}|\le 2|T’_m|$ 。</p>
<p>定理 2 ： $|T’_{m+1}|&lt;2|T’_m|$ 时，则后面 $|T_{m+1}|-|T_m|$ 恒定。</p>
<p><details class="toggle" ><summary class="toggle-button" style="">证明</summary><div class="toggle-content"><p>设 $U=mxBd(T’_{0})$ 。</p></p>
<p>$T_{m}-T_{m-1},T_{m+1}-T_m$ 是 $S$ 的一个 Bd ，显然 $T_{m}-T_{m-1}$ 是 $T_{m+1}-T_m$ 的一个 Bd 。可以得到 $T’_{0}$ 是 $T_{m+1}-T_m$ 的一个 Bd 。</p>
<p>根据引理 $1$ 可以得到 $U$ 是 $T_{m+1}-T_{m}$ 的最小整周期。</p>
<p>这个时候，可以把 $T’_{m+1},T’_{m}$ 等字符串想象成若干 $U$ 的拼接，显然 $U$ 也是 $T’_{m+1}$ 等字符串的最小整周期，否则最小整周期也是 $U$ 的整周期，与前面矛盾。</p>
<p><img src="3.png" alt=""></p>
<p>则 $|T’_{m+1}|&lt;2|T’_m|$ ，就已经说明了 $S_{m}$ 前面只有 $\frac{|T’_{m+1}|}{|U|}$ 个 $U$ ，没有 $\frac{|T’_{m+1}|}{|U|}+1$ 个 $U$ ，若 $|T_{m+2}|-|T_{m-1}|&gt;|T_{m+2}|-|T_{m-1}|$ ，则与 $U$ 的个数矛盾，证毕。</p>
</div></details>
<p>定理 3 ：若 $|T’_{m+1}|=2|T’_m|$ ，那么 $|T_{m+1}|-|T_{m}|&lt;|S|$。</p>
<details class="toggle" ><summary class="toggle-button" style="">证明</summary><div class="toggle-content"><p>反证法，若 $\ge n$ 。</p>
<p>显然 $T’_{0}$ 是 $T_{m+1}-T_{m}$ 的一个周期，即 $S_{m}$ 一个 $\ge n$ 的 Bd 的周期是 $T’_{0}$ ，注意到 $T’_{0}$ 也出现在 $S$ 的末尾，根据引理 $1$ 知道 $S$ 有整周期，矛盾，证毕。</p>
</div></details>
<p>推论： $m=\left \lfloor \log_2{|S|} \right \rfloor+1$ ，则一定有 $|T’_{m+1}|&lt;2|T’_m|$ 。</p>
<p>于是就有很多种搞法了。</p>
<p>我的方法是直接 Kmp ，注意到长度 $\le 3n$ ，所以时间复杂度为：$O(n\log{n})$ ，空间复杂度为 : $O(n)$ 。</p>
<p>当然，根据上面的证明，有更加快速的搞法：求出 $U$ ，然后从左到右找至多有多少个 $U$ ，这样就可以在 $O(n)$ 的时间解决这个问题了。</p></div></details>
<p>注意：上面的时间复杂度都忽略了快速幂计算答案的时间。</p>
<p>综上，时间复杂度为：$O(n\log{n}+\log{R})$ ，空间复杂度：$O(n)$。</p>
<p>当然，时间复杂度可以优化到：$O(n+\log{R})$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> LL mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e6</span>+<span class="number">5</span>;</span><br><span class="line"><span class="function">LL <span class="title">ksm</span><span class="params">(LL x,LL y)</span></span>&#123;</span><br><span class="line">    LL ans=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(y)&#123;</span><br><span class="line">        <span class="keyword">if</span>(y&amp;<span class="number">1</span>)ans=ans*x%mod;</span><br><span class="line">        x=x*x%mod;y&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">char</span> st[N*<span class="number">3</span>];</span><br><span class="line"><span class="type">int</span> fail[N*<span class="number">3</span>],n;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">gp</span><span class="params">(<span class="type">int</span> len)</span></span>&#123;</span><br><span class="line">    fail[<span class="number">0</span>]=<span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> now=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=len;i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(now!=<span class="number">-1</span> &amp;&amp; st[now+<span class="number">1</span>]!=st[i])now=fail[now];</span><br><span class="line">        fail[i]=++now;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fail[len];</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> len[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,st+<span class="number">1</span>);n=<span class="built_in">strlen</span>(st+<span class="number">1</span>);</span><br><span class="line">    <span class="type">int</span> d=<span class="built_in">gp</span>(n),p=n-d;</span><br><span class="line">    <span class="keyword">if</span>(!d)&#123;</span><br><span class="line">        LL l,r;<span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>,&amp;l,&amp;r);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,(r-l+<span class="number">1</span>)*n%mod);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n%p==<span class="number">0</span>)&#123;</span><br><span class="line">        LL l,r;<span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>,&amp;l,&amp;r);</span><br><span class="line">        LL ans=<span class="built_in">ksm</span>(<span class="number">2</span>,l)*(<span class="built_in">ksm</span>(<span class="number">2</span>,r-l+<span class="number">1</span>)<span class="number">-1</span>+mod)%mod*(n-p)%mod;</span><br><span class="line">        ans=(ans+p*(r-l+<span class="number">1</span>))%mod;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> pred,m=<span class="number">0</span>;</span><br><span class="line">    len[m]=n;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        m++;</span><br><span class="line">        len[m]=len[m<span class="number">-1</span>];</span><br><span class="line">        <span class="built_in">assert</span>(len[m]+d&lt;=n*<span class="number">3</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=d;i++)st[++len[m]]=st[i];</span><br><span class="line">        pred=d;</span><br><span class="line">        d=<span class="built_in">gp</span>(len[m]);</span><br><span class="line">        p=len[m]-d;</span><br><span class="line">    &#125;<span class="keyword">while</span>(d==pred*<span class="number">2</span>);</span><br><span class="line">    <span class="comment">//d is key;</span></span><br><span class="line">    LL l,r;<span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>,&amp;l,&amp;r);</span><br><span class="line">    LL ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=l;i&lt;=m &amp;&amp; i&lt;=r;i++)ans=(ans+len[i])%mod;</span><br><span class="line">    <span class="keyword">if</span>(m&lt;r)&#123;</span><br><span class="line">        l=<span class="built_in">max</span>(l-m,<span class="number">1ll</span>);</span><br><span class="line">        r-=m;</span><br><span class="line">        ans=(ans+len[m]*(r-l+<span class="number">1</span>))%mod;</span><br><span class="line">        ans=(ans+(r+l)*(r-l+<span class="number">1</span>)/<span class="number">2</span>%mod*d)%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>感觉想出这个做法非常花时间啊。</p></div></details>
<details class="toggle" ><summary class="toggle-button" style="">官方题解</summary><div class="toggle-content"><p>官方做法和我的 $O(n)$ 做法没什么区别，区别在于官方题解导出正解的路线非常短。</p>
<p>想想怎么更快的想出正解？</p>
<ol>
<li>首先注意到 $S$ 有整周期（简单的）和没有整周期（不简单的）是两种情况。</li>
<li>其次一个必要条件是足够快的想出引理 $1$ （我的做法有提到）。</li>
<li>然后要有足够的观察力观察到如果设 $U$ 是 $mxBd(S)$ 的最小整周期，那么 $U$ 是这个问题的关键。</li>
<li>需要观察到 $U$ 是每次添加的字符串的整周期（那么显然 $U$ 是最小的整周期），否则可以证明 $mxBd(S)$ 存在更小的整周期。</li>
<li>设 $l$ 是从左到右 $S$ 可以匹配上的 $U$ 的个数，$r$ 是从右到左的，如果 $(l+r-1)*|U|\ge |S|$ ，则可以说明 $S$ 有最小整周期，矛盾。</li>
<li>根据 $4,5$ 就可以得到 $O(n)$ 做法，也可以根据至多 $O(\log)$ 后增速固定，且在这之前字符串长度至多乘 $3$ 倍的性质，想出更加好写的 $O(n\log{n})$ 做法。</li>
</ol>
<p>观察上面过程，在第 $3$ 步之后对我而言比较自然，也就是想要更快的做出这题，更快的想出第 $2,3$ 步是关键。</p>
</div></details>
<h1 id="D-大娱乐至上"><a href="#D-大娱乐至上" class="headerlink" title="D 大娱乐至上"></a>D 大娱乐至上</h1><p>题目链接：<a href="https://www.luogu.com.cn/problem/P10273?contestId=155684">https://www.luogu.com.cn/problem/P10273?contestId=155684</a></p>
<p>题目大意：给你一个字符串，给一堆区间代表子串，问你每个区间能不能在只改变原串一个字母的情况下，使原本给出的小于它的子串现在大于等于它了。</p>
<details class="toggle" ><summary class="toggle-button" style="">我的做法</summary><div class="toggle-content"><p>我考场的第一想法是后缀数组，但非常可惜的是太过答辩，以至于我根本没有时间在考场上品鉴完。</p>
<p>一个简单的思路是：要么改变这个子串，变小一个字母。要么让其余所有原本小于它的给定子串变大，变大一个字母。</p>
<p>基础实现思路：从小到大遍历子串，然后讨论当前这个子串是否可行，如果有多个相同的子串，则同时进行查询即可（即全部询问完后再执行相应的修改操作）。</p>
<p>然后就可以开始讨论了：</p>
<p>不妨设现在考虑的是 $[l_i, r_i]$ ，下面不加说明时，都仅考虑原本小于它的子串 $[l_j, r_j]$ ，设 $lcp(x,y)$ 表示 $x,y$ 后缀的最长公共前缀，同时下面提到的子串都指题目给定的子串。</p>
<p><strong>变小一个字母</strong>（一个基本性质是所有子串只可能变小不可能变大）：</p>
<ol>
<li>显然，如果要让 $[l_i, r_i]$ 小于等于 $[l_j,r_j]$ ，设 $len = min(lcp(l_i, l_j), r_j - l_j + 1, r_i - l_i + 1)$ ，则显然改的字符必须落在 $[l_i, l_i + len - 1]$ 。</li>
<li>同时如果改的字符同时落在 $[l_i, r_i]$ 和 $[l_j, r_j]$ ，那么显然必须有：$l_i &gt; l_j$ ，即如果有 $l_j \ge l_i$ 的话，修改的位置不能在 $[l_i,r_i]\cap [l_j,r_j]$ ，同时根据上一条可以知道，修改的位置不可能在 $l_j$ 之后，即落点只能落在 $[l_i, l_j - 1]$ 。（可以发现，找到右边最近的 $l_j$ 给个约束就行了，可以用单调栈预处理达到 $O(n)$ ）</li>
</ol>
<p>这样就可以得到修改的位置必须落在的区间，而且根据上面的讨论，不难发现只要落在这个区间，直接改到 $&lt;a$ 就可以符合要求了，即这个区间有可改的位置是改小可行的充要条件。</p>
<p>现在问题是，第一点怎么实现？</p>
<p>假设小于等于 $[l_i,r_i]$ 的子串（包括自己）中 $l$ 后缀 rank 最大为 $k$ ，同时所有给定的字符串中 rank 最小的 $l$ 的 rk 为 $smallrk$ 。</p>
<p>那么第一点的限制可以写成 $min(lcp(sa[smallrk],l),r_{j}-l_{j}+1(\forall j : [l_j,r_j]\le [l_i,r_i]))$ ，这样就可以维护了，具体实现中，还可以将 $lcp(sa[smallrk],l)$ 换成 $lcp(sa[k],l)$ ，因为显然 $lcp(sa[smallrk],sa[k])\ge min(r_{j}-l_{j}+1(\forall j : [l_j,r_j]\le [l_i,r_i]))$ 。</p>
<p>可以在询问的过程中一起维护，时间复杂度 $O(n)$ 。</p>
<p><strong>变大一个字母</strong>（一个基本性质是所有子串只可能变大不可能变小）：</p>
<ol>
<li>需要让这个位置落在所有 $[l_j,r_j]$ $([l_j,r_j]&lt;[l_i,r_i])$ 。（很容易 $O(n)$ 处理）</li>
<li>如果要让 $[l_i, r_i]$ 小于等于 $[l_j,r_j]$ ，则显然改的字符必须落在 $[l_j, l_j + lcp(l_i, l_j)]$ 。</li>
<li>如果要让 $[l_i, r_i]$ 小于等于 $[l_j,r_j]$ ，则显然改的字符必须落在 $[l_j, l_j + (r_i - l_i + 1) - 1]$ 。（很容易 $O(n)$ 处理）</li>
<li>若 $\exists j : l_j \le l_i ,[l_j,r_j] &lt;[l_i,r_i]$ ，则显然修改位置不能落在 $[l_i,r_i]$ ，否则 $[l_i,r_i]$ 的增大程度大于 $[l_j,r_j]$ 。（很容易 $O(n)$ 处理）</li>
</ol>
<p>这样就可以得到修改的位置必须落在的区间，而且根据上面的讨论，不难发现只要落在这个区间，直接改到 $&gt;z$ 就可以符合要求了，即这个区间有可改的位置是改大可行的充要条件。</p>
<p>现在问题是，第二点怎么实现？毕竟 $rk[l_i]$ 可以跳上跳下的 ，因此维护 $lcp(l_i,l_j)$ 是个很困难的事情。</p>
<p>假设大于等于 $[l_i,r_i]$ 的子串（包括自己）中 $l$ 后缀 rank 最大为 $k$ 。</p>
<p>那么实际上只需要考虑 $j:[l_j,r_j]&lt;[l_i,r_i],rk(l_j)&lt;k$ ，且 $lcp$ 只需要考虑 $lcp(l_j,sa[k])$ ，原因是这样子改的影响一定可以被其余三点消掉。（一个基本的事实是：若 $rk[l_i]\ge rk[l_j]$，但 $[l_i,r_i]\le[l_j,r_j]$ ，那么 $[l_i,r_i]$ 一定是 $[l_j,r_j]$ 的前缀）</p>
<p>这样子的好处是可以用一个栈轻松实现这个过程。</p>
<p>综上，在对子串排序后，所有的讨论都可以在线性的时间解决。</p>
<p>时间复杂度：$O(n\log{n})$</p>
<p>空间复杂度：$O(n\log{n})$</p>
<p>我的代码实现细节和上述实现不完全相同，但是思路是一致的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> SN = <span class="number">20</span>;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">char</span> ss[N],ch[N];</span><br><span class="line"><span class="type">char</span> ans[N];</span><br><span class="line">set&lt;<span class="type">int</span>&gt; chp;<span class="comment">//change pos</span></span><br><span class="line"><span class="function">PII <span class="title">getcp</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    PII x = &#123;n+<span class="number">1</span>, n+<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">if</span>(l&gt;r)<span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">auto</span> tmp = chp.<span class="built_in">lower_bound</span>(l);</span><br><span class="line">    <span class="keyword">if</span>(tmp != chp.<span class="built_in">end</span>()) x.first = *tmp;</span><br><span class="line">    tmp = chp.<span class="built_in">upper_bound</span>(r);</span><br><span class="line">    <span class="keyword">if</span>(tmp != chp.<span class="built_in">begin</span>())&#123;</span><br><span class="line">        tmp--;</span><br><span class="line">        x.second = *tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(x.first &gt; r) x.first = n + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x.second &lt; l) x.second = n + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> SA&#123;</span><br><span class="line">    <span class="type">int</span> cc[N],sa[N],xx[N],yy[N],top,V;</span><br><span class="line">    <span class="type">int</span> rk[N],height[N],h[N];</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">getsa</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//need clear : height,h</span></span><br><span class="line">        V=<span class="number">26</span>;<span class="built_in">memset</span>(cc+<span class="number">1</span>,<span class="number">0</span>,V&lt;&lt;<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)cc[xx[i]=ss[i]-<span class="string">&#x27;a&#x27;</span>+<span class="number">1</span>]++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=V;i++)cc[i]+=cc[i<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=n;i&gt;=<span class="number">1</span>;i--)sa[cc[xx[i]]--]=i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;n;k&lt;&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">            top=<span class="number">0</span>;<span class="keyword">for</span>(<span class="type">int</span> i=n;i&gt;n-k;i--)yy[++top]=i;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(sa[i]&gt;k)yy[++top]=sa[i]-k;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">memset</span>(cc+<span class="number">1</span>,<span class="number">0</span>,V&lt;&lt;<span class="number">2</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)cc[xx[i]]++;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=V;i++)cc[i]+=cc[i<span class="number">-1</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=n;i&gt;=<span class="number">1</span>;i--)sa[cc[xx[yy[i]]]--]=yy[i];</span><br><span class="line">            <span class="built_in">swap</span>(xx,yy);</span><br><span class="line">            V=xx[sa[<span class="number">1</span>]]=<span class="number">1</span>;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)xx[sa[i]]=V+=!(sa[i]+k&lt;=n &amp;&amp; sa[i<span class="number">-1</span>]+k&lt;=n &amp;&amp; yy[sa[i]]==yy[sa[i<span class="number">-1</span>]] &amp;&amp; yy[sa[i]+k]==yy[sa[i<span class="number">-1</span>]+k]);</span><br><span class="line">            <span class="keyword">if</span>(V==n)<span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)rk[sa[i]]=i;</span><br><span class="line">        <span class="type">int</span> now=<span class="number">0</span>;ss[n+<span class="number">1</span>]=<span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(now)now--;</span><br><span class="line">            <span class="keyword">if</span>(rk[i]==<span class="number">1</span>)<span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">while</span>(ss[i+now]==ss[sa[rk[i]<span class="number">-1</span>]+now])now++;</span><br><span class="line">            h[i]=now;height[rk[i]]=now;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> rmq[SN][N];</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init_rmq</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)rmq[<span class="number">0</span>][i]=height[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">19</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=n-(<span class="number">1</span>&lt;&lt;i)+<span class="number">1</span>;j&gt;=<span class="number">1</span>;j--)rmq[i][j]=<span class="built_in">min</span>(rmq[i<span class="number">-1</span>][j],rmq[i<span class="number">-1</span>][j+(<span class="number">1</span>&lt;&lt;(i<span class="number">-1</span>))]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getrmq</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> z=__lg(y-x+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">min</span>(rmq[z][x],rmq[z][y-(<span class="number">1</span>&lt;&lt;z)+<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getlcp</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x==y)<span class="keyword">return</span> n-x+<span class="number">1</span>;</span><br><span class="line">        x=rk[x];y=rk[y];</span><br><span class="line">        <span class="keyword">if</span>(x&gt;y)<span class="built_in">swap</span>(x,y);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">getrmq</span>(x+<span class="number">1</span>,y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> SA::getsa;</span><br><span class="line"><span class="keyword">using</span> SA::init_rmq;</span><br><span class="line"><span class="keyword">using</span> SA::getlcp;</span><br><span class="line"><span class="keyword">using</span> SA::height;</span><br><span class="line"><span class="keyword">using</span> SA::sa;</span><br><span class="line"><span class="keyword">using</span> SA::rk;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> ql[N],qr[N],qlen[N],id[N];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>&#123;<span class="comment">//x&lt;y;</span></span><br><span class="line">    <span class="type">int</span> k=<span class="built_in">getlcp</span>(ql[x], ql[y]);</span><br><span class="line">    <span class="keyword">if</span>(qlen[x] &lt;= k || qlen[y] &lt;= k) <span class="keyword">return</span> qlen[x] &lt; qlen[y];</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> ss[ql[x] + k] &lt; ss[ql[y] + k];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//small square</span></span><br><span class="line"><span class="type">int</span> smallrk,minlen;</span><br><span class="line">set&lt;<span class="type">int</span>&gt; banp;<span class="comment">//ban pos</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//big square</span></span><br><span class="line"><span class="type">int</span> minl, maxl;</span><br><span class="line">PII stk[N];<span class="type">int</span> top;</span><br><span class="line"><span class="type">int</span> maxrk,rp;</span><br><span class="line">multiset&lt;<span class="type">int</span>&gt; querypos;</span><br><span class="line"><span class="type">bool</span> v[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    cin &gt;&gt; ss+<span class="number">1</span> &gt;&gt; ch+<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">getsa</span>();</span><br><span class="line">    <span class="built_in">init_rmq</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ch[i] == <span class="string">&#x27;1&#x27;</span>) chp.<span class="built_in">insert</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">        cin &gt;&gt; ql[i] &gt;&gt; qr[i];</span><br><span class="line">        qlen[i] = qr[i] - ql[i] + <span class="number">1</span>;</span><br><span class="line">        id[i] = i;</span><br><span class="line">        ans[i] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        querypos.<span class="built_in">insert</span>(rk[ql[i]]);</span><br><span class="line">        v[ql[i]] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(id + <span class="number">1</span>, id + m +<span class="number">1</span>, cmp);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//small init</span></span><br><span class="line">    minlen = smallrk = n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)smallrk = <span class="built_in">min</span>(smallrk, rk[ql[i]]);</span><br><span class="line">    <span class="comment">//max init</span></span><br><span class="line">    maxrk = maxl = <span class="number">1</span>;</span><br><span class="line">    minl = n + <span class="number">1</span>;</span><br><span class="line">    rp = n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> tl = <span class="number">1</span>; tl &lt;= m; tl++)&#123;</span><br><span class="line">        <span class="type">int</span> tr = tl;</span><br><span class="line">        <span class="keyword">while</span>(tr &lt; m &amp;&amp; <span class="built_in">getlcp</span>(ql[id[tl]], ql[id[tr + <span class="number">1</span>]]) &gt;= qlen[id[tl]] &amp;&amp;</span><br><span class="line">            <span class="built_in">getlcp</span>(ql[id[tl]], ql[id[tr + <span class="number">1</span>]]) &gt;= qlen[id[tr + <span class="number">1</span>]] &amp;&amp; qlen[id[tl]] == qlen[id[tr + <span class="number">1</span>]]) tr++;</span><br><span class="line">        <span class="keyword">if</span>(tl == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = tl; i &lt;= tr; i++) ans[id[i]] = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = tl; i &lt;= tr; i++)&#123;</span><br><span class="line">            <span class="comment">//small change</span></span><br><span class="line">            <span class="type">int</span> x = id[i];</span><br><span class="line">            <span class="type">int</span> l = ql[x], r = qr[x];</span><br><span class="line">            <span class="keyword">while</span>(rk[l] &gt; smallrk)&#123;</span><br><span class="line">                smallrk++;</span><br><span class="line">                minlen = <span class="built_in">min</span>(minlen, height[smallrk] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            minlen = <span class="built_in">min</span>(minlen, qlen[x]);</span><br><span class="line">            <span class="comment">//big change</span></span><br><span class="line">            <span class="keyword">while</span>((*querypos.<span class="built_in">begin</span>()) &gt; maxrk)&#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(v[sa[maxrk]])&#123;</span><br><span class="line">                    <span class="type">int</span> pos = sa[maxrk];</span><br><span class="line">                    stk[++top] = &#123;pos, n - pos + <span class="number">1</span>&#125;;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                maxrk++;</span><br><span class="line">                <span class="type">int</span> tmp = height[maxrk] + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(top &amp;&amp; stk[top].second &gt; tmp)&#123;</span><br><span class="line">                    PII y = stk[top];</span><br><span class="line">                    <span class="keyword">while</span>(top &amp;&amp; stk[top].second &gt;= tmp)&#123;</span><br><span class="line">                        y.first = <span class="built_in">min</span>(y.first, stk[top].first);</span><br><span class="line">                        top--;</span><br><span class="line">                    &#125;</span><br><span class="line">                    y.second = tmp;</span><br><span class="line">                    stk[++top] = y;</span><br><span class="line"></span><br><span class="line">                    rp = <span class="built_in">min</span>(rp, y.first + y.second - <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = tl; i &lt;= tr; i++)&#123;</span><br><span class="line">            <span class="type">int</span> x = id[i];</span><br><span class="line">            <span class="type">int</span> l = ql[x], r = qr[x];</span><br><span class="line">            <span class="comment">//small query</span></span><br><span class="line">            <span class="keyword">if</span>(minlen)&#123;</span><br><span class="line">                <span class="type">int</span> rban= n + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">auto</span> tmp=banp.<span class="built_in">lower_bound</span>(l);</span><br><span class="line">                <span class="keyword">if</span>(tmp != banp.<span class="built_in">end</span>()) rban = *tmp;</span><br><span class="line">                <span class="keyword">auto</span> [al, ar] = <span class="built_in">getcp</span>(l, <span class="built_in">min</span>(rban - <span class="number">1</span>, l + minlen - <span class="number">1</span>));</span><br><span class="line">                <span class="keyword">if</span>(al != n + <span class="number">1</span>) ans[x] = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//big query</span></span><br><span class="line">            <span class="keyword">if</span>(maxl &lt;= <span class="built_in">min</span>(rp, minl + qlen[x] - <span class="number">1</span>))&#123;</span><br><span class="line">                <span class="keyword">auto</span> [al, ar] = <span class="built_in">getcp</span>(maxl, <span class="built_in">min</span>(rp, minl + qlen[x] - <span class="number">1</span>));</span><br><span class="line">                <span class="keyword">if</span>(al&lt;l) ans[x] = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">                <span class="keyword">if</span>(minl &gt; l &amp;&amp; ar != n + <span class="number">1</span>) ans[x] = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = tl; i &lt;= tr; i++)&#123;</span><br><span class="line">            <span class="type">int</span> x = id[i];</span><br><span class="line">            <span class="type">int</span> l = ql[x], r = qr[x];</span><br><span class="line">            <span class="comment">//small change</span></span><br><span class="line">            banp.<span class="built_in">insert</span>(l);</span><br><span class="line">            <span class="comment">//big change</span></span><br><span class="line">            querypos.<span class="built_in">erase</span>(querypos.<span class="built_in">find</span>(rk[l]));</span><br><span class="line">            </span><br><span class="line">            minl = <span class="built_in">min</span>(minl, l);</span><br><span class="line">            maxl = <span class="built_in">max</span>(maxl, l);</span><br><span class="line"></span><br><span class="line">            rp = <span class="built_in">min</span>(rp, r);</span><br><span class="line">        &#125;</span><br><span class="line">        tl = tr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; ans + <span class="number">1</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>能不能再快一点？空间能不能再小一点？</p>
<p>答案是可以的，首先后缀数组换成 SA-IS ，但即使换成 $O(n)-O(1)$ RMQ 排序也要 $O(n\log{n})$ ，如何处理呢？</p>
<p>注意到一个事情，排序的时候只关注子串是什么，而不关注子串的位置，因此只要我们能给每一个子串，找到最小的以该子串为前缀的后缀即可，做法也很简单：</p>
<p>将 height 从大到小跑，然后用并查集维护连接起来的一块，然后每次把一个子串送到所在连通块中排名最小的后缀即可。</p>
<p>这样就能在 $O(n\alpha(n))$ 时间排序完毕，再算上 $O(n)$ 的讨论，理论上能做到的最优复杂度：</p>
<p>时间复杂度：$O(n\alpha(n)))$ </p>
<p>空间复杂度：$O(n)$ </p>
</div></details>]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>总结</tag>
        <tag>后缀数组</tag>
        <tag>后缀自动机</tag>
      </tags>
  </entry>
  <entry>
    <title>slope trick 学习笔记</title>
    <url>/2024/06/27/slope-trick-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>byd ，这么好用的东西怎么我上了大学才会啊 QAQAQAQAQAQAQAQ 。</p>
<h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><p>题目链接：<a href="https://codeforces.com/problemset/problem/713/C">https://codeforces.com/problemset/problem/713/C</a></p>
<p>题目大意：给一个数字 $±1$ 的代价是 $1$ ，问给一个序列花最小多少代价可以变成严格递增序列。</p>
<p>$O(n^2)$ 的做法在此就不再赘述，主要讲解 slope trick 做法。</p>
<h1 id="做法"><a href="#做法" class="headerlink" title="做法"></a>做法</h1><p>注意到一个事情，我们设 $f_{i}$ 表示在处理完当前前缀后，最后一个数值是 $i$ 的最小代价。</p>
<p>那么每次添加一个数值 $a$ 就有两部分 $dp$ 过程：</p>
<p>$f_{i}=f_{i}+|a-i|$</p>
<p>$f_{i}=\min\limits_{j\le i}f_{j}$</p>
<p>可以观察到，$f$ 是长成下面那样的凸函数：</p>
<p><img src="1.png" alt=""></p>
<p>而 slope trick 就是维护斜率 $+1$ 的位置，也就是维护折点，但是有的折点如果要 $+k(k&gt;1)$ 咋整？那就维护 $k$ 个折点。（一般来说还要额外的维护一些值来保证函数能够唯一确定，比如本题就要维护当斜率为 $0$ 的值，用来确定函数的高度，同时也是最后的答案）</p>
<p>可以发现，上面两个过程分别对应：</p>
<ol>
<li>在 $a$ 处添加两个折点。</li>
<li>弹出最靠右的折点，并且维护函数的高度。</li>
</ol>
<p>然后就做完了，这个过程可以用堆维护，从而得到时间复杂度为 $O(n\log{n})$ 的做法。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">3e3</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">LL a[N];</span><br><span class="line">priority_queue&lt;LL&gt; p;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    LL ans = <span class="number">0ll</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">        a[i] -= i;</span><br><span class="line">        p.<span class="built_in">push</span>(a[i]);</span><br><span class="line">        p.<span class="built_in">push</span>(a[i]);</span><br><span class="line">        ans += <span class="built_in">abs</span>(p.<span class="built_in">top</span>() - a[i]);</span><br><span class="line">        p.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="slope-trick"><a href="#slope-trick" class="headerlink" title="slope trick"></a>slope trick</h1><p>具体来说，当序列 $dp$ 满足：</p>
<ol>
<li>连续。</li>
<li>分段线性。</li>
<li>凸函数。</li>
</ol>
<p>就可以考虑 slope trick 。</p>
<p>而且这样的函数还有很好的性质，若 $f,g$ 满足，则 $f+g$ 也满足，且新的折点可重集合是 $f,g$ 可重集合合并起来。（是合并，不是并）</p>
<h1 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h1><h2 id="1-A-New-Beginning"><a href="#1-A-New-Beginning" class="headerlink" title="1. A New Beginning"></a>1. A New Beginning</h2><p>题目链接：<a href="https://codeforces.com/problemset/problem/1534/G">https://codeforces.com/problemset/problem/1534/G</a></p>
<p>题目大意：在平面上，你初始在原点，每次只能往右往上走，然后有 $n$ 个点，你在 $(x,y)$ 与访问 $(x_i,y_i)$ 的代价是 $\max(|x_i-x|,|y_i-y|)$ ，然后问你访问所有点的最小代价。（访问并不会导致实际的移动）</p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>可以发现，$(x_i,y_i)$ 在 $(x,y)$ $x+y=x_i+y_i$ 的时候访问一定是代价最小的，直接从斜线角度来看这道题目。</p>
<p>也可以换个角度，这个是切比雪夫距离，切比雪夫距离和曼哈顿距离可以互相转化，转化成曼哈顿距离以后就显然了，在 $x$ 坐标相等的时候访问就是代价最小的。</p>
<p>观察一下 $dp$ 式子，可以发现，我们要对这个函数维护两个过程。</p>
<ol>
<li>插入一个 V 字。</li>
<li>将斜率为 $0$ 的平台延长。</li>
</ol>
<p>用数据结构维护就是维护四个东西：</p>
<ol>
<li>斜率为 $0$ 的平台左/右边的折点。（可以用堆维护）</li>
<li>平台高度。</li>
<li>平台宽度。</li>
</ol>
<p>时间复杂度：$O(n\log{n})$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">8e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    LL pos, val;</span><br><span class="line">&#125;a[N];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">priority_queue&lt;LL, vector&lt;LL&gt;, less&lt;LL&gt; &gt; l;</span><br><span class="line">priority_queue&lt;LL, vector&lt;LL&gt;, greater&lt;LL&gt; &gt; r;</span><br><span class="line">LL lazy, ans = <span class="number">0ll</span>;</span><br><span class="line"><span class="function">LL <span class="title">gettop</span><span class="params">(<span class="type">int</span> type)</span></span>&#123;</span><br><span class="line">    LL val;</span><br><span class="line">    <span class="keyword">if</span>(!type) val = l.<span class="built_in">top</span>();</span><br><span class="line">    <span class="keyword">else</span> val = r.<span class="built_in">top</span>() + lazy;</span><br><span class="line">    <span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">poptop</span><span class="params">(<span class="type">int</span> type)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!type) l.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">else</span> r.<span class="built_in">pop</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushval</span><span class="params">(LL val, <span class="type">int</span> type)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!type) l.<span class="built_in">push</span>(val);</span><br><span class="line">    <span class="keyword">else</span> r.<span class="built_in">push</span>(val - lazy);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        LL x, y;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        a[i].pos = x + y;</span><br><span class="line">        a[i].val = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(a + <span class="number">1</span>, a + n + <span class="number">1</span>, [](node x, node y)&#123;<span class="keyword">return</span> x.pos &lt; y.pos;&#125;);</span><br><span class="line">    l.<span class="built_in">push</span>(a[<span class="number">1</span>].val);</span><br><span class="line">    r.<span class="built_in">push</span>(a[<span class="number">1</span>].val);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        lazy += a[i].pos - a[i - <span class="number">1</span>].pos;</span><br><span class="line">        <span class="keyword">if</span>(a[i].val &lt;= <span class="built_in">gettop</span>(<span class="number">0</span>))&#123;</span><br><span class="line">            ans += <span class="built_in">abs</span>(a[i].val - <span class="built_in">gettop</span>(<span class="number">0</span>));</span><br><span class="line">            <span class="built_in">pushval</span>(<span class="built_in">gettop</span>(<span class="number">0</span>), <span class="number">1</span>);</span><br><span class="line">            <span class="built_in">poptop</span>(<span class="number">0</span>);</span><br><span class="line">            <span class="built_in">pushval</span>(a[i].val, <span class="number">0</span>);</span><br><span class="line">            <span class="built_in">pushval</span>(a[i].val, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(a[i].val &gt;= <span class="built_in">gettop</span>(<span class="number">1</span>))&#123;</span><br><span class="line">            ans += <span class="built_in">abs</span>(a[i].val - <span class="built_in">gettop</span>(<span class="number">1</span>));</span><br><span class="line">            <span class="built_in">pushval</span>(<span class="built_in">gettop</span>(<span class="number">1</span>), <span class="number">0</span>);</span><br><span class="line">            <span class="built_in">poptop</span>(<span class="number">1</span>);</span><br><span class="line">            <span class="built_in">pushval</span>(a[i].val, <span class="number">1</span>);</span><br><span class="line">            <span class="built_in">pushval</span>(a[i].val, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">pushval</span>(a[i].val, <span class="number">0</span>);</span><br><span class="line">            <span class="built_in">pushval</span>(a[i].val, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></details>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p><a href="https://zhuanlan.zhihu.com/p/389740015">https://zhuanlan.zhihu.com/p/389740015</a></p>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>slope trick</tag>
      </tags>
  </entry>
  <entry>
    <title>关于 dp 优化的几种常用的证明方法</title>
    <url>/2024/07/04/%E5%85%B3%E4%BA%8E-dp-%E4%BC%98%E5%8C%96%E7%9A%84%E5%87%A0%E7%A7%8D%E5%B8%B8%E7%94%A8%E7%9A%84%E8%AF%81%E6%98%8E%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h1 id="减少转移"><a href="#减少转移" class="headerlink" title="减少转移"></a>减少转移</h1><p>有一种优化 $dp$ 的方式是减少转移，即我们发现某些转移就是不优秀的，然后扔掉，但是又怕多种转移扔掉后，相互作用，把答案扔掉了怎么办。</p>
<p>一种简单的证明方法是：</p>
<p>证明答案可以用当前 $dp$ 生成，即用现在的转移生成的的集合一定是原来转移集合的子集，答案一定不优于原答案，因此只要证明存在一种原答案的方案使得能够用这种转移生成就行。</p>
<h1 id="减少状态"><a href="#减少状态" class="headerlink" title="减少状态"></a>减少状态</h1><p>一种经典的 $dp$ 优化是我们记录二元组 $(x,y)$ ，发现 $y$ 单调，所以用 $f[x]$ 记录 $y$ 的最值。</p>
<p>但是这怎么用 $dp$ 语言证明呢？</p>
<p>我的建议是一种类似归纳的证法，从小到大，证明每个被丢掉的状态答案都一定不优于没被丢掉的状态，所以答案一定出在保留状态所能转移出来的答案中，即答案一定在保留状态能转移出来的集合中。</p>
<p>举个例子，我们证明 $(x,1)$ 根据<strong>现有转移</strong>所产生的的答案严格不优于 $(x,2)$ ，所以答案一定产生于 $(x,2)$ 转移出来的状态中，所以只关心 $(x,f[x])$ 转移出来的结果，然后再证明 $(x+1,f[x+1])$ ，以此类推，就可以证明该 $dp$ 的正确性了。（之所以要从小打大类似归纳，是因为我们在证明 $(x+1)$ 的时候，实际上就已经只在丢 $(x,f[x])$ 转移出来的没用的状态，那些之前就丢到的状态，甚至都没法转移，自然讨论 $x+1$ 的时候不会带上他们）</p>
<h2 id="既减少转移又减少状态"><a href="#既减少转移又减少状态" class="headerlink" title="既减少转移又减少状态"></a>既减少转移又减少状态</h2><p>这个时候要小心了，有可能减少转移的前提是存在某些状态，或者减少状态的前提是存在某些转移。</p>
<p>一种常见的流程是：先证明减少转移的正确性，再在减少过的转移下（即新问题下），证明减少状态的正确性，或者反过来。即先证明一个，再证明另外一个，但是注意后一个是基于前面一个已经实现的新问题上的。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>总之，上面说的证明思路总结下来就一条：</p>
<p>证明扔掉的部分答案小于等于留存的，从而证明答案一定出现在留存状态的集合中。（因为是减少状态或者转移，只能是原来状态的子集，因此答案只会变劣，不会变优，证明单边等号即可）</p>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
  </entry>
  <entry>
    <title>一句话题解.md</title>
    <url>/2023/08/22/%E4%B8%80%E5%8F%A5%E8%AF%9D%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<ol>
<li>UR 2 猪猪侠再战括号序列：<a href="https://uoj.ac/problem/31">https://uoj.ac/problem/31</a> 。</li>
<li>UR 3 核聚变反应强度：<a href="https://uoj.ac/problem/48">https://uoj.ac/problem/48</a> 。做法：把 $a_1$ 所有质因数找出来判一下就行了，时间复杂度：$O(n\log{V}+\sqrt{V})$ 。</li>
<li>ECNU 2023.8 A Extra Large Knapsack：<a href="https://acm.ecnu.edu.cn/contest/695/problem/A/">https://acm.ecnu.edu.cn/contest/695/problem/A/</a> 显然所有数字的异或和必须为 $0$ ，然后随便拉出一个数字出来就行了，记得特判 $n=1$ 的情况。</li>
<li>UR 8 赴京赶考：<a href="https://uoj.ac/problem/118">https://uoj.ac/problem/118</a> ，想想网格图长成啥样就知道怎么做了，时间复杂度：$O(n+m+q)$ 。</li>
</ol>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>杂题</tag>
      </tags>
  </entry>
  <entry>
    <title>五边形数定理学习笔记</title>
    <url>/2024/01/29/%E4%BA%94%E8%BE%B9%E5%BD%A2%E6%95%B0%E5%AE%9A%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<script type="math/tex; mode=display">\prod\limits_{i=1}^{\infty}(1-x^i)=\sum\limits_{k=-\infty}^{\infty}(-1)^{k}x^{\frac{k(3k-1)}{2}}=1+\sum\limits_{k=1}^{\infty}(-1)^{k}x^{\frac{k(3k\pm 1)}{2}}</script><details class="toggle" ><summary class="toggle-button" style="">证明</summary><div class="toggle-content"><p>这个证明太厉害了，拍案叫绝。</p>
<p>首先，不难发现，$x^i$ 的系数是：偶数个不同正整数的拆分数的方案-奇数个不同正整数的拆分数的方案。</p>
<p>所以要证明这个定理就得找到一个关于偶数拆分和奇数拆的双射。</p>
<p>现在用一个点阵表示一个拆分，考虑把拆分数从大到小排序，然后第 $i$ 行的点的数量表示数的大小。（这玩意又叫Ferrers图）</p>
<p>下面是拆分：$6,5,3,1$ 的例子。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0 0 0 0 0 0</span><br><span class="line">0 0 0 0 0</span><br><span class="line">0 0 0</span><br><span class="line">0</span><br></pre></td></tr></table></figure>
<p>考虑把最下面一行点的数量，也就是最小的数字设为 $s$ ，最右边 $45$ 度斜线的点的数量设为 $m$ 。</p>
<p>为了方便理解，对上面那个例子做了标记，$1$ 表示 $s$ ，$2$ 表示 $m$。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0 0 0 0 0 2</span><br><span class="line">0 0 0 0 2</span><br><span class="line">0 0 0</span><br><span class="line">1</span><br></pre></td></tr></table></figure>
<p>如果 $s&gt;m$ 就把 $m$ 个元素放到最下面一行，否则把 $s$ 个元素放到 $m$ 个元素右边。</p>
<p>例如上面那个例子就是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0 0 0 0 0 2 1</span><br><span class="line">0 0 0 0 2</span><br><span class="line">0 0 0</span><br></pre></td></tr></table></figure>
<p>可以发现，这大部分情况下是一个双射，但是有一些特殊情况：</p>
<ol>
<li>$s=m+1$ ，同时拆分数的数字个数也就恰好 $m$ 个，这个时候如果拆出来就会有相同的两行：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0 0 0 0</span><br><span class="line">0 0 0</span><br></pre></td></tr></table></figure>
这个时候数字总数为 ：$\frac{m(3m+1)}{2}$ ，系数为 $(-1)^m$ 。</li>
<li>$s=m$ ，同时拆分数的数字个数也就恰好 $m$ 个：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0 0 0</span><br><span class="line">0 0</span><br></pre></td></tr></table></figure>
这个时候数字总数为 ：$\frac{m(3m-1)}{2}$ ，系数为 $(-1)^m$ 。</li>
</ol>
<p>综上，结论得证，证毕。</p>
<p>这个证明真的是太优美了。</p>
</div></details>
<p>参考资料：<a href="https://blog.csdn.net/visit_world/article/details/52734860">https://blog.csdn.net/visit_world/article/details/52734860</a></p>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>五边形数定理</tag>
        <tag>组合数学</tag>
      </tags>
  </entry>
  <entry>
    <title>博客食用指北</title>
    <url>/2024/01/19/%E5%8D%9A%E5%AE%A2%E9%A3%9F%E7%94%A8%E6%8C%87%E5%8C%97/</url>
    <content><![CDATA[<p>我写博客有以下目的：</p>
<ol>
<li><strong>帮助我重新梳理一遍做法。</strong>（必要）（我自己写过的博客一般是不会自己再看一遍的，所以复习作用很小，更多的作用是帮助梳理）</li>
<li><strong>锻炼自己用简短语言描述做法的能力。</strong>（重要）（打ACM被队友吐槽表达能力不行，而且能简洁说明的事情为啥要长篇大论，还能节省写博客的时间）</li>
<li><strong>用更加标准公式化的方式描述做法，比如把某个题的做法和其他题目联系起来，总结成一类做法。</strong>（重要）（有助于能力提升）</li>
<li><strong>尝试扩展题目以及做法，学习更多的做法。</strong>（适当）（因为有些做法和题目就是没法扩展的，强行扩展可能浪费时间，但收益还行，学习做法这个事情也是两面的，有点显然，缺点是浪费时间，很多时候某些复杂做法其实就是简单做法的同构，但是需要等到看了很久才能发现这一点，这就会浪费很多时间，尤其是数据结构题）</li>
<li><strong>让读者看懂。</strong>（最次）（我的博客首先肯定是基于我自己再看一遍能懂的，所以肯定阅读门槛就是我自己的水平，或者比自己再弱一点的水平，如果你不能看懂请移步别人的博客。因为我写博客的初衷就是为了自己的提升，当作自己的笔记本用的，而不是造福广大OIer的。当然，如果几乎大部分人都看不懂的话我就有必要反思自己的语言表达能力了）</li>
</ol>
<p>至于第5条，对我自己最重要的警告就是，写博客要明白什么东西是要写的，什么东西是不用写的（我一定懂的），深刻明白这一点能够节省我很多时间，最大化博客对我的作用。（毕竟我之前经常放弃写博客的原因就是浪费时间，而且我写博客一贯的作风就是冗杂，对读者对我都不好，这点一定要改）</p>
<p>一个经典的例子是：一个题目有很多证明，不需要什么证明都写，写一两个个人认为最优美的证明就行了。不否认每个证明都有其自己的价值，但实际上有很多证明我自己心里也清楚，我绝对不会再想看他第二次了，感觉不如 ** 证明。（有很多做法的情况也是同理）</p>
<p>至于反思总结的工作，我会自己在本地机子上用excel编写，写在博客上一来我自己不会看，而且多篇博客的形式很不方便重新浏览这些总结，二来这些极具个人色彩的东西放在博客里也十分影响观感，而写在excel上清晰明了，方便反复查看，作用最大化。</p>
<p>比较简单的题目不会写博客，有时候可能会提一嘴。</p>
<p>附录：</p>
<ol>
<li>官方题解的部分不仅会解释官方题解，某些题目还会额外的思考：究竟如何思考这道题目，才能更快的想出做法。（思考如何正确的思考）</li>
<li>一场比赛的题目有时候会在比赛总结里面统一讲解，不会单独开一个博客单独讲解。</li>
</ol>
<h1 id="暂未解决"><a href="#暂未解决" class="headerlink" title="暂未解决"></a>暂未解决</h1><p>按照如下步骤进行：</p>
<ol>
<li>在文章的小标题（不是文章标题）中使用“坑”的标记。（结合第二条方便定位在文章中的位置）</li>
<li>在博客“待解决”中加入需要解决的事宜。（方便定位）</li>
<li>在本地机子的计划中写上期望解决的日期，到达这个日期就就将这个“坑”的解决提上日程。</li>
</ol>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>ACM杂类</tag>
      </tags>
  </entry>
  <entry>
    <title>关于一个特殊背包的时间复杂度证明</title>
    <url>/2024/07/01/%E5%85%B3%E4%BA%8E%E4%B8%80%E4%B8%AA%E7%89%B9%E6%AE%8A%E8%83%8C%E5%8C%85%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E8%AF%81%E6%98%8E/</url>
    <content><![CDATA[<p>众所周知，如果完全背包中所有物品大小总和是 $V$ ，那么时间复杂度是 $O(V\sqrt{V})$ 的。</p>
<p> $01$ 背包也类似，但是我以前一直以为要写成多重背包的形式复杂度才是对的。</p>
<p>但实际上可以二进制拆分，时间复杂度也是对的，为什么呢？</p>
<details class="toggle" ><summary class="toggle-button" style="">证明</summary><div class="toggle-content"><p>首先，拆分中的最后一步，显然只有至多 $O(\sqrt{V})$ 种物品。</p>
<p>现在问题是那些 $2$ 的幂次的情况。</p>
<p>我们不妨考虑最坏情况，选择 $x$ 后，$\frac{x}{2^{i}}$ 全部都贡献了一次。</p>
<p>即对于 $x$ ，选其的贡献是最大的 $k$ ，满足：$x=2^ky$ 。</p>
<p>那么可以发现，这个贡献的数量级小于等于 $\sum\limits_{i=0}\sqrt{\frac{V}{2^{i}}}$ ，所以物品个数还是 $O(\sqrt{V})$ 的。</p>
<p>时间复杂度还是：$O(V\sqrt{V})$ ，比多重背包好写很多。</p>
</div></details>]]></content>
      <categories>
        <category>信息学</category>
      </categories>
  </entry>
  <entry>
    <title>卡常的辅助方法</title>
    <url>/2024/02/20/%E5%8D%A1%E5%B8%B8%E7%9A%84%E8%BE%85%E5%8A%A9%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<ol>
<li><p>使用能够测量代码时间的代码辅助卡常。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> begin = std::chrono::high_resolution_clock::<span class="built_in">now</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> end = std::chrono::high_resolution_clock::<span class="built_in">now</span>();</span><br><span class="line"><span class="keyword">auto</span> elapsed = std::chrono::<span class="built_in">duration_cast</span>&lt;std::chrono::nanoseconds&gt;(end - begin);</span><br><span class="line">cerr &lt;&lt; B &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; elapsed.<span class="built_in">count</span>() * <span class="number">1e-9</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br></pre></td></tr></table></figure></li>
<li>警告：别开O3，那不真实，万一比赛ban了O3你就完了，老老实实卡常，练习卡常技巧。</li>
</ol>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>卡常</tag>
      </tags>
  </entry>
  <entry>
    <title>实验</title>
    <url>/2023/08/08/%E5%AE%9E%E9%AA%8C/</url>
    <content><![CDATA[<h1 id="喜"><a href="#喜" class="headerlink" title="喜"></a>喜</h1><h2 id="怒"><a href="#怒" class="headerlink" title="怒"></a>怒</h2><h3 id="哀"><a href="#哀" class="headerlink" title="哀"></a>哀</h3><h2 id="乐"><a href="#乐" class="headerlink" title="乐"></a>乐</h2><h1 id="典"><a href="#典" class="headerlink" title="典"></a>典</h1><p>$a_{i}=1$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>$good$<br>good</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hello world.</span><br></pre></td></tr></table></figure>
<p><img src="1.png" alt="1.png"></p>
<p>😀</p>
<div class="tabs" id="test1"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test1-1">test1 1</button></li><li class="tab"><button type="button" data-href="#test1-2">test1 2</button></li><li class="tab"><button type="button" data-href="#test1-3">test1 3</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test1-1"><p><strong>This is Tab 1.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-2"><p><strong>This is Tab 2.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-3"><p><strong>This is Tab 3.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>
<p>现在已经知道 hidetoggle 和代码块嵌套会导致渲染出错。</p>
<p>解决方法为在每层嵌套中间加句号。</p>
<details class="toggle" ><summary class="toggle-button" style="">1</summary><div class="toggle-content"><p>。</p>
<p><details class="toggle" ><summary class="toggle-button" style="">2</summary><div class="toggle-content"><p>。</p></p>
<p><details class="toggle" ><summary class="toggle-button" style="">3</summary><div class="toggle-content"><p>。</p>
</div></details></p>
<p>。</p></div></details>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>。</p></div></details>
<details class="toggle" ><summary class="toggle-button" style="">1</summary><div class="toggle-content"><p><details class="toggle" ><summary class="toggle-button" style="">2</summary><div class="toggle-content"><details class="toggle" ><summary class="toggle-button" style="">3</summary><div class="toggle-content"></div></details>&lt;/div&gt;&lt;/details&gt;<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br></pre></td></tr></table></figure></p>
</div></details>]]></content>
      <categories>
        <category>杂项</category>
      </categories>
  </entry>
  <entry>
    <title>可以尝试解决的题目</title>
    <url>/2023/09/04/%E5%8F%AF%E4%BB%A5%E5%B0%9D%E8%AF%95%E8%A7%A3%E5%86%B3%E7%9A%84%E9%A2%98%E7%9B%AE/</url>
    <content><![CDATA[<ol>
<li><a href="https://acm.ecnu.edu.cn/contest/695/problem/E/">https://acm.ecnu.edu.cn/contest/695/problem/E/</a></li>
</ol>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>杂题</tag>
        <tag>待解决</tag>
      </tags>
  </entry>
  <entry>
    <title>待解决</title>
    <url>/2024/01/20/%E5%BE%85%E8%A7%A3%E5%86%B3/</url>
    <content><![CDATA[<p>学习书籍 《A course in combinatorial optimization》，在网上突然看到的，感觉这一本书还是很有学习的必要的。</p>
<ol>
<li>“MEXimum Spanning Tree” 中的根号做法是什么。（解决条件：学会 Hopcroft Karp 的复杂度分析）</li>
<li>“拟阵学习笔记”：<ol>
<li>匹配拟阵交换性的证明。（用增广路的证明）</li>
<li>用基的定义能不能再弱一点。</li>
<li>带权拟阵交。</li>
<li>学习剩下的内容。</li>
</ol>
</li>
<li>Game of Connect(Shannon’s Switching Game) 学会 Shannon’s Switching Game 。</li>
<li>Graffiti 那个dp分块到底是哪一年提高组初赛的题目。</li>
<li>Not Intersect 的生成函数做法。</li>
<li>The 2nd Ucup Stage 2: SPb M. Hardcore String Counting 写代码</li>
</ol>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>ACM杂类</tag>
      </tags>
  </entry>
  <entry>
    <title>楼房重建</title>
    <url>/2024/03/20/%E6%A5%BC%E6%88%BF%E9%87%8D%E5%BB%BA/</url>
    <content><![CDATA[<p>题目链接：<a href="https://www.luogu.com.cn/problem/P4198">https://www.luogu.com.cn/problem/P4198</a></p>
<p>题目大意：维护有多少个不同的前缀最大值（相同数值但是位置更靠后的认为更大且两数不同，即认为每个数字加上与位置成正比的浮动）</p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>非常经典的题目，众所周知，信息学有一类题目的出题方法就是打破常规。</p>
<p>这道题目就是个经典的打破常规的题目，当然你也可以从别的角度去看他。</p>
<p>正常的线段树 updata 都是 $O(1)$ 的，但是这道题目的 updata 是 $\log$ 的。</p>
<p>更详细的来说，维护这么一个函数 $g(x,k)$ ，能够维护 $x$ 所管理的区间中 $\ge k$ 的不同前缀最大值个数。</p>
<p>这个函数可以 $\log$ ，当左区间的最大值 $&lt;k$ ，那么直接去右区间，左区间贡献为 $0$ 。否则，说明考虑左区间的话，对右区间的不同前缀最大值没有影响，直接去左区间就行了，而右区间的贡献就是 $x$ 的不同前缀最大值个数，减去左儿子的。（满足可减性）</p>
<p>用这个函数可以在 $\log$ 的时间轻松实现 updata ，这样就可以在 $O(\log^2)$ 的时间解决这个问题。</p>
<p>显然，这个做法还能轻松实现区间不同的前缀最大值个数。</p>
<p>时间复杂度： $O(n+q\log^2n)$ 。</p>
<p>空间复杂度： $O(n)$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> NN=<span class="number">2e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> eps=<span class="number">1e-8</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Fac</span>&#123;LL a,b;&#125;;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>&lt;(Fac x,Fac y)&#123;<span class="keyword">return</span> x.a*y.b&lt;x.b*y.a;&#125;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>&lt;=(Fac x,Fac y)&#123;<span class="keyword">return</span> !(y&lt;x);&#125;</span><br><span class="line">Fac a[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> lc,rc,c;</span><br><span class="line">    Fac mx;</span><br><span class="line">&#125;tr[NN];<span class="type">int</span> len;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">findans</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> l,<span class="type">int</span> r,Fac k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l==r)<span class="keyword">return</span> k&lt;=tr[x].mx &amp;&amp; tr[x].mx.a;</span><br><span class="line">    <span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(tr[tr[x].lc].mx&lt;k)<span class="keyword">return</span> <span class="built_in">findans</span>(tr[x].rc,mid+<span class="number">1</span>,r,k);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> tr[x].c-tr[tr[x].lc].c+<span class="built_in">findans</span>(tr[x].lc,l,mid,k);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">updata</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> l,<span class="type">int</span> mid,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(tr[x].lc &amp;&amp; tr[x].rc);</span><br><span class="line">    tr[x].mx=<span class="built_in">max</span>(tr[tr[x].lc].mx,tr[tr[x].rc].mx);</span><br><span class="line">    tr[x].c=tr[tr[x].lc].c+<span class="built_in">findans</span>(tr[x].rc,mid+<span class="number">1</span>,r,tr[tr[x].lc].mx);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bt</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> x=++len;</span><br><span class="line">    <span class="keyword">if</span>(l&lt;r)&#123;</span><br><span class="line">        <span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        tr[x].lc=<span class="built_in">bt</span>(l,mid);</span><br><span class="line">        tr[x].rc=<span class="built_in">bt</span>(mid+<span class="number">1</span>,r);</span><br><span class="line">        <span class="built_in">updata</span>(x,l,mid,r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> tr[x].mx=a[l];</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">change</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> id,Fac k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">        tr[x].mx=k;</span><br><span class="line">        tr[x].c=k.a&gt;<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(id&lt;=mid)<span class="built_in">change</span>(tr[x].lc,l,mid,id,k);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">change</span>(tr[x].rc,mid+<span class="number">1</span>,r,id,k);</span><br><span class="line">    <span class="built_in">updata</span>(x,l,mid,r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,q;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;q);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)a[i]=&#123;<span class="number">0</span>,<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="built_in">bt</span>(<span class="number">1</span>,n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=q;i++)&#123;</span><br><span class="line">        <span class="type">int</span> x,y;<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;x,&amp;y);</span><br><span class="line">        a[x]=&#123;y,x&#125;;</span><br><span class="line">        <span class="built_in">change</span>(<span class="number">1</span>,<span class="number">1</span>,n,x,a[x]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,tr[<span class="number">1</span>].c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然，这个问题还能扩展。</p>
<p>思考一下，假如维护的信息不满足可减性怎么办呢？</p>
<p>答案是每个点不维护区间的答案，而是维护在考虑左区间的情况下右区间的贡献即可。</p>
<p>这个方法又有个别名，叫兔队线段树。</p>
<p>原链接在这：<a href="https://www.cnblogs.com/PinkRabbit/p/Segment-Tree-and-Prefix-Maximums.html">https://www.cnblogs.com/PinkRabbit/p/Segment-Tree-and-Prefix-Maximums.html</a></p>
<p>一道练习题在这：<a href="https://codeforces.com/contest/671/problem/E">https://codeforces.com/contest/671/problem/E</a></p>
<p>具体做法看原链接吧，我感觉粉兔已经说的很明白了。<del>其实是因为我懒</del></p>
</div></details>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>经典问题</tag>
      </tags>
  </entry>
  <entry>
    <title>小凯的疑惑</title>
    <url>/2024/05/29/%E5%B0%8F%E5%87%AF%E7%9A%84%E7%96%91%E6%83%91/</url>
    <content><![CDATA[<p>题目链接：<a href="https://www.luogu.com.cn/problem/P3951">https://www.luogu.com.cn/problem/P3951</a></p>
<p>题目大意：给你两个互质的整数 $a,b$ ，求最大的不能由 $ka+tb$ 表示的数字，其中 $k,t$ 非负。</p>
<p>看到一个很好的解法，这里写一下。</p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>需要明白，不定方程和同余方程本质是一样的。</p>
<p>从同余方程的角度考虑，$ka\equiv x\mod{b}$ ，不妨令 $0\le k \le b-1$ ，那么 $x$ 能够表示的充要条件是 $\frac{x-ka}{b}\ge 0$ ，因此直接令 $k=b-1,\frac{x-ka}{b}=-1$ 就可以得到最大的不能被表示的数字：$ab-a-b$ 。</p>
<p>当然也可以从不定方程的角度考虑，对于任意一组解：$ka+tb=x$ ，则 $(k-b)a+(t+a)b=x$ ，所以不妨令 $0\le k\le b-1$ （即找到最小的非负的 $k$），然后能表示当且仅当 $t\ge 0$ ，所以令 $k=b-1,t=-1$ 就行了。</p>
<p>可以看到，这两个做法几乎一样，本质上是相同的。因此在做题目的时候，可以哪个角度好想就从哪个角度想。</p>
</div></details>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
  </entry>
  <entry>
    <title>拟阵初级学习笔记</title>
    <url>/2024/01/26/%E6%8B%9F%E9%98%B5%E5%88%9D%E7%BA%A7%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>建议直接去看原论文，哪篇论文放在参考文献了。</p>
<p>前排提示，本篇中对于集合操作 $+$ 和 $\cup$ 没有区分，都表示<strong>并</strong>的意思，$-$ 和 $\setminus$ 同理。</p>
<h1 id="拟阵的入门"><a href="#拟阵的入门" class="headerlink" title="拟阵的入门"></a>拟阵的入门</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><h3 id="幂集"><a href="#幂集" class="headerlink" title="幂集"></a>幂集</h3><p> $2^S$ 称作 $S$ 的拟阵当且仅当 $2^S$ 是 $S$ 所有子集构成的集合。</p>
<p> 例如：$\{1,2\}$ 的幂集是 $\{\{1,2\},\{1\},\{2\},\emptyset\}$ 。</p>
<h3 id="拟阵"><a href="#拟阵" class="headerlink" title="拟阵"></a>拟阵</h3><p>记 $M=(S,\mathcal{I})$ 表示一个定于在有限集合 $S$ 且独立集的集合为 $\mathcal{I}$ 的当且仅当满足以下三条：</p>
<ol>
<li>$\mathcal{I}\subset 2^S$</li>
<li><strong>遗传性</strong> ：如果 $J\subset I\in \mathcal{I}$，那么 $J\in \mathcal{I}$ 。</li>
<li><strong>交换性/扩张性</strong> ：如果 $I,J\in\mathcal{I},|J|&lt;|I|$，那么 ${\exists}z\in J\setminus I , I\cup z\in \mathcal{I}$ 。</li>
</ol>
<p>为了方便，我们一般认为 $\emptyset \in \mathcal{I}$ ，即认为独立集的集合是非空的。</p>
<p>我们称 $\mathcal{I}$ 的元素为独立集。</p>
<p>例子：</p>
<p><strong>均匀拟阵</strong> ：$U^k_n=(S,\mathcal{I})$，其中 $|S|=n,\mathcal{I}=\{I\subset S : |I| \le k \}$ 。</p>
<p><strong>图拟阵</strong> ：令无向图 $G=(V,E)$，令图拟阵：$M=(E,\mathcal{I})$ ，其中 $\mathcal{I}=\{F\subset E : F 无环\}$ 。</p>
<p>为啥是拟阵这件事不难自证，不再赘述。</p>
<p>图拟阵非常的重要，因为他提供了一个形象想象拟阵的工具，在前期学习拟阵在图拟阵上想想是非常有用的方法。</p>
<p>不过图拟阵在有向图上不一定成立，一样的定义，只不过把无向图换成有向图。</p>
<p><img src="1.png" alt=""></p>
<p><strong>匹配拟阵</strong> ：令无向图 $G=(V,E)$，匹配拟阵：$M=(V,\mathcal{I})$ ，其中一个点集是独立集当且仅当存在一个匹配能够覆盖点集中的所有点（可以覆盖点集外的点）。</p>
<p>遗传性显然，交换性不会。</p>
<p>拟阵同时还可以与高代联动，对于一个有限的向量空间，一个独立集定义为线性无关的向量组，非常有意思的是，此时下面基的定义就是高代中基的定义，环是最小的线性相关的向量组，而引理1.2对应的就是基扩张定理。（从这个角度来看，很多拿到一个子空间的极大独立集，直接扩张成大空间的极大独立集的证明，突然就熟悉多了，这也能与课内联动？）</p>
<p>这么说的话，用线性空间来作为拟阵的例子辅助思考貌似也是一个不错的选择。</p>
<h6 id="坑1"><a href="#坑1" class="headerlink" title="坑1"></a>坑1</h6><p>不会交换性的证明。</p>
<h3 id="基"><a href="#基" class="headerlink" title="基"></a>基</h3><p>独立集 $I$ 是基当且仅当加入 $S/I$ 中的任何一个元素都不是独立集。</p>
<p>这种拟阵中的极大元素，在拟阵的研究中发挥着至关重要的作用。</p>
<h3 id="环"><a href="#环" class="headerlink" title="环"></a>环</h3><p>一个非独立集 $I’$ 是环当且仅当 $I’$ 删除其中任意一个元素都是独立集。</p>
<p>例子：图拟阵中的简单环。</p>
<p>我们用 $C(M)$ 表示拟阵 $M$ 中所有的环。</p>
<h2 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h2><p><strong>引理 1.1</strong> ：基的大小相同。（用交换性显然）</p>
<p><strong>引理 1.2</strong> ：${\forall} J \in \mathcal{I},{\exists} 基I:J\in I$ 。（用交换性显然）</p>
<p>该引理说明任意一个元素都属于一个基，所以对于一个拟阵，只要知道基，加上遗传性就可以知道所有独立集。</p>
<p>但是能不能凭借此定义独立集的集合呢？</p>
<p>还需要一个定理：</p>
<p><strong>定理 1.3(基交换定理)</strong> ：${\forall}基A,B,A\ne B,{\forall} z\in A\setminus B,{\exists} y\in B\setminus A:A-\{z\}+\{y\}\in \mathcal{I}$ 。（用遗传性显然）</p>
<p>满足基交换定律且大小相同的基的集合可以定义一个拟阵。（可以证明交换性成立，并不困难，在此不再赘述，证明过程类似【完美匹配那个证明】）</p>
<p>这种定义相较于原来定义的优势在于检验拟阵的工作量小了，本来对于每一对独立集都要检验，现在只需要检验基，尤其是对于自己随手写的拟阵，例如：$\{\{1,3,4\},\{2,3,4\}\}$ 。</p>
<h6 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h6><p>完美匹配定理的编号。</p>
<h6 id="坑2"><a href="#坑2" class="headerlink" title="坑2"></a>坑2</h6><p>其实我觉得这里的大小相同的限制可以改得再弱一点：基之间没有包含关系，我严重怀疑没有包含关系可以推出大小相同，但是水平有限，目前我证不出来。</p>
<p>基交换定理可以放宽一下条件，仍然成立：</p>
<p>${\forall}A,B\in \mathcal{I},|A|\le|B|,{\forall} z\in A,{\exists} y\in B\setminus (A-\{z\}):A-\{z\}+\{y\}\in \mathcal{I}$ 。</p>
<p><strong>引理 1.4</strong> ：$I$ 不是独立集，则一定有一个子集是环 。（显然）</p>
<p><strong>引理 1.5</strong> ：${\forall}X,Y\in C(M),X\subset Y:X=Y$ 。（显然）</p>
<p><strong>引理 1.6</strong> ：${\forall}X,Y\in C(M),X\ne Y,e\in X\cap Y:{\exists} C\in C(M),C\subset X\cup Y-\{e\}$ 。</p>
<details class="toggle" ><summary class="toggle-button" style="">证明</summary><div class="toggle-content"><p>等价于证明 $X\cup Y-\{e\}$ 不是独立集。</p>
<p>证明一个集合不是独立集，思考一下条件：环、一个已知的集合。因此我们考虑利用这个已知的集合用反证法，通过构造与环产生矛盾。</p>
<p>反证法：已知 $X\cap Y \in \mathcal{I}$ ，然后用 $X\cup Y-\{e\}$ 扩大这个集合到同样的大小，由于环的限制， $X\setminus Y,Y\setminus X$ 都要丢掉一个元素，所以集合大小最大是 $|X|+|Y|-2$ ，然而可以扩展到 $|X|+|Y|-1$ ，矛盾，证毕。</p>
<p>至于更加严谨的写法，这里引用一下2018国集论文（根据引理编号对内容做了一点更改）：</p>
<p>证明：由引理 1.5 可得， $X\setminus Y$ 非空，设 $f \in X\setminus Y$ 。假设 $X\cup Y − \{e\}$ 是独立集。由于 $X$ 是环，<br>所以 $X − \{f\}$ 是独立集，假设 $X\cup Y$ 中最大的包含 $X − \{f\}$ 的独立集是 $Z$ 。由于 $Y$ 不是独立<br>集，所以 $Y \not\subset Z$ 。由此可得 $|Z|\le |X\cup Y − \{f\}| − 1 \le |X \cup Y| − 2 &lt; |X \cup Y − \{e\}|$ 。因为 $Z$ 已经<br>是最大的独立集了，所以 $X\cup Y − \{e\}$ 不可能是独立集（否则由交换性可以扩大 $Z$ ），命题得证。</p>
</div></details>
<p><strong>引理 1.7</strong> ：$I$ 是基，$e\notin I$ ，那么 $I+\{e\}$ 包含一个唯一的环。</p>
<details class="toggle" ><summary class="toggle-button" style="">证明</summary><div class="toggle-content"><p>至少有一个环是显然的，每个环都有 $e$ 是显然的。</p>
<p>引理 1.6 告诉我们只要有两个环，就可以构造出不含 $e$ 的环，所以至多只有一个环。</p>
<p>证毕。</p>
</div></details>
<h1 id="秩函数"><a href="#秩函数" class="headerlink" title="秩函数"></a>秩函数</h1><h2 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h2><p>对于拟阵 $M=(S,\mathcal{I})$ ，基的元素的个数称为拟阵的秩，对于任意一个 $U\subset S$，定义秩函数 $r(U)$ 表示 $U$ 中极大独立集的大小。</p>
<h2 id="性质-1"><a href="#性质-1" class="headerlink" title="性质"></a>性质</h2><p><strong>定理 2.1(有界性)</strong> ：${\forall}U\subset S, 0\le r(U)\le|U|$</p>
<p><strong>定理 2.2 (单调性)</strong> ：${\forall}A\subset B\subset S,r(A)\le r(B)$</p>
<p><strong>定理 2.3 (次模性)</strong> ：${\forall}A,B\subset S,r(A\cup B)+r(A\cap B)\le r(A)+r(B)$</p>
<p>定理1,2都是显然的，下面证明定理3。</p>
<details class="toggle" ><summary class="toggle-button" style="">证明</summary><div class="toggle-content"><p>首先，我们使用构造方法，证明一个集合的秩的下界是更加容易的（构造一个独立集总比说明独立集大小的上界要容易得多），根据这个方向，我们得到这个证明：</p>
<p>先找到 $A\cap B$ 的极大独立集，然后用交换性扩大成 $A\cup B$ 的极大独立集，然后把扩大的部分，按照 $A\setminus B,B\setminus A$ 分成两部分，和 $A\cap B$ 的极大独立集合成 $A,B$ 的独立集，然后就证完了。</p>
<p>更加严谨的写法看国集论文，这里懒得复制粘贴了，思路是一样的。</p>
</div></details>
<p>那么问题来了，我们能否用秩函数定义拟阵？答案是：可以。</p>
<p>如果我们有一个函数 $r$ ；$2^S\to \mathbb{Z}$，定义 $\mathcal{I}={I:r(I)=|I|}$ 。</p>
<details class="toggle" ><summary class="toggle-button" style="">遗传性证明</summary><div class="toggle-content"><p>在遗传性的证明中，我们更希望证明一个集合是独立集，也就是证明 $r(I)=I$ ，显然，我们其实是需要证明 $r(I)\ge I$ ，所以在证明中应该更多的将目标集合放在 $\le$ 的右边。</p>
<p>$A=J,B=I\setminus J$，即可证明。</p>
</div></details>
<details class="toggle" ><summary class="toggle-button" style="">交换性证明</summary><div class="toggle-content"><p>在交换性的证明中，由于找到具体哪个集合是独立集有点困难，采用反证，则考虑限制集合秩的上界，去证明大集合（$I$）并不是独立集，此时把目标集合（$I$）放在 $le$ 左边限制上界。</p>
<p>令 $\{b_1,b_2,…,b_n\}=I\setminus J$</p>
<p>考虑 ：$A=J+\{b_1\},B=J+\{b_2\}$，则可以证明 $r(J+\{b_1,b_2\})=|J|$，然后将其作为新的 $A$，令 $B=J+\{b_3\}$ ，不断往下做，直到合成出 $I\cup J$ 为止，此时 $r(I\cup J)=|J|&lt;|I|=r(I)$ ，矛盾，证毕。</p>
</div></details>
<p>说点抽象的话：</p>
<p>事实上，定理 3 变换一下可以得到另外一个形式：$r(A\cup B)-r(A)\le r(B)-r(A\cap B)$ ，然后变个符号：$r(A\cup C)-r(A)\le r(B\cup C)-r(B),B\subset A$ 。</p>
<p>在面对一个集合时，小集合的增量要不劣于大集合的增量，这说明小集合比起大集合具有更大的增长潜力，在后面闭包算子中会反复提及这一点。</p>
<p>当然，对于这一点，可以这么理解，现在假设有个空集，他可以到达任何的基，但是随着元素一个个被确定，能到达的基越来越少，选择也越来越少，因此增长潜力也在减小，极端的，当为基的时候，没有选择，增长不了，增长潜力达到最低值。</p>
<h1 id="拟阵最优化"><a href="#拟阵最优化" class="headerlink" title="拟阵最优化"></a>拟阵最优化</h1><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>定义函数 $w:S\to \mathbb{R}$ ，定义一个集合的权值为：$w(I)=\sum\limits_{e\in I}w(e)$，找 $\mathcal{I}$ 中最大的 $w(I)$ 。</p>
<p>例子：最小生成树。</p>
<h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p><del>最小生成树plus版</del></p>
<p>以下先默认权值非负，因此显然权值最大的基就是权值最大的独立集。</p>
<ol>
<li>把 $S$ 中的元素按照从大到小的顺序排序，记作 $s_1,s_2,s_3,…,s_n$ 。</li>
<li>维护一个集合 $I$ ，初始为空，按顺序考虑 $s_i$ ，如果 $I$ 加上 $s_i$ 是独立集就加入，否则就不加入。</li>
</ol>
<details class="toggle" ><summary class="toggle-button" style="">证明</summary><div class="toggle-content"><p>没看懂论文第二步的证明，自己瞎掰了一个。</p>
<p>记 $U_i=\{s_1,s_2,…,s_i\}$，$I_i$ 为考虑完 $s_i$ 后的 $I$ 。</p>
<p>$|I_i|=r(U_i)$ ，否则$|I_i|$ 可以扩大，加入的元素为 $s_j(j\le i)$ ，则一定会在考虑到 $s_j$ 的时候加入该元素，矛盾，所以成立。</p>
<p>所以最后 $I$ 是一个基。</p>
<p>考虑把每个独立集用其所含元素的下标从小到大呈现，例如：$\{1,2,4\}$ 表示其含有 $s_1,s_2,s_4$ 。</p>
<p>那么对于 $I$ ，假设其呈现出来是：$a_1,a_2,…,a_t$ , 对于任意一个基而言，是：$a’_1,a’_2,…,a’_t$ ，那么显然有 $a_i\le a’_i$ ，则显然 $I$ 是权值最大的基。</p>
</div></details>
<p>事实上，同样的证明方法，不一定要 $I$ 是基，可以扩展，当 $|I|$ 的大小为 $t$ 时，$I$ 就是所有大小为 $t$ 的独立集中权值最大的。</p>
<p>所以就算权值是非负的，如果指定了目标独立集的大小，仍然可以用此算法。（不过如果已经指定了大小，令总体权值加减一个数字只会让答案改变 $siz*val$，也能把问题转化到非负情形下）</p>
<p>但是如果权值可以是负数呢？</p>
<p>显然当 $s_i\le 0$ 时推出就行了，显然正确，考虑答案只可能出在 $I_i$ 就行了。（显然，$I_i$ 是同集合大小的独立集中权值最大的，只考虑他就行了）</p>
<h1 id="拟阵交"><a href="#拟阵交" class="headerlink" title="拟阵交"></a>拟阵交</h1><h2 id="问题-1"><a href="#问题-1" class="headerlink" title="问题"></a>问题</h2><p>对于 $M_1=(S,\mathcal{I}_1)$，$M_2=(S,\mathcal{I}_2)$ ，定义 $M_1,M_2$ 的交是所有 $I$ 的集合 ，$I$ 满足在两个集合中都是独立集。</p>
<p>首先，拟阵的交是拟阵吗？不是。</p>
<p>反例：$S=\{1,2,3\},\mathcal{I}_1=\{\emptyset,\{1\},\{2\},\{3\},\{1,2\},\{1,3\}\},\mathcal{I}_2=\{\emptyset,\{1\},\{2\},\{3\},\{1,2\},\{2,3\}\}$ 。</p>
<p>交为：$\{\emptyset,\{1\},\{2\},\{3\},\{1,2\}\}$</p>
<p>显然不是拟阵。</p>
<p>不过拟阵交虽然不是拟阵，但是显然是个集合，那问题来了，这个集合中大小最大的独立集有多大？并且求出一个合法解。</p>
<p>这个问题在两个拟阵的交时有多项式求法，但是三个以上是 NP-hard 的。</p>
<p>所以接下来的讨论默认是两个拟阵的交。</p>
<h2 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h2><h3 id="闭包算子"><a href="#闭包算子" class="headerlink" title="闭包算子"></a>闭包算子</h3><p>对于 $A\subset S$ ，我们定义 $A$ 的闭包算子 $cl(A)=\{e\in S : r(A\cup \{e\})=e(A)\}$ 。</p>
<p>也就是加入后不会影响 $A$ 的秩的元素。</p>
<p>一个显然的事情：$A\subset cl(A)$ 。</p>
<h3 id="交换图"><a href="#交换图" class="headerlink" title="交换图"></a>交换图</h3><p>对于 $I\in \mathcal{I}$，定义一个二分图，一边是 $I$ ，一边是 $S\setminus I$ ，存在边 $(x,y)(x\in I,y\in S\setminus I)$ 当且仅当 ：$I-\{x\}+\{y\}\in \mathcal{I}$ 。</p>
<p>称此二分图为 $I$ 的交换图，记作 $D_M(I)$ 。</p>
<h2 id="性质-2"><a href="#性质-2" class="headerlink" title="性质"></a>性质</h2><p><strong>引理 4.1</strong> ：如果 $A\subset B$ ，那么 $cl(A)\subset cl(B)$ 。</p>
<details class="toggle" ><summary class="toggle-button" style="">证明</summary><div class="toggle-content"><p>兄弟，来一个极其富有高代特色的证明。</p>
<p>对于任意一个 $z\in cl(A)$ ，找到 $A$ 的一个极大独立集，然后在 $B+\{z\}$ 中扩大，那么一定会得到一个不含 $z$ 的极大独立集，所以 $z$ 不会扩大 $B$ 的秩。</p>
<p>这个证明用到了一个显然正确的结论：如果加入 $z$ 后，存在一个极大独立集不包含 $z$ ，那么 $z$ 一定在该集合的闭包算子中，否则不在。</p>
<p>论文采用秩函数证明：</p>
<p>$r(A+\{z\})+r(B)\ge r((A+\{z\})\cap B)+r(B+\{z\})\ge r(A)+r(B+\{z\})$ 。（也可以由 $r(A+\{z\})-r(A)\ge r(B+\{z\})-r(B)$ 得到，这个式子在上面的次模性的变形中给出过）</p>
<p>又 $r(A+\{z\})=r(A)$ ，所以 $r(B)\ge r(B+\{z\})$，所以 $r(B)=r(B+\{z\})$ ，证毕。</p>
</div></details>
<p>这个定理同样反映了小集合比大集合更加具有增长潜力，一个元素对小集合没有贡献，那么对大集合同样没有贡献。</p>
<p><strong>引理 4.2</strong> ：$A\subset S,e\in cl(A)$ ，那么 $cl(A)=cl(A\cup \{e\})$ 。</p>
<details class="toggle" ><summary class="toggle-button" style="">证明</summary><div class="toggle-content"><p>${\forall} z \in cl(A\cup \{e\}),r(A)=r(A+\{z\})=r(A+\{e,z\})$，则 $r(A)\le r(A+\{z\})\le r(A+\{e,z\})$ ，所以 $r(A)=r(A+z)$ ，证毕。</p>
<p>人话讲就是，如果加到大集合秩不变，由于大集合秩等于小集合，大集合的秩本来就比小集合大，如果小集合变大了，就比大集合大了，所以加入到小集合中秩也不能变大。</p>
<p>所以如果 $r(A)=r(B),A\subset B$，那么 $cl(A)=cl(B)$ 。（引出下文）</p>
</div></details>
<p><strong>引理 4.3</strong> ：$cl(A)=cl(cl(A)),r(A)=r(cl(A))$ 。（反复用 引理 4.2 就行了）</p>
<p>上面两个引理说明了个什么事呢？（包括证明过程）</p>
<p>显然的事情：</p>
<ol>
<li>$A\subset B,r(A)=r(B)$，那么 $cl(A)=cl(B),B\setminus A \subset B\subset cl(B)=cl(A)$ 。（秩相同则 $cl$ 相同）</li>
<li>${\forall} B\subset cl(A):cl(A\cup B)=cl(A),r(A\cup B)=r(A)$ 。（这一条主要是对引理4.3的扩展）</li>
<li>$A\subset B,cl(A)=cl(B):r(A)=r(B)$ 。（因为 $B\subset cl(B)=cl(A)$，所以 $r(B)=r(A\cup B)=r(A)$ ）（ $cl$ 相同则秩相同）</li>
</ol>
<p>因此，如果子集之间相互包含，那么秩相同和 $cl$ 相同同时成立，也很符合直觉，集合变大，秩不变，那一定是你一直在加一些没有贡献的元素进来。同时，加入没有贡献的元素进来，也并不会改变没贡献的元素的集合，也就是说没贡献的元素之间不会产生联动，突然就产生贡献了，没用就是一直没用，直到秩增大。</p>
<p>这几个引理还可以从另外一个视角看：若 $C\subset cl(B)$ ，$B\subset cl(A)$ ，那么 $C\subset cl(A)$ ，这体现了闭包的传递性。</p>
<p>这也说明了一个事情：在产生秩增量这件事情上， $B$ 没用，$C$ 一定没用，$C$ 有用，$B$ 一定有用，也就是说某种程度上讲 $B$ 覆盖了 $C$ 的功能，这在后面的某些证明中有所体现。</p>
<p>在图拟阵中的一个体现就是：$(x,y)$ 和一个简单路径 $x\to y$ 形成了一个简单环，$(x,y)$ 的作用是有他在的边集合中，最大的独立集 $x,y$ 一定是联通的，而 $x\to y$ 一样能办到这件事。（此时 $(x,y)\in cl(x\to y))$）</p>
<p>注意一个特殊的集合：环，对于环 $I’,{\forall} z\in I’:z\in cl(I’-\{z\})$ ，这在后面的证明中会用到。</p>
<p><strong>定理 4.4(强基交换定理)</strong> ：对于两个不同的基 $A,B$ ，${\forall}x\in A\setminus B,{\exists} y\in B\setminus A : A-\{x\}+\{y\},B-\{y\}+\{x\}$ 都是基 。</p>
<details class="toggle" ><summary class="toggle-button" style="">证明</summary><div class="toggle-content"><p>先写论文的证法：</p>
<p>将 $x$ 加入 $B$ 中得到一个环 $C$ 。</p>
<p>则 $x\in cl(C-\{x\})$ ，则 $x\in cl((A\cup C)-\{x\})$ ，那么 $cl((A\cup C)-\{x\})=cl(A\cup C)$ ，所以 $r((A\cup C)-\{x\})=r(A\cup C)$ ，综上，存在 $y\in C-\{x\}$ ，满足 $A-\{x\}+\{y\}$ 是基，同时因为 $y$ 是环中的一个元素，所以 $B-\{y\}+\{x\}$ 也是环中的一个基。</p>
<p>这里其实就是用 $C-\{x\}$ 去代替 $x$ 的作用，然后找到是哪个元素起到了作用，将他作为 $y$ 。</p>
<p>当然，可以从染色的视角去看这个问题：</p>
<p>如果把这个问题放在图拟阵，也就是 $A$ 的一条边 $(x,y)$ 放到 $B$ 中，然后需要我去证明在 $B$ 的环中存在一条不是刚刚加入进来的边，满足能够填补 $A$ 的空缺。（一般的，我们认为 $A,B$ 都是生成树，就算是生成森林，边所在的联通块是一致的）</p>
<p>那么把 $A$ 中 $(x,y)$ 切断，与 $x$ 联通染蓝色， $y$ 联通染红色，显然，$B$ 中与 $(x,y)$ 形成环的路径上一定存在一条边，一端红色，一端蓝色，他就是我们要找的边。（因为路径两端一端红色，一端蓝色）</p>
<p>但是对点染色貌似和拟阵没什么关系，但是不妨换个角度看，我们要找的是路径上两端异色的边，所以我们不妨对边也染色，两端同色染为白色，异色染为黑色，观察一下这是什么？这就是 $cl(A-\{x\})$ ，也就是说 $cl$ 其实可以看成一种染色，无用染白，有用染黑。</p>
<p>有了这个想法，证明就轻松多了，显然在图拟阵中，一个环不能只有恰好一条黑边，否则从 $x$ 的联通块走黑边到达 $y$ 联通块，就没有另外一条黑边走回来了，与简单环的定义矛盾。所以去掉这条黑边是一个独立集（环的定义），加上这条黑边还是个独立集，与环矛盾，证毕。</p>
<p>用拟阵的话就是：反证法，如果 $C-\{x\}\subset cl(A-\{x\})$ ，那么 $x\notin cl(A-\{x\})$ ，则 $x\notin cl(C-\{x\})$ ，与环的定义矛盾，证毕。</p>
<p>所以 $cl$ 某种角度上可以算是拟阵的染色法。（先从图拟阵的角度思考是有道理的，直观）</p>
</div></details>
<p>当然，由上面的证明过程，可以放宽定理条件：$A,B$ 不一定得是基，只要满足 $|A|\le|B|$ 即可。</p>
<p>即：</p>
<p>${\forall}A,B\in \mathcal{I},|A|\le|B|,{\forall} x\in A,{\exists} y\in B\setminus (A-\{x\}):A-\{x\}+\{y\}，B+\{x\}-\{y\}\in \mathcal{I}$ 。</p>
<details class="toggle" ><summary class="toggle-button" style="">证明</summary><div class="toggle-content"><p>$B+\{x\}$ 不是独立集就类似上面证明就行了，小改即可。</p>
<p>是独立集，则 $|B+\{x\}|=|B|+1&gt;|A|$ ，则有交换性，存在 $y\in B:A+\{y\}\in\mathcal{I}$ 。</p>
<p>则 $A+\{y\}-\{x\}\in \mathcal{I}$ 。</p>
<p>这里还有个非常有意思的想法，用上面的思路证完 $|A|=|B|$ 的情况，然后对于 $|A|&lt;|B|$ 的情况，先用 $B$ 把 $A$ 扩大到相同大小，然后强交换，由于用于扩大的集合是两个集合的交集，所以不会出现在 $x,y$ 中，所以可以直接用遗传性再缩小回去，从而完成 $|A|&lt;|B|$ 的证明。</p>
<p>但是上面的思路可以直接把两种情况都证了，也就不需要多此一举了。</p>
</div></details>
<p><strong>引理 4.5</strong> ：对于独立集 $I,J,I\ne J,|I|=|J|$ ，则 $I\setminus J$ 与 $J \setminus I$ 存在完美匹配。</p>
<details class="toggle" ><summary class="toggle-button" style="">证明</summary><div class="toggle-content"><p>很有意思的构造性解，反正我没有证出来，思路确实新奇，小清新构造。（mad，没有证出来真TM不爽）</p>
<p>对于元素 $y\in J\setminus I$ ，由强交换定理可知存在 $x\in I\setminus J$ ，使得 $I-\{x\}+\{y\},J-\{y\}+\{x\}$ 仍然是独立集。</p>
<p>则认为 $x,y$ 匹配，然后令 $J=J+\{x\}-\{y\}$ ，接着构造，直到 $I=J$ ，构造完毕。</p>
</div></details>
<p><strong>引理 4.6</strong> ：对于独立集 $I$ 和集合 $J,I\ne J,|I|=|J|$ ，且 $I\setminus J$ 与 $J \setminus I$ 存在唯一的完美匹配，则 $J$ 也是独立集。</p>
<details class="toggle" ><summary class="toggle-button" style="">证明</summary><div class="toggle-content"><p>显然，要直接证明 $J$ 是不是独立集这件事情非常的困难，所以我的思路是构造+归纳，通过已有的信息，把 $I$ 构造出 $J$ 。</p>
<p>我们考虑把 $I\setminus J$ 换成 $J\setminus I$ 的一个元素，变成 $I’$ ，使得 $I’$ 与 $J$ 仍然只存在唯一的完美匹配。</p>
<p>考虑对于 $(x,y),x\in I\setminus J,y\in J\setminus I$ ，如果 唯一匹配是 $(x,y)$ ，则认为是 $x\to y$ ，否则认为是 $y\to x$ ，由于无环，所以是拓扑图。（因为是唯一匹配，所以无环，唯一匹配这个信息，显然是要往无环的角度去靠）</p>
<p>所以一定存在一个点 $x\in I\setminus J$ ，$x$ 没有入边，即在由 $I\setminus J$ 与 $J\setminus I$ 的导出子图中，$x$ 只有一条边。</p>
<p>考虑直接把 $x$ 换成与他匹配的 $y$ 。</p>
<p>不难证明（用交换性搞搞就行了），在 $D_M(I’)$ 中 $I’\setminus J$ 与 $J\setminus I’$ 的导出子图中的边一定在 $D_M(I)$ 中出现，同时 原来的匹配边也一定在新的导出子图中，所以仍然是唯一匹配。（匹配边还在，非匹配边减少了）</p>
<p>然后归纳就行了。</p>
<p>不过论文给了种更加简单的证明，不过我觉得本质应该差不多。</p>
<p>首先把匹配写成 $(x_1,y_1),(x_2,y_2),…,(x_t,y_t)$ 的形式，一般的，当 $i&lt;j$ 时， $x_i,y_j$ 没有边。（把 $x$ 按照拓扑序从小到大排就行了） </p>
<p>然后假设 $J$ 不是独立集，那么就存在环，假设为 $C$ ，并且其中下标最小的是 $y_i$ （显然一定有 $J\setminus I$ 的元素）。</p>
<p>考虑 $I-\{x_i\}$ ，那么 $C-y_i\subset cl(I-\{x_i\})$ ，又 $y_i\subset cl(C-y_i)\subset cl(cl(I-\{x_i\}))=cl(I-\{x_i\})$ ，这与 $x_i,y_i$ 匹配矛盾，证毕。</p>
<p>本质上就是 $C-\{y_i\}$ 能够替代 $y_i$ 的功能，但是由唯一匹配可以导出不能替代，从而导致了矛盾。</p>
</div></details>
<p><strong>引理 4.7</strong> ：$I,J\in \mathcal{I},|I|=|J|,{\forall} z\in J\setminus I,I+\{z\}\notin\mathcal{I},x\in S\setminus I,I+\{x\}\in \mathcal{I}$ ，那么 $J+\{x\}\in \mathcal{I}$ 。</p>
<details class="toggle" ><summary class="toggle-button" style="">证明</summary><div class="toggle-content"><p>$J\setminus I\subset cl(I)$ ，如果 $x\in cl(J)$ ，那么 $x\in cl(I)$ ，矛盾，证毕。</p>
</div></details>
<p><strong>定理 4.8(最小最大定理)</strong> ：$\max\limits_{I\in \mathcal{I_1}\cap\mathcal{I_2}} |I|=\min\limits_{U\subset S}(r_1(U)+r_2(S\setminus U))$</p>
<p>这里证明 $\le$ 是显然的，$|I\cap U|\le r_1(U)$ ，另一边同理，加起来就行了。</p>
<p>但是证明相等比较麻烦，后面在算法中用构造性方法证明。</p>
<h2 id="算法-1"><a href="#算法-1" class="headerlink" title="算法"></a>算法</h2><p>现在给出算法流程。</p>
<p>现有集合 $I,X_1=\{x\in S\setminus I:I+\{x\}\in \mathcal{I_1}\},X_2=\{x\in S\setminus I:I+\{x\}\in \mathcal{I_2}\}$ ，初始时 $I=\emptyset$ 。</p>
<p>定义交换图（有向图） $D_{M_1,M_2}(I)$ 为 ：</p>
<ol>
<li>$x\in I,y\in S\setminus I$ ，如果 $(x,y)\in D_{M_1}(I)$ ，那么 $x\to y\in D_{M_1,M_2}(I)$ 。</li>
<li>$x\in I,y\in S\setminus I$ ，如果 $(x,y)\in D_{M_2}(I)$ ，那么 $y\to x\in D_{M_1,M_2}(I)$ 。</li>
</ol>
<p>重复进行算法流程：</p>
<ol>
<li>在 $D_{M_1,M_2}(I)$ 找到一条起点属于 $X_1$ ，终点属于 $X_2$ 的最短路 $P$。（没有就结束算法）</li>
<li>令 $I=I∆P$ 。（ $∆$ 表示集合的对称差操作）</li>
</ol>
<p>最后得到的 $I$ 就是一个最大大小的拟阵交，同时 $U=\{x\in S:x 在D_{M_1,M_2}(I)能够到达 X_2 中的点\}$ 。</p>
<p>这个算法的正确性要证明两件事：</p>
<ol>
<li>$I$ 为什么仍然是拟阵交。</li>
<li>为什么 $|I|=r_1(U)+r_2(S\setminus U)$ 。</li>
</ol>
<details class="toggle" ><summary class="toggle-button" style="">证明1</summary><div class="toggle-content"><p>先证明新的 $I\in \mathcal{I_1}$ 。</p>
<p>令路径 $P=\{y_0,x_1,y_1,…,y_t\}$ ，令 $J=I-\{x_1,x_2,…,x_t\}+\{y_1,y_2,…,y_t\}$ ，由最短路可以导出是唯一匹配（因为 $D_{M_1}(I)$ 的结构类似 DAG 那样，BFS图），所以 $J$ 也是独立集，且同时可以直到 $y_1,y_2,…,y_t\in cl(I)$ ，由引理 4.7可知 $I+\{x\}\in \mathcal{I_1}$ 。</p>
<p>同理可证 $I\in \mathcal{I_2}$ 。</p>
<p>证毕。</p>
</div></details>
<details class="toggle" ><summary class="toggle-button" style="">证明2</summary><div class="toggle-content"><p>假设 $r_1(U)&gt;|I\cap U|$ ，则 ${\exists} z\in U\setminus I,(I\cap U)+\{z\}\in\mathcal{I_1}$ ，如果 $I+\{z\}\in \mathcal{I_1}$ ，则显然存在路径 $P$ ，否则，显然，$|I|&gt;|I\cap U|$ ，所以用 $I$ 把 $I\cap U +\{z\}$ 扩大，则显然存在 $x\in S\setminus U,I-\{x\}+\{z\}\in\mathcal{I_1}$ ，所以存在 $x\to z$ ，这与 $x\notin S$ 矛盾。</p>
<p>另外一边类似，不再赘述。</p>
<p>证毕。</p>
</div></details>
<p>这样，就证明了最小最大定理，同时也给出了一个求一组 $I,U$ 的多项式算法。</p>
<p>分析一下时间复杂度。</p>
<p>不计建 $D_{M_1,M_2}(I)$ 的复杂度，令 $n=|S|,r=\max(r_1(S),r_2(S))$ ，每次增广的代价是 $O(rn)$ ，每轮 $|I|$ 增大 $1$ ，所以至多进行 $r$ 轮，所以时间复杂度为 $O(r^2n)$ 。</p>
<p>非常优秀的时间复杂度。</p>
<h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><h3 id="三个以上的拟阵交为什么是-NP-Hard-的"><a href="#三个以上的拟阵交为什么是-NP-Hard-的" class="headerlink" title="三个以上的拟阵交为什么是 NP-Hard 的"></a>三个以上的拟阵交为什么是 NP-Hard 的</h3><p>可以证明难于哈密顿路径：</p>
<p>对于有向图 $G=(V,E)$ ，求 $s\to t$ 的哈密顿路径。</p>
<p>构造拟阵：</p>
<ol>
<li>令 $M_1$ 为边集满足把有向边看成无向边，则无环。</li>
<li>令 $M_2$ 为 $s$ 的入度为 $0$ ，其余点入度至多为 $1$ 。</li>
<li>令 $M_3$ 为 $t$ 的出度为 $0$ ，其余点出度至多为 $1$ 。</li>
</ol>
<p>求出这三个拟阵的拟阵交显然就能求出哈密顿路径，或者证明无解。</p>
<p>所以求三个及以上的拟阵交是 NP-Hard 的。</p>
<h3 id="带权拟阵交"><a href="#带权拟阵交" class="headerlink" title="带权拟阵交"></a>带权拟阵交</h3><p>定义权值函数：$w:S\to \mathbb{R}$ ，求 $\max\limits_{I\in \mathcal{I_1}\cap\mathcal{I_2}}\sum\limits_{e\in I}w(e)$ 。</p>
<p>扩展版本的最小最大定理我没看懂，这一部分建议自己去看论文。我没看懂这一部分，就不在这里胡说八道了。</p>
<p>算法流程就是把最短路径换成，以点权和最大为第一关键字，最少边数为第二关键字找路径。</p>
<p>其中 $I$ 的点权为 $-w(e)$ ，$S\setminus I$ 为 $w(e)$ 。</p>
<p>论文里写的是点权和最小，但是一个很简单的例子，所有独立集大小最大为 $1$ ，然后让这个拟阵自己和自己做交，那么最大值是什么？显然是权值最大的元素，但是按照论文里写的会找权值最小的元素，这显然是错误的。</p>
<p>更重要的是，在做题的时候，我写最长路过了。</p>
<p>至于为什么不会有正环，为什么算法一定会停止，为什么这个算法对，我一概不知，我只知道写最长路能过，仅此而已，现在当黑盒用了。</p>
<p>时间复杂度：$O(r^2n^2)$ 。</p>
<h6 id="坑3"><a href="#坑3" class="headerlink" title="坑3"></a>坑3</h6><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>兄弟，学了这么久，该做做题了，不然你学拟阵干什么。</p>
<p>拟阵交的题目一般是题目的条件无法直接使用拟阵，但是单看其中的一部分条件是满足拟阵要求的，所以就搞两个拟阵交起来，获得一个满足多个条件的集合，这种题目最难的就是怎么去构造合适的拟阵。</p>
<h3 id="二分图匹配"><a href="#二分图匹配" class="headerlink" title="二分图匹配"></a>二分图匹配</h3><p>虽然二分图匹配的匹配点集本身就是个拟阵，但是检验一个子集是否是独立集，就需要判断是否被一个匹配覆盖，这显然是难的。（我都能找匹配了，为什么还要多此一举再用个拟阵=.=）</p>
<p>所以构造拟阵。</p>
<ol>
<li>第一个拟阵 $M_1=(E,\mathcal{I_1})$ ，满足左部点的每个点的度数至多为 $1$ 。</li>
<li>第二个拟阵 $M_2=(E,\mathcal{I_2})$ ，满足右部点的每个点的度数至多为 $1$ 。</li>
</ol>
<p>拟阵交即可。</p>
<p>其实如果思考一下，会发现拟阵交找的增广路和匈牙利算法找的是一样的。</p>
<h3 id="最小树形图"><a href="#最小树形图" class="headerlink" title="最小树形图"></a>最小树形图</h3><p>给定带权有向图 $G=(V,E)$ ，求以 $root$ 为根的最小权外向树。</p>
<ol>
<li>第一个拟阵 $M_1=(E,\mathcal{I_1})$ ，满足把有向边看成无向边无环。</li>
<li>第二个拟阵 $M_2=(E,\mathcal{I_2})$ ，除 $root$ 之外入度至多为 $1$ ，$root$ 入度为 $0$ 。</li>
</ol>
<p>然后用带权拟阵交。</p>
<h3 id="Colorful-Tree"><a href="#Colorful-Tree" class="headerlink" title="Colorful Tree"></a>Colorful Tree</h3><p>给定带权无向图 $G=(V,E)$ ，每条边有一个 $1$ 到 $n-1$ 的颜色，求一个最大权的生成树，满足每个颜色恰好出现一次。</p>
<ol>
<li>第一个拟阵 $M_1=(E,\mathcal{I_1})$ ，无环。</li>
<li>第二个拟阵 $M_2=(E,\mathcal{I_2})$ ，每个颜色至多出现一次。</li>
</ol>
<p>带权拟阵交。</p>
<h1 id="一些拟阵的操作"><a href="#一些拟阵的操作" class="headerlink" title="一些拟阵的操作"></a>一些拟阵的操作</h1><p>在理解接下来的操作时，推荐用基的定义去理解，优先考虑基的变化，会很有助于理解这个拟阵在这个操作后会发生什么变化。</p>
<h2 id="对偶拟阵"><a href="#对偶拟阵" class="headerlink" title="对偶拟阵"></a>对偶拟阵</h2><p>定义：对于拟阵 $M=(S,\mathcal{I})$ ，定义 $M$ 的对偶拟阵 $M^{<em>}=(S,\mathcal{I^</em>})$ ，其中 $I^*=\{U\subset S:{\exists}基I\in \mathcal{I},I\subset S\setminus U\}$ 。</p>
<p>遗传性显然，现在证明交换性：</p>
<details class="toggle" ><summary class="toggle-button" style="">交换性的证明</summary><div class="toggle-content"><p>假设 $|U_1|&gt;|U_2|$ ，设基 $I_1\subset S\setminus U_1,I_2\subset S\setminus U_2$ 。</p>
<p>设基 $I_3=I_1\setminus U2$ ，然后用 $I_2$ 去扩张 $I_3$ 成基 $I_4$ 。</p>
<p>那么 $|I_4\cap U_1|\le|I_4\setminus I_3|\le |U_2|-|U_1\cap U_2|&lt; |U_1|-|U_1\cap U_2|$ 。</p>
<p>显然 $I_4\subset S\setminus U_2$ ，所以显然 ${\exists} z\in U_1\setminus U_2: U_2+\{z\}\in \mathcal{I_2}$ 。</p>
</div></details>
<p>对偶拟阵的秩函数：</p>
<p>$r^<em>(U)=\max\limits_{I\subset U,I\subset I^</em>}|I|=\max\limits_{B是M中的基}|U\setminus B|=|U|-\min\limits_{B是M中的基}|U\cap B|=|U|-r(S)+\max\limits_{B是M中的基}|B\cap (S\setminus U)|=|U|-r(S)+r(S\setminus U)$</p>
<p>也可以用秩函数证明这是个拟阵，在这里就不展开讲了，不是很麻烦，可以自证。</p>
<p>对偶拟阵的用途很广，他代表了一般拟阵的另外一个方面，举个例子：图拟阵的对偶就是去掉哪些边仍能保证图是联通的。</p>
<p>对偶拟阵实际上就是把所有基的补集作为了基的集合定义的拟阵。</p>
<h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><p>对于拟阵 $M=(S,I)$ ，和 $Z\subset S$ ，定义拟阵 $M$ 删除子集 $Z$ 的拟阵为 $(S\setminus Z,\mathcal{I’}), \mathcal{I’}=\{I:I\subset S\setminus Z, I\in \mathcal{I}\}$ 。记为 $M\setminus Z$ 。</p>
<p>这个操作非常好理解，就是只考虑和 $Z$ 没有交集的独立集，秩函数直接用原来的就行，非常的简单。</p>
<h2 id="收缩"><a href="#收缩" class="headerlink" title="收缩"></a>收缩</h2><p>对于拟阵 $M=(S,I)$ ，和 $Z\subset S$ ，定义拟阵 $M$ 删除子集 $Z$ 的拟阵为 $(M^<em>\setminus Z)^</em>$ 。记为 $M/Z$ 。</p>
<p>由于是用上面两个操作定义的，所以显然是个拟阵。</p>
<p>这个操作理解起来会比较困难。</p>
<p>考虑 $M/Z$ 的基，首先得是 $M^<em>\setminus Z$ 的基的补集，$M^</em>\setminus Z$ 的基又得是 $M^<em>$ 中和 $Z$ 交集最小的基去掉交集部分的集合，而 $M^</em>$ 中和 $Z$ 交集最小的基对应的是 $M$ 中和 $Z$ 交集最大的基的补集。</p>
<p>综上，可以得出，$M/Z$ 的基是原来和 $Z$ 交集最大的基去掉交集的部分，同理，独立集也是类似的。</p>
<p>当然也可以从秩的角度考虑，这里不再赘述，直接给出秩函数的式子：</p>
<p>$r_{M/Z}(U)=r_M(Z\cup U)-r_M(Z)$ 。</p>
<p>例子：图拟阵中的缩边操作。</p>
<h2 id="极小元"><a href="#极小元" class="headerlink" title="极小元"></a>极小元</h2><p>对于一个拟阵，经过一系列删除和收缩操作得到的任意拟阵 $M’$ ，称作拟阵 $M$ 的极小元。</p>
<h1 id="拟阵并"><a href="#拟阵并" class="headerlink" title="拟阵并"></a>拟阵并</h1><h2 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a>定义</h2><p>对于给定的 $k$ 个拟阵 $M_i=(S_i,\mathcal{I_i}),1\le i\le k$ 。定义这 $k$ 个拟阵的并为 $M=(S,\mathcal{I})$ ，其中 $S=\bigcup\limits_{i=1}^k S_i,\mathcal{I}=\{\bigcup\limits_{i=1}^k I_i:I_i\in \mathcal{I_i}\}$ 。</p>
<p>遗传性非常简单，重点是交换性。</p>
<details class="toggle" ><summary class="toggle-button" style="">交换性的证明</summary><div class="toggle-content"><p>不妨认为 $|I|&lt;|I’|$</p>
<p>不妨这么考虑一个事情，首先不妨认为：$I_i\cap I_j=\emptyset,i\ne j$ 。</p>
<p>同理对于 $I’_i$ 也是。</p>
<p>这样 $|I|=\sum\limits|I_i|,|I’|=\sum\limits|I’_i|$ 。</p>
<p>所以一定存在 $i:|I’_i|&gt;|I_i|$ ,所以考虑一定存在 $x\in I’_i,I_i+\{x\}\in \mathcal{I_i}$ ，如果 $x\in \mathcal{I}$ ，则说明 $x\in I_j,i\ne j$ ，所以令 $I_j$ 删掉 $x$ ，$I_i$ 加上 $x$ ，然后重新进行这个过程，反之，则交换性成立。</p>
<p>由于 $\sum\limits |I_i\cap I’_i|$ 会不断变大，所以这个过程一定会停下来，即交换性一定成立，证毕。</p>
<p>论文是一开始就找使 $\sum\limits |I_i\cap I’_i|$ 最大的 $I_i$ ，所以不用重复这个过程。</p>
</div></details>
<h2 id="秩函数-1"><a href="#秩函数-1" class="headerlink" title="秩函数"></a>秩函数</h2><script type="math/tex; mode=display">r_M(U)=\min\limits_{T\subset U}(|T|+\sum\limits_{i=1}^k r_{M_i}((U\setminus T)\cap S_i))</script><p>要证明这个定理，我们需要证明一个引理：</p>
<p><strong>引理 6.1</strong> ：拟阵 $\hat{M}=(\hat{S},\hat{\mathcal{I}})$ ，定义函数 $f:\hat{S}\to S$ ，定义拟阵 $M=(S,\mathcal{I}),I=\{f(\hat{I})\:\hat{I}\in\hat{\mathcal{I}}\}$ ，则 $M$ 的秩函数为：</p>
<script type="math/tex; mode=display">r_M(U)=\min\limits_{T\subset U}(r_{\hat{M}}(f^{-1}(U\setminus T))+|T|)</script><p>注 ： $f^{-1}(T)=\{x\in\hat{U}:f(x)\in T\}$ 。</p>
<details class="toggle" ><summary class="toggle-button" style="">证明</summary><div class="toggle-content"><p>这个证明不需要证明这是个拟阵，但是这并不难证，交换性的证明，和拟阵并交换性的证明是几乎一样的。（也可以先证了秩函数再导出其是个拟阵）</p>
<p>考虑构造一个划分拟阵 $(\hat{S},\mathcal{I_p})$ ，其中 $I\in \mathcal{I_p}$ 当且仅当 $I$ 中不存在两个元素 $f$ 的映射值相等。</p>
<p>这样的话，$r_M(U)$ 实际上就是拟阵 $\hat{M}$ 和 $(\hat{S},\mathcal{I_p})$ 限制在 $f^{-1}(U)$ 集合的拟阵交，用最小最大定理便可证明。</p>
</div></details>
<p>用引理证明秩函数并不困难，令 $S_i$ 中的元素 $e$ 变成二元元素 $(e,i)$ ，从而区分开所有的元素，再构造函数 $f((e,i))=e$ 即可得证。</p>
<h6 id="坑4"><a href="#坑4" class="headerlink" title="坑4"></a>坑4</h6><p>后面那些判断独立集啥的，还有表示法啥的还没有学，以后再说，先咕咕了，得去做些题目了，太久没敲代码手感不对了，现在。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>国家集训队2018论文：《浅谈拟阵的一些拓展及其应用》—- 江苏省淮阴中学 杨乾澜</p>
<p>图片生成：<a href="https://csacademy.com/app/graph_editor/">https://csacademy.com/app/graph_editor/</a></p>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>拟阵</tag>
      </tags>
  </entry>
  <entry>
    <title>组合计数练习</title>
    <url>/2024/02/01/%E7%BB%84%E5%90%88%E8%AE%A1%E6%95%B0%E7%BB%83%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="括号序列和折线法"><a href="#括号序列和折线法" class="headerlink" title="括号序列和折线法"></a>括号序列和折线法</h1><p>一个经典的问题：一个括号序列的最长的合法括号子序列有多长。</p>
<h2 id="折线法解决经典问题"><a href="#折线法解决经典问题" class="headerlink" title="折线法解决经典问题"></a>折线法解决经典问题</h2><p>不难发现，每一个左括号，也就是上升的部分，我们总能指定他右边和他同高度的右括号，然后消掉。</p>
<p><img src="1.png" alt=""></p>
<p>所以消到最后，我们总是会得到一条先下降后上升的折线，可以发现，这样子消不会改变整个折线的最低点，所以，<strong>一个指定起终点的折线，其最长的合法括号子序列取决于这条折线的最低点</strong> 。</p>
<p>这也是用折线法解决括号序列问题会非常方便的原因。</p>
<h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><ol>
<li><p>指定起终点，问最低点低于某个高度的折线数量。</p>
<p>对应在括号序列：指定左括号和右括号的数量，限制最长合法括号序列的长度小于某个值。</p>
<p>做法就是折一下就行了。</p>
</li>
<li><p>有多少个折线满足 $(0,0)\to(len,0)$ 且在 $y=0$ 上方，且恰好有 $m$ 个点在 $y$ 轴上。</p>
<p>对应在括号序列：有多少个合法的括号序列满足可以恰好分成 $m-1$ 份，使得满足每一份都是：$(A)$ ，$A$ 是一个合法的括号序列。</p>
<p>做法就是：考虑每次要到 $y=0$ 的那一段就去掉，认为起点是在 $(1,1)$ ，同时整条折线不能碰到 $y=0$ 这条线，则答案等价于从 $(1,1)\to (len-m+1,m-1)$ 的折线数量。（认为起点在 $(1,1)$ 是因为我们要求这条线不能碰到 $y=0$ ）</p>
<p><img src="3.png" alt=""></p>
</li>
</ol>
<h1 id="使用排列计算概率的方法"><a href="#使用排列计算概率的方法" class="headerlink" title="使用排列计算概率的方法"></a>使用排列计算概率的方法</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>有些时候，一些问题会涉及到等概率选择一些剩余的点，并且删除这个点和一些与这个点有关联的点集，然后问关于这个过程的一些概率或者是数量问题，就可以尝试使用这个方法。</p>
<p>这个方法的关键在于：考虑将被删除这个操作看成一个删除标记，只有当一个点被选中，才会被真正的删除，这样每个点恰好被选一次，只不过，如果选中了一个点有删除标记，就重新选（这个点也视作已经被选了，真正删除掉），直到选到没有标记的为止，由于没有标记的点数量不变，所以每个点在各种情况下被选中的概率不变。</p>
<p>形式化的表述就是：对于任意一个排列，其对应的情况为：每个点有被选中当且仅当能删除他的节点都在他后面，而选中的先后顺序就是排列的先后顺序。</p>
<p>则一种情况的概率就是能对应到这种情况的排列的出现概率。</p>
<p>这样，就把计算概率，变成了统计符合条件的排列数量。</p>
<h2 id="练习-1"><a href="#练习-1" class="headerlink" title="练习"></a>练习</h2><ol>
<li><p>现在有 $n$ 个数字，每次选择一个没被删除的数字，并且删除这个数字的所有倍数，问每个数字被选中的概率。</p>
<p>设 $d(i)$ 为 $i$ 的约数个数，显然答案就是 $\frac{1}{d(i)}$ 。</p>
</li>
<li><p>给定一个 $DAG$ ，每次选择一个没被删除的点，然后删除他能到达的所有点，问期望进行几轮。</p>
<p>期望可以转化为求每个点被选中的概率和，一个点被选中的概率为 $\frac{1}{能到达他的点的数量}$ 。</p>
</li>
<li><p>给定一个数字 $n$ ，令 $n=等概率选择1到n-1中的一个数字$ ，直到 $n\le k$ ，问期望轮数。</p>
<p>同理：可以看成是每个点可以删除所有 $\ge$ 他的点，和上一题基本一样，答案就是所有 $&gt;k$ 的点的经过概率之和。</p>
<p>答案为：$1+\sum\limits_{i=k+1}^{n-1}\frac{1}{i}$ 。</p>
<p>这道题目还有个加强版，但是做法基本一样，讨论一下就行了：<a href="https://codeforces.com/contest/1924/problem/E">Codeforces Round 921 Div.1 E.Paper Cutting Again</a></p>
<p>题目大意：给定 $n*m$ 的纸，每次可以等概率选择 $n-1$ 条整数横线或者 $m-1$ 条整数竖线，剪开然后丢掉下面或者右边的部分，问当面积小于 $k$ 时至多需要多少轮。</p>
<p>$n,m\le 10^{6},2\le k\le 10^{12}$  </p>
</li>
</ol>
<h1 id="图计数"><a href="#图计数" class="headerlink" title="图计数"></a>图计数</h1><h2 id="练习-2"><a href="#练习-2" class="headerlink" title="练习"></a>练习</h2><ol>
<li><p>求 $n$ 个有标号点的无向图的数量。</p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>容斥原理，枚举 $1$ 号点的连通块大小就行了。</p>
<script type="math/tex; mode=display">f_i=2^{\frac{i(i-1)}{2}}-\sum\limits_{j=1}^{i-1}\binom{i-1}{j-1}*f_{j}*2^{\frac{(i-j)(i-j-1)}{2}}</script><p>时间复杂度：$O(n^2)$ 。</p>
</div></details></li>
<li><p>求 $n$ 个有标号的点的边双联通图的数量。</p>
<details class="toggle" ><summary class="toggle-button" style="">DP做法</summary><div class="toggle-content"><p>方法 1 ：设 $dp[i][j]$ 表示有 $j$ 个点，恰好有 $i$ 个连通块的图的权值和（一个图的权值定义为每个连通块大小的乘积），然后枚举 $1$ 号点所在的边双大小进行容斥。</p>
<p>设 $f_i$ 表示 $i$ 个点的联通块数量， $g_i$ 表示 $i$ 个点的边双联通块数量。</p>
<script type="math/tex; mode=display">g_i=f_i-\sum\limits_{j=1}^{i-1}\binom{i-1}{j-1}*g_{j}*\sum\limits_{k=1}^{i-j}dp[k][i-j]*j^{k}</script><p>方法 2 ：设 $dp[i][j]$ 表示有 $j$ 个点，恰好有 $i$ 个点双连通块且点双之间不连通的图的权值和（一个图的权值定义，为每个点双连通块大小的乘积）。</p>
<p>显然：$dp[i][j]=\sum\limits_{k=1}^{j-(i-1)}dp[i-1][j-k]<em>\binom{j-1}{k-1}</em>k*g_k$ 。</p>
<p>注意到，先固定一个 $j$ ，除了 $dp[1][j]$ 以外的 $dp[i][j]$ 的转移都不依赖 $g_j$ ，所以考虑先处理出 $dp[i][j],(i\ne 1)$ ，然后用容斥算出 $g_j$ ，然后再求 $dp[1][j]$ ，从而完成 $dp[i][j]$ 对所有 $i$ 的转移。</p>
<p>实现上就是 $j$ 从小到达枚举，每一层先对 $i\ne 1$进行转移，再求 $g_j$ ，再求 $dp[1][j]$ 即可。</p>
<p>至于容斥的式子：$g_j=f_j-\sum\limits_{i=2}^{i}dp[i][j]*j^{i-2}$ 。</p>
<p>时间复杂度：$O(n^3)$ 。</p>
<p>方法 $1$ 更加自然，方法 $2$ 主要是感觉 $dp$ 顺序非常的奇妙，所以就记录一下。</p>
</div></details>
</li>
</ol>
<h1 id="一些奇奇怪怪的方法"><a href="#一些奇奇怪怪的方法" class="headerlink" title="一些奇奇怪怪的方法"></a>一些奇奇怪怪的方法</h1><h2 id="必定经过的事件集"><a href="#必定经过的事件集" class="headerlink" title="必定经过的事件集"></a>必定经过的事件集</h2><p>想法来自：</p>
<p><a href="https://www.luogu.com.cn/blog/xuanxuan001/solution-cf1924e">https://www.luogu.com.cn/blog/xuanxuan001/solution-cf1924e</a></p>
<h3 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h3><p>当你想要求一个事件的概率时，可以找一些其他事件，使得这个事件集必然发生，且在这个事件集发生的条件下，这个事件集内的每个事件的发生概率固定，那么就可以知道我们想要的事件的概率。</p>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><ol>
<li><p><a href="https://codeforces.com/contest/1924/problem/E">Codeforces Round 921 Div.1 E.Paper Cutting Again</a></p>
<p>题目大意：给定 $n*m$ 的纸，每次可以等概率选择 $n-1$ 条整数横线或者 $m-1$ 条整数竖线，剪开然后丢掉下面或者右边的部分，问当面积小于 $k$ 时至多需要多少轮。</p>
<p>$n,m\le 10^{6},2\le k\le 10^{12}$  </p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>假设纸张为 $(n’,m’)$。</p>
<p>不难想到先转化为 $(n’=x,m’=y):xy\ge k$ 的事件的经过概率之和。</p>
<p>那么经过 $(x,y)$ 的概率有多少呢？</p>
<p>不妨先假设 $m=y$ 。</p>
<p>不难发现，第一次使得 $n’\le x$ 或者 $m’&lt;m$ 的事件集构成了一个必然事件集，且内部的事件都是等概率的。</p>
<p>所以使得 $n’=x,m’=m$ 的概率为：$\frac{1}{x+m-1}$ 。</p>
<p>那么当 $x&lt;n,y&lt;m$ 如何处理？</p>
<p>首先，我们得求得第一次使得 $n’=x,m’=y$ 的概率，类似的，令第一次 $n’\le x$ 或者 $m’\le y$ 构成一个事件集，所以 $n’=x$ 或者 $m’=y$ 的概率为 $\frac{2}{x+y}$ ，然后剩下的情况就和前面的情况一样了，概率为 $\frac{1}{x+y-1}$ ，乘在一起就是：$\frac{2}{(x+y)(x+y-1)}$ 。</p>
<p>然后裂项求个和就可以在 $O(n+m)$ 的时间得到答案了。</p>
</div></details></li>
</ol>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>计数</tag>
      </tags>
  </entry>
  <entry>
    <title>求图上最大异或和路径的证明</title>
    <url>/2024/02/27/%E6%B1%82%E5%9B%BE%E4%B8%8A%E6%9C%80%E5%A4%A7%E5%BC%82%E6%88%96%E5%92%8C%E8%B7%AF%E5%BE%84%E7%9A%84%E8%AF%81%E6%98%8E/</url>
    <content><![CDATA[<p>还记得 OI 时期有一道典的不能再典的题目：给一张图，求一条从 $s$ 到 $t$ 的最大异或和的路径。</p>
<p>一个很典的结论是：跑一棵生成树，然后把这棵生成树上的环全部拿下来做个线性基，然后用任意一条 $s\to t$ 的路径丢进线性基里求最大值。</p>
<p>之前一直不知道怎么证明。</p>
<p>现在来证明一手：</p>
<p>不妨假设图中只有一个联通图。</p>
<p>可以发现，答案路径和随便一条路径的对称差满足每个点的度数都为  $0$ ，我们不妨把所有满足所有点度数为 $0$ 的边集集中到一个集合 $S$ 。</p>
<p>显然，不仅路径的对称差属于 $S$ ，$S$ 的任意一个元素都显然可以称为路径的对称差，因此，任意一条路径的异或和，和答案的异或值，可以且仅可以是 $S$ 中某个元素的异或值。</p>
<p>然后在这个集合上定义一种类似异或的运算：对应两个集合 $X,Y$ ，这种运算的返回结果为：$(X\cup Y)\setminus(X\cap Y)$ ，下面直接称这种运算为异或。</p>
<p>显然这个运算是封闭的（即结果还在这个集合内），显然这个结构能够像线性基一样定义基（把存在或不存在看成 $0/1$ 就可以直接看成线性基了），如果能够证明基的大小是 $m-(n-1)$ ，那么这个问题就解决了。</p>
<p>考虑生成树用到的边集 $E_1$ ，那么显然 $E\setminus E_1$ 中的每个元素都会生成一个环，这下环构成的集合我们称为 $S’$ ，显然 $S’\subset S$ ，且 $S’$ 线性无关，现在我们证明这个组合能够表示出 $S$ 就行了。</p>
<p>对于任意一个 $S$ 的元素 $L$，对于 $L$ 中非 $E_1$ 的元素，我们将他们拉出来异或，得到元素 $L’$ ，显然 $L,L’$ 在 $E\setminus  E_1$ 的部分是相同的，而在 $E_1$ 的部分，显然也能根据树的结构以及度数都为 $0$ 这一性质证明是相同的，这样，就构造性的证明了 $L’=L$ ，因此 $S’$ 就是 $S$ 的一组基。</p>
<p>证毕。</p>
<p>说起来，现在用异或的角度观察图的结构发现，图的结构其实和向量空间很像，不过只有一个运算。</p>
<p>同时从拟阵的角度来看，图拟阵和有限的向量空间都是拟阵。</p>
<p>太神奇了，可惜碍于我浅薄的知识面，无法看见更加深层次的联系，实在可惜。</p>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
  </entry>
  <entry>
    <title>经典trick汇总</title>
    <url>/2023/09/04/%E7%BB%8F%E5%85%B8trick%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<details class="toggle" ><summary class="toggle-button" style="">时间复杂度</summary><div class="toggle-content"><details class="toggle" ><summary class="toggle-button" style="">分数之和</summary><div class="toggle-content"><ol>
<li>$O(\sum\limits_{i=1}^{n})=O(\log{n})$ （调和级数）</li>
<li>$O(\sum\limits_{i=1}^n)=O(1)$ （可以用积分、裂项证明，也可以搜搜’巴塞尔问题’，这个式子收敛于 $\frac{\pi^2}{6}$ ）</li>
</ol>
</div></details></div></details>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>ACM杂类</tag>
      </tags>
  </entry>
  <entry>
    <title>感悟</title>
    <url>/2023/09/01/%E6%84%9F%E6%82%9F/</url>
    <content><![CDATA[<ol>
<li>锻炼在写 DP 之前先把转移方程写出来的能力，方便自己写代码，也方便队友 Debug ，还有就是变量名一定要和代码中的是一样的。</li>
<li>要多锻炼动笔想题的能力，防止一动笔脑子就宕机。</li>
<li>赛时只要证明了做法是对的就直接写，赛后可以思考一下更加优美的证明，但是不要太久，思考太久的话还不如直接去多做几道题目。</li>
<li>即使 AC 了题目，也要看看题解，因为题解中可能会有值得学习的点，如果一直沉浸在自己的世界，不去接受一些别人的东西，进步起来是非常慢的。</li>
</ol>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>ACM杂类</tag>
      </tags>
  </entry>
</search>
